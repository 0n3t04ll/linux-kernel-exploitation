<!DOCTYPE html>
<!-- saved from url=(0038)https://mcyoloswagham.github.io/linux/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>A foray into Linux kernel exploitation on Android – Ayaz Mammadov – Reverse Engineering to go forward...</title>

        
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

    
    <meta name="description" content="In November of 2020, I decided to dive into the world of Android, more specifically the linux kernel. I did this because earlier in the year, around February, I broke my old phone during a skiing trip and hastily bought a cheap android phone, the Alcatel 1S 2019.

">
    <meta property="og:description" content="In November of 2020, I decided to dive into the world of Android, more specifically the linux kernel. I did this because earlier in the year, around February, I broke my old phone during a skiing trip and hastily bought a cheap android phone, the Alcatel 1S 2019.

">
    
    <meta name="author" content="Ayaz Mammadov">

    
    <meta property="og:title" content="A foray into Linux kernel exploitation on Android">
    <meta property="twitter:title" content="A foray into Linux kernel exploitation on Android">
    



	<!-- Twitter cards -->
	<meta name="twitter:site" content="@">
	<meta name="twitter:creator" content="@">
	<meta name="twitter:title" content="A foray into Linux kernel exploitation on Android">

	

	

	<meta name="twitter:card" content="summary">
	<!-- end of Twitter cards -->




    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="./2021 - A foray into Linux kernel exploitation on Android_files/style.css">
    <link rel="alternate" type="application/rss+xml" title="Ayaz Mammadov - Reverse Engineering to go forward..." href="https://mcyoloswagham.github.io/feed.xml">

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="https://mcyoloswagham.github.io/" class="site-avatar"><img src="./2021 - A foray into Linux kernel exploitation on Android_files/37028601"></a>

          <div class="site-info">
            <h1 class="site-name"><a href="https://mcyoloswagham.github.io/">Ayaz Mammadov</a></h1>
            <p class="site-description">Reverse Engineering to go forward...</p>
          </div>

          <nav>
            <a href="https://mcyoloswagham.github.io/">Blog</a>
            <a href="https://mcyoloswagham.github.io/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>A foray into Linux kernel exploitation on Android</h1>

  <div class="entry">
    <p>In November of 2020, I decided to dive into the world of Android, more specifically the linux kernel. I did this because earlier in the year, around February, I broke my old phone during a skiing trip and hastily bought a cheap android phone, the Alcatel 1S 2019.</p>

<p>Coming from a background of Windows research I had no idea how to start. My first intuition was that in order to do anything I’d need to root my phone. Thankfully the Alcatel hosts a UNISOC SC9863A, a chipset made by Spreadtrum, who fortunately also provide flashing tools, making the entire process extremely easy, I’ll skip this part because it’s not really relevant and varies from phone to phone.</p>

<p>The next goal was to find the source code, and due to licensing requiremnts the linux kernel in use has to be open source. A quick search on google for “Alcatel linux source code” netted me a link to their sourceforge where I found all the zips of each phone titled by version (5024 for the Alcatel 1S 2019).</p>

<p>At this point I had to start assessing where I think there would be any poorly written code, I knew I wouldn’t be auditing shared linux kernel code. My first guess to figure out where I could find some targets would be to check all the devices and loaded kernel modules.
In the loaded devices (<code class="language-plaintext highlighter-rouge">/dev</code>) I didn’t find anything unique to the phone, so I decided to move on and check the linux kernel modules, and these were the results.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">Module                  Size  Used by
sprd_fm                57344  0
sprdbt_tty             24576  0
sprd_vibrator          16384  0
sunwave_fp             20480  1
leds_sprd_bltc_rgb     20480  0
pvrsrvkm             1454080  105</code></pre></figure>

<p>I didn’t want to explore any uncharted territory, so I ended up doing some research if there had been any previous work done on any of these modules, I found <a href="https://www.youtube.com/watch?v=lBgtZvIxEwA">Di Shens video</a> on exploiting the pvrsrvkm, which is the PowerVR Kernel Module for PowerVR gpus.
While the linux kernel source provided by Alcatel had no mentions on pvrsrvkm, the driver is opensource in the chromiumOS source code and can be found <a href="https://source.chromium.org/chromiumos/chromiumos/codesearch/+/main:src/third_party/kernel/v4.4/drivers/gpu/drm/img-rogue/">here</a></p>

<p>The PowerVR kernel module contains only 1 <code class="language-plaintext highlighter-rouge">ioctl</code> that is of any importance and its purpose is to dispatch to relevant functions, you send in a package (described by the struct below), the <code class="language-plaintext highlighter-rouge">bridge_id</code> describing the subsystem to which the function belongs, and the <code class="language-plaintext highlighter-rouge">bridge_func_id</code> is an identifier for each function, the rest of the variables are for transporting data.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">drm_pvr_srvkm_cmd</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">bridge_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">bridge_func_id</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">in_data_ptr</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">out_data_ptr</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">in_data_size</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">out_data_size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ioctl_package</span><span class="p">;</span></code></pre></figure>

<h1 id="the-bug-hunting-process">The Bug hunting process</h1>

<p>Looking through the driver, there was about 200000 lines of code in total, so I went around looking at subsystems, the most interesting seemed to be memory management.</p>

<p>I went through the functions registered to the <a href="https://source.chromium.org/chromiumos/chromiumos/codesearch/+/main:src/third_party/kernel/v4.4/drivers/gpu/drm/img-rogue/1.10/server_mm_bridge.c;l=3295">memory management bridge</a>, manually auditing them.
For debugging, I couldn’t connect any sort of kernel debugger to my phone, so instead I wrote a kernel module that would hook functions and intercept them to log values, while crude it helped immensely in understanding. Thankfully there was already a lot of logging in the PowerVR module, easily obtainable with <code class="language-plaintext highlighter-rouge">dmesg</code></p>

<p>That’s when I found it.</p>

<h1 id="the-bug">The Bug</h1>

<p>Here is the call-stack (backtrace) or code flow to reach the bug.</p>

<p><img src="./2021 - A foray into Linux kernel exploitation on Android_files/flow.png" alt="Code Flow"></p>

<p>The function that I am targetting (<code class="language-plaintext highlighter-rouge">PhysmemNewRamBackedPMR</code>) is responsible for creating shared memory, it has certain options for whether the memory should be GPU, OS, etc… The one constraint being that this memory is actually backed by physical memory (<code class="language-plaintext highlighter-rouge">PMR = PhysicalMemoryResource</code>), with the choice given to the user on how to map virtual to physical addresses.</p>

<p>This is the structure that is passed in to PRVSRVBridge</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">PVRSRV_BRIDGE_IN_PHYSMEMNEWRAMBACKEDPMR_TAG</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">uiSize</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">uiChunkSize</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ui32NumPhysChunks</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ui32NumVirtChunks</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="o">*</span> <span class="n">pui32MappingTable</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ui32Log2PageSize</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">uiFlags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ui32AnnotationLength</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">puiAnnotation</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ui32PID</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">PVRSRV_BRIDGE_IN_PHYSMEMNEWRAMBACKEDPMR</span><span class="p">;</span></code></pre></figure>

<p>It describes many things like the name of the mapping, how many chunks, and certain flags, the mapping table for virtual to physical.</p>

<p>the final function in the chain <code class="language-plaintext highlighter-rouge">_PMRCreate</code> is responsible for creating a physical memory resource and actually handling the translation/bookkeeping between virtual and physical addresses, the bug occurs in the initialization of this bookkeeping.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">pvPMRLinAddr</span> <span class="o">=</span> <span class="n">OSAllocMem</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">psPMR</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">psMappingTable</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">IMG_UINT32</span><span class="p">)</span> <span class="o">*</span> <span class="n">ui32NumVirtChunks</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pvPMRLinAddr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">PVRSRV_ERROR_OUT_OF_MEMORY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">psPMR</span> <span class="o">=</span> <span class="p">(</span><span class="n">PMR</span> <span class="o">*</span><span class="p">)</span> <span class="n">pvPMRLinAddr</span><span class="p">;</span>
	<span class="n">psMappingTable</span> <span class="o">=</span> <span class="p">(</span><span class="n">PMR_MAPPING_TABLE</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="n">IMG_CHAR</span> <span class="o">*</span><span class="p">)</span> <span class="n">pvPMRLinAddr</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">psPMR</span><span class="p">));</span>

	<span class="n">eError</span> <span class="o">=</span> <span class="n">OSLockCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psPMR</span><span class="o">-&gt;</span><span class="n">hLock</span><span class="p">,</span> <span class="n">LOCK_TYPE_PASSIVE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eError</span> <span class="o">!=</span> <span class="n">PVRSRV_OK</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">OSFreeMem</span><span class="p">(</span><span class="n">psPMR</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">eError</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">psMappingTable</span><span class="o">-&gt;</span><span class="n">uiChunkSize</span> <span class="o">=</span> <span class="n">uiChunkSize</span><span class="p">;</span>
	<span class="n">psMappingTable</span><span class="o">-&gt;</span><span class="n">ui32NumVirtChunks</span> <span class="o">=</span> <span class="n">ui32NumVirtChunks</span><span class="p">;</span>
	<span class="n">psMappingTable</span><span class="o">-&gt;</span><span class="n">ui32NumPhysChunks</span> <span class="o">=</span> <span class="n">ui32NumPhysChunks</span><span class="p">;</span>
	<span class="n">OSCachedMemSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psMappingTable</span><span class="o">-&gt;</span><span class="n">aui32Translation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">psMappingTable</span><span class="o">-&gt;</span><span class="n">aui32Translation</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span>
	               <span class="n">ui32NumVirtChunks</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">ui32NumPhysChunks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ui32Temp</span> <span class="o">=</span> <span class="n">pui32MappingTable</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">psMappingTable</span><span class="o">-&gt;</span><span class="n">aui32Translation</span><span class="p">[</span><span class="n">ui32Temp</span><span class="p">]</span> <span class="o">=</span> <span class="n">ui32Temp</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<p>In this code, <code class="language-plaintext highlighter-rouge">pui32MappingTable</code> is a copied over usermode table that describes linear translations from virtual to physical addresses. With -1 being the default value meaning that no translation was provided. The issue being that the <code class="language-plaintext highlighter-rouge">aui32Translation</code> table is only the size of the number of Virtual Chunks provided.</p>

<p>This on its own is not an issue, because in order to reach this area there is a constraint, the number of virtual chunks has to be equal to the number of physical checks. The actual issue occurs in the bounds checking when setting up these linear chunks, the index <code class="language-plaintext highlighter-rouge">ui32Temp</code> is a user controlled variable because it comes from the unverified <code class="language-plaintext highlighter-rouge">pui32MappingTable</code> and indexs into an array which is meant to hold the number of chunks requested, this gives us a heap overwrite primitive in any cache larger than or equal to <code class="language-plaintext highlighter-rouge">kmalloc-256</code>, due to the fact that we can control how large <code class="language-plaintext highlighter-rouge">psMappingTable</code> is, by controlling <code class="language-plaintext highlighter-rouge">ui32NumVirtChunks</code></p>

<h1 id="exploitation">Exploitation</h1>

<p>I limited myself to write an exploit with PXN/PAN and ASLR exploitation mitigations in mind, the first step would be to leak an kernel address of any kind, heap or ideally a function address.</p>

<p>Since <code class="language-plaintext highlighter-rouge">aui32Translation</code> is a 32-bit pointer, I cannot do any freelist shenanigans because realistically the values that I can set and groom are from 0-1000, larger than that I start to edit memory 1000s of bytes away from the corrupted block, making it very unreliable</p>

<p>My next thought was that I have a 4 byte arbitrary overwrite with values 0-1000 which meant I had realistically 2 options, find a structure with a reference counter and cause a UaF or corrupt a length integer.</p>

<p>Upon searching for previous research on usable linux structures, I found this <a href="http://www.personal.psu.edu/yxc431/talks/Bypassing-Many-Kernel-Protections-Using-Elastic-Objects.pdf">great talk</a> talking about elastic objects in the linux kernel, specifically a chart of objects, where I found the suitable inotify_event_info, The idea here being corrupting the length of the inotify_event_info and grooming another object infront of the inotify_event_info and reading it.</p>

<p>What is inotify_event_info and how do we use it? Linux has mechanisms to notify programs when files are changed/modified/deleted etc….
inotify_event_info is the structure used to store the events, the name, the type of operation, a cookie.</p>

<p>essentially it works by giving you a file descriptor which you create with certain options, then when you read it, if there are any events you can easily retrieve them by reading the fd. When an event occurs, it is allocated to the kmalloc-256 cache and when you read it is destroyed.</p>

<p>the gameplan being, fill the heap with inotify_event_infos then, free an inotify_event_info, and trigger the bug overwriting a length value, then as you read the inotify_event_infos you start cluttering the remaining free spaces with a structure whose content you want to leak.</p>

<p>in my case the ideal structure for leaking a function address is a timer, which contains a function address in the first 30 bytes and is very easy to use.</p>

<p><img src="./2021 - A foray into Linux kernel exploitation on Android_files/fd.png" alt="Heap structure"></p>

<p>I wrote the PoC, adjusted values and figured out and I kept on crashing, but what was happening???
Here were the panic logs</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">[</span>&lt;ffffff80081df04c&gt;] __check_object_size+0x54/0x220
<span class="o">[</span>&lt;ffffff80082296c4&gt;] inotify_read+0x314/0x39c
<span class="o">[</span>&lt;ffffff80081e2f14&gt;] vfs_read+0x84/0x168
<span class="o">[</span>&lt;ffffff80081e39c4&gt;] sys_read+0x50/0xb0
<span class="o">[</span>&lt;ffffff8008085af0&gt;] el0_svc_naked+0x24/0x28</code></pre></figure>

<p>and this line was also in the panic logs</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">&lt;0&gt;[ 5522.162040] c7 14180 usercopy: kernel memory exposure attempt detected from ffffffc0f50d912c <span class="o">(</span>kmalloc-256<span class="o">)</span> <span class="o">(</span>284 bytes<span class="o">)</span></code></pre></figure>

<p>a little bit of research led me to, CONFIG_HARDENED_USERCOPY, a protection that stops you copying out of your allocation, meaning that this wouldn’t work.</p>

<h1 id="revelation">Revelation</h1>
<p>In my search to find a good object whose <code class="language-plaintext highlighter-rouge">kref</code> I could corrupt, while learning about linux I discovered a little thing known as slab merging, in order to optimize and reduce fragmenting in the kernel memory allocator, linux will merge slabs into one slab. The linux kernel source comes with a little program called <a href="https://github.com/torvalds/linux/blob/master/tools/vm/slabinfo.c">slabinfo</a> (not to be confused with <code class="language-plaintext highlighter-rouge">/proc/slabinfo</code>) that can show you merged slabs,  I thought of the structures I could use to corrupt and while there were many in the kmalloc-256+ caches, I couldn’t find something that was easy to use and groom.</p>

<p>I decided to check what slabs were merged on my phone by running slabinfo with the <code class="language-plaintext highlighter-rouge">-a</code> flag,</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">:t-0000256   &lt;- ip_dst_cache kmalloc-256 filp nf_conntrack_expect skbuff_head_cache pool_workqueue biovec-16 bio-0 sgpool-8
:t-0000360   &lt;- blkdev_requests dm_clone_request
:t-0000512   &lt;- xfrm_dst_cache kmalloc-512 sgpool-16 skbuff_fclone_cache</code></pre></figure>

<p>This was my output, I noticed that of the 256 byte caches, filp and kmalloc-256 were merged, this meant that I could corrupt file structures, let’s see what we can corrupt in the file structures.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="nc">file</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="nc">llist_node</span>	<span class="n">fu_llist</span><span class="p">;</span>
		<span class="k">struct</span> <span class="nc">rcu_head</span> 	<span class="n">fu_rcuhead</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">f_u</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">path</span>		<span class="n">f_path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">inode</span>		<span class="o">*</span><span class="n">f_inode</span><span class="p">;</span>	<span class="cm">/* cached value */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="nc">file_operations</span>	<span class="o">*</span><span class="n">f_op</span><span class="p">;</span>

	<span class="cm">/*
	 * Protects f_ep, f_flags.
	 * Must not be taken from IRQ context.
	 */</span>
	<span class="n">spinlock_t</span>		<span class="n">f_lock</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">rw_hint</span>		<span class="n">f_write_hint</span><span class="p">;</span>
	<span class="n">atomic_long_t</span>		<span class="n">f_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> 		<span class="n">f_flags</span><span class="p">;</span>
	<span class="n">fmode_t</span>			<span class="n">f_mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">mutex</span>		<span class="n">f_pos_lock</span><span class="p">;</span>
	<span class="n">loff_t</span>			<span class="n">f_pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">fown_struct</span>	<span class="n">f_owner</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="nc">cred</span>	<span class="o">*</span><span class="n">f_cred</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">file_ra_state</span>	<span class="n">f_ra</span><span class="p">;</span>

	<span class="n">u64</span>			<span class="n">f_version</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SECURITY
</span>	<span class="kt">void</span>			<span class="o">*</span><span class="n">f_security</span><span class="p">;</span>
<span class="cp">#endif
</span>	<span class="cm">/* needed for tty driver, and maybe others */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">private_data</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_EPOLL
</span>	<span class="cm">/* Used by fs/eventpoll.c to link all the hooks to this file */</span>
	<span class="k">struct</span> <span class="nc">hlist_head</span>	<span class="o">*</span><span class="n">f_ep</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_EPOLL */</span><span class="cp">
</span>	<span class="k">struct</span> <span class="nc">address_space</span>	<span class="o">*</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="n">errseq_t</span>		<span class="n">f_wb_err</span><span class="p">;</span>
	<span class="n">errseq_t</span>		<span class="n">f_sb_err</span><span class="p">;</span> <span class="cm">/* for syncfs */</span>
<span class="p">}</span> <span class="n">__randomize_layout</span>
  <span class="nf">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span>	<span class="cm">/* lest something weird decides that 2 is OK */</span></code></pre></figure>

<p>Fortunately for us, there’s an atomic integer that holds a reference count <code class="language-plaintext highlighter-rouge">f_count</code>, my idea is that we can open a file many times and increment the counter then we can trigger the heap overwrite to set the <code class="language-plaintext highlighter-rouge">f_count</code> to a number that is smaller than the current number of references, and then we can close it until, we have handles in our processes file descriptor table that point to <code class="language-plaintext highlighter-rouge">file*</code> that are non-existent, then from there on we can see what we can do, whether it be manipulating data structures or other things.</p>

<p><img src="./2021 - A foray into Linux kernel exploitation on Android_files/file.png" alt="File corruption">
The smallest number we can set the refcount to is 32.</p>

<p>One of the nice things about being able to mess with file structures, is that there are very easy paths to LPE, if you can replace file structures and keep handles on them, then you might be able to get access to a file that you shouldn’t have access to e.g. imagine SUID executables, giving you root and more…</p>

<p>I also took some inspiration from <a href="https://www.youtube.com/watch?v=MIJL5wLUtKE">Jann Horns video</a>, where he mentions how he exploits a file refcount overdecrement, using <code class="language-plaintext highlighter-rouge">FUSE</code>, and using vectored i/o he was able to replace <code class="language-plaintext highlighter-rouge">file*</code> by stalling a write operation once access checks were done, and was able to write contents of a file he did not have write access to. Unfortunately, <code class="language-plaintext highlighter-rouge">FUSE</code> is not accessible in android, so the second best option I had was trying to slow down the processor with interrupts and scheduler tricks.</p>

<h1 id="reliability">Reliability</h1>

<p>Another syscall he used to check that his UaF was reliable was <code class="language-plaintext highlighter-rouge">kcmp</code>, sadly <code class="language-plaintext highlighter-rouge">kcmp</code> isn’t implemented in android, but I found an alternative. Using inotify events I can see when a file has been closed, and since only the file with the altered refcount will be closed I’ll know whether and when I’ve closed the corrupted file. As for checking whether a file has been successfully replaced, I can use lseek on new <code class="language-plaintext highlighter-rouge">struct file</code>s and set the position to some magic number, then I can check my dangling handles and if the seek position has been changed to that magic number we can be sure that our dangling file has been replaced, :P</p>

<p>This is needed because once we find our replaced file, we can still have multiple handles pointing to it and still cause another refcount overflow but this time we know which handle it is, making it a lot more deterministic.</p>

<h1 id="the-new-gameplan">The New Gameplan</h1>
<p>1) Create an inotify event for a specific directory, for when files are closed</p>

<p>2) Create/open a bunch files, increment their refcount to a suitable number (to any number above 32), this can be done using the <code class="language-plaintext highlighter-rouge">dup</code> syscall</p>

<p>3) deallocate a file, to make holes in the block, allocate a <code class="language-plaintext highlighter-rouge">psMappingTable</code> in the hole.</p>

<p>4) Trigger the bug causing a heap overwrite and hopefully adjusting the refcount of a <code class="language-plaintext highlighter-rouge">struct file</code> infront of it to 32</p>

<p>5) Close the <code class="language-plaintext highlighter-rouge">dup</code> fds, 32 times.</p>

<p>6) if we can read an event from inotify, then we’ve closed a corrupted file meaning that its refcount has been altered.</p>

<p>7) start spraying files and seeking their position to a suitable magic number, check the dangling handles seek positions, if they have changed we’ve found the corrupted file
and we have spare handles to a <code class="language-plaintext highlighter-rouge">file*</code> with refcount = 1 and probably more dangling handles depending on how many we started with</p>

<p>10) write to the file using the vectored i/o, and try the  replacement trick that Jann Horn used, using timing delays to make the race condition easier to hit</p>

<p>11) hopefully replace the file* during the vectored i/o with a much more important file (I used the <code class="language-plaintext highlighter-rouge">runas</code> file which has suid permissions, which I can open as readable)</p>

<p>12) run modified suid file with LPE payload inside.</p>

<h1 id="the-unfortunate-conclusion">The Unfortunate Conclusion</h1>
<p>Since I didn’t have <code class="language-plaintext highlighter-rouge">FUSE</code>, I was unable to ever manage to even get the race condition to hit, but the idea was still there. I used scheduler tricks, even tried some interrupt tricks from another talk. Though it seemed impossible to ever get.</p>

<h2 id="possible-alternatives">Possible alternatives</h2>
<p>Thanks to <code class="language-plaintext highlighter-rouge">nspace</code>, who recommended an alternative exploitation strategy for this bug.
The idea was that I somehow communicate with priviledged services that open priviledged files, and that they’d replace the corrupted <code class="language-plaintext highlighter-rouge">file*</code> struct and I’d have spare handles to a priviledged file that I could edit. Unfortunately I wasn’t able to find any easy or useful services that open important priviledged files that I could repeatedly spray reliably.</p>

<p>If anyone has some ideas feel free to message me, I’d love to hear them 
<a href="mailto:ayazmammadov@hotmail.co.uk">ayazmammadov@hotmail.co.uk</a></p>

<p><em>I’m looking for <a href="https://mcyoloswagham.github.io/about">employment opportunies</a></em></p>


  </div>

  <div class="date">
    Written on March 31, 2021
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/mcyoloswagham"><i class="svg-icon github"></i></a>




<a href="https://www.twitter.com/dynapate"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    

  

</body></html>