<!DOCTYPE html>
<!-- saved from url=(0081)https://jon.oberheide.org/blog/2010/10/23/linux-kernel-pktcdvd-memory-disclosure/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="viewport" content="width=device-width,minimum-scale=1">
  <meta name="author" content="Jon Oberheide">
  <meta name="description" content="Jon Oberheide&#39;s website">

  <title>Linux Kernel pktcdvd Memory Disclosure | Jon Oberheide</title>
 
  
  
    <meta name="ROBOTS" content="INDEX, FOLLOW">

    
    <script async="" src="./2010 - Linux Kernel pktcdvd Memory Disclosure_files/js"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-P6TVZTTZN2');
    </script>
  

  <link rel="preconnect" href="https://fonts.gstatic.com/">
  <link href="./2010 - Linux Kernel pktcdvd Memory Disclosure_files/css2" rel="stylesheet">

  <link href="./2010 - Linux Kernel pktcdvd Memory Disclosure_files/style.css" rel="stylesheet">
  <link href="./2010 - Linux Kernel pktcdvd Memory Disclosure_files/fontawesome.css" rel="stylesheet">
  <link href="./2010 - Linux Kernel pktcdvd Memory Disclosure_files/brands.css" rel="stylesheet">

</head>

<body>
  <aside>
    <div id="user_meta">
      <a href="https://jon.oberheide.org/">
        <img src="./2010 - Linux Kernel pktcdvd Memory Disclosure_files/jono.jpg" alt="logo" id="logo">
      </a>
      <h2><a href="https://jon.oberheide.org/" class="nohover">Jon Oberheide</a></h2>
      
      <div class="social">
        <ul>
	  <li><a href="https://www.linkedin.com/in/jonoberheide">LinkedIn<i class="fab fa-linkedin fa-lg"></i></a></li>
	  <li><a href="https://twitter.com/jonoberheide">Twitter<i class="fab fa-twitter fa-lg"></i></a></li>  
	</ul>
      </div>
      <ul>
      </ul>
    </div>
  </aside>

  <main id="main">

    
    
    <header>
      <p id="header">
      <a href="https://jon.oberheide.org/">Home</a>
      | <a href="https://jon.oberheide.org/blog/">Blog</a>
      | <a href="https://jon.oberheide.org/research/">Research</a>
      | <a href="https://jon.oberheide.org/advisories/">Advisories</a>
      | <a href="https://jon.oberheide.org/projects/">Projects</a>
    </p></header>
    

    <article>
      <div class="article_title">
        <h1>Linux Kernel pktcdvd Memory Disclosure</h1>
        
        
        
        <h4>Saturday, October 23, 2010</h4>
        
      </div>

      <div class="article_text">
<p>A vulnerability in the pktcdvd driver in the Linux kernel allows for the
disclosure of 4 bytes of kernel memory. In this post, I'll describe the
tad bit of magic that's necessary to exploit the vulnerability on both
32-bit and 64-bit hosts to disclosure an arbitrary amount of kernel
memory.</p>
<h2 id="the-vulnerability">The Vulnerability</h2>
<p>The vulnerability was first introduced in 2.6.10 (way back in 2004) and
was recently discovered in late September 2010 by Dan Rosenberg. As
described by Dan:</p>
<pre><code>The PKT_CTRL_CMD_STATUS device ioctl retrieves a pointer to a
pktcdvd_device from the global pkt_devs array.  The index into this
array is provided directly by the user and is a signed integer, so the
comparison to ensure that it falls within the bounds of this array will
fail when provided with a negative index.

This can be used to read arbitrary kernel memory or cause a crash due to
an invalid pointer dereference.  This can be exploited by users with
permission to open /dev/pktcdvd/control (on many distributions, this is
readable by group "cdrom").
</code></pre>
<p>The vulnerable code is present in drivers/block/pktcdvd.c:</p>
<pre><code>static struct pktcdvd_device *pkt_find_dev_from_minor(int dev_minor)
{
 if (dev_minor &gt;= MAX_WRITERS)
 return NULL;
 return pkt_devs[dev_minor];
}
</code></pre>
<p>The vulnerable path is reachable via a PKT_CTRL_CMD_STATUS ioctl on
the /dev/pktcdvd/control device. By specifying a negative dev_minor
value, an attacker can bypass the MAX_WRITERS check and cause the
kernel to reference an address far outside in the intended range of
pkt_devs. The kernel later uses the specified pktcdvd_device structure
to copy a bit of data back to user space. If an attacker tricks the
kernel into referencing a fake pktcdvd_device structure under his
control via a negative dev_minor index into pkt_devs, he may be able
to disclosure sensitive kernel memory back to userspace.</p>
<p><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3437">CVE-2010-3437</a>
has been assigned to this vulnerability.</p>
<h2 id="the-initial-exploit">The Initial Exploit</h2>
<p>On a 32-bit host, the exploit for this vulnerability is fairly
straightforward. Our goal is to specify a large negative device index
during our ioctl in order to trick the kernel into dereferencing memory
under our control in userspace. For example, if we know the address of
the pkt_devs symbol and specify a large negative index (eg. -30000000),
we can calculate the address in userspace that the kernel will access
(pkt_devs + (-30000000 * sizeof(void *))). The kernel will follow the
value at that address to find the address of the pktcdvd_device
structure. We can provide a fake pktcdvd_device structure at that
address to cause the kernel to reference any memory address and copy 4
bytes worth of data at that address back to userspace. Since we can leak
4 bytes of arbitrary memory for each ioctl, we can repeatedly perform
the same operation with a different target address to dump as much
kernel memory as we desire.</p>
<p>This exploit approach is illustrated in the following diagram:</p>
<p><img src="./2010 - Linux Kernel pktcdvd Memory Disclosure_files/32bit-small.png" alt="32bit-small"><br>
How the initial exploitation approach operates on a 32-bit host.</p>
<p>The full version of this initial exploit approach is available
<a href="https://jon.oberheide.org/files/cve-2010-3437.old.c">here</a>.</p>
<h2 id="the-revised-exploit">The Revised Exploit</h2>
<p>This previous approach operates perfectly fine on a 32-bit host, since
the TASK_SIZE boundary between kernel space and user space memory can
be hurdled. That is, we can specify a negative device index that is
large enough to cause the kernel to reference memory that under our
control in userspace (pkt_devs + (device_index * sizeof(void *)) &lt;
TASK_SIZE).</p>
<p>However, on 64-bit hosts, the expanded address space has an unfortunate
side effect on the efficacy of our exploit. No matter how large we make
the negative device index, there's no way to reach an address that is
under our control in userspace, as illustrated in the following diagram:</p>
<p><img src="./2010 - Linux Kernel pktcdvd Memory Disclosure_files/64bit-small.png" alt="64bit-small"><br>
How the initial exploitation approach fails on a 64-bit host.</p>
<p>To work around this problem, we need to revise our exploitation
approach. While causing the kernel to reference a memory address under
our control in userspace is certainly preferable, it is not a strict
requirement. In theory, we can cause the kernel to reference an address
within kernel memory since we can't reach userspace. However, there are
a few requirements that must be fulfilled to result in successful
exploitation:</p>
<ol>
<li>The address in kernel memory must be predictable.</li>
<li>The address in kernel memory must be less than the address of
pkt_devs since we're using a negative index.</li>
<li>The value contained at that address must be predictable.</li>
<li>The value contained at that address must represent an address in
userspace (&lt; TASK_SIZE).</li>
<li>The value contained at that address must represent an address that
can be mapped (&gt;= mmap_min_addr).</li>
</ol>
<p>My initial thoughts were to look for constants at predictable addresses
in kernel memory. For example, the pkt_misc structure (of type
miscdevice) has a member named "minor" that has the constant value
MISC_DYNAMIC_MINOR (0xff). With access to the kernel symbols for
pkt_devs and pkt_misc, we could calculate the proper negative device
index to specify to cause the kernel to reference the address of the
pkt_misc.minor and hop down to the address 0x000000ff in userspace.
However, this fails to satisfy the 5th condition, since many modern
distributions specify a non-zero mmap_min_addr, disallowing the
mapping of the page containing the 0x000000ff address.</p>
<p>Then Captain Obvious paid me a visit. What kernel address can we
reference that has a predictable value and is greater than or equal to
mmap_min_addr? Well, why not mmap_min_addr itself?!? We know its
address in kernel memory from /proc/kallsyms, we can infer its value by
simply trying to mmap a couple common mmap_min_addr values (4096,
65536), and it obviously satisfies the greater than or equal to
mmap_min_addr requirement.</p>
<p>Success! The revised approach is illustrated as follows and operates
effectively on both 32-bit and 64-bit hosts:</p>
<p><img src="./2010 - Linux Kernel pktcdvd Memory Disclosure_files/32bit-mmap-small.png" alt="32bit-mmap-small"><br>
How the revised exploitation approach succeeds on both 32-bit and 64-bit
hosts.</p>
<p>The full version of this revised exploit approach is available
<a href="https://jon.oberheide.org/files/cve-2010-3437.c">here</a>.</p>
<p>All in all, a great find by Dan, a fun puzzle to get exploitation
functional on 64-bit, and a nice long-standing vuln providing arbitrary
kernel memory disclosure on several popular Linux distributions. Patch
up, hide kernel symbols to hamper reliable exploitation, use UDEREF,
etc.</p>


      </div>
    </article>

    <div id="ending_message">
      <p>Copyright Â© 2021 - Jon Oberheide</p>
    </div>

  </main>



</body></html>