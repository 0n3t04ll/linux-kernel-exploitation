<!DOCTYPE html>
<!-- saved from url=(0088)https://jon.oberheide.org/blog/2009/08/29/linux-kernel-getname-stack-memory-disclosures/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="viewport" content="width=device-width,minimum-scale=1">
  <meta name="author" content="Jon Oberheide">
  <meta name="description" content="Jon Oberheide&#39;s website">

  <title>Linux Kernel getname() Stack Memory Disclosures | Jon Oberheide</title>
 
  
  
    <meta name="ROBOTS" content="INDEX, FOLLOW">

    
    <script async="" src="./2009 - Linux Kernel getname() Stack Memory Disclosures_files/js"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-P6TVZTTZN2');
    </script>
  

  <link rel="preconnect" href="https://fonts.gstatic.com/">
  <link href="./2009 - Linux Kernel getname() Stack Memory Disclosures_files/css2" rel="stylesheet">

  <link href="./2009 - Linux Kernel getname() Stack Memory Disclosures_files/style.css" rel="stylesheet">
  <link href="./2009 - Linux Kernel getname() Stack Memory Disclosures_files/fontawesome.css" rel="stylesheet">
  <link href="./2009 - Linux Kernel getname() Stack Memory Disclosures_files/brands.css" rel="stylesheet">

</head>

<body>
  <aside>
    <div id="user_meta">
      <a href="https://jon.oberheide.org/">
        <img src="./2009 - Linux Kernel getname() Stack Memory Disclosures_files/jono.jpg" alt="logo" id="logo">
      </a>
      <h2><a href="https://jon.oberheide.org/" class="nohover">Jon Oberheide</a></h2>
      
      <div class="social">
        <ul>
	  <li><a href="https://www.linkedin.com/in/jonoberheide">LinkedIn<i class="fab fa-linkedin fa-lg"></i></a></li>
	  <li><a href="https://twitter.com/jonoberheide">Twitter<i class="fab fa-twitter fa-lg"></i></a></li>  
	</ul>
      </div>
      <ul>
      </ul>
    </div>
  </aside>

  <main id="main">

    
    
    <header>
      <p id="header">
      <a href="https://jon.oberheide.org/">Home</a>
      | <a href="https://jon.oberheide.org/blog/">Blog</a>
      | <a href="https://jon.oberheide.org/research/">Research</a>
      | <a href="https://jon.oberheide.org/advisories/">Advisories</a>
      | <a href="https://jon.oberheide.org/projects/">Projects</a>
    </p></header>
    

    <article>
      <div class="article_title">
        <h1>Linux Kernel getname() Stack Memory Disclosures</h1>
        
        
        
        <h4>Saturday, August 29, 2009</h4>
        
      </div>

      <div class="article_text">
<p>In this post, we'll look at some kernel stack information disclosures
in the getname() functions of several socket AFs recently discovered in
the Linux kernel.</p>
<h2 id="the-vulnerability">The Vulnerability</h2>
<p>The getname() function of an address family in the kernel is used to
retrieve information about a given socket. This information, in the form
of a sockaddr struct, is accessed from userspace through the
getsockname(2) and getpeername(2) system calls for bound and connected
sockets respectively.</p>
<p>The operation of a typical getname() function is as follows: a sockaddr
struct on the stack is filled in with addressing information from
internal socket structures and then is memcpy()'ed into the destination
sockaddr which is later copied back to userspace. For example, the
following is the getname() for the irda address family in
net/irda/af_irda.c:</p>
<pre><code>static int irda_getname(struct socket *sock, struct sockaddr *uaddr, int *uaddr_len, int peer)
{
    struct sockaddr_irda saddr;
    struct sock *sk = sock-&gt;sk;
    struct irda_sock *self = irda_sk(sk);

    if (peer) {
        if (sk-&gt;sk_state != TCP_ESTABLISHED)
            return -ENOTCONN;

        saddr.sir_family = AF_IRDA;
        saddr.sir_lsap_sel = self-&gt;dtsap_sel;
        saddr.sir_addr = self-&gt;daddr;
    } else {
        saddr.sir_family = AF_IRDA;
        saddr.sir_lsap_sel = self-&gt;stsap_sel;
        saddr.sir_addr = self-&gt;saddr;
    }

    IRDA_DEBUG(1, "%s(), tsap_sel = %#x\n", __func__, saddr.sir_lsap_sel);
    IRDA_DEBUG(1, "%s(), addr = %08x\n", __func__, saddr.sir_addr);

    /* uaddr_len come to us uninitialised */
    *uaddr_len = sizeof (struct sockaddr_irda);
    memcpy(uaddr, &amp;saddr, *uaddr_len);

    return 0;
}
</code></pre>
<p>As we see here, irda_getname() is filling in several of the members of
saddr, which is a sockaddr_irda structure. We can take a look at the
definition of a sockaddr_irda structure in include/linux/irda.h:</p>
<pre><code>struct sockaddr_irda {
    sa_family_t sir_family;   /* AF_IRDA */
    __u8        sir_lsap_sel; /* LSAP selector */
    __u32       sir_addr;     /* Device address */
    char        sir_name[25]; /* Usually &lt;service&gt;:IrDA:TinyTP */
};
</code></pre>
<p>The total size of this structure is 36 bytes, including a large 25-byte
sir_name member. Notice that the sir_name member is not memset()'ed
or initialized in the above irda_getname() function. This means that
our final memcpy() will be copying uninitialized data from the stack
which will then be returned to userspace, leaking potentially sensitive
information. In addition to the 25-byte sir_name, there is also one
byte of padding inserted by the compiler for alignment purposes between
sir_lsap_sel and sir_addr and 3 bytes of padding after sir_name.
This results in a total of 29 bytes of uninitialized kernel stack memory
being leaked to userspace.</p>
<p>As it turns out, this issue was not limited to only irda, but also the
can, appletalk, rose, netrom, econet, and llc address families. These
vulnerabilities affect versions of the Linux 2.6 kernel before
2.6.31-rc7. While these socket families aren't the most common, they
ship as modules in common distributions that are loaded automatically
via request_module("net-pf-X") when a socket is created. Yet another
reason why you should trim unused and potentially vulnerable code from
your kernel configuration or use something like grsecurity's MODHARDEN
to reduce your attack surface.</p>
<h2 id="the-exploit">The Exploit</h2>
<p>Exploiting this memory disclosure vulnerability is straightforward and
can be performed by an unprivileged user. For irda, we just need to
create an AF_IRDA socket and then call getsockname(2) on it. Exploiting
some of the other vulnerable address families may require binding or
connecting the socket in order to satisfy certain conditions in the
getname() function. For irda, the required code is trivial:</p>
<pre><code>struct sockaddr_irda saddr;
int sock, len = sizeof(saddr);
sock = socket(AF_IRDA, SOCK_DGRAM, 0);
getsockname(sock, (struct sockaddr *) &amp;saddr, &amp;len);
</code></pre>
<p>The saddr structure will now contain 29-bytes of uninitialized kernel
stack memory (byte 4 and bytes 9-36).</p>
<p>A full example exploit for this issue is available here: <a href="https://jon.oberheide.org/files/cve-2009-3002.c">cve-2009-3002.c</a></p>
<h2 id="the-fix">The Fix</h2>
<p>The first set of fixes rolled into davem's
<a href="http://git.kernel.org/?p=linux/kernel/git/davem/net-2.6.git;a=summary">net-2.6</a>
git repo via Eric Dumazet (and somehow slipped under my radar) in early
August. The patches covered a number of address families including
<a href="http://git.kernel.org/?p=linux/kernel/git/davem/net-2.6.git;a=blobdiff;f=net/can/raw.c;h=db3152df7d2b627fd2484c14734e9a084d3e93a0;hp=f4cc44548bdaa35a2b6947b8c7ef89affe8ac615;hb=e84b90ae5eb3c112d1f208964df1d8156a538289;hpb=b79a79471bd31d737c939a6ddc347417047b4320">can</a>,
<a href="http://git.kernel.org/?p=linux/kernel/git/davem/net-2.6.git;a=commit;h=09384dfc76e526c3993c09c42e016372dc9dd22c">irda</a>,
<a href="http://git.kernel.org/?p=linux/kernel/git/davem/net-2.6.git;a=commit;h=3d392475c873c10c10d6d96b94d092a34ebd4791">appletalk</a>,
<a href="http://git.kernel.org/?p=linux/kernel/git/davem/net-2.6.git;a=blobdiff;f=net/rose/af_rose.c;h=e5f478ca3d61574e01bc74bad58cfdc910a33b4a;hp=f0a76f6bca711a064f4611a592c82eeca9968f0f;hb=17ac2e9c58b69a1e25460a568eae1b0dc0188c25;hpb=b4adbb4ddf63091f48668e7ff1b9b0f6f84d4b40">rose</a>,
<a href="http://git.kernel.org/?p=linux/kernel/git/davem/net-2.6.git;a=blobdiff;f=net/netrom/af_netrom.c;h=ce1a34b99c2328f16648d5cf96cb8ff5edc25ed6;hp=ce51ce012cdab48e4c0bbfd99c3053a0bfcaa636;hb=f6b97b29513950bfbf621a83d85b6f86b39ec8db;hpb=80922bbb12a105f858a8f0abb879cb4302d0ecaa">netrom</a>,
and
<a href="http://git.kernel.org/?p=linux/kernel/git/davem/net-2.6.git;a=blobdiff;f=net/econet/af_econet.c;h=f0bbc57926cdbbb8d70b3e2e59cbdd4f090800f3;hp=2e1f836d424064ffe346321e053c136f86682545;hb=80922bbb12a105f858a8f0abb879cb4302d0ecaa;hpb=17ac2e9c58b69a1e25460a568eae1b0dc0188c25">econet</a>,
the worst of the bunch being the irda example we covered here. Another
similar patch for the
<a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=28e9fc592cb8c7a43e4d3147b38be6032a0e81bc">llc</a>
address family rolled in on August 24th which is what alerted me to the
previous issues.</p>
<p>The fix is obvious: memset() the sockaddr structure at the beginning of
the getname() function so that uninitialized memory will be not be
leaked to userspace. For completeness, here's the patch for the irda
example:</p>
<pre><code>--- a/net/irda/af_irda.c
+++ b/net/irda/af_irda.c
@@ -714,6 +714,7 @@ static int irda_getname(struct socket *sock, struct sockaddr *uaddr,
        struct sock *sk = sock-&gt;sk;
        struct irda_sock *self = irda_sk(sk);

+       memset(&amp;saddr, 0, sizeof(saddr));
        if (peer) {
                if (sk-&gt;sk_state != TCP_ESTABLISHED)
                        return -ENOTCONN;
</code></pre>
<h2 id="references">References</h2>
<ul>
<li>NVD/CVE:
<a href="http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2009-3001">CVE-2009-3001</a></li>
<li>NVD/CVE:
<a href="http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2009-3002">CVE-2009-3002</a></li>
<li>AF_IRDA exploit: <a href="https://jon.oberheide.org/files/cve-2009-3002.c">cve-2009-3002.c</a></li>
<li>AF_LLC exploit: <a href="https://jon.oberheide.org/files/cve-2009-3001.c">cve-2009-3001.c</a></li>
<li>Clement Lecigne's AF_APPLETALK exploit:
<a href="http://milw0rm.com/exploits/9521">http://milw0rm.com/exploits/9521</a></li>
</ul>


      </div>
    </article>

    <div id="ending_message">
      <p>Copyright © 2021 - Jon Oberheide</p>
    </div>

  </main>



</body></html>