<!DOCTYPE html>
<!-- saved from url=(0051)https://salls.github.io/Linux-Kernel-CVE-2017-5123/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Exploiting CVE-2017-5123 with full protections. SMEP, SMAP, and the Chrome Sandbox! – Chris Salls's Blog – </title>

        
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

    
    <meta name="description" content="In this blog post I’m going to explain how to exploit CVE-2017-5123, a bug I found in the Linux kernel, and show how it can be used to escalate privileges, even with SMEP, SMAP and from inside the Chrome sandbox.

">
    <meta property="og:description" content="In this blog post I’m going to explain how to exploit CVE-2017-5123, a bug I found in the Linux kernel, and show how it can be used to escalate privileges, even with SMEP, SMAP and from inside the Chrome sandbox.

">
    
    <meta name="author" content="Chris Salls&#39;s Blog">

    
    <meta property="og:title" content="Exploiting CVE-2017-5123 with full protections. SMEP, SMAP, and the Chrome Sandbox!">
    <meta property="twitter:title" content="Exploiting CVE-2017-5123 with full protections. SMEP, SMAP, and the Chrome Sandbox!">
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="./2017 - Exploiting CVE-2017-5123 with full protections. SMEP, SMAP, and the Chrome Sandbox!_files/style.css">
    <link rel="alternate" type="application/rss+xml" title="Chris Salls&#39;s Blog - " href="https://salls.github.io/feed.xml">

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">

          <div class="site-info">
            <h1 class="site-name"><a href="https://salls.github.io/">Chris Salls's Blog</a></h1>
            <p class="site-description"></p>
          </div>

          <nav>
            <a href="https://salls.github.io/">Blog</a>
            <a href="https://salls.github.io/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>Exploiting CVE-2017-5123 with full protections. SMEP, SMAP, and the Chrome Sandbox!</h1>

  <div class="entry">
    <p>In this blog post I’m going to explain how to exploit CVE-2017-5123, a bug I found in the Linux kernel, and show how it can be used to escalate privileges, even with SMEP, SMAP and from inside the Chrome sandbox.</p>

<h3 id="background">Background</h3>
<p>During system call handling, the kernel needs to be able to read and write to the memory of the process which invoked the system call.
To do this the kernel has special functions such as <code class="highlighter-rouge">copy_from_user</code>, <code class="highlighter-rouge">put_user</code>, and others, which copy data to or from userland.
On a very high level, <code class="highlighter-rouge">put_user</code> does approximately the following:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">put_user</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span>
    <span class="n">user_access_begin</span><span class="p">()</span>
    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">user_access_end</span><span class="p">()</span></code></pre></figure>

<p>The <code class="highlighter-rouge">access_ok()</code> call checks that the ptr is in userland and not kernel memory.
If this check passes, the <code class="highlighter-rouge">user_access_begin()</code> call disables <a href="https://en.wikipedia.org/wiki/Supervisor_Mode_Access_Prevention">SMAP</a>, allowing the kernel to access userland.
The kernel does the memory write, and then re-enables SMAP.
One important note here: these user access functions handle page faults during the memory read/write and will not cause a crash when accessing unmapped memory.</p>

<h3 id="the-vulnerability">The Vulnerability</h3>
<p>Certain system calls require many calls to <code class="highlighter-rouge">put/get_user</code> to copy data between the kernel and userland. 
To avoid the extra overhead of the repeated checks and SMAP enabling/disabling, the kernel developers included unsafe versions: <code class="highlighter-rouge">__put_user</code> and <code class="highlighter-rouge">unsafe_put_user</code>, which don’t include the checks.
Unsurprisingly, it’s possible to forget the extra check.
This is exactly what happened in CVE-2017-5123.
In kernel version 4.13, the <code class="highlighter-rouge">waitid</code> syscall was updated to use <code class="highlighter-rouge">unsafe_put_user</code>, but the <code class="highlighter-rouge">access_ok</code> check was missing. 
The vulnerable code is shown below.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">waitid</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">upid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span>
                                  <span class="n">infop</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rusage</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">ru</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">rusage</span> <span class="n">r</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">waitid_info</span> <span class="n">info</span> <span class="o">=</span> <span class="p">{.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">long</span> <span class="n">err</span> <span class="o">=</span> <span class="n">kernel_waitid</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">upid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">ru</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">signo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">signo</span> <span class="o">=</span> <span class="n">SIGCHLD</span><span class="p">;</span>
        <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ru</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">ru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rusage</span><span class="p">)))</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">infop</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">err</span><span class="p">;</span>

        <span class="n">user_access_begin</span><span class="p">();</span>
        <span class="n">unsafe_put_user</span><span class="p">(</span><span class="n">signo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_signo</span><span class="p">,</span> <span class="n">Efault</span><span class="p">);</span>    <span class="o">&lt;-</span>    <span class="n">no</span> <span class="n">access_ok</span> <span class="n">call</span>
        <span class="n">unsafe_put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_errno</span><span class="p">,</span> <span class="n">Efault</span><span class="p">);</span>
        <span class="n">unsafe_put_user</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">cause</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_code</span><span class="p">,</span> <span class="n">Efault</span><span class="p">);</span>
        <span class="n">unsafe_put_user</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_pid</span><span class="p">,</span> <span class="n">Efault</span><span class="p">);</span>
        <span class="n">unsafe_put_user</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">uid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_uid</span><span class="p">,</span> <span class="n">Efault</span><span class="p">);</span>
        <span class="n">unsafe_put_user</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infop</span><span class="o">-&gt;</span><span class="n">si_status</span><span class="p">,</span> <span class="n">Efault</span><span class="p">);</span>
        <span class="n">user_access_end</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="n">Efault</span><span class="o">:</span>
        <span class="n">user_access_end</span><span class="p">();</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h3 id="the-primitive">The primitive</h3>
<p>The lack of the <code class="highlighter-rouge">access_ok</code> check allows us to give a kernel address as the <code class="highlighter-rouge">infop</code> parameter of the <code class="highlighter-rouge">waitid</code> syscall and then the syscall will simply write over that kernel address using <code class="highlighter-rouge">unsafe_put_user</code> because it is never checked.
One tricky part of this primitive is we don’t have great control over what is written.
It writes 6 different fields, and we don’t have full control over any one of them.
<code class="highlighter-rouge">info.status</code> is a 32 bit int, but constrained to be 0 &lt; status &lt; 256.
<code class="highlighter-rouge">info.pid</code> can be somewhat controlled by repeatedly forking, but has a max value of 0x8000.</p>

<p>Here’s an overview of the fields written that we will refer to later during the exploit.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">siginfo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">si_signo</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">si_errno</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">si_code</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">padding</span><span class="p">;</span>   <span class="c1">// this remains unchanged by waitid
</span>    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>       <span class="c1">// process id
</span>    <span class="kt">int</span> <span class="n">uid</span><span class="p">;</span>       <span class="c1">// user id
</span>    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>    <span class="c1">// return code
</span><span class="p">}</span></code></pre></figure>

<h3 id="the-chrome-sandbox">The chrome sandbox</h3>
<p>What makes this bug more interesting than just a privilege escalation is that it can be used from inside the Chrome sandbox.
First, let’s explain what the Chrome Sandbox is and how it works.</p>

<p>Google Chrome uses a sandbox to protect the browser, such that even if an exploit gets code execution, it can’t touch the rest of the system.
There are two layers of sandboxes.
The first restricts access to resources by changing the user id and doing a chroot.
The second tries to limit the kernel attack surface using a seccomp filter to block system calls that aren’t needed in the sandboxed process.
This is normally fairly effective — most Linux kernel vulnerabilities are in syscalls which are blocked by the seccomp sandbox.</p>

<p>However, the waitid syscall is interesting because it’s commonly allowed in seccomp sandboxes and, sure enough, this includes the Chrome sandbox (<a href="https://chromium.googlesource.com/chromium/src.git/+/master/sandbox/linux/seccomp-bpf-helpers/">chrome seccomp source</a>).
This means we can attack the kernel to escape from the Chrome sandbox!</p>

<p>One limitation imposed by the sandbox - fork is not allowed.
We can only create new threads not processes.
This is a problem because if we can’t fork, waitid will fail, and only allow us to write 0’s to kernel memory.</p>

<h3 id="taking-a-breather-getting-an-infoleak">Taking a breather: Getting an infoleak</h3>
<p>You’ll have to trust me that we’ll be able to pwn this eventually.
But either way, we’ll need to know the kernel base address for exploiting, so let’s get that first.
A nice property of <code class="highlighter-rouge">unsafe_put_user</code> is that it won’t crash when accessing invalid memory addresses, and instead will just return <code class="highlighter-rouge">-EFAULT</code>.
Thus, we can just keep guessing addresses where the kernel data section could be at until we get a different error code, then we know we found the kernel address, and can defeat KASLR. 
Just be a little careful not to overwrite anything too important :)</p>

<p>We can do the same to find the address of the kernel heap, or other regions of kernel memory.</p>

<h3 id="an-unreliable-exploit-bypassing-smap">An Unreliable Exploit Bypassing SMAP</h3>
<p>At this point, I wanted to see if it was possible to exploit this bug with full protections.
As a recap, we are currently quite limited in what we can do:</p>
<ul>
  <li>We can only write 0’s.</li>
  <li>We write 24 bytes of 0’s and will clobber nearby memory.</li>
  <li>We don’t have a <em>great</em> info leak. We can know where the kernel base is, where the heap is, but not where an object in the heap is.</li>
</ul>

<p>I thought for a while about different ways to exploit the bug, and identified a few directions:</p>
<ul>
  <li>Find an object in the kernel data section, where an index/size/value of zero would cause an out of bounds memory access.</li>
  <li>Overwrite a spinlock in the kernel to allow us to create a race condition.</li>
  <li>Try overwriting a base pointer or other value on the kernel stack.</li>
  <li>Trigger actions that will result in the creation of useful structures on the kernel heap, then see if we can hit them with our arbitrary write of 0’s.</li>
</ul>

<p>I ended up going with the fourth strategy and spraying the heap.</p>

<h3 id="the-heap-spray">The heap spray</h3>
<p>At the beginning of the <code class="highlighter-rouge">task_struct</code> (<a href="http://elixir.free-electrons.com/linux/v4.13.11/source/include/linux/sched.h#L519">the structure representing each process and thread</a>) is some flags, one if which marks if a seccomp filter is applied or not.
If we can spray the heap with task_structs, and overwrite just those beginning flags, then we can remove seccomp from one of our processes and then we have some more hope.</p>

<p>Since I’m not an expert at the Linux kernel heap, I first sprayed 10000 threads and then used a debugger to examine where the task structures were in the heap.
I noticed that when I sprayed enough objects, most of the task structures would end up at a lower address in the heap than any structures that were there before.
This seems to imply to that the heap would expand downward as the free slots are used up.</p>

<p>The plan is then:</p>
<ul>
  <li>Create 10000 threads</li>
  <li>Starting at the lowest address in the heap, keep guessing possible addresses that a task structure could be at</li>
  <li>Have the 10000 threads keep checking if they are still in the seccomp sandbox</li>
  <li>Stop when one finds that it no longer affected by seccomp.</li>
</ul>

<p>Turns out, this sort of works!
Although it’s unreliable, it works enough for a proof of concept, and I think it’s likely that it could be made more reliable by tuning the spray more.
Maybe if you spray other objects to fill in the “holes” first, and then free them after creating the 10000 threads, you can be more certain that the target task structures will be at the bottom of the heap.
I haven’t explored this enough, but currently it seems to work around 50% of the time on my computer, with the kernel crashing the other 50% of the time.</p>

<h3 id="getting-a-better-arbitrary-write">Getting a better “Arbitrary” write</h3>
<p>At this point we have a task that is no longer in the seccomp sandbox, and we know the address that its <code class="highlighter-rouge">task_struct</code> is at from the previous step.
We still need to figure out how to exploit the kernel from here to escalate to root privileges and remove the chroot.</p>

<p>Fortunately, our primitive has gotten better, we can now use fork() to create children and, in turn, make <code class="highlighter-rouge">waitid</code> write non-zero values.
Unfortunately, we still don’t control much of the <code class="highlighter-rouge">siginfo</code> struct.
The only values that seem usable are the <code class="highlighter-rouge">pid</code> and the <code class="highlighter-rouge">status</code>, both of which are limited.
The maximum pid is 0x8000 and the status is a single byte.</p>

<p>However, since the <code class="highlighter-rouge">pid</code> is right next to some unused padding (shown in the structure earlier), we can do 5 writes, shifting back a byte each time. to construct an arbitrary 5 byte write.</p>

<h3 id="5-byte-write--physmap">5 Byte Write + Physmap</h3>
<p>It’s not straightforward to see how to use the 5 byte write we constructed above.
We still can’t create arbitrary addresses.
We can however, create addresses that look like 0x**********000000, where the *’s can be anything.</p>

<p>Here, I take inspiration from ret2dir.
There is a section of kernel memory, called the <a href="https://www.blackhat.com/docs/eu-14/materials/eu-14-Kemerlis-Ret2dir-Deconstructing-Kernel-Isolation.pdf">physmap</a>, where the kernel keeps an ‘alias’, a second virtual address, mapped to the same physical memory as userspace memory.
Thus, by creating a page filled with 0x41 in userland, there is actually an address in the kernel that we can find that exact same page filled with 0x41.</p>

<p>My strategy here is to allocate a very large amount of memory in userland.
Then try randomly overwriting pages in the kernel’s physmap, while simultaneously checking if the userland page has changed.
If we see a change, then we have found a kernel virtual address that corresponds to a userland address and we can write to userland to create our payload in kernel memory.
I only try pages in the kernel’s physmap where the address ends in six 0’s, so that once we find an ‘alias’ we can construct a pointer to that kernel address.</p>

<p>This part is very reliable, but on rare occasions can crash a random process.</p>

<h3 id="true-arbitrary-readwrite-and-root">True Arbitrary Read/Write and Root!</h3>
<p>Now I overwrite the <code class="highlighter-rouge">files</code> pointer in the task_struct to point it at the ‘alias’ we found in the kernel, and in userland I construct a fake <code class="highlighter-rouge">files_struct</code> object which will also be at the <code class="highlighter-rouge">alias</code>.
<code class="highlighter-rouge">file</code> objects, are quite nice, since they contain function pointers which you control the arguments to using functions such as <code class="highlighter-rouge">read</code>, <code class="highlighter-rouge">lseek</code>, <code class="highlighter-rouge">ioctl</code>. 
By pointing <code class="highlighter-rouge">ioctl</code> at various ROP gadgets in the kernel we can create an arbitrary read and write primitive.
I fix up the clobbered portions of the task_struct, change our creds structure to become root.
Finally, I remove the chroot, by resetting the current fs .
Now we have fully escaped the sandbox and can pop a calculator as root!</p>

<p>This full exploit is available at <a href="https://github.com/salls/kernel-exploits/blob/master/CVE-2017-5123/exploit_smap_bypass.c">https://github.com/salls/kernel-exploits/blob/master/CVE-2017-5123/exploit_smap_bypass.c</a></p>

<p>Thanks to the people at Chrome/Chromium security for the very quick response to my bug report!</p>


  </div>

  <div class="date">
    Written on November  6, 2017
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/salls"><i class="svg-icon github"></i></a>








        </footer>
      </div>
    </div>

    

  

</body></html>