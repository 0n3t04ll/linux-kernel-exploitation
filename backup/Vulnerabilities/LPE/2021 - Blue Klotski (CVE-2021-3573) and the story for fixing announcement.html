<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0056)https://www.openwall.com/lists/oss-security/2021/06/08/2 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>oss-security - CVE-2021-3573: UAF in hci_sock_bound_ioctl() function</title>

<link href="./2021 - Blue Klotski (CVE-2021-3573) and the story for fixing announcement_files/style.css" type="text/css" rel="stylesheet">
<style type="text/css">
.calendar { text-align: center; }
.ccell { background: #ccc; width: 5ex; padding: 2px; }

.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>
</head>

<body bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">


<table bgcolor="#ffffff" width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody><tr>

<td>
<a href="https://www.openwall.com/"><img class="logo" src="./2021 - Blue Klotski (CVE-2021-3573) and the story for fixing announcement_files/logo.png" border="0" width="182" height="80" alt="Openwall"></a>
</td><td width="100%">
<div class="nav">
<ul>
<li><a href="https://www.openwall.com/">Products</a>
<ul>
<li><a href="https://www.openwall.com/Owl/">Openwall GNU/*/Linux &nbsp; <i>server OS</i></a>
</li><li><a href="https://www.openwall.com/lkrg/">Linux Kernel Runtime Guard</a>
</li><li><a href="https://www.openwall.com/john/">John the Ripper &nbsp; <i>password cracker</i></a>
<ul>
<li><a href="https://www.openwall.com/john/">Free &amp; Open Source for any platform</a>
</li><li><a href="https://www.openwall.com/john/cloud/">in the cloud</a>
</li><li><a href="https://www.openwall.com/john/pro/linux/">Pro for Linux</a>
</li><li><a href="https://www.openwall.com/john/pro/macosx/">Pro for macOS</a>
</li></ul>
</li><li><a href="https://www.openwall.com/wordlists/">Wordlists &nbsp; <i>for password cracking</i></a>
</li><li><a href="https://www.openwall.com/passwdqc/">passwdqc &nbsp; <i>policy enforcement</i></a>
<ul>
<li><a href="https://www.openwall.com/passwdqc/">Free &amp; Open Source for Unix</a>
</li><li><a href="https://www.openwall.com/passwdqc/windows/">Pro for Windows (Active Directory)</a>
</li></ul>
</li><li><a href="https://www.openwall.com/yescrypt/">yescrypt &nbsp; <i>KDF &amp; password hashing</i></a>
</li><li><a href="https://www.openwall.com/yespower/">yespower &nbsp; <i>Proof-of-Work (PoW)</i></a>
</li><li><a href="https://www.openwall.com/crypt/">crypt_blowfish &nbsp; <i>password hashing</i></a>
</li><li><a href="https://www.openwall.com/phpass/">phpass &nbsp; <i>ditto in PHP</i></a>
</li><li><a href="https://www.openwall.com/tcb/">tcb &nbsp; <i>better password shadowing</i></a>
</li><li><a href="https://www.openwall.com/pam/">Pluggable Authentication Modules</a>
</li><li><a href="https://www.openwall.com/scanlogd/">scanlogd &nbsp; <i>port scan detector</i></a>
</li><li><a href="https://www.openwall.com/popa3d/">popa3d &nbsp; <i>tiny POP3 daemon</i></a>
</li><li><a href="https://www.openwall.com/blists/">blists &nbsp; <i>web interface to mailing lists</i></a>
</li><li><a href="https://www.openwall.com/msulogin/">msulogin &nbsp; <i>single user mode login</i></a>
</li><li><a href="https://www.openwall.com/php_mt_seed/">php_mt_seed &nbsp; <i>mt_rand() cracker</i></a>
</li></ul>
</li><li><a href="https://www.openwall.com/services/">Services</a>
</li><li id="narrow-li-1"><a>Publications</a>
<ul>
<li><a href="https://www.openwall.com/articles/">Articles</a>
</li><li><a href="https://www.openwall.com/presentations/">Presentations</a>
</li></ul>
</li><li><a>Resources</a>
<ul>
<li><a href="https://www.openwall.com/lists/">Mailing lists</a>
</li><li><a href="https://openwall.info/wiki/">Community wiki</a>
</li><li><a href="https://github.com/openwall">Source code repositories (GitHub)</a>
</li><li><a href="https://cvsweb.openwall.com/">Source code repositories (CVSweb)</a>
</li><li><a href="https://www.openwall.com/mirrors/">File archive &amp; mirrors</a>
</li><li><a href="https://www.openwall.com/signatures/">How to verify digital signatures</a>
</li><li><a href="https://www.openwall.com/ove/">OVE IDs</a>
</li></ul>
</li><li id="last-li"><a href="https://www.openwall.com/news">What's new</a>
</li></ul>
</div>


</td></tr></tbody></table>


<table bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<tbody><tr><td>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td bgcolor="#ECF8FF">
<a href="https://twitter.com/openwall">
Follow @Openwall on Twitter for new release announcements and other news</a>

</td></tr></tbody></table>
</td></tr></tbody></table>

<a href="https://www.openwall.com/lists/oss-security/2021/06/08/1">[&lt;prev]</a> <a href="https://www.openwall.com/lists/oss-security/2021/06/08/3">[next&gt;]</a> <a href="https://www.openwall.com/lists/oss-security/2021/06/08/">[day]</a> <a href="https://www.openwall.com/lists/oss-security/2021/06/">[month]</a> <a href="https://www.openwall.com/lists/oss-security/2021/">[year]</a> <a href="https://www.openwall.com/lists/oss-security/">[list]</a>
<pre style="white-space: pre-wrap">Date: Tue, 8 Jun 2021 08:53:42 +0800
From: Lin Horse &lt;kylin.formalin@...il.com&gt;
To: oss-security@...ts.openwall.com
Subject: CVE-2021-3573: UAF in hci_sock_bound_ioctl() function

Hello there,

Our team (BlockSec) found an UAF vulnerability in function
hci_sock_bound_ioctl(). It can allow attackers to corrupt kernel heaps
(kmalloc-8k to be specific) and adopt further exploitations.


=*=*=*=*=*=*=*=*=  BUG DETAILS  =*=*=*=*=*=*=*=*=

&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; background knowledge &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

The hci_sock_bound_ioctl() function is in charge of five HCI commands.

/* Ioctls that require bound socket */
static int hci_sock_bound_ioctl(struct sock *sk, unsigned int cmd,
                unsigned long arg)
{
    struct hci_dev *hdev = hci_pi(sk)-&gt;hdev; // { 1 }

    if (!hdev)
        return -EBADFD;

    /* ..... */

    switch (cmd) {
    case HCISETRAW:
        ...

    case HCIGETCONNINFO:
        ...

    case HCIGETAUTHINFO:
        ...

    case HCIBLOCKADDR:
        ...

    case HCIUNBLOCKADDR:
        ...
    }

    return -ENOIOCTLCMD;
}

As you can see, the biggest difference between functions
hci_sock_bound_ioctl() and hci_sock_ioctl() is that the former one will
derive the hci_dev struct through hci_pi(sk)-&gt;hdev. (as code mark { 1 }
shows)

In other words, the bind() syscall needs to be called before the
hci_sock_bound_ioctl() to write this struct. The hdev is obtained through
hci_dev_get(), which based on the counter.

static int hci_sock_bind(struct socket *sock, struct sockaddr *addr,
             int addr_len)
{
    ...
    switch (haddr.hci_channel) {
    case HCI_CHANNEL_RAW:
        ...
            hdev = hci_dev_get(haddr.hci_dev); // { 2 }

        ...
        hci_pi(sk)-&gt;hdev = hdev;
        ...
    }
}

&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bug iteself &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

The bug itself is about the UAF of hdev and the root cause is the race
(again).

When the HCI device detaches from the kernel, the function
hci_unregister_dev() will be called. This function will call
hci_sock_dev_event(hdev, HCI_DEV_UNREG) to inform all sockets that this
device is going to be removed. The core logic is presented below.

void hci_sock_dev_event(struct hci_dev *hdev, int event)
{
...
    if (event == HCI_DEV_UNREG) {
        struct sock *sk;

        /* Detach sockets from device */
        read_lock(&amp;hci_sk_list.lock);
        sk_for_each(sk, &amp;hci_sk_list.head) {
            bh_lock_sock_nested(sk);
            if (hci_pi(sk)-&gt;hdev == hdev) {
                hci_pi(sk)-&gt;hdev = NULL;
                sk-&gt;sk_err = EPIPE;
                sk-&gt;sk_state = BT_OPEN;
                sk-&gt;sk_state_change(sk);

                hci_dev_put(hdev);
            }
            bh_unlock_sock(sk);
        }
        read_unlock(&amp;hci_sk_list.lock);
    }
}

That is, the hci_sock_dev_event() function will release the hdev from the
bounded sockets, all at once.

Therefore, one question arises: Is there any possibility that the
hci_sock_dev_event() in detaching routine take places and release the hdev
while the hci_sock_bound_ioctl() is still working?

Unfortunately, the answer is YES. The hci_sock_dev_event() can release the
hdev and cause the UAF in function hci_sock_bound_ioctl(). This race can be
shown below.

hci_sock_bound_ioctl thread    |    hci_sock_dev_event thread
                               |
                               |
if (!hdev)                     |
    return -EBADFD;            |
                               |
                               |    hci_pi(sk)-&gt;hdev = NULL;
                               |    ...
                               |    hci_dev_put(hdev);
// UAF, for example            |
hci_dev_lock(hdev);            |
                               |
                               |
....

It is worth mentioning that the attacker can stably control and trigger
this race with userfaultfd primitive, which will be discussed later.


=*=*=*=*=*=*=*=*=  BUG EFFECTS  =*=*=*=*=*=*=*=*=

There are four different types of functions will be called from the
vulnerable hci_sock_bound_ioctl().

* hci_get_conn_info()
* hci_get_auth_info()
* hci_sock_blacklist_add()
* hci_sock_blacklist_del()

All these functions can have different effects when the UAF of hdev
happens. For example, the hci_sock_blacklist_add() will allow the attacker
to write arbitrary 6 bytes to any place if the released hdev-&gt;blacklist can
be sprayed.

static int hci_sock_blacklist_add(struct hci_dev *hdev, void __user *arg)
{
    bdaddr_t bdaddr;
    int err;

    if (copy_from_user(&amp;bdaddr, arg, sizeof(bdaddr)))
        return -EFAULT;

    hci_dev_lock(hdev);

    err = hci_bdaddr_list_add(&amp;hdev-&gt;blacklist, &amp;bdaddr, BDADDR_BREDR);
   // the user controlled bdaddr will be insert to list

    hci_dev_unlock(hdev);

    return err;
}

In a nutshell, the UAF of hdev can easily crash the kernel. It can also be
the weapon of skillful hackers (with CAP_NET_ADMIN privilege). Below we
provide the report from KASan.

[   12.663166]
==================================================================
[   12.664161] BUG: KASAN: use-after-free in mutex_lock+0xa9/0x130
[   12.664837] Write of size 8 at addr ffff88800c2ba010 by task exp/125
[   12.665551]
[   12.665731] CPU: 0 PID: 125 Comm: exp Not tainted 5.11.11+ #8
[   12.666378] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
1.10.2-1ubuntu1 04/01/2014
[   12.667372] Call Trace:
[   12.667661]  dump_stack+0x1b9/0x22e
[   12.668068]  ? show_regs_print_info+0x12/0x12
[   12.668563]  ? log_buf_vmcoreinfo_setup+0x45d/0x45d
[   12.669114]  print_address_description+0x7b/0x3a0
[   12.669646]  __kasan_report+0x14e/0x200
[   12.670084]  ? mutex_lock+0xa9/0x130
[   12.670494]  kasan_report+0x47/0x60
[   12.670894]  check_memory_region+0x2e2/0x330
[   12.671379]  mutex_lock+0xa9/0x130
[   12.671777]  ? mutex_trylock+0xb0/0xb0
[   12.672206]  ? copy_user_generic_string+0x31/0x40
[   12.672742]  hci_get_auth_info+0xbb/0x2b0
[   12.673206]  ? hci_get_conn_info+0x630/0x630
[   12.673696]  ? release_sock+0x155/0x1b0
[   12.674140]  hci_sock_ioctl+0x749/0x900
[   12.674582]  ? hci_sock_getname+0x1d0/0x1d0
[   12.675060]  ? do_vfs_ioctl+0x892/0x1a50
[   12.675514]  ? selinux_file_ioctl+0xd41/0x1200
[   12.676036]  ? __ia32_compat_sys_ioctl+0xc00/0xc00
[   12.676599]  sock_do_ioctl+0xdc/0x310
[   12.677042]  ? sock_show_fdinfo+0xb0/0xb0
[   12.677523]  ? hci_sock_release+0x400/0x400
[   12.677991]  sock_ioctl+0x4a6/0x710
[   12.678386]  ? sock_poll+0x400/0x400
[   12.678816]  ? __sys_socket+0x1c2/0x350
[   12.679275]  ? security_file_ioctl+0xa3/0xc0
[   12.679818]  ? sock_poll+0x400/0x400
[   12.680219]  __se_sys_ioctl+0x101/0x170
[   12.680683]  do_syscall_64+0x33/0x40
[   12.681085]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[   12.681675] RIP: 0033:0x7f89a2384247
[   12.682077] Code: 00 00 90 48 8b 05 49 8c 0c 00 64 c7 00 26 00 00 00 48
c7 c0 ff ff ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 b8 10 00 00 00 0f 05
&lt;48&gt; 3d 01 f0 ff ff 73 01 c3 48 8b 0d 19 8c 0c 00 f7 d8 64 89 01 48
[   12.684221] RSP: 002b:00007ffd49ce4538 EFLAGS: 00000246 ORIG_RAX:
0000000000000010
[   12.685111] RAX: ffffffffffffffda RBX: 00005623b3401c10 RCX:
00007f89a2384247
[   12.685918] RDX: 00007f89a249e000 RSI: 00000000800448d7 RDI:
0000000000000006
[   12.686752] RBP: 00007ffd49ce45c0 R08: 0000000000000001 R09:
00007f89a1a7c700
[   12.687561] R10: 0000000000000000 R11: 0000000000000246 R12:
00005623b3400d50
[   12.688367] R13: 00007ffd49ce46b0 R14: 0000000000000000 R15:
0000000000000000
[   12.689172]
[   12.689345] Allocated by task 125:
[   12.689758]  ____kasan_kmalloc+0xc6/0x100
[   12.690235]  kmem_cache_alloc_trace+0x124/0x200
[   12.690768]  hci_alloc_dev+0x4d/0x1ab0
[   12.691186]  hci_uart_tty_ioctl+0x3ba/0xa20
[   12.691686]  tty_ioctl+0x11ac/0x1b60
[   12.692121]  __se_sys_ioctl+0x101/0x170
[   12.692581]  do_syscall_64+0x33/0x40
[   12.693011]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[   12.693600]
[   12.693773] Freed by task 126:
[   12.694115]  kasan_set_track+0x3d/0x70
[   12.694593]  kasan_set_free_info+0x1f/0x40
[   12.695050]  ____kasan_slab_free+0x10e/0x140
[   12.695551]  kfree+0xeb/0x2d0
[   12.695920]  bt_host_release+0x18/0x20
[   12.696339]  device_release+0x9e/0x1d0
[   12.696791]  kobject_put+0x194/0x2b0
[   12.697188]  hci_uart_tty_close+0x1a7/0x220
[   12.697681]  tty_ldisc_hangup+0x4d7/0x6d0
[   12.698128]  __tty_hangup+0x6b2/0x970
[   12.698569]  tty_release+0x408/0x10e0
[   12.698979]  __fput+0x32f/0x7a0
[   12.699334]  task_work_run+0x15c/0x1e0
[   12.699819]  exit_to_user_mode_prepare+0xeb/0x110
[   12.700338]  syscall_exit_to_user_mode+0x20/0x40
[   12.700880]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[   12.701454]
[   12.701641] Last potentially related work creation:
[   12.702175]  kasan_save_stack+0x27/0x50
[   12.702633]  kasan_record_aux_stack+0xbd/0xe0
[   12.703116]  insert_work+0x4f/0x340
[   12.703536]  __queue_work+0x9cc/0xdb0
[   12.703975]  queue_work_on+0xd8/0x130
[   12.704387]  hci_recv_frame+0x182/0x1e0
[   12.704846]  h4_recv_buf+0x904/0xd40
[   12.705245]  h4_recv+0xf4/0x1b0
[   12.705628]  hci_uart_tty_receive+0x1be/0x380
[   12.706111]  tty_ldisc_receive_buf+0x130/0x170
[   12.706633]  tty_port_default_receive_buf+0x6a/0x90
[   12.707172]  flush_to_ldisc+0x2e8/0x510
[   12.707630]  process_one_work+0x6df/0xf80
[   12.708112]  worker_thread+0xac1/0x1340
[   12.708572]  kthread+0x2fc/0x320
[   12.708937]  ret_from_fork+0x22/0x30
[   12.709337]
[   12.709543] Second to last potentially related work creation:
[   12.710169]  kasan_save_stack+0x27/0x50
[   12.710627]  kasan_record_aux_stack+0xbd/0xe0
[   12.711111]  insert_work+0x4f/0x340
[   12.711532]  __queue_work+0x9cc/0xdb0
[   12.711983]  queue_work_on+0xd8/0x130
[   12.712392]  hci_event_packet+0x1bce1/0x23430
[   12.712908]  hci_rx_work+0x2a8/0x780
[   12.713308]  process_one_work+0x6df/0xf80
[   12.713783]  worker_thread+0xac1/0x1340
[   12.714212]  kthread+0x2fc/0x320
[   12.714610]  ret_from_fork+0x22/0x30
[   12.715012]
[   12.715186] The buggy address belongs to the object at ffff88800c2ba000
[   12.715186]  which belongs to the cache kmalloc-8k of size 8192
[   12.716629] The buggy address is located 16 bytes inside of
[   12.716629]  8192-byte region [ffff88800c2ba000, ffff88800c2bc000)
[   12.717930] The buggy address belongs to the page:
[   12.718485] page:(____ptrval____) refcount:1 mapcount:0
mapping:0000000000000000 index:0x0 pfn:0xc2b8
[   12.719519] head:(____ptrval____) order:3 compound_mapcount:0
compound_pincount:0
[   12.720364] flags: 0x100000000010200(slab|head)
[   12.720899] raw: 0100000000010200 ffffea0000346808 ffff888006c41270
ffff888006c4c2c0
[   12.721776] raw: 0000000000000000 0000000000010001 00000001ffffffff
0000000000000000
[   12.722676] page dumped because: kasan: bad access detected
[   12.723287]
[   12.723492] Memory state around the buggy address:
[   12.723961]  ffff88800c2b9f00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc
fc fc
[   12.724547]  ffff88800c2b9f80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc
fc fc
[   12.725133] &gt;ffff88800c2ba000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb
fb fb
[   12.725718]                          ^
[   12.726028]  ffff88800c2ba080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb
fb fb
[   12.726612]  ffff88800c2ba100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb
fb fb
[   12.727196]
==================================================================
[   12.727784] Disabling lock debugging due to kernel taint


=*=*=*=*=*=*=*=*=  BUG REPRODUCE  =*=*=*=*=*=*=*=*=

As above introduced, this race condition is highly controllable. This is
because the four related functions all call copy_from_user() function after
the check of hdev.

static int hci_sock_blacklist_add(struct hci_dev *hdev, void __user *arg)
{
    bdaddr_t bdaddr;
    int err;

    if (copy_from_user(&amp;bdaddr, arg, sizeof(bdaddr)))
        return -EFAULT;

    ...
}

static int hci_sock_blacklist_del(struct hci_dev *hdev, void __user *arg)
{
    bdaddr_t bdaddr;
    int err;

    if (copy_from_user(&amp;bdaddr, arg, sizeof(bdaddr)))
        return -EFAULT;

    ...
}

int hci_get_conn_info(struct hci_dev *hdev, void __user *arg)
{
    struct hci_conn_info_req req;
    struct hci_conn_info ci;
    struct hci_conn *conn;
    char __user *ptr = arg + sizeof(req);

    if (copy_from_user(&amp;req, arg, sizeof(req)))
        return -EFAULT;

    ...
}

int hci_get_auth_info(struct hci_dev *hdev, void __user *arg)
{
    struct hci_auth_info_req req;
    struct hci_conn *conn;

    if (copy_from_user(&amp;req, arg, sizeof(req)))
        return -EFAULT;

    ...
}

That is, we can adopt userfaultfd to stop these functions and then call the
detach routine to release the hdev object. After the hdev is already freed,
we handle the page fault from copy_from_user() can let these functions
cause UAF. (attacker can further spray the heap during this window)

The provided POC code can be used to prove the feasibility.

=*=*=*=*=*=*=*=*=  Bug FIX  =*=*=*=*=*=*=*=*=

The adopted patch is presented at
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth.git/commit/?id=e305509e678b3a4af2b3cfd410f409f7cdaabb52" rel="nofollow">https://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth.git/commit/?id=e305509e678b3a4af2b3cfd410f409f7cdaabb52</a>

In short, this patch replaces the lock to the correct one for serialization
requirements.

=*=*=*=*=*=*=*=*=  Timeline  =*=*=*=*=*=*=*=*=

2021-05-30: Bug reported to security@...nel.org and
linux-distros@...openwall.org
2021-05-31: Patch is adopted into Bluetooth tree
2021-06-01: CVE-2021-3573 is assigned

=*=*=*=*=*=*=*=*=  Credt  =*=*=*=*=*=*=*=*=
LinMa@...ckSec Team
syzkaller of course

Best Regards

<span style="font-family: times;"><strong>Content of type "</strong>text/html<strong>" skipped</strong></span>

<span style="font-family: times;"><strong>Download attachment "</strong><a href="https://www.openwall.com/lists/oss-security/2021/06/08/2/1" rel="nofollow" download="">POC.zip</a><strong>" of type "</strong>application/zip<strong>" (6574 bytes)</strong></span>
</pre>
<p><a href="http://www.openwall.com/blists/">Powered by blists</a> - <a href="http://lists.openwall.net/">more mailing lists</a>


</p><p>
Please check out the
<a href="https://oss-security.openwall.org/wiki/">
Open Source Software Security Wiki</a>, which is counterpart to this
<a href="https://oss-security.openwall.org/wiki/mailing-lists/oss-security">mailing list</a>.
</p><p>
Confused about <a href="https://www.openwall.com/lists/">mailing lists</a> and their use?
<a href="https://en.wikipedia.org/wiki/Electronic_mailing_list">Read about mailing lists on Wikipedia</a>
and check out these
<a href="https://www.complang.tuwien.ac.at/anton/mail-news-errors.html">guidelines on proper formatting of your messages</a>.
</p><p>

<a href="https://www.openwall.com/Owl/" title="Powered by Openwall GNU/*/Linux - security-enhanced &quot;Linux distribution&quot;"><img src="./2021 - Blue Klotski (CVE-2021-3573) and the story for fixing announcement_files/Owl-80x15-4.png" width="80" height="15" border="0" alt="Powered by Openwall GNU/*/Linux"></a>
<a href="https://openvz.org/" title="Powered by OpenVZ - OS virtualization solution for Linux"><img src="./2021 - Blue Klotski (CVE-2021-3573) and the story for fixing announcement_files/OpenVZ-80x15-cd.png" width="80" height="15" border="0" alt="Powered by OpenVZ"></a>





</p></body></html>