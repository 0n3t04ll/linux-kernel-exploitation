<!DOCTYPE html>
<!-- saved from url=(0081)https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html -->
<html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>CVE-2021-22555: Turning \x00\x00 into 10000$ | security-research</title>
<meta name="generator" content="Jekyll v3.9.0">
<meta property="og:title" content="CVE-2021-22555: Turning \x00\x00 into 10000$">
<meta property="og:locale" content="en_US">
<meta name="description" content="This project hosts security advisories and their accompanying proof-of-concepts related to research conducted at Google which impact non-Google owned code.">
<meta property="og:description" content="This project hosts security advisories and their accompanying proof-of-concepts related to research conducted at Google which impact non-Google owned code.">
<link rel="canonical" href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html">
<meta property="og:url" content="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html">
<meta property="og:site_name" content="security-research">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="CVE-2021-22555: Turning \x00\x00 into 10000$">
<script type="application/ld+json">
{"description":"This project hosts security advisories and their accompanying proof-of-concepts related to research conducted at Google which impact non-Google owned code.","url":"https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html","@type":"WebPage","headline":"CVE-2021-22555: Turning \\x00\\x00 into 10000$","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <style class="anchorjs"></style><link rel="stylesheet" href="./2021 - CVE-2021-22555 Turning double null byte into 10000$_files/style.css">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/security-research/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="https://google.github.io/security-research/">security-research</a></h1>
      

      <h1 id="cve-2021-22555-turning-x00x00-into-10000">CVE-2021-22555: Turning \x00\x00 into 10000$</h1>

<p align="right">Andy Nguyen (theflow@) - Information Security Engineer</p>

<p>CVE-2021-22555 is a 15 years old heap out-of-bounds write vulnerability in Linux Netfilter that is powerful enough to bypass all modern security mitigations and achieve kernel code execution. It was used to break the kubernetes pod isolation of the <a href="https://google.github.io/kctf/vrp.html">kCTF cluster</a> and won 10000$ for charity (where Google will match and double the donation to 20000$).</p>

<p align="center"><img src="./2021 - CVE-2021-22555 Turning double null byte into 10000$_files/poc.gif"></p>

<h2 id="table-of-contents">Table of Contents<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#table-of-contents" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>

<ul>
  <li><a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#introduction">Introduction</a></li>
  <li><a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#vulnerability">Vulnerability</a></li>
  <li><a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#exploitation">Exploitation</a>
    <ul>
      <li><a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#exploring-struct-msg_msg">Exploring struct msg_msg</a></li>
      <li><a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#achieving-use-after-free">Achieving use-after-free</a></li>
      <li><a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#bypassing-smap">Bypassing SMAP</a></li>
      <li><a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#achieving-a-better-use-after-free">Achieving a better use-after-free</a></li>
      <li><a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#finding-a-victim-object">Finding a victim object</a></li>
      <li><a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#bypassing-kaslrsmep">Bypassing KASLR/SMEP</a></li>
      <li><a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#escalating-privileges">Escalating privileges</a>
        <ul>
          <li><a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#kernel-rop-chain">Kernel ROP chain</a></li>
          <li><a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#escaping-the-container-and-popping-a-root-shell">Escaping the container and popping a root shell</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#proof-of-concept">Proof-Of-Concept</a></li>
  <li><a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#timeline">Timeline</a></li>
  <li><a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#thanks">Thanks</a></li>
</ul>

<h2 id="introduction">Introduction<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#introduction" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>

<p>After <a href="https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup.html">BleedingTooth</a>, which was the first time I looked into Linux, I wanted to find a privilege escalation vulnerability as well. I started by looking at old vulnerabilities like CVE-2016-3134 and CVE-2016-4997 which inspired me to grep for <code class="language-plaintext highlighter-rouge">memcpy()</code> and <code class="language-plaintext highlighter-rouge">memset()</code> in the Netfilter code. This led me to some buggy code.</p>

<h2 id="vulnerability">Vulnerability<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#vulnerability" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>

<p>When <code class="language-plaintext highlighter-rouge">IPT_SO_SET_REPLACE</code> or <code class="language-plaintext highlighter-rouge">IP6T_SO_SET_REPLACE</code> is called in compatibility mode, which requires the <code class="language-plaintext highlighter-rouge">CAP_NET_ADMIN</code> capability that can however be obtained in a user+network namespace, structures need to be converted from user to kernel as well as 32bit to 64bit in order to be processed by the native functions. Naturally, this is destined to be error prone. Our vulnerability is in <code class="language-plaintext highlighter-rouge">xt_compat_target_from_user()</code> where <code class="language-plaintext highlighter-rouge">memset()</code> is called with an offset <code class="language-plaintext highlighter-rouge">target-&gt;targetsize</code> that is not accounted for during the allocation - leading to a few bytes written out-of-bounds:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/netfilter/x_tables.c</span>
<span class="kt">void</span> <span class="nf">xt_compat_target_from_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">xt_entry_target</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">dstptr</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">xt_target</span> <span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">kernel</span><span class="p">.</span><span class="n">target</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">compat_xt_entry_target</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">compat_xt_entry_target</span> <span class="o">*</span><span class="p">)</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pad</span><span class="p">,</span> <span class="n">off</span> <span class="o">=</span> <span class="n">xt_compat_target_offset</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
	<span class="n">u_int16_t</span> <span class="n">tsize</span> <span class="o">=</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">user</span><span class="p">.</span><span class="n">target_size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">user</span><span class="p">.</span><span class="n">name</span><span class="p">)];</span>

	<span class="n">t</span> <span class="o">=</span> <span class="o">*</span><span class="n">dstptr</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ct</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ct</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">compat_from_user</span><span class="p">)</span>
		<span class="n">target</span><span class="o">-&gt;</span><span class="n">compat_from_user</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">tsize</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ct</span><span class="p">));</span>
	<span class="n">pad</span> <span class="o">=</span> <span class="n">XT_ALIGN</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">targetsize</span><span class="p">)</span> <span class="o">-</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">targetsize</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">targetsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>

	<span class="n">tsize</span> <span class="o">+=</span> <span class="n">off</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">user</span><span class="p">.</span><span class="n">target_size</span> <span class="o">=</span> <span class="n">tsize</span><span class="p">;</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">me</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">user</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">user</span><span class="p">.</span><span class="n">name</span><span class="p">));</span>

	<span class="o">*</span><span class="n">size</span> <span class="o">+=</span> <span class="n">off</span><span class="p">;</span>
	<span class="o">*</span><span class="n">dstptr</span> <span class="o">+=</span> <span class="n">tsize</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">targetsize</code> is not controllable by the user, but one can choose different targets with different structure sizes by name (like <code class="language-plaintext highlighter-rouge">TCPMSS</code>, <code class="language-plaintext highlighter-rouge">TTL</code> or <code class="language-plaintext highlighter-rouge">NFQUEUE</code>). The bigger <code class="language-plaintext highlighter-rouge">targetsize</code> is, the more we can vary in the offset. Though, the target size must <em>not</em> be 8 bytes aligned in order to fulfill <code class="language-plaintext highlighter-rouge">pad &gt; 0</code>. The biggest possible I found is <code class="language-plaintext highlighter-rouge">NFLOG</code> for which we can choose an offset up to 0x4C bytes out-of-bounds (one can influence the offset by adding padding between <code class="language-plaintext highlighter-rouge">struct xt_entry_match</code> and <code class="language-plaintext highlighter-rouge">struct xt_entry_target</code>):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">xt_nflog_info</span> <span class="p">{</span>
	<span class="cm">/* 'len' will be used iff you set XT_NFLOG_F_COPY_LEN in flags */</span>
	<span class="n">__u32</span>	<span class="n">len</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">group</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">threshold</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">pad</span><span class="p">;</span>
	<span class="kt">char</span>		<span class="n">prefix</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Note that the destination of the buffer is allocated with <code class="language-plaintext highlighter-rouge">GFP_KERNEL_ACCOUNT</code> and can also vary in the size:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/netfilter/x_tables.c</span>
<span class="k">struct</span> <span class="n">xt_table_info</span> <span class="o">*</span><span class="nf">xt_alloc_table_info</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xt_table_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sz</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">)</span> <span class="o">||</span> <span class="n">sz</span> <span class="o">&gt;=</span> <span class="n">XT_MAX_TABLE_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">kvmalloc</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">GFP_KERNEL_ACCOUNT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">));</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">info</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Though, the minimum size is &gt; 0x100 which means that the smallest slab this object can be allocated in is kmalloc-512. In other words, we have to find victims which are allocated between kmalloc-512 and kmalloc-8192 to exploit.</p>

<h2 id="exploitation">Exploitation<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#exploitation" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>

<p>Our primitive is limited to writing four bytes of zero up to 0x4C bytes out-of-bounds. With such a primitive, usual targets are:</p>

<ul>
  <li>Reference counter
    <ul>
      <li>Unfortunately, I could not find any suitable objects with a reference counter in the first 0x4C bytes.</li>
    </ul>
  </li>
  <li>Free list pointer
    <ul>
      <li><a href="https://duasynt.com/blog/cve-2016-6187-heap-off-by-one-exploit">CVE-2016-6187: Exploiting Linux kernel heap off-by-one</a> is a good example on how to exploit the free list pointer. However, this was already 5 years ago, and meanwhile, kernels have the <code class="language-plaintext highlighter-rouge">CONFIG_SLAB_FREELIST_HARDENED</code> option enabled which among other things protects free list pointers.</li>
    </ul>
  </li>
  <li>Pointer in a struct
    <ul>
      <li>This is the most promising approach, however four bytes of zero is too much to write. For example, a pointer 0xffff91a49cb7f000 could only be turned to 0xffff91a400000000 or 0x9cb7f000, where both of them would likely be invalid pointers. On the other hand, if we used the primitive to write at the very beginning of the adjacent block, we could write less bytes, e.g. 2 bytes, and for example turn a pointer from 0xffff91a49cb7f000 to 0xffff91a49cb70000.</li>
    </ul>
  </li>
</ul>

<p>Playing around with some victim objects, I noticed that I could never reliably allocate them around <code class="language-plaintext highlighter-rouge">struct xt_table_info</code> on kernel 5.4. I realized that it had something to do with the <code class="language-plaintext highlighter-rouge">GFP_KERNEL_ACCOUNT</code> flag, as other objects allocated with <code class="language-plaintext highlighter-rouge">GFP_KERNEL_ACCOUNT</code> did not have this issue. Jann Horn confirmed that before 5.9, separate slabs were used to implement <em>accounting</em>. Therefore, every heap primitive we use in the exploit chain should also use <code class="language-plaintext highlighter-rouge">GFP_KERNEL_ACCOUNT</code>.</p>

<p>The syscall <code class="language-plaintext highlighter-rouge">msgsnd()</code> is a well known primitive for heap spraying (which uses <code class="language-plaintext highlighter-rouge">GFP_KERNEL_ACCOUNT</code>) and has been utilized for multiple public exploits already. Though, its structure <code class="language-plaintext highlighter-rouge">msg_msg</code> has surprisingly never been abused. In this write-up, we will demonstrate how this data-structure can be abused to gain a use-after-free primitive which in turn can be used to leak addresses and fake other objects. Coincidentally, in parallel to my research in March 2021, Alexander Popov also explored the very same structure in <a href="https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html">Four Bytes of Power: exploiting CVE-2021-26708 in the Linux kernel</a>.</p>

<h3 id="exploring-struct-msg_msg">Exploring struct msg_msg<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#exploring-struct-msg_msg" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>When sending data with <code class="language-plaintext highlighter-rouge">msgsnd()</code>, the payload is split into multiple segments:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/ipc/msgutil.c</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="nf">alloc_msg</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_msgseg</span> <span class="o">**</span><span class="n">pseg</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">alen</span><span class="p">;</span>

	<span class="n">alen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">DATALEN_MSG</span><span class="p">);</span>
	<span class="n">msg</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="p">)</span> <span class="o">+</span> <span class="n">alen</span><span class="p">,</span> <span class="n">GFP_KERNEL_ACCOUNT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">-=</span> <span class="n">alen</span><span class="p">;</span>
	<span class="n">pseg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">msg_msgseg</span> <span class="o">*</span><span class="n">seg</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="n">alen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">DATALEN_SEG</span><span class="p">);</span>
		<span class="n">seg</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">seg</span><span class="p">)</span> <span class="o">+</span> <span class="n">alen</span><span class="p">,</span> <span class="n">GFP_KERNEL_ACCOUNT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pseg</span> <span class="o">=</span> <span class="n">seg</span><span class="p">;</span>
		<span class="n">seg</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">pseg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">alen</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">msg</span><span class="p">;</span>

<span class="nl">out_err:</span>
	<span class="n">free_msg</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>where the headers for <code class="language-plaintext highlighter-rouge">struct msg_msg</code> and <code class="language-plaintext highlighter-rouge">struct msg_msgseg</code> are:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/msg.h</span>
<span class="cm">/* one msg_msg structure for each message */</span>
<span class="k">struct</span> <span class="n">msg_msg</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">m_list</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">m_type</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">m_ts</span><span class="p">;</span>		<span class="cm">/* message text size */</span>
	<span class="k">struct</span> <span class="n">msg_msgseg</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">security</span><span class="p">;</span>
	<span class="cm">/* the actual message follows immediately */</span>
<span class="p">};</span>

<span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/types.h</span>
<span class="k">struct</span> <span class="n">list_head</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/ipc/msgutil.c</span>
<span class="k">struct</span> <span class="n">msg_msgseg</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">msg_msgseg</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="cm">/* the next part of the message follows immediately */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The first member in <code class="language-plaintext highlighter-rouge">struct msg_msg</code> is the <code class="language-plaintext highlighter-rouge">mlist.next</code> pointer which is pointing to another message in the queue (which is different from <code class="language-plaintext highlighter-rouge">next</code> as this is a pointer to the next segment). This is a perfect candidate to corrupt as you will learn next.</p>

<h3 id="achieving-use-after-free">Achieving use-after-free<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#achieving-use-after-free" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>First, we initialize a lot of message queues (in our case 4096) using <code class="language-plaintext highlighter-rouge">msgget()</code>. Then, we send one message of size 4096 (including the <code class="language-plaintext highlighter-rouge">struct msg_msg</code> header) for each of the message queues using <code class="language-plaintext highlighter-rouge">msgsnd()</code>, which we will call the <strong>primary message</strong>. Eventually, after a lot of messages, we have some that are consecutive:</p>

<p align="center"><img src="./2021 - CVE-2021-22555 Turning double null byte into 10000$_files/1.png"></p>

<p>[Figure 1: A series of blocks of <strong>primary messages</strong>]</p>

<p>Next, we send a <strong>secondary message</strong> of size 1024 for each of the message queues using <code class="language-plaintext highlighter-rouge">msgsnd()</code>:</p>

<p align="center"><img src="./2021 - CVE-2021-22555 Turning double null byte into 10000$_files/2.png"></p>

<p>[Figure 2: A series of blocks of <strong>primary messages</strong> pointing to <strong>secondary messages</strong>]</p>

<p>Finally, we create some holes (in our case every 1024th) in the <strong>primary messages</strong>, and trigger the vulnerable <code class="language-plaintext highlighter-rouge">setsockopt(IPT_SO_SET_REPLACE)</code> option, which, in the best scenario, will allocate the <code class="language-plaintext highlighter-rouge">struct xt_table_info</code> object in one of the holes:</p>

<p align="center"><img src="./2021 - CVE-2021-22555 Turning double null byte into 10000$_files/3.png"></p>

<p>[Figure 3: A <code class="language-plaintext highlighter-rouge">xt_table_info</code> allocated in between the blocks which corrupts the next pointer]</p>

<p>We choose to overwrite two bytes of the adjacent object with zeros. Assume we are adjacent to another <strong>primary message</strong>, these bytes we overwrite are part of the pointer to the <strong>secondary message</strong>. Since we allocate them with a size of 1024 bytes, we therefore have a 1 - (1024 / 65536) chance to redirect the pointer (the only case we fail is when the two least significant bytes of the pointer are already zero).</p>

<p>Now, the best scenario we can hope for is that the manipulated pointer <em>also</em> points to a <strong>secondary message</strong>, since the consequence will be two different <strong>primary messages</strong> pointing to the same <strong>secondary message</strong>, and this can lead to a use-after-free:</p>

<p align="center"><img src="./2021 - CVE-2021-22555 Turning double null byte into 10000$_files/4.png"></p>

<p>[Figure 4: Two <strong>primary messages</strong> pointing to the same <strong>secondary message</strong> due to the corrupted pointer]</p>

<p>However, how do we know which two <strong>primary messages</strong> are pointing to the same <strong>secondary message</strong>? In order to answer this question, we tag every (primary and secondary) message with the index of the message queue which is in [0, 4096). Then, after triggering the corruption, we iterate through all message queues, peek at all messages using <code class="language-plaintext highlighter-rouge">msgrcv()</code> with <code class="language-plaintext highlighter-rouge">MSG_COPY</code> and see if they are the same. If the tag of the <strong>primary message</strong> is different from the <strong>secondary message</strong>, it means that it has been redirected. In which case the tag of the <strong>primary message</strong> represents the index of the <em>fake message queue</em>, i.e. the one containing the wrong <strong>secondary message</strong>, and the tag of the wrong <strong>secondary message</strong> represents the index of the <em>real message queue</em>. Knowing these two indices, achieving a use-after-free is now trivial - we namely fetch the <strong>secondary message</strong> from the <em>real message queue</em> using <code class="language-plaintext highlighter-rouge">msgrcv()</code> and as such free it:</p>

<p align="center"><img src="./2021 - CVE-2021-22555 Turning double null byte into 10000$_files/5.png"></p>

<p>[Figure 5: Freed <strong>secondary message</strong> with a stale reference]</p>

<p>Note that we still have a reference to the freed message in the <em>fake message queue</em>.</p>

<h3 id="bypassing-smap">Bypassing SMAP<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#bypassing-smap" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>Using unix sockets (which can be easily set up with <code class="language-plaintext highlighter-rouge">socketpair()</code>), we now spray a lot of messages of size 1024 and imitate the <code class="language-plaintext highlighter-rouge">struct msg_msg</code> header. Ideally, we are able to reclaim the address of the previously freed message:</p>

<p align="center"><img src="./2021 - CVE-2021-22555 Turning double null byte into 10000$_files/6.png"></p>

<p>[Figure 6: Fake <code class="language-plaintext highlighter-rouge">struct msg_msg</code> put in place of the freed <strong>secondary message</strong>]</p>

<p>Note that <code class="language-plaintext highlighter-rouge">mlist.next</code> is 41414141 as we do not yet know any kernel addresses (when SMAP is enabled, we cannot specify a user address). Not having a kernel address is crucial as it actually prevents us from freeing the block again (you will learn later why that is desired). The reason is that during <code class="language-plaintext highlighter-rouge">msgrcv()</code>, the message is unlinked from the message queue that is a circular list. Luckily, we are actually in a good position to achieve an information leak, as there are some interesting fields in <code class="language-plaintext highlighter-rouge">struct msg_msg</code>. Namely, the field <code class="language-plaintext highlighter-rouge">m_ts</code> is used to determine how much data to return to userland:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/ipc/msgutil.c</span>
<span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="nf">copy_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msg_msgseg</span> <span class="o">*</span><span class="n">dst_pseg</span><span class="p">,</span> <span class="o">*</span><span class="n">src_pseg</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">m_ts</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">alen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">m_ts</span> <span class="o">&gt;</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">m_ts</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">alen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">DATALEN_MSG</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">src</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alen</span><span class="p">);</span>

	<span class="p">...</span>
	<span class="k">return</span> <span class="n">dst</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The original size of the message is only <code class="language-plaintext highlighter-rouge">1024-sizeof(struct msg_msg)</code> bytes which we can now artificially increase to <code class="language-plaintext highlighter-rouge">DATALEN_MSG=4096-sizeof(struct msg_msg)</code>. As a consequence, we will now be able to read past the intended message size and leak the <code class="language-plaintext highlighter-rouge">struct msg_msg</code> header of the adjacent message. As said before, the message queue is implemented as a circular list, thus, <code class="language-plaintext highlighter-rouge">mlist.next</code> points back to the <strong>primary message</strong>.</p>

<p>Knowing the address of a <strong>primary message</strong>, we can re-craft the fake <code class="language-plaintext highlighter-rouge">struct msg_msg</code> with that address as <code class="language-plaintext highlighter-rouge">next</code> (meaning that it is the next segment). The content of the <strong>primary message</strong> can then be leaked by reading more than <code class="language-plaintext highlighter-rouge">DATALEN_MSG</code> bytes. The leaked <code class="language-plaintext highlighter-rouge">mlist.next</code> pointer from the <strong>primary message</strong> reveals the address of the <strong>secondary message</strong> that is adjacent to our fake <code class="language-plaintext highlighter-rouge">struct msg_msg</code>. Subtracting 1024 from that address, we finally have the address of the fake message.</p>

<h3 id="achieving-a-better-use-after-free">Achieving a better use-after-free<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#achieving-a-better-use-after-free" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>Now, we can rebuild the fake <code class="language-plaintext highlighter-rouge">struct msg_msg</code> object with the leaked address as <code class="language-plaintext highlighter-rouge">mlist.next</code> and <code class="language-plaintext highlighter-rouge">mlist.prev</code> (meaning that it is pointing to itself), making the fake message free-able with the <em>fake message queue</em>.</p>

<p align="center"><img src="./2021 - CVE-2021-22555 Turning double null byte into 10000$_files/7.png"></p>

<p>[Figure 7: Fake <code class="language-plaintext highlighter-rouge">struct msg_msg</code> with a valid next pointer pointing to itself]</p>

<p>Note that when spraying using unix sockets, we actually have a <code class="language-plaintext highlighter-rouge">struct sk_buff</code> object which points to the fake message. Obviously, this means that when we free the fake message, we still have a stale reference:</p>

<p align="center"><img src="./2021 - CVE-2021-22555 Turning double null byte into 10000$_files/8.png"></p>

<p>[Figure 8: Freed fake message with a stale reference]</p>

<p>This stale <code class="language-plaintext highlighter-rouge">struct sk_buff</code> data buffer is a better use-after-free scenario to exploit, because it does not contain header information, meaning that we can now use it to free <em>any</em> kind of object on the slab. In comparison, freeing a <code class="language-plaintext highlighter-rouge">struct msg_msg</code> object is only possible if the first two members are writable pointers (needed to unlink the message).</p>

<h3 id="finding-a-victim-object">Finding a victim object<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#finding-a-victim-object" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>The best victim to attack is one that has a function pointer in its structure. Remember that the victim must also be allocated with <code class="language-plaintext highlighter-rouge">GFP_KERNEL_ACCOUNT</code>.</p>

<p>Talking to Jann Horn, he suggested the <code class="language-plaintext highlighter-rouge">struct pipe_buffer</code> object which is allocated in kmalloc-1024 (hence why the <strong>secondary message</strong> is 1024 bytes). The <code class="language-plaintext highlighter-rouge">struct pipe_buffer</code> can be easily allocated with <code class="language-plaintext highlighter-rouge">pipe()</code> that has <code class="language-plaintext highlighter-rouge">alloc_pipe_info()</code> as a subroutine:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/pipe.c</span>
<span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="nf">alloc_pipe_info</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pipe_bufs</span> <span class="o">=</span> <span class="n">PIPE_DEF_BUFFERS</span><span class="p">;</span>
	<span class="p">...</span>
	<span class="n">pipe</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe_inode_info</span><span class="p">),</span> <span class="n">GFP_KERNEL_ACCOUNT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pipe</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_uid</span><span class="p">;</span>
	<span class="p">...</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">bufs</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">pipe_bufs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe_buffer</span><span class="p">),</span>
			     <span class="n">GFP_KERNEL_ACCOUNT</span><span class="p">);</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>While it does not contain a function pointer directly, it contains a pointer to <code class="language-plaintext highlighter-rouge">struct pipe_buf_operations</code> that on the other hand has function pointers:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/pipe_fs_i.h</span>
<span class="k">struct</span> <span class="n">pipe_buffer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pipe_buf_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">private</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pipe_buf_operations</span> <span class="p">{</span>
	<span class="p">...</span>
	<span class="cm">/*
	 * When the contents of this pipe buffer has been completely
	 * consumed by a reader, -&gt;release() is called.
	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pipe_buffer</span> <span class="o">*</span><span class="p">);</span>
	<span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="bypassing-kaslrsmep">Bypassing KASLR/SMEP<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#bypassing-kaslrsmep" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>When one writes to the pipes, <code class="language-plaintext highlighter-rouge">struct pipe_buffer</code> is populated. Most importantly, <code class="language-plaintext highlighter-rouge">ops</code> will point to the static structure <code class="language-plaintext highlighter-rouge">anon_pipe_buf_ops</code> which resides in the .data segment:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/pipe.c</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pipe_buf_operations</span> <span class="n">anon_pipe_buf_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">anon_pipe_buf_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">try_steal</span>	<span class="o">=</span> <span class="n">anon_pipe_buf_try_steal</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span>		<span class="o">=</span> <span class="n">generic_pipe_buf_get</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Since the difference between the .data segment and the .text segment is always the same, having <code class="language-plaintext highlighter-rouge">anon_pipe_buf_ops</code> basically allows us to calculate the kernel base address.</p>

<p>We spray a lot of <code class="language-plaintext highlighter-rouge">struct pipe_buffer</code> objects and reclaim the location of the stale <code class="language-plaintext highlighter-rouge">struct sk_buff</code> data buffer:</p>

<p align="center"><img src="./2021 - CVE-2021-22555 Turning double null byte into 10000$_files/9.png"></p>

<p>[Figure 9: Freed fake message reclaimed with a <code class="language-plaintext highlighter-rouge">struct pipe_buffer</code>]</p>

<p>As we still have a reference from the <code class="language-plaintext highlighter-rouge">struct sk_buff</code>, we can read its data buffer, leak the content of <code class="language-plaintext highlighter-rouge">struct pipe_buffer</code> and reveal the address of <code class="language-plaintext highlighter-rouge">anon_pipe_buf_ops</code>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>+] anon_pipe_buf_ops: ffffffffa1e78380
<span class="o">[</span>+] kbase_addr: ffffffffa0e00000
</code></pre></div></div>

<p>With this information, we can now find JOP/ROP gadgets. Note that when reading from the unix socket, we actually free its buffer as well:</p>

<p align="center"><img src="./2021 - CVE-2021-22555 Turning double null byte into 10000$_files/10.png"></p>

<p>[Figure 10: Freed fake message reclaimed with a <code class="language-plaintext highlighter-rouge">struct pipe_buffer</code>]</p>

<h3 id="escalating-privileges">Escalating privileges<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#escalating-privileges" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>We reclaim the stale <code class="language-plaintext highlighter-rouge">struct pipe_buffer</code> with a fake one with <code class="language-plaintext highlighter-rouge">ops</code> pointing to a fake <code class="language-plaintext highlighter-rouge">struct pipe_buf_operations</code>. This fake structure is planted at the same location since we know its address, and obviously, this structure should contain a malicious function pointer as <code class="language-plaintext highlighter-rouge">release</code>.</p>

<p align="center"><img src="./2021 - CVE-2021-22555 Turning double null byte into 10000$_files/11.png"></p>

<p>[Figure 11: Freed <code class="language-plaintext highlighter-rouge">struct pipe_buffer</code> reclaimed with a fake <code class="language-plaintext highlighter-rouge">struct pipe_buffer</code>]</p>

<p>The final stage of the exploit is to close all pipes in order to trigger the release which in turn will kick off the JOP chain. Finding JOP gadgets is hard, thus the goal is to achieve a kernel stack pivot as soon as possible in order to execute a kernel ROP chain.</p>

<h4 id="kernel-rop-chain">Kernel ROP chain<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#kernel-rop-chain" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h4>

<p>We save the value of RBP at some scratchpad address in kernel so that we can later resume the execution, then we call <code class="language-plaintext highlighter-rouge">commit_creds(prepare_kernel_cred(NULL))</code> to install kernel credentials and finally we call <code class="language-plaintext highlighter-rouge">switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)</code> to switch the namespace of process 1 to the one of the <em>init</em> process. After that, we restore the value of RBP and return to resume the execution (which will immediately make <code class="language-plaintext highlighter-rouge">free_pipe_info()</code> return).</p>

<h4 id="escaping-the-container-and-popping-a-root-shell">Escaping the container and popping a root shell<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#escaping-the-container-and-popping-a-root-shell" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h4>

<p>Arriving back in userland, we now have root permissions to change mnt, pid and net namespaces to escape the container and break out of the kubernetes pod. Ultimately, we pop a root shell.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">setns</span><span class="p">(</span><span class="n">open</span><span class="p">(</span><span class="s">"/proc/1/ns/mnt"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">setns</span><span class="p">(</span><span class="n">open</span><span class="p">(</span><span class="s">"/proc/1/ns/pid"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">setns</span><span class="p">(</span><span class="n">open</span><span class="p">(</span><span class="s">"/proc/1/ns/net"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

  <span class="kt">char</span> <span class="o">*</span><span class="n">args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"/bin/bash"</span><span class="p">,</span> <span class="s">"-i"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
  <span class="n">execve</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="proof-of-concept">Proof-Of-Concept<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#proof-of-concept" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>

<p>The Proof-Of-Concept is available at <a href="https://github.com/google/security-research/tree/master/pocs/linux/cve-2021-22555">https://github.com/google/security-research/tree/master/pocs/linux/cve-2021-22555</a>.</p>

<p>Executing it on a vulnerable machine will grant you root:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>theflow@theflow:~<span class="nv">$ </span>gcc <span class="nt">-m32</span> <span class="nt">-static</span> <span class="nt">-o</span> exploit exploit.c
theflow@theflow:~<span class="nv">$ </span>./exploit
<span class="o">[</span>+] Linux Privilege Escalation by theflow@ - 2021

<span class="o">[</span>+] STAGE 0: Initialization
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Setting up namespace sandbox...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Initializing sockets and message queues...

<span class="o">[</span>+] STAGE 1: Memory corruption
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Spraying primary messages...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Spraying secondary messages...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Creating holes <span class="k">in </span>primary messages...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Triggering out-of-bounds write...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Searching <span class="k">for </span>corrupted primary message...
<span class="o">[</span>+] fake_idx: ffc
<span class="o">[</span>+] real_idx: fc4

<span class="o">[</span>+] STAGE 2: SMAP bypass
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Freeing real secondary message...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Spraying fake secondary messages...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Leaking adjacent secondary message...
<span class="o">[</span>+] kheap_addr: ffff91a49cb7f000
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Freeing fake secondary messages...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Spraying fake secondary messages...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Leaking primary message...
<span class="o">[</span>+] kheap_addr: ffff91a49c7a0000

<span class="o">[</span>+] STAGE 3: KASLR bypass
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Freeing fake secondary messages...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Spraying fake secondary messages...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Freeing sk_buff data buffer...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Spraying pipe_buffer objects...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Leaking and freeing pipe_buffer object...
<span class="o">[</span>+] anon_pipe_buf_ops: ffffffffa1e78380
<span class="o">[</span>+] kbase_addr: ffffffffa0e00000

<span class="o">[</span>+] STAGE 4: Kernel code execution
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Spraying fake pipe_buffer objects...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Releasing pipe_buffer objects...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Checking <span class="k">for </span>root...
<span class="o">[</span>+] Root privileges gained.

<span class="o">[</span>+] STAGE 5: Post-exploitation
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Escaping container...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Cleaning up...
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Popping root shell...
root@theflow:/# <span class="nb">id
</span><span class="nv">uid</span><span class="o">=</span>0<span class="o">(</span>root<span class="o">)</span> <span class="nv">gid</span><span class="o">=</span>0<span class="o">(</span>root<span class="o">)</span> <span class="nb">groups</span><span class="o">=</span>0<span class="o">(</span>root<span class="o">)</span>
root@theflow:/#
</code></pre></div></div>

<h2 id="timeline">Timeline<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#timeline" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>

<p>2021-04-06 - Vulnerability reported to security@kernel.org.<br>
2021-04-13 - Patch merged upstream.<br>
2021-07-07 - Public disclosure.</p>

<h2 id="thanks">Thanks<a class="anchorjs-link " href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#thanks" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>

<p>Eduardo Vela<br>
Francis Perron<br>
Jann Horn</p>


      
      <div class="footer border-top border-gray-light mt-5 pt-3 text-right text-gray">
        This site is open source. <a href="https://github.com/google/security-research/edit/master/pocs/linux/cve-2021-22555/writeup.md">Improve this page</a>.
      </div>
      
    </div>
    <script src="./2021 - CVE-2021-22555 Turning double null byte into 10000$_files/anchor.min.js.下載" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
  

</body></html>