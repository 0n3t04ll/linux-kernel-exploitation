<!DOCTYPE html>
<!-- saved from url=(0032)https://vul.360.net/archives/263 -->
<html lang="zh-Hans"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
<title>Internal of the Android kernel backdoor vulnerability</title>
<meta name="description" content="回顾Android内核漏洞史可以发现，大部分Android内核漏洞属于内存漏洞，而逻辑漏洞相对少见。由于内存漏洞具有典型的漏洞模式、明显的副作用以及较完善的检测方法，因此这类漏洞较容易发现。对应地，逻辑漏洞没有典型的漏洞模式（往往与功能紧密相关）、不确定的副作用以及缺乏普适的检测方法，因此，挖掘这类漏洞相对困难。正因为如此，逻辑漏洞有它独特的魅力。">
<meta name="keywords" content="漏洞分析,漏洞利用">
<link rel="apple-touch-icon" href="https://vul.360.net/wp-content/themes/JieStyle-Two/images/icon_32.png">
<link rel="icon" href="https://vul.360.net/wp-content/themes/JieStyle-Two/images/icon_32.png" type="image/x-icon">
<link rel="stylesheet" href="./2021 - Internal of the Android kernel backdoor vulnerability_files/bootstrap.min.css">
<link rel="stylesheet" href="./2021 - Internal of the Android kernel backdoor vulnerability_files/fontawesome.min.css">
<link rel="stylesheet" href="./2021 - Internal of the Android kernel backdoor vulnerability_files/style.css">
<meta name="robots" content="noindex, nofollow">
<link rel="stylesheet" id="wp-block-library-css" href="./2021 - Internal of the Android kernel backdoor vulnerability_files/style.min.css" type="text/css" media="all">
<link rel="stylesheet" id="pure-highlightjs-style-css" href="./2021 - Internal of the Android kernel backdoor vulnerability_files/vs.css" type="text/css" media="all">
<link rel="stylesheet" id="pure-highlightjs-css-css" href="./2021 - Internal of the Android kernel backdoor vulnerability_files/pure-highlight.css" type="text/css" media="all">
<link rel="stylesheet" id="wbui-css-css" href="./2021 - Internal of the Android kernel backdoor vulnerability_files/wbui.css" type="text/css" media="all">
<link rel="stylesheet" id="wbs-dwqr-css-css" href="./2021 - Internal of the Android kernel backdoor vulnerability_files/wbp_donate.css" type="text/css" media="all">
<style type="text/css">
    a{color:#5bc0eb}
    a:hover{color:#2980b9!important}
    #header{background-color:#5bc0eb}
    .widget .widget-title::after{background-color:#5bc0eb}
    .uptop{border-left-color:#5bc0eb}
    #titleBar .toggle:before{background:#5bc0eb}
</style>
</head>

<body>
	<div id="mobiletop" style="padding-top: 44px;"><img src="./2021 - Internal of the Android kernel backdoor vulnerability_files/mobile-top.png" style="width:100%"></div>
<header id="header">
 &nbsp; &nbsp;<div class="avatar"><img src="./2021 - Internal of the Android kernel backdoor vulnerability_files/pc-logo.png" width="65%"><h1 id="name">360政企安全漏洞研究院</h1></div>
    <div class="nav">
        <ul><li><img src="./2021 - Internal of the Android kernel backdoor vulnerability_files/主页" home=""><a href="https://vul.360.net/">主页 Home</a></li>
<li><img src="./2021 - Internal of the Android kernel backdoor vulnerability_files/归档" archive=""><a href="https://vul.360.net/archive">归档 Archive</a></li>
<li><img src="./2021 - Internal of the Android kernel backdoor vulnerability_files/成果" achievement=""><a href="https://vul.360.net/achievement">成果 Achievement</a></li>
<li><img src="./2021 - Internal of the Android kernel backdoor vulnerability_files/招聘" careers=""><a href="https://vul.360.net/careers">招聘 Careers</a></li>
<li><img src="./2021 - Internal of the Android kernel backdoor vulnerability_files/致谢" acknowledge=""><a href="https://vul.360.net/acknowledge">致谢 Acknowledge</a></li>
<li><img src="./2021 - Internal of the Android kernel backdoor vulnerability_files/关于" about=""><a href="https://vul.360.net/about">关于 About</a></li>
</ul>    </div>
	    <div class="sns">
        <a href="https://vul.360.net/feed" target="_blank" rel="nofollow" data-toggle="tooltip" data-placement="top" title="RSS"><i class="fas fa-rss"></i></a>        <a href="https://weibo.com/" target="_blank" rel="nofollow" data-toggle="tooltip" data-placement="top" title="Weibo"><i class="fab fa-weibo"></i></a>        <a href="https://twitter.com/" target="_blank" rel="nofollow" data-toggle="tooltip" data-placement="top" title="Twitter"><i class="fab fa-twitter"></i></a>        <a href="https://www.facebook.com/" target="_blank" rel="nofollow" data-toggle="tooltip" data-placement="top" title="Facebook"><i class="fab fa-facebook"></i></a>        <a href="https://github.com/" target="_blank" rel="nofollow" data-toggle="tooltip" data-placement="top" title="GitHub"><i class="fab fa-github-alt"></i></a>    </div>
        <div class="logo2">
<img src="./2021 - Internal of the Android kernel backdoor vulnerability_files/pc-logo2.png" width="65%" style="position:absolute;bottom:20px;left:40px">
    </div>
    </header>
<div id="main">
    <article class="col-md-10 col-md-offset-1 view clearfix">
        <h1 class="view-title">Internal of the Android kernel backdoor vulnerability</h1>
        <div class="view-meta">
            <span>作者: 2freeman（姚俊）</span>
            <span>分类: <a href="https://vul.360.net/archives/category/%e5%ae%89%e5%85%a8%e7%a0%94%e7%a9%b6" rel="category tag">安全研究</a>,<a href="https://vul.360.net/archives/category/%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90" rel="category tag">漏洞分析</a></span>
            <span>发布时间: 2021-08-30 10:22</span>
            <span></span>
        </div>
        <div class="view-content">

<h1>综述</h1>



<p>回顾Android内核漏洞史可以发现，大部分Android内核漏洞属于内存漏洞，而逻辑漏洞相对少见。由于内存漏洞具有典型的漏洞模式、明显的副作用以及较完善的检测方法，因此这类漏洞较容易发现。对应地，逻辑漏洞没有典型的漏洞模式（往往与功能紧密相关）、不确定的副作用以及缺乏普适的检测方法，因此，挖掘这类漏洞相对困难。正因为如此，逻辑漏洞有它独特的魅力。</p>



<p>这篇文章将深入分析CVE-2021-28663，它是ARM Mali GPU驱动里的一个逻辑漏洞。这个漏洞堪称后门：</p>



<p>1 抗碎片化：影响使用联发科、海思以及猎户座SoC的手机，近几年面世的手机几乎都受影响；<br>2 攻击具有隐蔽性：该漏洞的攻击方式与常见的利用方式有很大不同，据我所知，目前没有公开资料介绍该漏洞的利用方法；<br>3 普通APP可以轻易窃取其他APP或者内核运行时数据，甚至修改其他APP的代码，整个过程不需要获得任何额外的权限；<br>4 ROOT提权具有100%的成功率；</p>



<p>下面我将揭开它神秘的面纱。</p>



<h1>漏洞影响</h1>



<p>由于联发科、海思以及猎户座SoC均使用ARM Mali GPU，所以使用这些芯片的手机都可能受影响。我搜集了部分主流芯片或者手机相关源代码，发现均受影响：</p>



<div class="wp-block-group"><div class="wp-block-group__inner-container">
<figure class="wp-block-table is-style-regular"><table><thead><tr><th class="has-text-align-center" data-align="center">时间</th><th class="has-text-align-center" data-align="center">厂商</th><th class="has-text-align-center" data-align="center">手机型号</th><th class="has-text-align-center" data-align="center">芯片型号</th><th class="has-text-align-center" data-align="center">驱动版本</th></tr></thead><tbody><tr><td class="has-text-align-center" data-align="center">2021</td><td class="has-text-align-center" data-align="center">SAMSUNG</td><td class="has-text-align-center" data-align="center">S21</td><td class="has-text-align-center" data-align="center">Exynos 2100</td><td class="has-text-align-center" data-align="center">v_r20p0</td></tr><tr><td class="has-text-align-center" data-align="center">2020</td><td class="has-text-align-center" data-align="center">HUAWEI</td><td class="has-text-align-center" data-align="center">Mate40</td><td class="has-text-align-center" data-align="center">Kirin 9000</td><td class="has-text-align-center" data-align="center">r23p0-01rel0</td></tr><tr><td class="has-text-align-center" data-align="center">2020</td><td class="has-text-align-center" data-align="center">Redmi</td><td class="has-text-align-center" data-align="center">K30U</td><td class="has-text-align-center" data-align="center">天玑1000+</td><td class="has-text-align-center" data-align="center">v_r21p0</td></tr><tr><td class="has-text-align-center" data-align="center">2020</td><td class="has-text-align-center" data-align="center">Redmi</td><td class="has-text-align-center" data-align="center">10X</td><td class="has-text-align-center" data-align="center">天玑820</td><td class="has-text-align-center" data-align="center">v_r21p0</td></tr><tr><td class="has-text-align-center" data-align="center">2020</td><td class="has-text-align-center" data-align="center">SAMSUNG</td><td class="has-text-align-center" data-align="center">S20</td><td class="has-text-align-center" data-align="center">Exynos 990</td><td class="has-text-align-center" data-align="center">v_r25p1</td></tr><tr><td class="has-text-align-center" data-align="center">2019</td><td class="has-text-align-center" data-align="center">HUAWEI</td><td class="has-text-align-center" data-align="center">Mate30</td><td class="has-text-align-center" data-align="center">Kirin 990</td><td class="has-text-align-center" data-align="center">b-r18p0-01rel0</td></tr><tr><td class="has-text-align-center" data-align="center">2019</td><td class="has-text-align-center" data-align="center">Redmi</td><td class="has-text-align-center" data-align="center">Note8 Pro</td><td class="has-text-align-center" data-align="center">Helio G90T</td><td class="has-text-align-center" data-align="center">b_r20p0</td></tr><tr><td class="has-text-align-center" data-align="center">2019</td><td class="has-text-align-center" data-align="center">SAMSUNG</td><td class="has-text-align-center" data-align="center">S10</td><td class="has-text-align-center" data-align="center">Exynos 9820</td><td class="has-text-align-center" data-align="center">b_r16p0</td></tr><tr><td class="has-text-align-center" data-align="center">2018</td><td class="has-text-align-center" data-align="center">HUAWEI</td><td class="has-text-align-center" data-align="center">Mate20</td><td class="has-text-align-center" data-align="center">Kirin 980</td><td class="has-text-align-center" data-align="center">b-r18p0-01rel0</td></tr><tr><td class="has-text-align-center" data-align="center">2018</td><td class="has-text-align-center" data-align="center">Redmi</td><td class="has-text-align-center" data-align="center">红米 6</td><td class="has-text-align-center" data-align="center">Helio P22</td><td class="has-text-align-center" data-align="center">m-r20p0</td></tr><tr><td class="has-text-align-center" data-align="center">2018</td><td class="has-text-align-center" data-align="center">SAMSUNG</td><td class="has-text-align-center" data-align="center">S9</td><td class="has-text-align-center" data-align="center">Exynos 9810</td><td class="has-text-align-center" data-align="center">b_r19p0</td></tr><tr><td class="has-text-align-center" data-align="center">2017</td><td class="has-text-align-center" data-align="center">HUAWEI</td><td class="has-text-align-center" data-align="center">Mate10</td><td class="has-text-align-center" data-align="center">Kirin 970</td><td class="has-text-align-center" data-align="center">b-r14p0-00cet0</td></tr><tr><td class="has-text-align-center" data-align="center">2017</td><td class="has-text-align-center" data-align="center">LENOVO</td><td class="has-text-align-center" data-align="center">K8 Plus</td><td class="has-text-align-center" data-align="center">Heli0 P25</td><td class="has-text-align-center" data-align="center">r18p0</td></tr><tr><td class="has-text-align-center" data-align="center">2017</td><td class="has-text-align-center" data-align="center">SAMSUNG</td><td class="has-text-align-center" data-align="center">S8</td><td class="has-text-align-center" data-align="center">Exynos 8895</td><td class="has-text-align-center" data-align="center">b_r16p0</td></tr><tr><td class="has-text-align-center" data-align="center">2016</td><td class="has-text-align-center" data-align="center">HUAWEI</td><td class="has-text-align-center" data-align="center">Mate9</td><td class="has-text-align-center" data-align="center">Kirin 960</td><td class="has-text-align-center" data-align="center">b-r14p0-00cet0</td></tr><tr><td class="has-text-align-center" data-align="center">2016</td><td class="has-text-align-center" data-align="center">Meizu</td><td class="has-text-align-center" data-align="center">M3x</td><td class="has-text-align-center" data-align="center">Helio P20</td><td class="has-text-align-center" data-align="center">r12p1</td></tr><tr><td class="has-text-align-center" data-align="center">2016</td><td class="has-text-align-center" data-align="center">SAMSUNG</td><td class="has-text-align-center" data-align="center">S7</td><td class="has-text-align-center" data-align="center">Exynos 8890</td><td class="has-text-align-center" data-align="center">r22p0</td></tr><tr><td class="has-text-align-center" data-align="center">2015</td><td class="has-text-align-center" data-align="center">HUAWEI</td><td class="has-text-align-center" data-align="center">Mate8</td><td class="has-text-align-center" data-align="center">Kirin 950</td><td class="has-text-align-center" data-align="center">r20p0-01rel0</td></tr><tr><td class="has-text-align-center" data-align="center">2015</td><td class="has-text-align-center" data-align="center">SAMSUNG</td><td class="has-text-align-center" data-align="center">S6</td><td class="has-text-align-center" data-align="center">Exynos 7420</td><td class="has-text-align-center" data-align="center">r15p0</td></tr></tbody></table></figure>
</div></div>



<p>正如综述里提到，普通APP可以借助漏洞完成以下攻击：</p>



<p>1 窃取其他APP运行时内存数据<br>2 修改其他APP代码<br>3 窃取内核运行时内存数据<br>4 稳定地获得ROOT权限</p>



<p>相对常见的内核漏洞，这个漏洞不但可以稳定地获取ROOT权限，而且可以以非常隐蔽的方式获取其他APP和内核的运行时数据，甚至修改其他APP的代码，整个过程不需要获得任何额外的权限。从攻击过程和结果来看，堪称后门级漏洞。</p>



<h1>漏洞分析</h1>



<p>除了CPU，一个SoC上还有很多针对具体业务场景特制的处理器，比如GPU。GPU的主要功能是对图形进行渲染。在IOMMU的帮助下，GPU可以有自己的虚拟地址空间。通过映射物理页，GPU和CPU之间可以高效地传输数据。而上述功能的实现，依赖于内核驱动。</p>



<h2>GPU映射物理页过程 – 返回假的虚拟地址</h2>



<p>具体到ARM设计实现的GPU，它使用的是Mali驱动。Mali驱动的一个重要功能是为GPU维护IOMMU页表。当应用（运行在CPU上）想要让GPU为其处理数据或者渲染图形时，驱动需要帮忙将数据所在的物理页映射到GPU的地址空间中，这样，GPU可以立即“看到”这些数据。整个过程没有额外的数据拷贝操作，从而大大提高处理效率。Mali驱动实现了以下相关操作：</p>



<figure class="wp-block-table mytable"><table><thead><tr><th class="has-text-align-center myth1" data-align="center">序号</th><th class="has-text-align-center myth2" data-align="center">命令</th><th class="has-text-align-center" data-align="center">功能</th></tr></thead><tbody><tr><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">KBASE_IOCTL_MEM_ALLOC</td><td class="has-text-align-center" data-align="center">分配内存区域，内存区域中的页会映射到GPU中，可选择同时映射到CPU</td></tr><tr><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">KBASE_IOCTL_MEM_QUERY</td><td class="has-text-align-center" data-align="center">查询内存区域属性</td></tr><tr><td class="has-text-align-center" data-align="center">3</td><td class="has-text-align-center" data-align="center">KBASE_IOCTL_MEM_FREE</td><td class="has-text-align-center" data-align="center">释放内存区域</td></tr><tr><td class="has-text-align-center" data-align="center">4</td><td class="has-text-align-center" data-align="center">KBASE_IOCTL_MEM_SYNC</td><td class="has-text-align-center" data-align="center">同步数据，使得CPU和GPU可以及时看到对方操作结果</td></tr><tr><td class="has-text-align-center" data-align="center">5</td><td class="has-text-align-center" data-align="center">KBASE_IOCTL_MEM_COMMIT</td><td class="has-text-align-center" data-align="center">改变内存区域中页的数量</td></tr><tr><td class="has-text-align-center" data-align="center">6</td><td class="has-text-align-center" data-align="center">KBASE_IOCTL_MEM_ALIAS</td><td class="has-text-align-center" data-align="center">为某个内存区域创建别名，即多个GPU虚拟地址指向同一个区域</td></tr><tr><td class="has-text-align-center" data-align="center">7</td><td class="has-text-align-center" data-align="center">KBASE_IOCTL_MEM_IMPORT</td><td class="has-text-align-center" data-align="center">将CPU使用的内存页映射到GPU地址空间中</td></tr><tr><td class="has-text-align-center" data-align="center">8</td><td class="has-text-align-center" data-align="center">KBASE_IOCTL_MEM_FLAGS_CHANGE</td><td class="has-text-align-center" data-align="center">改变内存区域属性</td></tr></tbody></table></figure>



<p>表格中提到的内存区域（memory region）实际上是Mali驱动里的一个概念，它包含了实际使用的物理页。以下分析基于<a href="https://opensource.samsung.com/uploadSearch?searchValue=A7160">三星A71源代码</a></p>



<p>我先介绍下<code>KBASE_IOCTL_MEM_ALLOC</code>命令处理过程。通过这个命令，你可以了解驱动是如何将物理页映射到进程地址空间（CPU）和GPU地址空间。</p>



<p>这个命令接收的参数如下：</p>



<pre class="wp-block-code"><code>drivers/gpu/arm/b_r19p0/mali_kbase_core_linux.c

183 union kbase_ioctl_mem_alloc {
184     struct {
185         __u64 va_pages;
186         __u64 commit_pages;
187         __u64 extent;
188         __u64 flags;
189     } in;
190     struct {
191         __u64 flags;
192         __u64 gpu_va;
193     } out;
194 };</code></pre>



<p>主要的输入参数有：</p>



<p><code>va_pages</code>表示待分配的内存区域最多可以容纳多少物理页，驱动会在GPU空间中留出相应大小的虚拟地址范围；<br><code>commit_pages</code>表示当下驱动需要为这个内存区域分配多少个物理页，应用可根据自身需要调用<code>KBASE_IOCTL_MEM_COMMIT</code>命令调整页的数量；<br><code>flags</code>表示内存区域属性，比如是否映射到CPU、是否可读可写；</p>



<p>输出参数有：</p>



<p><code>gpu_va</code>表示分配的内存区域在GPU空间中的虚拟地址，GPU可以使用该地址访问相应的物理页；</p>



<p>具体的分配过程如下：</p>



<pre class="wp-block-code"><code>drivers/gpu/arm/b_r19p0/mali_kbase_core_linux.c

kbase_api_mem_alloc()
|
| BASE_MEM_SAME_VA
|
|-&gt; kbase_mem_alloc()
    |
    |-&gt; kbase_check_alloc_flags()
    |
    |-&gt; kbase_alloc_free_region()
    |
    |-&gt; kbase_reg_prepare_native()
    |
    |-&gt; kbase_alloc_phy_pages()
    |
    |-&gt; kctx-&gt;pending_regions[cookie_nr] = reg</code></pre>



<p>如果进程是64位，默认使用<code>BASE_MEM_SAME_VA</code>方式创建映射，它的含义是CPU和GPU使用相同的虚拟地址。具体的分配过程由<code>kbase_mem_alloc()</code>实现。</p>



<p>它首先调用<code>kbase_check_alloc_flags()</code>来检查应用传入的flags（属性）是否合法：</p>



<pre class="wp-block-code"><code>drivers/gpu/arm/b_r19p0/mali_kbase_mem.c

2582 bool kbase_check_alloc_flags(unsigned long flags)
2583 {
2592     /* Either the GPU or CPU must be reading from the allocated memory */
2593     if ((flags &amp; (BASE_MEM_PROT_CPU_RD | BASE_MEM_PROT_GPU_RD)) == 0)
2594         return false;
2595 
2596     /* Either the GPU or CPU must be writing to the allocated memory */
2597     if ((flags &amp; (BASE_MEM_PROT_CPU_WR | BASE_MEM_PROT_GPU_WR)) == 0)
2598         return false;
2617     /* GPU should have at least read or write access otherwise there is no
2618        reason for allocating. */
2619     if ((flags &amp; (BASE_MEM_PROT_GPU_RD | BASE_MEM_PROT_GPU_WR)) == 0)
2633 }</code></pre>



<p>上述摘录的代码片段主要与映射属性有关，通过代码可以了解到：</p>



<p>1 内存区域必须映射到GPU中，映射属性可以是只读、仅可写、可读写（line 2619）；<br>2 CPU和GPU至少有一方是可以读内存区域的，否则分配物理页没有意义（line 2593）；<br>3 同样，至少有一方是可以写内存区域的，否则分配物理页没有意义（line 2597）；</p>



<p>之后，驱动调用<code>kbase_alloc_free_region()</code>来分配新的内存区域<code>kbase_va_region</code>：</p>



<pre class="wp-block-code"><code>drivers/gpu/arm/b_r19p0/mali_kbase_mem.h

241 struct kbase_va_region {
248     size_t nr_pages;
372     struct kbase_mem_phy_alloc *cpu_alloc; /* the one alloc object we mmap to the CPU when mapping this region */
373     struct kbase_mem_phy_alloc *gpu_alloc; /* the one alloc object we mmap to the GPU when mapping this region */
383 };</code></pre>



<p>我摘录了相关字段：</p>



<p><code>nr_pages</code>表示这个区域最多可以包含多少物理页；<br><code>cpu_alloc</code>用于CPU地址空间映射；<br><code>gpu_alloc</code>用户GPU地址空间映射；</p>



<p><code>kbase_reg_prepare_native()</code>负责初始化<code>reg-&gt;cpu_alloc</code>和<code>reg-&gt;gpu_alloc</code>：</p>



<pre class="wp-block-code"><code>drivers/gpu/arm/b_r19p0/mali_kbase_mem.h

541 static inline int kbase_reg_prepare_native(struct kbase_va_region *reg,
542         struct kbase_context *kctx, int group_id)
543 {
549     reg-&gt;cpu_alloc = kbase_alloc_create(kctx, reg-&gt;nr_pages,
550             KBASE_MEM_TYPE_NATIVE, group_id);
551     if (IS_ERR(reg-&gt;cpu_alloc))
552         return PTR_ERR(reg-&gt;cpu_alloc);
553     else if (!reg-&gt;cpu_alloc)
554         return -ENOMEM;
555 
556     reg-&gt;cpu_alloc-&gt;imported.native.kctx = kctx;
557     if (kbase_ctx_flag(kctx, KCTX_INFINITE_CACHE)
558         &amp;&amp; (reg-&gt;flags &amp; KBASE_REG_CPU_CACHED)) {
566     } else {
567         reg-&gt;gpu_alloc = kbase_mem_phy_alloc_get(reg-&gt;cpu_alloc);
568     }
578 }</code></pre>



<p>这里我们需要使<code>reg-&gt;cpu_alloc</code>和<code>reg-&gt;gpu_alloc</code>指向同一个对象(line 567)，它们均是<code>kbase_mem_phy_alloc</code>:</p>



<pre class="wp-block-code"><code>drivers/gpu/arm/b_r19p0/mali_kbase_mem.h

128 struct kbase_mem_phy_alloc {
129     struct kref           kref;
130     atomic_t              gpu_mappings;
131     size_t                nents;
132     struct tagged_addr    *pages;
133     struct list_head      mappings;
134     struct list_head      evict_node;
135     size_t                evicted;
136     struct kbase_va_region *reg;
137     enum kbase_memory_type type;
177 };</code></pre>



<p>我仅摘录了相关字段：</p>



<p><code>kref</code>表示对象的引用次数；<br><code>gpu_mappings</code>表示多少虚拟地址映射到该区域（想想前面提到<code>KBASE_IOCTL_MEM_ALIAS</code>命令）；<br><code>nents</code>表示当前有多少物理页；<br><code>pages</code>表示物理页数组；<br><code>reg</code>指向包含该对象的reg；<br><code>type</code>表示内存类型，这里是<code>KBASE_MEM_TYPE_NATIVE</code>；</p>



<p>基本的数据结构已经建立起来，驱动调用<code>kbase_alloc_phy_pages()</code>为<code>reg-&gt;cpu_alloc</code>分配物理页，之后将reg挂载到<code>kctx-&gt;pending_regions</code>数组中：</p>



<pre class="wp-block-code"><code>drivers/gpu/arm/b_r19p0/mali_kbase_mem_linux.c

254 struct kbase_va_region *kbase_mem_alloc(struct kbase_context *kctx,
255         u64 va_pages, u64 commit_pages, u64 extent, u64 *flags,
256         u64 *gpu_va)
257 {
376     if (*flags &amp; BASE_MEM_SAME_VA) {
389         /* return a cookie */
390         cookie_nr = __ffs(kctx-&gt;cookies);
391         kctx-&gt;cookies &amp;= ~(1UL &lt;&lt; cookie_nr);
392         BUG_ON(kctx-&gt;pending_regions[cookie_nr]);
393         kctx-&gt;pending_regions[cookie_nr] = reg;
394 
395         /* relocate to correct base */
396         cookie = cookie_nr + PFN_DOWN(BASE_MEM_COOKIE_BASE);
397         cookie &lt;&lt;= PAGE_SHIFT;
398 
403         if (kctx-&gt;api_version &lt; KBASE_API_VERSION(10, 1) ||
404             kctx-&gt;api_version &gt; KBASE_API_VERSION(10, 4)) {
405             *gpu_va = (u64) cookie;
406             kbase_gpu_vm_unlock(kctx);
407             return reg;
408         }
484 }</code></pre>



<p>这里的逻辑很简单：在<code>kctx-&gt;pending_regions</code>数组中找一个空余位置（line 391），然后保存reg（line 393），需要注意的是返回值并非真正的地址（line 405），只是一个临时值而已（line 396/397），这个值会在后续过程中使用。</p>



<p>至此，<code>kbase_api_mem_alloc()</code>的主要过程我们已经分析完毕：</p>



<pre class="wp-block-code"><code>drivers/gpu/arm/b_r19p0/mali_kbase_core_linux.c

kbase_api_mem_alloc()
|
|-&gt; kbase_mem_alloc()
    |
    |-&gt; kbase_check_alloc_flags()                   // 检查属性是否合法
    |
    |-&gt; kbase_alloc_free_region()                   // 分配reg
    |
    |-&gt; kbase_reg_prepare_native()                  // 分配kbase_mem_phy_alloc，reg-&gt;cpu_alloc和reg-&gt;gpu_alloc指向同一个对象
    |
    |-&gt; kbase_alloc_phy_pages()                     // 分配物理页
    |
    |-&gt; kctx-&gt;pending_regions[cookie_nr] = reg      // 返回假的虚拟地址</code></pre>



<h2>GPU映射物理页过程 – 建立CPU及GPU映射</h2>



<p>应用该如何使用假的虚拟地址呢？实际上是作为<code>mmap</code>系统调用参数：</p>



<pre class="wp-block-code"><code>gpu_va = mmap(0, MALI_MAP_PAGES * PAGE_SIZE, PROT_READ | PROT_WRITE,
            MAP_SHARED, dev, alloc.out.gpu_va);</code></pre>



<p><code>mmap</code>系统调用最终调用Mali驱动注册的<code>kbase_mmap()</code>，这个函数具体过程如下：</p>



<pre class="wp-block-code"><code>drivers/gpu/arm/b_r19p0/mali_kbase_core_linux.c

kbase_mmap()
|
|-&gt; kbase_context_mmap()
    |
    |-&gt; kbase_reg_mmap()
    |   |
    |   | reg = kctx-&gt;pending_regions[cookie]
    |   |
    |   |-&gt; kbase_gpu_mmap()
    |
    |-&gt; kbase_cpu_mmap()</code></pre>



<p><code>mmap</code>系统调用正常语义是将物理页映射到进程的地址空间，由于驱动指定了<code>BASE_MEM_SAME_VA</code>，所以<code>kbase_mmap()</code>在实现正常的映射功能之外，还要将这些物理页映射到GPU地址空间中。需要注意的是：CPU和GPU映射的虚拟地址是一样的。</p>



<p>这里仅分析<code>kbase_gpu_mmap()</code>：</p>



<pre class="wp-block-code"><code>drivers/gpu/arm/b_r19p0/mali_kbase_mem.c

1174 int kbase_gpu_mmap(struct kbase_context *kctx, struct kbase_va_region *reg, u64 addr, size_t nr_pages, size_t align)
1175 {
1198     err = kbase_add_va_region(kctx, reg, addr, nr_pages, align);
1199     if (err)
1200         return err;

1205     if (reg-&gt;gpu_alloc-&gt;type == KBASE_MEM_TYPE_ALIAS) {
            // 稍后我会分析这里
1235     } else {
1236         err = kbase_mmu_insert_pages(kctx-&gt;kbdev,
1237                 &amp;kctx-&gt;mmu,
1238                 reg-&gt;start_pfn,
1239                 kbase_get_gpu_phy_pages(reg),
1240                 kbase_reg_current_backed_size(reg),
1241                 reg-&gt;flags &amp; gwt_mask,
1242                 ctx-&gt;as_nr,
1243                 group_id);
1244         if (err)
1245             goto bad_insert;
1246         kbase_mem_phy_alloc_gpu_mapped(alloc);
1247     }
1291 }</code></pre>



<p><code>kbase_gpu_mmap()</code>主要功能是将物理页映射到IOMMU中，即调用<code>kbase_mmu_insert_pages()</code>，之后将<code>alloc-&gt;gpu_mappings</code>引用计数加1。这个引用计数至关重要，驱动通过查看这个引用计数来确定相关操作是否可以应用到相应的内存区域。最终，<code>mmap</code>系统调用返回值就是映射到CPU和GPU的虚拟地址。</p>



<p>综上所述，GPU映射的典型流程分为两步：</p>



<pre class="wp-block-code"><code>alloc and map pages for GPU
|
|-&gt; kbase_api_mem_alloc()        // 分配reg及物理页，reg-&gt;gpu_alloc-&gt;gpu_mappings = 0
|
|-&gt; kbase_mmap()                // 将reg中的物理页映射到CPU和GPU空间，reg-&gt;gpu_alloc-&gt;gpu_mappings = 1</code></pre>



<p>在分配物理页时，这些页面并没有映射到GPU的虚拟地址空间中，因此，<code>reg-&gt;gpu_alloc-&gt;gpu_mappings</code>计数为0；当<code>kbase_gpu_mmap()</code>将物理页映射到GPU空间时，<code>reg-&gt;gpu_alloc-&gt;gpu_mappings</code>计数加1。从语义上看，这样做非常合理，<code>gpu_alloc-&gt;gpu_mappings</code>准确、及时地表示了内存区域中物理页的映射状态。但是，随着功能的增加，情况变得复杂。</p>



<h2>GPU映射物理页过程 – 别名操作</h2>



<p>正如我之前提到，Mali GPU实现了KBASE_IOCTL_MEM_ALIAS命令，它的主要作用是将同一个内存区域映射到多个不同的虚拟地址空间中。整个别名实现过程类似于<code>KBASE_IOCTL_MEM_ALLOC</code>，也是分为两步：</p>



<pre class="wp-block-code"><code>alias mapping on GPU
|
|-&gt; kbase_api_mem_alias()            // 创建新的reg对象，引用需要别名操作的内存区域，返回假的虚拟地址
|
|-&gt; kbase_mmap()                    // 将内存区域映射到新的虚拟地址</code></pre>



<p><code>kbase_api_mem_alias()</code>主要逻辑由<code>kbase_mem_alias()</code>完成，其实现如下：</p>



<pre class="wp-block-code"><code>drivers/gpu/arm/b_r19p0/mali_kbase_core_linux.c

1681 u64 kbase_mem_alias(struct kbase_context *kctx, u64 *flags, u64 stride,
1682             u64 nents, struct base_mem_aliasing_info *ai,
1683             u64 *num_pages)
1684 {
1696     *flags &amp;= (BASE_MEM_PROT_GPU_RD | BASE_MEM_PROT_GPU_WR |
1697            BASE_MEM_COHERENT_SYSTEM | BASE_MEM_COHERENT_LOCAL |
1698            BASE_MEM_PROT_CPU_RD | BASE_MEM_COHERENT_SYSTEM_REQUIRED);
1723     if (!kbase_ctx_flag(kctx, KCTX_COMPAT)) {
1726         *flags |= BASE_MEM_NEED_MMAP;
1727         reg = kbase_alloc_free_region(&amp;kctx-&gt;reg_rbtree_same, 0,
1728                 *num_pages,
1729                 KBASE_REG_ZONE_SAME_VA);
1730     }
1743     reg-&gt;gpu_alloc = kbase_alloc_create(kctx, 0, KBASE_MEM_TYPE_ALIAS,
1744         BASE_MEM_GROUP_DEFAULT);
1762     for (i = 0; i &lt; nents; i++) {
1763         if (ai[i].handle.basep.handle &lt; BASE_MEM_FIRST_FREE_ADDRESS) {
1773         } else {
1774             struct kbase_va_region *aliasing_reg;
1775             struct kbase_mem_phy_alloc *alloc;
1776 
1777             aliasing_reg = kbase_region_tracker_find_region_base_address(
1778                 kctx,
1779                 (ai[i].handle.basep.handle &gt;&gt; PAGE_SHIFT) &lt;&lt; PAGE_SHIFT);
1804             alloc = aliasing_reg-&gt;gpu_alloc;
1812             reg-&gt;gpu_alloc-&gt;imported.alias.aliased[i].alloc = kbase_mem_phy_alloc_get(alloc);
1813             reg-&gt;gpu_alloc-&gt;imported.alias.aliased[i].length = ai[i].length;
1814             reg-&gt;gpu_alloc-&gt;imported.alias.aliased[i].offset = ai[i].offset;
1817         }
1818     }
1821     if (!kbase_ctx_flag(kctx, KCTX_COMPAT)) {
1827         /* return a cookie */
1828         gpu_va = __ffs(kctx-&gt;cookies);
1829         kctx-&gt;cookies &amp;= ~(1UL &lt;&lt; gpu_va);
1830         BUG_ON(kctx-&gt;pending_regions[gpu_va]);
1831         kctx-&gt;pending_regions[gpu_va] = reg;
1832 
1833         /* relocate to correct base */
1834         gpu_va += PFN_DOWN(BASE_MEM_COOKIE_BASE);
1835         gpu_va &lt;&lt;= PAGE_SHIFT;
1836     }
1853     return gpu_va;
1873 }</code></pre>



<p>首先，<code>kbase_mem_alias()</code>检查用户传入的flags，从中可以看出（line 1696）：别名映射允许CPU只读，GPU可读写。这个条件对利用起到了限制作用，稍后我会分析。之后分配新的reg（line 1727），并为其分配gpu_alloc（line 1743）。这里并没有直接使用之前分配的reg（回头看看<code>kbase_mem_alloc()</code>），而是创建一个新的reg。</p>



<p>然后根据用户传入的handle找到reg（line 1777），经过一番检查之后，<code>reg-&gt;gpu_alloc-&gt;imported.alias.aliased[i].alloc</code>引用了原来的reg。同时，<code>kbase_mem_phy_alloc_get()</code>会将<code>reg-&gt;ref</code>加1。</p>



<p>与<code>kbase_mem_alloc()</code>一样，<code>kbase_mem_alias()</code>将reg挂载到<code>kctx-&gt;pending_regions</code>数组中（line 1831），返回假的虚拟地址（line 1853）。</p>



<p>之后，用户同样需要调用<code>mmap</code>，<code>kbase_gpu_mmap</code>会根据reg的类型（KBASE_MEM_TYPE_ALIAS）进行相应的处理：</p>



<pre class="wp-block-code"><code>drivers/gpu/arm/b_r19p0/mali_kbase_core_linux.c

kbase_mmap() -&gt; kbase_context_mmap()
|
|-&gt; kbasep_reg_mmap()
    |
    |-&gt; kbase_gpu_mmap()

drivers/gpu/arm/b_r19p0/mali_kbase_mem.c

1174 int kbase_gpu_mmap(struct kbase_context *kctx, struct kbase_va_region *reg, u64 addr, size_t nr_pages, size_t align)
1175 {
1202     alloc = reg-&gt;gpu_alloc;
1203     group_id = alloc-&gt;group_id;
1204 
1205     if (reg-&gt;gpu_alloc-&gt;type == KBASE_MEM_TYPE_ALIAS) {
1206         u64 const stride = alloc-&gt;imported.alias.stride;
1207 
1208         KBASE_DEBUG_ASSERT(alloc-&gt;imported.alias.aliased);
1209         for (i = 0; i &lt; alloc-&gt;imported.alias.nents; i++) {
1210             if (alloc-&gt;imported.alias.aliased[i].alloc) {
1211                 err = kbase_mmu_insert_pages(kctx-&gt;kbdev,
1212                         &amp;kctx-&gt;mmu,
1213                         reg-&gt;start_pfn + (i * stride),
1214                         alloc-&gt;imported.alias.aliased[i].alloc-&gt;pages + alloc-&gt;imported.alias.aliased[i].offset,
1215                         alloc-&gt;imported.alias.aliased[i].length,
1216                         reg-&gt;flags &amp; gwt_mask,
1217                         kctx-&gt;as_nr,
1218                         group_id);
1219                 if (err)
1220                     goto bad_insert;
1221 
1222                 kbase_mem_phy_alloc_gpu_mapped(alloc-&gt;imported.alias.aliased[i].alloc);
1223             }
1234         }
1235     }
1291 }</code></pre>



<p><code>kbase_gpu_mmap()</code>主要逻辑看上去非常简单：将<code>kbase_mem_alias()</code>收集到的内存区域（line 1210）映射到新的地址空间（line 1211）。如果成功建立映射，将相关的<code>reg-&gt;gpu_alloc</code>的<code>gpu_mappings</code>加1。</p>



<p>至此，关于内存区域的两个重要操作介绍完毕，从上述分析看，相关操作准确、合理，没有明显的问题。</p>



<h2>GPU映射物理页过程 – 改变属性</h2>



<p>前面我提到Mali驱动实现了KBASE_IOCTL_MEM_FLAGS_CHANGE命令，该命令可以修改内存区域属性。相关实现在<code>kbase_api_mem_flags_change()</code>中：</p>



<pre class="wp-block-code"><code>drivers/gpu/arm/b_r19p0/mali_kbase_core_linux.c

kbase_api_mem_flags_change()
|
|-&gt; kbase_mem_flags_change()

drivers/gpu/arm/b_r19p0/mali_kbase_mem_linux.c

838 int kbase_mem_flags_change(struct kbase_context *kctx, u64 gpu_addr, unsigned int flags, unsigned int mask)
839 {
876     reg = kbase_region_tracker_find_region_base_address(kctx, gpu_addr);
877     if (kbase_is_region_invalid_or_free(reg))
878         goto out_unlock;
879 
880     /* Is the region being transitioning between not needed and needed? */
881     prev_needed = (KBASE_REG_DONT_NEED &amp; reg-&gt;flags) == KBASE_REG_DONT_NEED;
882     new_needed = (BASE_MEM_DONT_NEED &amp; flags) == BASE_MEM_DONT_NEED;
883     if (prev_needed != new_needed) {
884         /* Aliased allocations can't be made ephemeral */
885         if (atomic_read(&amp;reg-&gt;cpu_alloc-&gt;gpu_mappings) &gt; 1)
886             goto out_unlock;
887 
888         if (new_needed) {
889             /* Only native allocations can be marked not needed */
890             if (reg-&gt;cpu_alloc-&gt;type != KBASE_MEM_TYPE_NATIVE) {
891                 ret = -EINVAL;
892                 goto out_unlock;
893             }
894             ret = kbase_mem_evictable_make(reg-&gt;gpu_alloc);
895             if (ret)
896                 goto out_unlock;
897         } else {
898             kbase_mem_evictable_unmake(reg-&gt;gpu_alloc);
899         }
900     }
978 }</code></pre>



<p>这个函数主要功能是支持BASE_MEM_DONT_NEED操作，即应用不再需要某个内存区域上的物理页了，驱动可以将这些物理页缓存，待合适时机将其释放（line 894）；同时，驱动也支持反向操作：应用继续使用这个内存区域，驱动需要将缓存的物理页找回来，如果已经释放，可以分配新的物理页（line 898）。</p>



<p>上述操作的一个前提条件是<code>reg-&gt;cpu_alloc-&gt;gpu_mappings</code>不能大于1，大于1意味着这些页映射到多个虚拟地址上。Mali驱动不打算处理这种复杂情形。如果内存区域符合上述条件，<code>kbase_mem_evictable_make()</code>被调用，来进行清理操作：</p>



<pre class="wp-block-code"><code>drivers/gpu/arm/b_r19p0/mali_kbase_mem_linux.c

765 int kbase_mem_evictable_make(struct kbase_mem_phy_alloc *gpu_alloc)
766 {
767     struct kbase_context *kctx = gpu_alloc-&gt;imported.native.kctx;
768 
769     lockdep_assert_held(&amp;kctx-&gt;reg_lock);
770 
771     kbase_mem_shrink_cpu_mapping(kctx, gpu_alloc-&gt;reg,
772             0, gpu_alloc-&gt;nents);
773 
774     mutex_lock(&amp;kctx-&gt;jit_evict_lock);
775     /* This allocation can't already be on a list. */
776     WARN_ON(!list_empty(&amp;gpu_alloc-&gt;evict_node));
777 
778     /*
779      * Add the allocation to the eviction list, after this point the shrink
780      * can reclaim it.
781     */
782     list_add(&amp;gpu_alloc-&gt;evict_node, &amp;kctx-&gt;evict_list);
783     mutex_unlock(&amp;kctx-&gt;jit_evict_lock);
784     kbase_mem_evictable_mark_reclaim(gpu_alloc);
785 
786     gpu_alloc-&gt;reg-&gt;flags |= KBASE_REG_DONT_NEED;
787     return 0;
788 }</code></pre>



<p><code>kbase_mem_evictable_make()</code>首先将之前建立的CPU映射取消（line 771）。此时，应用再也无法通过虚拟地址访问这些物理页。之后，将<code>gpu_alloc</code>加入<code>kctx-&gt;evict_list</code>链表。这个链表实际上会被<code>kbase_mem_evictable_reclaim_scan_objects()</code>使用：</p>



<pre class="wp-block-code"><code>drivers/gpu/arm/b_r19p0/mali_kbase_mem_linux.c

627 unsigned long kbase_mem_evictable_reclaim_scan_objects(struct shrinker *s,
628         struct shrink_control *sc)
629 {
638     list_for_each_entry_safe(alloc, tmp, &amp;kctx-&gt;evict_list, evict_node) {
639         int err;
640 
641         err = kbase_mem_shrink_gpu_mapping(kctx, alloc-&gt;reg,
642                 0, alloc-&gt;nents);
660         kbase_free_phy_pages_helper(alloc, alloc-&gt;evicted);
661         freed += alloc-&gt;evicted;
662         list_del_init(&amp;alloc-&gt;evict_node);
673     }
678 }</code></pre>



<p><code>kbase_mem_evictable_reclaim_scan_objects()</code>主要作用是遍历<code>kctx-&gt;evict_list</code>链表（line 638），将之前建立的GPU映射撤销（line 641），最后释放所有的物理页（line 660）。</p>



<p>至此，物理页整个生命周期已经分析完毕。漏洞实际上隐藏在KBASE_IOCTL_MEM_ALIAS命令和KBASE_IOCTL_MEM_FLAGS_CHANGE命令中。之前提到<code>kbase_mem_flags_change()</code>有一个前提：<code>reg-&gt;cpu_alloc-&gt;gpu_mappings</code>不能大于1。而别名操作是分两步实现的，<code>gpu_mappings</code>引用计数加1是在<code>kbase_gpu_mmap()</code>中。如果我们只调用<code>kbase_mem_alias()</code>，然后紧接着调用<code>kbase_mem_flags_change()</code>会如何？</p>



<p>答案是我们可以映射释放的页！</p>



<pre class="wp-block-code"><code>1.1 kbase_api_mem_alloc()                         // 分配物理页
1.2 mmap()                                        // 映射到CPU和GPU地址空间
2.1 kbase_mem_alias()                             // 索引第1步创建的gpu_alloc
3     kbase_mem_flags_change()                    // 清除第1.2步中建立的CPU映射，gpu_alloc加入kctx-&gt;evict_list链表，但物理页没有被释放
2.2 mmap()                                        // 将物理页映射到新的CPU和GPU地址空间
4     kbase_mem_evictable_reclaim_scan_objects()  // 清除第1.2步中建立的GPU映射，物理页被回收，但第2.2步建立的CPU和GPU映射不会清除</code></pre>



<h1>利用方法</h1>



<p>通过上述调用过程，我们可以将几乎所有内核可以分配的页映射到CPU和GPU地址空间。之前提到，别名映射要求是CPU只读，GPU可读写。我们可以在进程的虚拟地址空间中窃取这些页的内容，但不能修改。而GPU可以读写这些页，因此后面的分析主要集中在如何利用GPU读写物理页。</p>



<h2>mesa</h2>



<p>针对高通的Adreno GPU，无论是KGSL驱动，还是freeadreno项目，你可以找到大量的GPU私有指令，从而实现GPU读写内存。针对ARM的Mali GPU，没有公开资料介绍它的指令集（商业机密）。唯一的线索是<a href="https://gitlab.freedesktop.org/alyssa">Alyssa Rosenzweig</a>主导的Bifrost和Panfrost项目。我花费了很长时间试图能够手写一段可以直接在Mali GPU上运行的二进制代码。最后发现这条路困难重重。</p>



<p>如果没有办法实现GPU读写物理页，这个漏洞只能实现信息泄露。我们真的无路可走了么？</p>



<p>我们知道大部分的软件是典型的分层体系结构，通过不断地抽象，最终完成复杂的功能。具体到GPU，即便我们对指令集一无所知，我们还是可以让它绘制图形。这得益于OpenGL，它对底层进行了抽象，屏蔽了硬件之间的不同。但是，OpenGL更多地是面向图形，比如点、线、投影、剪裁等。我没有找到接口可以随意访问特定位置的内存。</p>



<p>其实，现在的GPU已经不单单是绘制图形，它还可以用来进行密集计算。而在常规数学运算中，从内存读取某个变量值（读内存）和向内存写入计算结果（写内存）是基本操作，我们是不是可以通过上层封装的功能来实现GPU读写物理页？</p>



<h2>OpenCL</h2>



<p>在浏览维基百科关于<a href="https://en.wikipedia.org/wiki/OpenCL">OpenCL</a>的介绍时，我看到了希望：</p>



<pre class="wp-block-code"><code>OpenCL(Open Computing Language) is a framework for writing programs that execute across heterogeneous platforms consisting of central processing(CPUs), graphics processing units(GPUs), digital signal processors(DSPs), field-programmable gate arrays(FPGAs) and other processors or hardware accelerators.</code></pre>



<p>网上有很多OpenCL代码示例，这里不做详细介绍。仅展示下我实现的利用中使用的OpenCL代码。</p>



<p>片段一：泄露内存地址</p>



<pre class="wp-block-code"><code>char *cl_code =
        "__kernel void leak_mem_addr(__global unsigned long *addr) {"
        "   *addr = (unsigned long)addr;"
        "}";</code></pre>



<p>OpenCL库本身会分配相关内存，我需要知道它分配的内存地址。通过上述代码，我可以获取该地址。</p>



<p>片段二：任意地址读</p>



<pre class="wp-block-code"><code>char *cl_code =
    "__kernel void gpu_read(__global unsigned long *addr, int offset) {"
    "   int idx = get_global_id(0);"
    "   *(addr+idx) = addr[offset+idx];"
    "}";</code></pre>



<p>上述代码实现了GPU任意地址读。由于映射的物理页非常多，我们可以通过并行编程加速这个过程;)</p>



<p>相信你已经深得要领，这里就不展示任意地址写了。</p>



<h2>ROOT提权</h2>



<p>由于我们可以映射大量的物理页，这些页有可能用于保存应用代码或者数据，也有可能保存内核代码或者数据。实际上，内核暴露了大量的数据结构，实现ROOT提权的方法多种多样。这里就不一一介绍了，下面是我在某手机上实现的本地提权（100%成功率）</p>



<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img loading="lazy" src="./2021 - Internal of the Android kernel backdoor vulnerability_files/root-1024x614.png" alt="" class="wp-image-264" width="512" height="307" srcset="https://vul.360.net/wp-content/uploads/2021/08/root-1024x614.png 1024w, https://vul.360.net/wp-content/uploads/2021/08/root-300x180.png 300w, https://vul.360.net/wp-content/uploads/2021/08/root-768x461.png 768w, https://vul.360.net/wp-content/uploads/2021/08/root.png 1050w" sizes="(max-width: 512px) 100vw, 512px"></figure></div>



<h1>补丁</h1>



<p>漏洞发生的主要原因是别名操作中对<code>gpu_alloc-&gt;gpu_mappings</code>增加计数滞后，导致在<code>mmap</code>系统调用之前，相关的物理页加入待释放列表。补丁的思路是将<code>gpu_alloc-&gt;gpu_mappings</code>增加计数提前到<code>kbase_mem_alias()</code>：</p>



<pre class="wp-block-code"><code>drivers/gpu/arm/b_r19p0/mali_kbase_core_linux.c

1681 u64 kbase_mem_alias(struct kbase_context *kctx, u64 *flags, u64 stride,
1682             u64 nents, struct base_mem_aliasing_info *ai,
1683             u64 *num_pages)
1684 {
1762     for (i = 0; i &lt; nents; i++) {
1763         if (ai[i].handle.basep.handle &lt; BASE_MEM_FIRST_FREE_ADDRESS) {
1773         } else {
1774             struct kbase_va_region *aliasing_reg;
1775             struct kbase_mem_phy_alloc *alloc;
1776 
1777             aliasing_reg = kbase_region_tracker_find_region_base_address(
1778                 kctx,
1779                 (ai[i].handle.basep.handle &gt;&gt; PAGE_SHIFT) &lt;&lt; PAGE_SHIFT);
1804             alloc = aliasing_reg-&gt;gpu_alloc;
1812             reg-&gt;gpu_alloc-&gt;imported.alias.aliased[i].alloc = kbase_mem_phy_alloc_get(alloc);
1813             reg-&gt;gpu_alloc-&gt;imported.alias.aliased[i].length = ai[i].length;
1814             reg-&gt;gpu_alloc-&gt;imported.alias.aliased[i].offset = ai[i].offset;
+                /* Ensure the underlying alloc is marked as being
+                 * mapped at &gt;1 different GPU VA immediately, even
+                 * though mapping might not happen until later.
+                 *
+                 * Otherwise, we would (incorrectly) allow shrinking of
+                 * the source region (aliasing_reg) and so freeing the
+                 * physical pages (without freeing the entire alloc)
+                 * whilst we still hold an implicit reference on those
+                 * physical pages.
+                 */
+                kbase_mem_phy_alloc_gpu_mapped(alloc);
1817         }
1818     }
1873 }</code></pre>



<h1>总结</h1>



<p>本文详细分析位于ARM Mali GPU驱动中的一个逻辑漏洞。这个漏洞可以帮助攻击者：</p>



<p>1 窃取其他APP运行时内存数据<br>2 修改其他APP代码<br>3 窃取内核运行时内存数据<br>4 稳定地获得ROOT权限</p>



<p>在此之前，据我所知，没有公开资料介绍如何利用该漏洞。而本文指出了一种可行方法：借助OpenCL绕过GPU私有指令集，实现GPU读写任意内存。</p>

			<div class="wbp-cbm" style="--dwqrColor: #00B64B;" wb-share-url="https://vul.360.net/?p=263"><div class="dwqr-inner"><a class="wb-btn-dwqr wb-btn-like j-dwqr-like-btn" data-count="156" rel="nofollow"><svg class="wb-icon wbsico-like"><use xlink:href="#wbsico-dwqr-like"></use></svg><span class="like-count">赞(156)</span></a><a class="wb-btn-dwqr wb-share-poster j-dwqr-poster-btn" rel="nofollow"><svg class="wb-icon wbsico-poster"><use xlink:href="#wbsico-dwqr-poster"></use></svg><span>微海报</span></a><a class="wb-btn-dwqr wb-btn-share j-dwqr-social-btn" rel="nofollow"><svg class="wb-icon wbsico-share"><use xlink:href="#wbsico-dwqr-share"></use></svg><span>分享</span></a></div></div>        </div>
        <section class="view-tag">
            <div class="pull-left"><i class="fas fa-tags"></i> <a href="https://vul.360.net/archives/tag/%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90" rel="tag">漏洞分析</a><a href="https://vul.360.net/archives/tag/%e6%bc%8f%e6%b4%9e%e5%88%a9%e7%94%a8" rel="tag">漏洞利用</a></div>
        </section>
            </article>
    <section class="col-md-10 col-md-offset-1 clearfix">
    <div class="read">
        <div class="read-head"><i class="fas fa-book"></i> 更多阅读</div>
        <div class="read-list row">
            <div class="col-md-6">
                <ul>
                    
<li><a href="https://vul.360.net/archives/263" target="_blank">Internal of the Android kernel backdoor vulnerability</a></li>
<li><a href="https://vul.360.net/archives/83" target="_blank">Windows Pool OverFlow漏洞利用</a></li>
<li><a href="https://vul.360.net/archives/95" target="_blank">Passwordless WinRm Backdoor Based On Certification</a></li>
<li><a href="https://vul.360.net/archives/144" target="_blank">Exploiting the Promise.allsettled bug in V8</a></li>
<li><a href="https://vul.360.net/archives/217" target="_blank">Escape from chrome sandbox to root</a></li>                </ul>
            </div>
            <div class="col-md-6">
                <ul>
                                    <li><a href="https://vul.360.net/archives/217" title="Escape from chrome sandbox to root">Escape from chrome sandbox to root</a></li>
                                    <li><a href="https://vul.360.net/archives/83" title="Windows Pool OverFlow漏洞利用">Windows Pool OverFlow漏洞利用</a></li>
                                    <li><a href="https://vul.360.net/archives/95" title="Passwordless WinRm Backdoor Based On Certification">Passwordless WinRm Backdoor Based On Certification</a></li>
                                    <li><a href="https://vul.360.net/archives/263" title="Internal of the Android kernel backdoor vulnerability">Internal of the Android kernel backdoor vulnerability</a></li>
                                    <li><a href="https://vul.360.net/archives/144" title="Exploiting the Promise.allsettled bug in V8">Exploiting the Promise.allsettled bug in V8</a></li>
                                </ul>
            </div>
        </div>
    </div>
    <div class="read">
        <div class="read-head"><i class="fas fa-tags"></i> 标签云</div>
        <div class="read-list">
            <a href="https://vul.360.net/archives/tag/windows" class="tag-cloud-link tag-link-17 tag-link-position-1" style="color:#f22607;font-size: 22pt;" aria-label="Windows (2 items);">Windows</a>
<a href="https://vul.360.net/archives/tag/%e5%86%85%e6%a0%b8" class="tag-cloud-link tag-link-18 tag-link-position-2" style="color:#6e0b1;font-size: 8pt;" aria-label="内核 (1 item);">内核</a>
<a href="https://vul.360.net/archives/tag/%e5%86%85%e6%a0%b8%e5%ae%89%e5%85%a8" class="tag-cloud-link tag-link-24 tag-link-position-3" style="color:#363a0;font-size: 8pt;" aria-label="内核安全 (1 item);">内核安全</a>
<a href="https://vul.360.net/archives/tag/%e5%ae%89%e5%85%a8" class="tag-cloud-link tag-link-19 tag-link-position-4" style="color:#9b77f0;font-size: 22pt;" aria-label="安全 (2 items);">安全</a>
<a href="https://vul.360.net/archives/tag/%e6%b5%8f%e8%a7%88%e5%99%a8%e5%ae%89%e5%85%a8" class="tag-cloud-link tag-link-23 tag-link-position-5" style="color:#14d3ad;font-size: 22pt;" aria-label="浏览器安全 (2 items);">浏览器安全</a>
<a href="https://vul.360.net/archives/tag/%e6%b8%97%e9%80%8f" class="tag-cloud-link tag-link-7 tag-link-position-6" style="color:#bccd14;font-size: 8pt;" aria-label="渗透 (1 item);">渗透</a>
<a href="https://vul.360.net/archives/tag/%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90" class="tag-cloud-link tag-link-22 tag-link-position-7" style="color:#488279;font-size: 22pt;" aria-label="漏洞分析 (2 items);">漏洞分析</a>
<a href="https://vul.360.net/archives/tag/%e6%bc%8f%e6%b4%9e%e5%88%a9%e7%94%a8" class="tag-cloud-link tag-link-16 tag-link-position-8" style="color:#1f3a7f;font-size: 22pt;" aria-label="漏洞利用 (2 items);">漏洞利用</a>        </div>
    </div>
    </section>
</div>
<div class="footer_search visible-xs visible-sm">
    <form id="searchform" action="https://vul.360.net/">
        <div class="input-group">
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<input type="search" class="form-control" placeholder="输入关键词搜索…" value="" name="s">
            <span class="input-group-btn" style="vertical-align:bottom !important"><button class="btn btn-default" type="submit"><i class="fas fa-search"></i></button></span>
        </div>
    </form>
</div>
<footer id="footer">
    <div class="copyright">
        <p><i class="far fa-copyright"></i> 2021 <b>京ICP备20015286号-8</b></p>
        <p><a href="https://beian.miit.gov.cn/" target="_blank" rel="nofollow"> </a> <a href="http://www.beian.gov.cn/" target="_blank" rel="nofollow">京公网安备 11010502041971号</a></p>
    </div>
            <div style="display:none;"> </div>
    </footer>
<script type="text/javascript" src="./2021 - Internal of the Android kernel backdoor vulnerability_files/jquery.min.js.下載"></script></body></html>