<!DOCTYPE html>
<!-- saved from url=(0077)https://securitylab.github.com/research/one_day_short_of_a_fullchain_android/ -->
<html lang="en" class="no-touch"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <!-- META DATA -->
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="preload" href="./One day short of a full chain_ Part 1 - Android Kernel arbitrary code execution _ GitHub Security Lab_files/index.css" as="style">
  <link rel="preload" href="./One day short of a full chain_ Part 1 - Android Kernel arbitrary code execution _ GitHub Security Lab_files/main.js.下載" as="script">
  <!--[if IE]><meta http-equiv="cleartype" content="on" /><![endif]-->
  <link rel="canonical" href="https://securitylab.github.com/research/one_day_short_of_a_fullchain_android/">
  <link rel="alternate" type="application/rss+xml" title="GitHub Security Lab" href="https://securitylab.github.com/feed.xml">
  <link rel="stylesheet" media="screen" href="./One day short of a full chain_ Part 1 - Android Kernel arbitrary code execution _ GitHub Security Lab_files/index.css">
  <script async="" src="./One day short of a full chain_ Part 1 - Android Kernel arbitrary code execution _ GitHub Security Lab_files/geoip2.js.下載"></script>
  <script src="./One day short of a full chain_ Part 1 - Android Kernel arbitrary code execution _ GitHub Security Lab_files/jquery.js.下載"></script>
  <link id="favicon" rel="shortcut icon" type="image/ico" href="https://securitylab.github.com/assets/img/favicons/favicon.png">
  <link rel="apple-touch-icon" href="https://securitylab.github.com/assets/img/favicons/apple-touch-icon.png">
  <link rel="icon" href="https://securitylab.github.com/assets/img/favicons/android-favicon.png">
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>One day short of a full chain: Part 1 - Android Kernel arbitrary code execution | GitHub Security Lab</title>
<meta name="generator" content="Jekyll v4.1.1">
<meta property="og:title" content="One day short of a full chain: Part 1 - Android Kernel arbitrary code execution">
<meta name="author" content="m-y-mo">
<meta property="og:locale" content="en_US">
<meta name="description" content="In this series of posts, I’ll go through the exploit of three security bugs that I reported, which, when used together, can achieve remote kernel code execution in Qualcomm’s devices by visiting a malicious website in a beta version of Chrome. In this first post, I’ll exploit a use-after-free in Qualcomm’s kgsl driver (CVE-2020-11239), a bug that I reported in July 2020 and that was fixed in January 2021, to gain arbitrary kernel code execution from the application domain.">
<meta property="og:description" content="In this series of posts, I’ll go through the exploit of three security bugs that I reported, which, when used together, can achieve remote kernel code execution in Qualcomm’s devices by visiting a malicious website in a beta version of Chrome. In this first post, I’ll exploit a use-after-free in Qualcomm’s kgsl driver (CVE-2020-11239), a bug that I reported in July 2020 and that was fixed in January 2021, to gain arbitrary kernel code execution from the application domain.">
<link rel="canonical" href="https://securitylab.github.com/research/one_day_short_of_a_fullchain_android/">
<meta property="og:url" content="https://securitylab.github.com/research/one_day_short_of_a_fullchain_android/">
<meta property="og:site_name" content="GitHub Security Lab">
<meta property="og:image" content="https://securitylab.github.com/assets/img/social-card.png">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2021-03-10T00:00:00+00:00">
<meta name="twitter:card" content="summary_large_image">
<meta property="twitter:image" content="https://securitylab.github.com/assets/img/social-card.png">
<meta property="twitter:title" content="One day short of a full chain: Part 1 - Android Kernel arbitrary code execution">
<meta name="twitter:site" content="@GHSecurityLab">
<meta name="twitter:creator" content="@m-y-mo">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"m-y-mo"},"dateModified":"2021-03-10T00:00:00+00:00","datePublished":"2021-03-10T00:00:00+00:00","description":"In this series of posts, I’ll go through the exploit of three security bugs that I reported, which, when used together, can achieve remote kernel code execution in Qualcomm’s devices by visiting a malicious website in a beta version of Chrome. In this first post, I’ll exploit a use-after-free in Qualcomm’s kgsl driver (CVE-2020-11239), a bug that I reported in July 2020 and that was fixed in January 2021, to gain arbitrary kernel code execution from the application domain.","headline":"One day short of a full chain: Part 1 - Android Kernel arbitrary code execution","image":"https://securitylab.github.com/assets/img/social-card.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://securitylab.github.com/research/one_day_short_of_a_fullchain_android/"},"url":"https://securitylab.github.com/research/one_day_short_of_a_fullchain_android/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body class="page-/research/one_day_short_of_a_fullchain_android page-ready">
  <a class="skip-to-content" href="https://securitylab.github.com/research/one_day_short_of_a_fullchain_android/#content">skip to content</a>

  <div class="d-none d-md-block py-2 bg-gray-dark">
  <div class="container-lg p-responsive d-flex flex-md-justify-between"><a class="d-block text-white no-underline" href="https://github.com/" data-ga-click="Top bar, go to github, text:Back to GitHub.com">Back to GitHub.com</a></div>
</div>
<nav class="site-navigation UnderlineNav d-block">
  <div class="container-lg d-flex flex-items-center px-3 px-md-6 px-lg-3 py-0">
    <svg height="32" class="octicon octicon-mark-github mr-2" viewBox="0 0 16 16" version="1.1" width="32" aria-hidden="true">
      <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
    </svg>
    <a aria-current="page" role="tab" title="Security Lab" class="UnderlineNav-item UnderlineNav-item--logo" href="https://securitylab.github.com/">Security Lab</a>
    <div class="UnderlineNav-body flex-auto flex-justify-end hide-sm hide-md" role="tablist">
      <a role="tab" title="Bounties" class="UnderlineNav-item " href="https://securitylab.github.com/bounties/">Bounties</a>
      <a role="tab" title="Research" class="UnderlineNav-item " href="https://securitylab.github.com/research/">Research</a>
      <a role="tab" title="Advisories" class="UnderlineNav-item " href="https://securitylab.github.com/advisories/">Advisories</a>
      <a role="tab" title="Get Involved" class="UnderlineNav-item " href="https://securitylab.github.com/get-involved/">Get Involved</a>
      <a role="tab" title="Events" class="UnderlineNav-item " href="https://securitylab.github.com/events/">Events</a>
		</div>
    <div class="flex-auto d-flex flex-justify-end hide-lg hide-xl"><button aria-label="Menu" aria-expanded="false" class="sc-VigVT sc-jzJRlG facTgp js-menu-trigger"><svg aria-hidden="true" class="sc-dxgOiQ hTjMfW" height="16" role="img" viewBox="0 0 12 16" width="12" style="display:inline-block;fill:currentColor;user-select:none;vertical-align:text-bottom"><path fill-rule="evenodd" d="M11.41 9H.59C0 9 0 8.59 0 8c0-.59 0-1 .59-1H11.4c.59 0 .59.41.59 1 0 .59 0 1-.59 1h.01zm0-4H.59C0 5 0 4.59 0 4c0-.59 0-1 .59-1H11.4c.59 0 .59.41.59 1 0 .59 0 1-.59 1h.01zM.59 11H11.4c.59 0 .59.41.59 1 0 .59 0 1-.59 1H.59C0 13 0 12.59 0 12c0-.59 0-1 .59-1z"></path></svg></button><div></div></div>
  </div>
</nav>

<div class="mobile-nav">
  <div>
    <a role="tab" title="Bounties" class="UnderlineNav-item " href="https://securitylab.github.com/">Home</a>
    <a role="tab" title="Bounties" class="UnderlineNav-item " href="https://securitylab.github.com/bounties/">Bounties</a>
    <a role="tab" title="Research" class="UnderlineNav-item " href="https://securitylab.github.com/research/">Research</a>
    <a role="tab" title="Advisories" class="UnderlineNav-item " href="https://securitylab.github.com/advisories/">Advisories</a>
    <a role="tab" title="Get Involved" class="UnderlineNav-item " href="https://securitylab.github.com/get-involved/">Get Involved</a>
    <a role="tab" title="Events" class="UnderlineNav-item " href="https://securitylab.github.com/events/">Events</a>
  </div>
</div>
<span class="mobile-nav-screen js-menu-trigger"></span>


  <div class="container-md p-responsive mt-7 mb-8 mt-md-10 pt-md-10">
    <header class="post-header d-block mb-6">
      <div class="date text-mono f5 my-3">March 10, 2021</div>
      <h1 class="my-2 h00-mktg lh-condensed">One day short of a full chain: Part 1 - Android Kernel arbitrary code execution</h1>

      
      
      
      
      

      

      <a target="_blank" class="sc-frDJqD SgxRc d-inline-flex flex-row flex-items-center text-gray" href="https://github.com/m-y-mo">
        <img class="mr-3" src="./One day short of a full chain_ Part 1 - Android Kernel arbitrary code execution _ GitHub Security Lab_files/15773368" height="35" width="35">
        <span>Man Yue Mo</span>
      </a>
    </header>

    <main id="content" class="markdown-body" aria-label="Content">
      <p>In this series of posts, I’ll exploit three bugs that I reported last year: a use-after-free in the renderer of Chrome, a Chromium sandbox escape that was reported and fixed while it was still in beta, and a use-after-free in the Qualcomm msm kernel. Together, these three bugs form an exploit chain that allows remote kernel code execution by visiting a malicious website in the beta version of Chrome. While the full chain itself only affects beta version of Chrome, both the renderer RCE and kernel code execution existed in stable versions of the respective software. All of these bugs had been patched for quite some time, with the last one patched on the first of January.</p>

<h2 id="vulnerabilities-used-in-the-series">Vulnerabilities used in the series</h2>

<p>The three vulnerabilities that I’m going to use are the following. To achieve arbitrary kernel code execution from a compromised beta version of Chrome, I’ll use CVE-2020-11239, which is a use-after-free in the kgsl driver in the Qualcomm msm kernel. This vulnerability was reported in July 2020 to the Android security team as <a href="https://issuetracker.google.com/issues/161467620">A-161544755</a> (<a href="https://securitylab.github.com/advisories/GHSL-2020-375-kgsl/">GHSL-2020-375</a>) and was patched in the <a href="https://source.android.com/security/bulletin/2021-01-01">January Bulletin</a>. In the security bulletin, this bug was mistakenly associated with A-168722551, although the Android security team has since confirmed to acknowledge me as the original reporter of the issue. (However, the acknowledgement page had not been updated to reflect this at the time of writing.) For compromising Chrome, I’ll use CVE-2020-15972, a use-after-free in web audio to trigger a renderer RCE. This is a duplicate bug, for which an anonymous researcher reported about three weeks before I reported it as <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1125635">1125635</a> (<a href="https://securitylab.github.com/advisories/GHSL-2020-167-chrome/">GHSL-2020-167</a>). To escape the Chrome sandbox and gain control of the browser process, I’ll use CVE-2020-16045, which was reported as <a href="https://bugs.chromium.org/p/chromium/issues/detail?1125614">1125614</a> (<a href="https://securitylab.github.com/advisories/GHSL-2020-165-chrome/">GHSL-2020-165</a>). While the exploit uses a component that was only enabled in the beta version of Chrome, the bug would probably have made it to the stable version and be exploitable if it weren’t reported. Interestingly, the renderer bug CVE-2020-15972 was fixed in version <a href="https://chromereleases.googleblog.com/2020/10/stable-channel-update-for-desktop.html">86.0.4240.75</a>, the same version where the sandbox escape bug would have made into stable version of Chrome (if not reported), so these two bugs literally missed each other by one day to form a stable full chain.</p>

<h2 id="qualcomm-kernel-vulnerability">Qualcomm kernel vulnerability</h2>

<p>The vulnerability used in this post is a use-after-free in the kernel graphics support layer (kgsl) driver. This driver is used to provide an interface for apps in the userland to communicate with the Adreno gpu (the gpu that is used on Qualcomm’s snapdragon chipset). As it is necessary for apps to access this driver to render themselves, this is one of the few drivers that can be reached from third-party applications on all phones that use Qualcomm chipsets. The vulnerability itself can be triggered on all of these phones that have a kernel version 4.14 or above, which should be the case for many mid-high end phones released after late 2019, for example, Pixel 4, Samsung Galaxy S10, S20, and A71. The exploit in this post, however, could not be launched directly from a third party App on Pixel 4 due to further SELinux restrictions, but it can be launched from third party Apps on Samsung phones and possibly some others as well. The exploit in this post is largely developed with a Pixel 4 running AOSP built from source and then adapted to a Samsung Galaxy A71. With some adjustments of parameters, it should probably also work on flagship models like Samsung Galaxy S10 and S20 (Snapdragon version), although I don’t have those phones and have not tried it out myself.</p>

<p>The vulnerability here concerns the ioctl calls <code class="language-plaintext highlighter-rouge">IOCTL_KGSL_GPUOBJ_IMPORT</code> and <code class="language-plaintext highlighter-rouge">IOCTL_KGSL_MAP_USER_MEM</code>. These calls are used by apps to create shared memory between itself and the kgsl driver.</p>

<p>When using these calls, the caller specifies a user space address in their process, the size of the shared memory, as well as the type of memory objects to create. After making the ioctl call successfully, the kgsl driver would map the user supplied memory into the gpu’s memory space and be able to access the user supplied memory. Depending on the type of the memory specified in the ioctl call parameter, different mechanisms are used by the kernel to map and access the user space memory.</p>

<p>The two different types of memory are <code class="language-plaintext highlighter-rouge">KGSL_USER_MEM_TYPE_ADDR</code>, which would ask kgsl to pin the user memory supplied and perform direct I/O on those memory (see, for example, <code class="language-plaintext highlighter-rouge">Performing Direct I/O</code> section <a href="https://www.oreilly.com/library/view/linux-device-drivers/0596005903/ch15.html">here</a>). The caller can also specify the memory type to be <code class="language-plaintext highlighter-rouge">KGSL_USER_MEM_TYPE_ION</code>, which would use a direct memory access (DMA) buffer (for example, <code class="language-plaintext highlighter-rouge">Direct Memory Access</code> section <a href="https://www.oreilly.com/library/view/linux-device-drivers/0596005903/ch15.html">here</a>) allocated by the <a href="https://lwn.net/Articles/480055/">ion allocator</a> to allow the gpu to access the DMA buffer directly. We’ll look at the DMA buffer a bit more later as it is important to both the vulnerability and the exploit, but for now, we just need to know that there are two different types of memory objects that can be created from these ioctl calls. When using these ioctl, a <code class="language-plaintext highlighter-rouge">kgsl_mem_entry</code> object will first be created, and then the type of memory is checked to make sure that the <code class="language-plaintext highlighter-rouge">kgsl_mem_entry</code> is correctly populated. In a way, these ioctl calls act like constructors of <code class="language-plaintext highlighter-rouge">kgsl_mem_entry</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">kgsl_ioctl_gpuobj_import</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kgsl_device_private</span> <span class="o">*</span><span class="n">dev_priv</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">entry</span> <span class="o">=</span> <span class="n">kgsl_mem_entry_create</span><span class="p">();</span>
    <span class="p">...</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">KGSL_USER_MEM_TYPE_ADDR</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">_gpuobj_map_useraddr</span><span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="k">private</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span>
			<span class="n">entry</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
    <span class="c1">//KGSL_USER_MEM_TYPE_ION is translated to KGSL_USER_MEM_TYPE_DMABUF</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">KGSL_USER_MEM_TYPE_DMABUF</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">_gpuobj_map_dma_buf</span><span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="k">private</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span>
			<span class="n">entry</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fd</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>

</code></pre></div></div>

<p>In particular, when creating a <code class="language-plaintext highlighter-rouge">kgsl_mem_entry</code> with DMA type memory, the user supplied DMA buffer will be “attached” to the gpu, which will then allow the gpu to share the DMA buffer. The process of sharing a DMA buffer with a device on Android generally looks like this (see <a href="https://www.kernel.org/doc/html/v4.16/driver-api/dma-buf.html">this</a> for the general process of sharing a DMA buffer with a device):</p>

<ol>
  <li>The user creates a DMA buffer using the <a href="https://lwn.net/Articles/480055/">ion allocator</a>. On Android, ion is the concrete implementation of DMA buffers, so sometimes the terms are used interchangeably, as in the kgsl code here, in which <code class="language-plaintext highlighter-rouge">KGSL_USER_MEM_TYPE_DMABUF</code> and <code class="language-plaintext highlighter-rouge">KGSL_USER_MEM_TYPE_ION</code> refers to the same thing.</li>
  <li>The ion allocator will then allocate memory from the ion heap, which is a special region of memory separated from the heap used by the <code class="language-plaintext highlighter-rouge">kmalloc</code> family of calls. I’ll cover more about the ion heap later in the post.</li>
  <li>The ion allocator will return a file descriptor to the user, which is used as a handle to the DMA buffer.</li>
  <li>The user can then pass this file descriptor to the device via an appropriate ioctl call.</li>
  <li>The device then obtains the DMA buffer from the file descriptor via <code class="language-plaintext highlighter-rouge">dma_buf_get</code> and uses <code class="language-plaintext highlighter-rouge">dma_buf_attach</code> to attach it to itself.</li>
  <li>The device uses <code class="language-plaintext highlighter-rouge">dma_buf_map_attachment</code> to obtain the <code class="language-plaintext highlighter-rouge">sg_table</code> of the DMA buffer, which contains the locations and sizes of the backing stores of the DMA buffer. It can then use it to access the buffer.</li>
  <li>After this, both the device and the user can access the DMA buffer. This means that the buffer can now be modified by both the cpu (by the user) and the device. So care must be taken to synchronize the cpu view of the buffer and the device view of the buffer. (For example, the cpu may cache the content of the DMA buffer and then the device modified its content, resulting in stale data in the cpu (user) view) To do this, the user can use <code class="language-plaintext highlighter-rouge">DMA_BUF_IOCTL_SYNC</code> call of the DMA buffer to synchronize the different views of the buffer before and after accessing it.</li>
</ol>

<p>When the device is done with the shared buffer, it is important to call the functions <code class="language-plaintext highlighter-rouge">dma_buf_unmap_attachment</code>, <code class="language-plaintext highlighter-rouge">dma_buf_detach</code>, and <code class="language-plaintext highlighter-rouge">dma_buf_put</code> to perform the appropriate clean up.</p>

<p>In the case of sharing DMA buffer with the kgsl driver, the <code class="language-plaintext highlighter-rouge">sg_table</code> that belongs to the DMA buffer will be stored in the <code class="language-plaintext highlighter-rouge">kgsl_mem_entry</code> as the field <code class="language-plaintext highlighter-rouge">sgt</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">kgsl_setup_dma_buf</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kgsl_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
				<span class="k">struct</span> <span class="nc">kgsl_pagetable</span> <span class="o">*</span><span class="n">pagetable</span><span class="p">,</span>
				<span class="k">struct</span> <span class="nc">kgsl_mem_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
				<span class="k">struct</span> <span class="nc">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
	<span class="n">sg_table</span> <span class="o">=</span> <span class="n">dma_buf_map_attachment</span><span class="p">(</span><span class="n">attach</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
    <span class="p">...</span>
	<span class="n">meta</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">sg_table</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">priv_data</span> <span class="o">=</span> <span class="n">meta</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">memdesc</span><span class="p">.</span><span class="n">sgt</span> <span class="o">=</span> <span class="n">sg_table</span><span class="p">;</span>

</code></pre></div></div>

<p>On the other hand, in the case of a <code class="language-plaintext highlighter-rouge">MAP_USER_MEM</code> type memory object, the <code class="language-plaintext highlighter-rouge">sg_table</code> in <code class="language-plaintext highlighter-rouge">memdesc.sgt</code> is created and owned by the <code class="language-plaintext highlighter-rouge">kgsl_mem_entry</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">memdesc_sg_virt</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kgsl_memdesc</span> <span class="o">*</span><span class="n">memdesc</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">file</span> <span class="o">*</span><span class="n">vmfile</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">//Creates an sg_table and stores it in memdesc-&gt;sgt</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sg_alloc_table_from_pages</span><span class="p">(</span><span class="n">memdesc</span><span class="o">-&gt;</span><span class="n">sgt</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">npages</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span> <span class="n">memdesc</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
</code></pre></div></div>

<p>As such, care must be taken with the ownership of <code class="language-plaintext highlighter-rouge">memdesc-&gt;sgt</code> when <code class="language-plaintext highlighter-rouge">kgsl_mem_entry</code> is destroyed. If the ioctl call somehow failed, then the memory object that is created will have to be destroyed. Depending on the type of the memory, the clean up logic will be different:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">unmap:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">KGSL_USER_MEM_TYPE_DMABUF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kgsl_destroy_ion</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">);</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">memdesc</span><span class="p">.</span><span class="n">sgt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kgsl_sharedmem_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">memdesc</span><span class="p">);</span>

</code></pre></div></div>

<p>If we created an ION type memory object, then apart from the extra clean up that detaches the gpu from the DMA buffer, <code class="language-plaintext highlighter-rouge">entry-&gt;memdesc.sgt</code> is set to <code class="language-plaintext highlighter-rouge">NULL</code> before entering <code class="language-plaintext highlighter-rouge">kgsl_sharedmem_free</code>, which will free <code class="language-plaintext highlighter-rouge">entry-&gt;memdesc.sgt</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">kgsl_sharedmem_free</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kgsl_memdesc</span> <span class="o">*</span><span class="n">memdesc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memdesc</span><span class="o">-&gt;</span><span class="n">sgt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sg_free_table</span><span class="p">(</span><span class="n">memdesc</span><span class="o">-&gt;</span><span class="n">sgt</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">memdesc</span><span class="o">-&gt;</span><span class="n">sgt</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memdesc</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">)</span>
		<span class="n">kgsl_free</span><span class="p">(</span><span class="n">memdesc</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So far, so good, everything is taken care of, but a closer look reveals that, when creating a <code class="language-plaintext highlighter-rouge">KGSL_USER_MEM_TYPE_ADDR</code> object, the code would first check if the user supplied address is allocated by the ion allocator, if so, it will create an ION type memory object instead.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">kgsl_setup_useraddr</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kgsl_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
		<span class="k">struct</span> <span class="nc">kgsl_pagetable</span> <span class="o">*</span><span class="n">pagetable</span><span class="p">,</span>
		<span class="k">struct</span> <span class="nc">kgsl_mem_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hostptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
 	<span class="cm">/* Try to set up a dmabuf - if it returns -ENODEV assume anonymous */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">kgsl_setup_dmabuf_useraddr</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">pagetable</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">hostptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Okay - lets go legacy */</span>
	<span class="k">return</span> <span class="n">kgsl_setup_anon_useraddr</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span>
		<span class="n">hostptr</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>While there is nothing wrong with using a DMA mapping when the user supplied memory is actually a dma buffer (allocated by ion), if something goes wrong during the ioctl call, the clean up logic will be wrong and <code class="language-plaintext highlighter-rouge">memdesc-&gt;sgt</code> will be incorrectly deleted. Fortunately, before the <a href="https://source.android.com/devices/architecture/kernel/ion_abi_changes">ION ABI change</a> introduced in the 4.12 kernel, the now freed <code class="language-plaintext highlighter-rouge">sg_table</code> cannot be reached again. However, after this change, the <code class="language-plaintext highlighter-rouge">sg_table</code> gets added to the <code class="language-plaintext highlighter-rouge">dma_buf_attachment</code> when a DMA buffer is attached to a device, and the <code class="language-plaintext highlighter-rouge">dma_buf_attachment</code> is then stored in the DMA buffer.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">ion_dma_buf_attach</span><span class="p">(</span><span class="k">struct</span> <span class="nc">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
                                <span class="k">struct</span> <span class="nc">dma_buf_attachment</span> <span class="o">*</span><span class="n">attachment</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">dup_sg_table</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">sg_table</span><span class="p">);</span>
    <span class="p">...</span>
        <span class="n">a</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>                          <span class="c1">//&lt;---- c. duplicated table stored in attachment, which is the output of dma_buf_attach in a.</span>
    <span class="p">...</span>
        <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
        <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">attachments</span><span class="p">);</span>  <span class="c1">//&lt;---- d. attachment got added to dma_buf::attachments</span>
        <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This will normally be removed when the DMA buffer is detached from the device. However, because of the wrong clean up logic, the DMA buffer will never be detached in this case, (<code class="language-plaintext highlighter-rouge">kgsl_destroy_ion</code> is not called) meaning that after the ioctl call failed, the user supplied DMA buffer will end up with an attachment that contains a free’d <code class="language-plaintext highlighter-rouge">sg_table</code>. This <code class="language-plaintext highlighter-rouge">sg_table</code> will then be used any time when the <code class="language-plaintext highlighter-rouge">DMA_BUF_IOCTL_SYNC</code> call is used on the buffer:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">__ion_dma_buf_begin_cpu_access</span><span class="p">(</span><span class="k">struct</span> <span class="nc">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">,</span>
                                          <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
                                          <span class="kt">bool</span> <span class="n">sync_only_mapped</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
        <span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">attachments</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sync_only_mapped</span><span class="p">)</span>
                        <span class="n">tmp</span> <span class="o">=</span> <span class="n">ion_sgl_sync_mapped</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">,</span>        <span class="c1">//&lt;--- use-after-free of a-&gt;table</span>
                                                  <span class="n">a</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">nents</span><span class="p">,</span>
                                                  <span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">vmas</span><span class="p">,</span>
                                                  <span class="n">direction</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
                <span class="k">else</span>
                        <span class="n">dma_sync_sg_for_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">,</span>              <span class="c1">//&lt;--- use-after-free of a-&gt;table</span>
                                            <span class="n">a</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">nents</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
            <span class="p">...</span>
                <span class="p">}</span>
        <span class="p">}</span>
<span class="p">...</span>
<span class="p">}</span>

</code></pre></div></div>

<p>There are actually multiple paths in this ioctl that can lead to the use of the <code class="language-plaintext highlighter-rouge">sg_table</code> in different ways.</p>

<h3 id="getting-a-freed-object-with-a-fake-out-of-memory-error"><a name="trigger"></a>Getting a free’d object with a fake out-of-memory error</h3>

<p>While this looks like a very good use-after-free that allows me to hold onto a free’d object and use it at any convenient time, as well as in different ways, to trigger it, I first need to cause the <code class="language-plaintext highlighter-rouge">IOCTL_KGSL_GPUOBJ_IMPORT</code> or <code class="language-plaintext highlighter-rouge">IOCTL_KGSL_MAP_USER_MEM</code> to fail and to fail at the right place. The only place where a use-after-free can happen in the <code class="language-plaintext highlighter-rouge">IOCTL_KGSL_GPUOBJ_IMPORT</code> call is when it fails at <code class="language-plaintext highlighter-rouge">kgsl_mem_entry_attach_process</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">kgsl_ioctl_gpuobj_import</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kgsl_device_private</span> <span class="o">*</span><span class="n">dev_priv</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
	<span class="n">kgsl_memdesc_init</span><span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">memdesc</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">KGSL_USER_MEM_TYPE_ADDR</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">_gpuobj_map_useraddr</span><span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="k">private</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span>
			<span class="n">entry</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">KGSL_USER_MEM_TYPE_DMABUF</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">_gpuobj_map_dma_buf</span><span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="k">private</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span>
			<span class="n">entry</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fd</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

    <span class="p">...</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">kgsl_mem_entry_attach_process</span><span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="k">private</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unmap</span><span class="p">;</span>

</code></pre></div></div>

<p>This is the last point where the call can fail. Any earlier failure will also not result in <code class="language-plaintext highlighter-rouge">kgsl_sharedmem_free</code> being called. One way that this can fail is if <code class="language-plaintext highlighter-rouge">kgsl_mem_entry_track_gpuaddr</code> failed to reserve memory in the gpu due to out-of-memory error:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">kgsl_mem_entry_attach_process</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kgsl_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
		<span class="k">struct</span> <span class="nc">kgsl_process_private</span> <span class="o">*</span><span class="n">process</span><span class="p">,</span>
		<span class="k">struct</span> <span class="nc">kgsl_mem_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">kgsl_mem_entry_track_gpuaddr</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">process</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kgsl_process_private_put</span><span class="p">(</span><span class="n">process</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>Of course, to actually cause an out-of-memory error would be rather difficult and unreliable, as well as risking to crash the device by exhausting the memory.</p>

<p>If we look at how a user provided address is mapped to gpu address in <code class="language-plaintext highlighter-rouge">kgsl_iommu_get_gpuaddr</code>, (which is called by <code class="language-plaintext highlighter-rouge">kgsl_mem_entry_track_gpuaddr</code>, note that these are actually user space gpu address in the sense that they are used by the gpu with a user process specific pagetable to resolve the actual addresses, so different processes can have the same gpu addresses that resolved to different actual locations, in the same way that user space addresses can be the same in different processes but resolved to different locations) then we see that an alignment parameter is taken from the <code class="language-plaintext highlighter-rouge">flags</code> of the <code class="language-plaintext highlighter-rouge">kgsl_memdesc</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">kgsl_iommu_get_gpuaddr</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kgsl_pagetable</span> <span class="o">*</span><span class="n">pagetable</span><span class="p">,</span>
		<span class="k">struct</span> <span class="nc">kgsl_memdesc</span> <span class="o">*</span><span class="n">memdesc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">align</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="c1">//Uses `memdesc-&gt;flags` to compute the alignment parameter</span>
	<span class="n">align</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">kgsl_memdesc_get_align</span><span class="p">(</span><span class="n">memdesc</span><span class="p">),</span>
			<span class="n">memdesc</span><span class="o">-&gt;</span><span class="n">pad_to</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div></div>

<p>and the flags of <code class="language-plaintext highlighter-rouge">memdesc</code> is taken from the <code class="language-plaintext highlighter-rouge">flags</code> parameter when the ioctl is called:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">kgsl_ioctl_gpuobj_import</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kgsl_device_private</span> <span class="o">*</span><span class="n">dev_priv</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
	<span class="n">kgsl_memdesc_init</span><span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">memdesc</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
</code></pre></div></div>

<p>When mapping memory to the gpu, this <code class="language-plaintext highlighter-rouge">align</code> value will be used to ensure that the memory address is mapped to a value that is aligned (i.e. multiples of) to <code class="language-plaintext highlighter-rouge">align</code>. In particular, the gpu address will be the next multiple of <code class="language-plaintext highlighter-rouge">align</code> that is not already occupied. If no such value exist, then an out-of-memory error will occur. So by using a large <code class="language-plaintext highlighter-rouge">align</code> value in the ioctl call, I can easily use up all the addresses that are aligned with the value that I specified. For example, if I set <code class="language-plaintext highlighter-rouge">align</code> to be <code class="language-plaintext highlighter-rouge">1 &lt;&lt; 31</code>, then there will only be two addresses that aligns with <code class="language-plaintext highlighter-rouge">align</code> (<code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">1 &lt;&lt; 31</code>). So after just mapping one memory object (which can be as small as <code class="language-plaintext highlighter-rouge">4096</code> bytes), I’ll get an out-of-memory error the next time I use the ioctl call. This will then give me a free’d <code class="language-plaintext highlighter-rouge">sg_table</code> in the DMA buffer. By allocating another object of similar size in the kernel, I can then replace this <code class="language-plaintext highlighter-rouge">sg_table</code> with an object that I control. I’ll go through the details of how to do this later, but for now, let’s assume I am able to do this and have complete control of all the fields in this <code class="language-plaintext highlighter-rouge">sg_table</code> and see what this bug potentially allows me to do.</p>

<h2 id="the-primitives-of-the-vulnerability"><a name="primitives"></a>The primitives of the vulnerability</h2>

<p>As mentioned before, there are different ways to use the free’d <code class="language-plaintext highlighter-rouge">sg_table</code> via the <code class="language-plaintext highlighter-rouge">DMA_BUF_IOCTL_SYNC</code> ioctl call:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">long</span> <span class="nf">dma_buf_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DMA_BUF_IOCTL_SYNC</span><span class="p">:</span>
        <span class="p">...</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sync</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DMA_BUF_SYNC_END</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sync</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DMA_BUF_SYNC_USER_MAPPED</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">dma_buf_end_cpu_access_umapped</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span>
								     <span class="n">dir</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">dma_buf_end_cpu_access</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sync</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DMA_BUF_SYNC_USER_MAPPED</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">dma_buf_begin_cpu_access_umapped</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span>
								       <span class="n">dir</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">dma_buf_begin_cpu_access</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

</code></pre></div></div>

<p>These will ended up calling the functions <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/drivers/staging/android/ion/ion.c#651"><code class="language-plaintext highlighter-rouge">__ion_dma_buf_begin_cpu_access</code></a> or <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/drivers/staging/android/ion/ion.c#745"><code class="language-plaintext highlighter-rouge">__ion_dma_buf_end_cpu_access</code></a> that provide the concrete implementations.</p>

<p>As explained before, the <code class="language-plaintext highlighter-rouge">DMA_BUF_IOCTL_SYNC</code> call is meant to synchronize the cpu view of the DMA buffer and the device (in this case, gpu) view of the DMA buffer. For the kgsl device, the synchronization is implemented in <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/lib/swiotlb.c"><code class="language-plaintext highlighter-rouge">lib/swiotlb.c</code></a>. The various different ways of syncing the buffer will more or less follow a code path like this:</p>

<ol>
  <li>The <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/include/linux/scatterlist.h#40"><code class="language-plaintext highlighter-rouge">scatterlist</code></a> in the free’d <code class="language-plaintext highlighter-rouge">sg_table</code> is iterated in a loop;</li>
  <li>In each iteration, the <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/include/linux/scatterlist.h#18"><code class="language-plaintext highlighter-rouge">dma_address</code></a> and <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/include/linux/scatterlist.h#20"><code class="language-plaintext highlighter-rouge">dma_length</code></a> of the <code class="language-plaintext highlighter-rouge">scatterlist</code> is used to identify the location and size of the memory for synchronization.</li>
  <li>The function <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/lib/swiotlb.c#925"><code class="language-plaintext highlighter-rouge">swiotlb_sync_single</code></a> is called to perform the actual synchronization of the memory.</li>
</ol>

<p>So what does <code class="language-plaintext highlighter-rouge">swiotlb_sync_single</code> do? It first checks whether the <code class="language-plaintext highlighter-rouge">dma_address</code> (<code class="language-plaintext highlighter-rouge">dev_addr</code>, <code class="language-plaintext highlighter-rouge">dma_to_phys</code> for <code class="language-plaintext highlighter-rouge">kgsl</code> is just the identity function) in the <code class="language-plaintext highlighter-rouge">scatterlist</code> is an address of a <code class="language-plaintext highlighter-rouge">swiotlb_buffer</code> using the <code class="language-plaintext highlighter-rouge">is_swiotlb_buffer</code> function, if so, it calls <code class="language-plaintext highlighter-rouge">swiotlb_tlb_sync_single</code>, otherwise, it will call <code class="language-plaintext highlighter-rouge">dma_mark_clean</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span>
<span class="nf">swiotlb_sync_single</span><span class="p">(</span><span class="k">struct</span> <span class="nc">device</span> <span class="o">*</span><span class="n">hwdev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dev_addr</span><span class="p">,</span>
		    <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
		    <span class="k">enum</span> <span class="n">dma_sync_target</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phys_addr_t</span> <span class="n">paddr</span> <span class="o">=</span> <span class="n">dma_to_phys</span><span class="p">(</span><span class="n">hwdev</span><span class="p">,</span> <span class="n">dev_addr</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_NONE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_swiotlb_buffer</span><span class="p">(</span><span class="n">paddr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">swiotlb_tbl_sync_single</span><span class="p">(</span><span class="n">hwdev</span><span class="p">,</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">!=</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dma_mark_clean</span><span class="p">(</span><span class="n">phys_to_virt</span><span class="p">(</span><span class="n">paddr</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">dma_mark_clean</code> simply flushes the cpu cache that corresponds to <code class="language-plaintext highlighter-rouge">dev_addr</code> and keeps the cpu cache in sync with the actual memory. I wasn’t able to exploit this path and so I’ll concentrate on the <code class="language-plaintext highlighter-rouge">swiotlb_tbl_sync_single</code> path.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">swiotlb_tbl_sync_single</span><span class="p">(</span><span class="k">struct</span> <span class="nc">device</span> <span class="o">*</span><span class="n">hwdev</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">tlb_addr</span><span class="p">,</span>
			     <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">dma_sync_target</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">tlb_addr</span> <span class="o">-</span> <span class="n">io_tlb_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">IO_TLB_SHIFT</span><span class="p">;</span>
	<span class="n">phys_addr_t</span> <span class="n">orig_addr</span> <span class="o">=</span> <span class="n">io_tlb_orig_addr</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">orig_addr</span> <span class="o">==</span> <span class="n">INVALID_PHYS_ADDR</span><span class="p">)</span>                            <span class="c1">//&lt;--------- a. checks address valid</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">orig_addr</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tlb_addr</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IO_TLB_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SYNC_FOR_CPU</span><span class="p">:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span> <span class="o">||</span> <span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">))</span>
			<span class="n">swiotlb_bounce</span><span class="p">(</span><span class="n">orig_addr</span><span class="p">,</span> <span class="n">tlb_addr</span><span class="p">,</span>
				       <span class="n">size</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>After a further check of the address (<code class="language-plaintext highlighter-rouge">tlb_addr</code>) against an array <code class="language-plaintext highlighter-rouge">io_tlb_orig_addr</code>, the function <code class="language-plaintext highlighter-rouge">swiotlb_bounce</code> is called.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">swiotlb_bounce</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">orig_addr</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">tlb_addr</span><span class="p">,</span>
			   <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">tlb_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">)))</span> <span class="p">{</span>
        <span class="p">...</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sz</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

			<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">buffer</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
            <span class="p">...</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">orig_addr</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">phys_to_virt</span><span class="p">(</span><span class="n">orig_addr</span><span class="p">),</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As <code class="language-plaintext highlighter-rouge">tlb_addr</code> and <code class="language-plaintext highlighter-rouge">size</code> comes from a <code class="language-plaintext highlighter-rouge">scatterlist</code> in the free’d <code class="language-plaintext highlighter-rouge">sg_table</code>, it becomes clear that I may be able to call a <code class="language-plaintext highlighter-rouge">memcpy</code> with a partially controlled source/destination (<code class="language-plaintext highlighter-rouge">tlb_addr</code> comes from <code class="language-plaintext highlighter-rouge">scatterlist</code> but is constrained as it needs to pass some checks, while <code class="language-plaintext highlighter-rouge">size</code> is unchecked). This could potentially give me a very strong relative read/write primitive. The questions are:</p>

<ol>
  <li>What is the <code class="language-plaintext highlighter-rouge">swiotlb_buffer</code> and is it possible to pass the <code class="language-plaintext highlighter-rouge">is_swiotlb_buffer</code> check without a separate info leak?</li>
  <li>What is the <code class="language-plaintext highlighter-rouge">io_tlb_orig_addr</code> and how to pass that test?</li>
  <li>How much control do I have with the <code class="language-plaintext highlighter-rouge">orig_addr</code>, which comes from <code class="language-plaintext highlighter-rouge">io_tlb_orig_addr</code>?</li>
</ol>

<h2 id="the-software-input-output-translation-lookaside-buffer">The Software Input Output Translation Lookaside Buffer</h2>

<p>The Software Input Output Translation Lookaside Buffer (SWIOTLB), sometimes known as the bounce buffer, is a memory region with physical address smaller than 32 bits. It seems to be very rarely used in modern Android phones and as far as I can gather, there are two main uses of it:</p>

<ol>
  <li>It is used when a DMA buffer that has a physical address higher than 32 bits is attached to a device that can only access 32 bit addresses. In this case, the SWIOTLB is used as a proxy of the DMA buffer to allow access of it from the device. This is the code path that we have been looking at. As this would mean an extra read/write operation between the DMA buffer and the SWIOTLB every time a synchronization between the device and DMA buffer happens, it is not an ideal scenario but is rather only used as a last resort.</li>
  <li>To use as a layer of protection to avoid untrusted usb devices from accessing DMA memory directly (See <a href="https://lwn.net/Articles/786558/">here</a>)</li>
</ol>

<p>As the second usage is likely to involve plugging a usb device to a phone and thus requires physical access. I’ll only cover the first usage here, which will also answer the three questions in the previous section.</p>

<p>To begin with, let’s take a look at the location of the SWIOTLB. This is used by the check <code class="language-plaintext highlighter-rouge">is_swiotlb_buffer</code> to determine whether a physical address belongs to the SWIOTLB:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">is_swiotlb_buffer</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">paddr</span> <span class="o">&gt;=</span> <span class="n">io_tlb_start</span> <span class="o">&amp;&amp;</span> <span class="n">paddr</span> <span class="o">&lt;</span> <span class="n">io_tlb_end</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The global variables <code class="language-plaintext highlighter-rouge">io_tlb_start</code> and <code class="language-plaintext highlighter-rouge">io_tlb_end</code> marks the range of the SWIOTLB. As mentioned before, the SWIOTLB needs to be an address smaller than 32 bits. How does the kernel guarantee this? By allocating the SWIOTLB very early during boot. From a rooted device, we can see that the SWIOTLB is allocated nearly right at the start of the boot. This is an excerpt of the kernel log during the early stage of booting a Pixel 4:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
[    0.000000] c0      0 software IO TLB: swiotlb init: 00000000f3800000
[    0.000000] c0      0 software IO TLB: mapped [mem 0xf3800000-0xf3c00000] (4MB)
...
</code></pre></div></div>

<p>Here we see that <code class="language-plaintext highlighter-rouge">io_tlb_start</code> is <code class="language-plaintext highlighter-rouge">0xf3800000</code> while <code class="language-plaintext highlighter-rouge">io_tlb_end</code> is <code class="language-plaintext highlighter-rouge">0xf3c00000</code>.</p>

<p>While allocating the SWIOTLB early makes sure that the its address is below 32 bits, it also makes it predictable. In fact, the address only seems to depend on the amount of memory configured for the SWIOTLB, which is passed as the <code class="language-plaintext highlighter-rouge">swiotlb</code> boot parameter. For Pixel 4, this is <code class="language-plaintext highlighter-rouge">swiotlb=2048</code> (which seems to be a common parameter and is the same for Galaxy S10 and S20) and will allocate 4MB of SWIOTLB (<code class="language-plaintext highlighter-rouge">allocation size = swiotlb * 2048</code>) For the Samsung Galaxy A71, the parameter is set to <code class="language-plaintext highlighter-rouge">swiotlb=1</code>, which allocates the minimum amount of SWIOTLB (<code class="language-plaintext highlighter-rouge">0x40000</code> bytes)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[    0.000000] software IO TLB: mapped [mem 0xfffbf000-0xfffff000] (0MB)

</code></pre></div></div>

<p>The SWIOTLB will be at the same location when changing <code class="language-plaintext highlighter-rouge">swiotlb</code> to <code class="language-plaintext highlighter-rouge">1</code> on Pixel 4.</p>

<p>This provides us with a predicable location for the SWIOTLB to pass the <code class="language-plaintext highlighter-rouge">is_swiotlb_buffer</code> test.</p>

<p>Let’s take a look at <code class="language-plaintext highlighter-rouge">io_tlb_orig_addr</code> next. This is an array used for storing addresses of DMA buffers that are attached to devices with addresses that are too high for the device to access:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">swiotlb_map_sg_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="nc">device</span> <span class="o">*</span><span class="n">hwdev</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nelems</span><span class="p">,</span>
		     <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nelems</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phys_addr_t</span> <span class="n">paddr</span> <span class="o">=</span> <span class="n">sg_phys</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="n">dma_addr_t</span> <span class="n">dev_addr</span> <span class="o">=</span> <span class="n">phys_to_dma</span><span class="p">(</span><span class="n">hwdev</span><span class="p">,</span> <span class="n">paddr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">swiotlb_force</span> <span class="o">==</span> <span class="n">SWIOTLB_FORCE</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">dma_capable</span><span class="p">(</span><span class="n">hwdev</span><span class="p">,</span> <span class="n">dev_addr</span><span class="p">,</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">//device cannot access dev_addr, so use SWIOTLB as a proxy</span>
			<span class="n">phys_addr_t</span> <span class="n">map</span> <span class="o">=</span> <span class="n">map_single</span><span class="p">(</span><span class="n">hwdev</span><span class="p">,</span> <span class="n">sg_phys</span><span class="p">(</span><span class="n">sg</span><span class="p">),</span>
						     <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
             <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this case, <code class="language-plaintext highlighter-rouge">map_single</code> will store the address of the DMA buffer (<code class="language-plaintext highlighter-rouge">dev_addr</code>) in the <code class="language-plaintext highlighter-rouge">io_tlb_orig_addr</code>. This means that if I can cause a SWIOTLB mapping to happen by attaching a DMA buffer with high address to a device that cannot access it (<code class="language-plaintext highlighter-rouge">!dma_capable</code>), then the <code class="language-plaintext highlighter-rouge">orig_addr</code> in <code class="language-plaintext highlighter-rouge">memcpy</code> of <code class="language-plaintext highlighter-rouge">swiotlb_bounce</code> will point to a DMA buffer that I control, which means I can read and write its content with complete control.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">swiotlb_bounce</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">orig_addr</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">tlb_addr</span><span class="p">,</span>
			   <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">//orig_addr is the address of a DMA buffer uses the SWIOTLB mapping</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">orig_addr</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">phys_to_virt</span><span class="p">(</span><span class="n">orig_addr</span><span class="p">),</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It now becomes clear that, if I can allocate a SWIOTLB, then I will be able to perform both read and write of a region behind the SWIOTLB region with arbitrary size (and completely controlled content in the case of write). In what follows, this is what I’m going to use for the exploit.</p>

<p>To summarize, this is how synchronization works for DMA buffer shared with the implementation in <code class="language-plaintext highlighter-rouge">/lib/swiotlb.c</code>.</p>

<p>When the device is capable of accessing the DMA buffer’s address, synchronization will involve flushing the cpu cache:</p>

<p><img src="./One day short of a full chain_ Part 1 - Android Kernel arbitrary code execution _ GitHub Security Lab_files/dma_sync.png" alt="figure"></p>

<p>When the device cannot access the DMA buffer directly, a SWIOTLB is created as an intermediate buffer to allow device access. In this case, the <code class="language-plaintext highlighter-rouge">io_tlb_orig_addr</code> array is served as a look up table to locate the DMA buffer from the SWIOTLB.</p>

<p><img src="./One day short of a full chain_ Part 1 - Android Kernel arbitrary code execution _ GitHub Security Lab_files/dma_sync_swiotlb.png" alt="figure"></p>

<p>In the use-after-free scenario, I can control the size of the <code class="language-plaintext highlighter-rouge">memcpy</code> between the DMA buffer and SWIOTLB in the above figure and that turns into a read/write primitive:</p>

<p><img src="./One day short of a full chain_ Part 1 - Android Kernel arbitrary code execution _ GitHub Security Lab_files/dma_read_write.png" alt="figure"></p>

<p>Provided I can control the <code class="language-plaintext highlighter-rouge">scatterlist</code> that specifies the location and size of the SWIOTLB, I can specify the size to be larger than the original DMA buffer to cause an out-of-bounds access (I still need to point to the SWIOTLB to pass the checks). Of course, it is no good to just cause out-of-bounds access, I need to be able to read back the out-of-bounds data in the case of a read access and control the data that I write in the case of a write access. This issue will be addressed in the next section.</p>

<h3 id="allocating-a-software-input-output-translation-lookaside-buffer"><a name="allocating_swiotlb"></a>Allocating a Software Input Output Translation Lookaside Buffer</h3>

<p>As it turns out, the SWIOTLB is actually very rarely used. For one or another reason, either because most devices are capable of reading 64 bit addresses, or that the DMA buffer synchronization is implemented with <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/drivers/iommu/arm-smmu.c"><code class="language-plaintext highlighter-rouge">arm_smmu</code></a> rather than <code class="language-plaintext highlighter-rouge">swiotlb</code>, I only managed to allocate a SWIOTLB using the <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/drivers/char/adsprpc.c"><code class="language-plaintext highlighter-rouge">adsprpc</code></a> driver. The <code class="language-plaintext highlighter-rouge">adsprpc</code> driver is used for communicating with the DSP (digital signal processor), which is a separate processor on Qualcomm’s snapdragon chipset. The DSP and the <code class="language-plaintext highlighter-rouge">adsprpc</code> itself is a very vast topic that had many security implications, and it is out of the scope of this post.</p>

<p>Roughly speaking, the DSP is a specialized chip that is optimized for certain computationally intensive tasks such as image, video, audio processing and machine learning. The cpu can offload these tasks to the DSP to improve overall performance. However, as the DSP is a different processor altogether, an RPC mechanism is needed to pass data and instructions between the cpu and the DSP. This is what the <code class="language-plaintext highlighter-rouge">adsprpc</code> driver is for. It allows the kernel to communicate with the DSP (which is running on a separate kernel and OS altogether, so this is truly “remote”) to invoke functions, allocate memory and retrieve results from the DSP.</p>

<p>While access to the <code class="language-plaintext highlighter-rouge">adsprpc</code> driver from third-party apps is not granted in the default SELinux settings and as such, I’m unable to use it on Google’s Pixel phones, it is still enabled on many different phones running Qualcomm’s snapdragon SoC (system on chip). For example, Samsung phones allow accesses of <code class="language-plaintext highlighter-rouge">adsprpc</code> from third party Apps, which allows the exploit in this post to be launched directly from a third party App or from a compromised beta version of Chrome (or any other compromised App). On phones which <code class="language-plaintext highlighter-rouge">adsprpc</code> accesses is not allowed, such as the Pixel 4, an additional bug that compromises a service that can access <code class="language-plaintext highlighter-rouge">adsprpc</code> is required to launch this exploit. There are various services that can access the <code class="language-plaintext highlighter-rouge">adsprpc</code> driver and reachable directly from third party Apps, such as the <a href="https://android.googlesource.com/device/google/coral-sepolicy/+/refs/tags/android-11.0.0_r28/vendor/qcom/common/hal_neuralnetworks.te#9"><code class="language-plaintext highlighter-rouge">hal_neuralnetworks</code></a>, which is implemented as a closed source service in <code class="language-plaintext highlighter-rouge">android.hardware.neuralnetworks@1.x-service-qti</code>. I did not investigate this path, so I’ll assume Samsung phones in the rest of this post.</p>

<p>With <code class="language-plaintext highlighter-rouge">adsprpc</code>, the most obvious ioctl to use for allocating SWIOTLB is the <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/drivers/char/adsprpc.c#3457"><code class="language-plaintext highlighter-rouge">FASTRPC_IOCTL_MMAP</code></a>, which calls <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/drivers/char/adsprpc.c#769"><code class="language-plaintext highlighter-rouge">fastrpc_mmap_create</code></a> to attach a DMA buffer that I supplied:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">fastrpc_mmap_create</span><span class="p">(</span><span class="k">struct</span> <span class="nc">fastrpc_file</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">attr</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">va</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mflags</span><span class="p">,</span>
	<span class="k">struct</span> <span class="nc">fastrpc_mmap</span> <span class="o">**</span><span class="n">ppmap</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mflags</span> <span class="o">==</span> <span class="n">FASTRPC_DMAHANDLE_NOMAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VERIFY</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">dma_buf_get</span><span class="p">(</span><span class="n">fd</span><span class="p">)));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="n">VERIFY</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="o">!</span><span class="n">dma_buf_get_flags</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">));</span>
        <span class="p">...</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">attach</span><span class="o">-&gt;</span><span class="n">dma_map_attrs</span> <span class="o">|=</span> <span class="n">DMA_ATTR_SKIP_CPU_SYNC</span><span class="p">;</span>
        <span class="p">...</span>
</code></pre></div></div>

<p>However, the call seems to always fail when <code class="language-plaintext highlighter-rouge">fastrpc_mmap_on_dsp</code> <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/drivers/char/adsprpc.c#2698">is called</a>, which will then detach the DMA buffer from the <code class="language-plaintext highlighter-rouge">adsprpc</code> driver and remove the SWIOTLB that was just allocated. While it is possible to work with a temporary buffer like this by racing with multiple threads, it would be better if I can allocate a permanent SWIOTLB.</p>

<p>Another possibility is to use the <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/drivers/char/adsprpc.c#1401"><code class="language-plaintext highlighter-rouge">get_args</code></a> function, which will also invoke <code class="language-plaintext highlighter-rouge">fastrpc_mmap_create</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">get_args</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">kernel</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">smq_invoke_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">bufs</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bufs</span> <span class="o">+</span> <span class="n">handles</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attrs</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">FASTRPC_ATTR_NOMAP</span><span class="p">))</span>
			<span class="n">dmaflags</span> <span class="o">=</span> <span class="n">FASTRPC_DMAHANDLE_NOMAP</span><span class="p">;</span>
		<span class="n">VERIFY</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="o">!</span><span class="n">fastrpc_mmap_create</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fl</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				<span class="n">FASTRPC_ATTR_NOVA</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dmaflags</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">maps</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
        <span class="p">...</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">get_args</code> function is used in the various <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/drivers/char/adsprpc.c#3435"><code class="language-plaintext highlighter-rouge">FASTRPC_IOCTL_INVOKE_*</code></a> calls for passing arguments to invoke functions on the DSP. Under normal circumstances, a corresponding <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/drivers/char/adsprpc.c#1960"><code class="language-plaintext highlighter-rouge">put_args</code></a> will be called to detach the DMA buffer from the <code class="language-plaintext highlighter-rouge">adsprpc</code> driver. However, if the remote invocation failed, the call to <code class="language-plaintext highlighter-rouge">put_args</code> will be skipped and the clean up will be deferred to the time when the <code class="language-plaintext highlighter-rouge">adsprpc</code> file is close:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">fastrpc_internal_invoke</span><span class="p">(</span><span class="k">struct</span> <span class="nc">fastrpc_file</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">mode</span><span class="p">,</span>
				   <span class="kt">uint32_t</span> <span class="n">kernel</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="nc">fastrpc_ioctl_invoke_crc</span> <span class="o">*</span><span class="n">inv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">REMOTE_SCALARS_LENGTH</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PERF</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">,</span> <span class="n">GET_COUNTER</span><span class="p">(</span><span class="n">perf_counter</span><span class="p">,</span> <span class="n">PERF_GETARGS</span><span class="p">),</span>
		<span class="n">VERIFY</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="mi">0</span> <span class="o">==</span> <span class="n">get_args</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">ctx</span><span class="p">));</span>                  <span class="c1">//&lt;----- get_args</span>
		<span class="n">PERF_END</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>
    <span class="p">...</span>
 <span class="nl">wait:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kernel</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">....</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">interrupted</span> <span class="o">=</span> <span class="n">wait_for_completion_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
		<span class="n">VERIFY</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="mi">0</span> <span class="o">==</span> <span class="p">(</span><span class="n">err</span> <span class="o">=</span> <span class="n">interrupted</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>                                        <span class="c1">//&lt;----- invocation failed and jump to bail directly</span>
	<span class="p">}</span>
    <span class="p">...</span>
	<span class="n">VERIFY</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="mi">0</span> <span class="o">==</span> <span class="n">put_args</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">invoke</span><span class="o">-&gt;</span><span class="n">pra</span><span class="p">));</span>    <span class="c1">//&lt;------ detach the arguments</span>
	<span class="n">PERF_END</span><span class="p">);</span>
    <span class="p">...</span>
 <span class="nl">bail:</span>
    <span class="p">...</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So by using <code class="language-plaintext highlighter-rouge">FASTRPC_IOCTL_INVOKE_*</code> with an invalid remote function, it is easy to allocate and keep the SWIOTLB alive until I choose to close the <code class="language-plaintext highlighter-rouge">/dev/adsprpc-smd</code> file that is used to make the ioctl call. This is the only part that the <code class="language-plaintext highlighter-rouge">adsprpc</code> driver is needed and we’re now set up to start writing the exploit.</p>

<p>Now that I can allocate SWIOTLB that maps to DMA buffers that I created, I can do the following to exploit the out-of-bounds read/write primitive from the previous section.</p>

<ol>
  <li>First allocate a number of DMA buffers. By manipulating the ion heap, (which I’ll go through later in this post), I can place some useful data behind one of these DMA buffers. I will call this buffer <code class="language-plaintext highlighter-rouge">DMA_1</code>.</li>
  <li>Use the <code class="language-plaintext highlighter-rouge">adsprpc</code> driver to allocate SWIOTLB buffers associated with these DMA buffers. I’ll arrange it so that the <code class="language-plaintext highlighter-rouge">DMA_1</code> occupies the first SWIOTLB (which means all other SWIOTLB will be allocated behind it), call this <code class="language-plaintext highlighter-rouge">SWIOTLB_1</code>. This can be done easily as SWIOTLB are simply allocated as a contiguous array.</li>
  <li>Use the read/write primitive in the previous section to trigger out-of-bounds read/write on <code class="language-plaintext highlighter-rouge">DMA_1</code>. This will either write the memory behind <code class="language-plaintext highlighter-rouge">DMA_1</code> to the SWIOTLB behind <code class="language-plaintext highlighter-rouge">SWIOTLB_1</code>, or vice versa.</li>
  <li>As the SWIOTLB behind <code class="language-plaintext highlighter-rouge">SWIOTLB_1</code> are mapped to the other DMA buffers that I controlled, I can use the <code class="language-plaintext highlighter-rouge">DMA_BUF_IOCTL_SYNC</code> ioctl of these DMA buffers to either read data from these SWIOTLB or write data to them. This translates into arbitrary read/write of memory behind <code class="language-plaintext highlighter-rouge">DMA_1</code>.</li>
</ol>

<p>The following figure illustrates this with a simplified case of two DMA buffers.</p>

<p><img src="./One day short of a full chain_ Part 1 - Android Kernel arbitrary code execution _ GitHub Security Lab_files/dma_oob_sync.png" alt="figure"></p>

<h2 id="replacing-the-sg_table">Replacing the <code class="language-plaintext highlighter-rouge">sg_table</code></h2>

<p>So far, I planned an exploitation strategy based on the assumption that I already have control of the <code class="language-plaintext highlighter-rouge">scatterlist</code> <code class="language-plaintext highlighter-rouge">sgl</code> of the free’d <code class="language-plaintext highlighter-rouge">sg_table</code>. In order to actually gain control of it, I need to replace the free’d <code class="language-plaintext highlighter-rouge">sg_table</code> with a suitable object. This turns out to be the most complicated part of the exploit. While there are well-known kernel heap spraying techniques that allows us to replace a free’d object with controlled data (for example the <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html"><code class="language-plaintext highlighter-rouge">sendmsg</code></a> and <a href="https://duasynt.com/blog/linux-kernel-heap-spray"><code class="language-plaintext highlighter-rouge">setxattr</code></a>), they cannot be applied directly here as the <code class="language-plaintext highlighter-rouge">sgl</code> of the free’d <code class="language-plaintext highlighter-rouge">sg_table</code> here needs to be a valid pointer that points to controlled data. Without a way to leak a heap address, I’ll not be able to use these heap spraying techniques to construct a valid object. With this bug alone, there is almost no hope of getting an info leak at this stage. The other alternative is to look for other suitable objects to replace the <code class="language-plaintext highlighter-rouge">sg_table</code>. A CodeQL query can be used to help looking for suitable objects:</p>

<pre><code class="language-ql">from FunctionCall fc, Type t, Variable v, Field f, Type t2
where (fc.getTarget().hasName("kmalloc") or
       fc.getTarget().hasName("kzalloc") or
       fc.getTarget().hasName("kcalloc"))
      and
      exists(Assignment assign | assign.getRValue() = fc and
             assign.getLValue() = v.getAnAccess() and
             v.getType().(PointerType).refersToDirectly(t)) and
      t.getSize() &lt; 128 and t.fromSource() and
      f.getDeclaringType() = t and
      (f.getType().(PointerType).refersTo(t2) and t2.getSize() &lt;= 8) and
      f.getByteOffset() = 0
select fc, t, fc.getLocation()
</code></pre>

<p>In this query, I look for objects created via <code class="language-plaintext highlighter-rouge">kmalloc</code>, <code class="language-plaintext highlighter-rouge">kzalloc</code> or <code class="language-plaintext highlighter-rouge">kcalloc</code> that are of size smaller than 128 (same bucket as <code class="language-plaintext highlighter-rouge">sg_table</code>) and have a pointer field as the first field. However, I wasn’t able to find a suitable object, although <code class="language-plaintext highlighter-rouge">filename</code> allocated in <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/fs/namei.c#128"><code class="language-plaintext highlighter-rouge">getname_flags</code></a> came close:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">filename</span> <span class="o">*</span>
<span class="nf">getname_flags</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">empty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="nc">filename</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
    <span class="p">...</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">EMBEDDED_NAME_MAX</span><span class="p">))</span> <span class="p">{</span>
        <span class="p">...</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__putname</span><span class="p">(</span><span class="n">kname</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">result</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">kname</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">strncpy_from_user</span><span class="p">(</span><span class="n">kname</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">PATH_MAX</span><span class="p">);</span>
        <span class="p">...</span>

</code></pre></div></div>

<p>with <code class="language-plaintext highlighter-rouge">name</code> points to a user controlled string and can be reached using, for example, the <code class="language-plaintext highlighter-rouge">mknod</code> syscall. However, not being able to use null character turns out to be too much of a restriction here.</p>

<h3 id="just-in-time-object-replacement">Just-in-time object replacement</h3>

<p>Let’s take a look at how the free’d <code class="language-plaintext highlighter-rouge">sg_table</code> is used, say, in <code class="language-plaintext highlighter-rouge">__ion_dma_buf_begin_cpu_access</code>, it seems that at some point in the execution, the <code class="language-plaintext highlighter-rouge">sgl</code> field is taken from the <code class="language-plaintext highlighter-rouge">sgl_table</code>, and the <code class="language-plaintext highlighter-rouge">sgl_table</code> itself will no longer be used, but only the cached pointer value of <code class="language-plaintext highlighter-rouge">sgl</code> is used:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">__ion_dma_buf_begin_cpu_access</span><span class="p">(</span><span class="k">struct</span> <span class="nc">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">,</span>
					  <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
					  <span class="kt">bool</span> <span class="n">sync_only_mapped</span><span class="p">)</span>
<span class="p">{</span>
    
		<span class="k">if</span> <span class="p">(</span><span class="n">sync_only_mapped</span><span class="p">)</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">ion_sgl_sync_mapped</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">,</span>    <span class="c1">//&lt;------- `sgl` got passed, and `table` never used again</span>
						  <span class="n">a</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">nents</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">vmas</span><span class="p">,</span>
						  <span class="n">direction</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dma_sync_sg_for_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">,</span>
					    <span class="n">a</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">nents</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
</code></pre></div></div>

<p>While source code could be misleading as auto function inlining is common in kernel code (in fact <code class="language-plaintext highlighter-rouge">ion_sgl_sync_mapped</code> is inlined), the bottom line is that, at some point, the value of <code class="language-plaintext highlighter-rouge">sgl</code> will be cached in registry and the state of the original <code class="language-plaintext highlighter-rouge">sg_table</code> will not affect the code path anymore. So if I am able to first replace <code class="language-plaintext highlighter-rouge">a-&gt;table</code> with another <code class="language-plaintext highlighter-rouge">sg_table</code>, then deleting this new <code class="language-plaintext highlighter-rouge">sg_table</code> using <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/lib/scatterlist.c#250"><code class="language-plaintext highlighter-rouge">sg_free_table</code></a> will also cause the <code class="language-plaintext highlighter-rouge">sgl</code> to be deleted, but of course, there will be clean up logic that sets <code class="language-plaintext highlighter-rouge">sgl</code> to <code class="language-plaintext highlighter-rouge">NULL</code>. But what if I set up another thread to delete this new <code class="language-plaintext highlighter-rouge">sg_table</code> after <code class="language-plaintext highlighter-rouge">sgl</code> had already been cached in the registry? Then it won’t matter if <code class="language-plaintext highlighter-rouge">sgl</code> is set to <code class="language-plaintext highlighter-rouge">NULL</code>, because the value in the registry will still be pointing to the original <code class="language-plaintext highlighter-rouge">scatterlist</code>, and as this <code class="language-plaintext highlighter-rouge">scatterlist</code> is now free’d, this means I will now get a use-after-free of <code class="language-plaintext highlighter-rouge">sgl</code> directly in <code class="language-plaintext highlighter-rouge">ion_sgl_sync_mapped</code>. I can then use the <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html"><code class="language-plaintext highlighter-rouge">sendmsg</code></a> to replace it with controlled data. There is one major problem with this though, as the time between <code class="language-plaintext highlighter-rouge">sgl</code> being cached in registry and the time where it is used again is very short, it is normally not possible to fit the entire <code class="language-plaintext highlighter-rouge">sg_table</code> replacement sequence within such a short time frame, even if I race the slowest cpu core against the fastest.</p>

<p>To resolve this, I’ll use a technique by Jann Horn in <a href="https://static.sched.com/hosted_files/lsseu2019/04/LSSEU2019%20-%20Exploiting%20race%20conditions%20on%20Linux.pdf">Exploiting race conditions on [ancient] Linux</a>, which turns out to still work like a charm on modern Android.</p>

<p>To ensure that each task(thread or process) has a fair share of the cpu time, the linux kernel scheduler can interrupt a running task and put it on hold, so that another task can be run. This kind of interruption and stopping of a task is called preemption (where the interrupted task is preempted). A task can also put itself on hold to allow other task to run, such as when it is waiting for some I/O input, or when it calls <code class="language-plaintext highlighter-rouge">sched_yield()</code>. In this case, we say that the task is voluntarily preempted. Preemption can happen inside syscalls such as ioctl calls as well, and on Android, tasks can be preempted except in some critical regions (e.g. holding a spinlock). This means that a thread running the <code class="language-plaintext highlighter-rouge">DMA_BUF_IOCTL_SYNC</code> ioctl call can be interrupted after the <code class="language-plaintext highlighter-rouge">sgl</code> field is cached in the registry and be put on hold. The default behavior, however, will not normally give us much control over when the preemption happens, nor how long the task is put on hold.</p>

<p>To gain better control in both these areas, cpu affinity and task priorities can be used. By default, a task is run with the priority <code class="language-plaintext highlighter-rouge">SCHED_NORMAL</code>, but a lower priority <code class="language-plaintext highlighter-rouge">SCHED_IDLE</code>, can also be set using the <code class="language-plaintext highlighter-rouge">sched_setscheduler</code> call (or <code class="language-plaintext highlighter-rouge">pthread_setschedparam</code> for threads). Furthermore, it can also be pinned to a cpu with <code class="language-plaintext highlighter-rouge">sched_setaffinity</code>, which would only allow it to run on a specific cpu. By pinning two tasks, one with <code class="language-plaintext highlighter-rouge">SCHED_NORMAL</code> priority and the other with <code class="language-plaintext highlighter-rouge">SCHED_IDLE</code> priority to the same cpu, it is possible to control the timing of the preemption as follows.</p>

<ol>
  <li>First have the <code class="language-plaintext highlighter-rouge">SCHED_NORMAL</code> task perform a syscall that would cause it to pause and wait. For example, it can read from a pipe with no data coming in from the other end, then it would wait for more data and voluntarily preempt itself, so that the <code class="language-plaintext highlighter-rouge">SCHED_IDLE</code> task can run;</li>
  <li>As the <code class="language-plaintext highlighter-rouge">SCHED_IDLE</code> task is running, send some data to the pipe that the <code class="language-plaintext highlighter-rouge">SCHED_NORMAL</code> task had been waiting on. This will wake up the <code class="language-plaintext highlighter-rouge">SCHED_NORMAL</code> task and cause it to preempt the <code class="language-plaintext highlighter-rouge">SCHED_IDLE</code> task, and because of the task priority, the <code class="language-plaintext highlighter-rouge">SCHED_IDLE</code> task will be preempted and put on hold.</li>
  <li>The <code class="language-plaintext highlighter-rouge">SCHED_NORMAL</code> task can then run a busy loop to keep the <code class="language-plaintext highlighter-rouge">SCHED_IDLE</code> task from waking up.</li>
</ol>

<p>In our case, the object replacement sequence goes as follows:</p>

<ol>
  <li>Obtain a free’d <code class="language-plaintext highlighter-rouge">sg_table</code> in a DMA buffer using the method in the section <a href="https://securitylab.github.com/research/one_day_short_of_a_fullchain_android/#trigger">Getting a free’d object with a fake out-of-memory error</a>.</li>
  <li>First replace this free’d <code class="language-plaintext highlighter-rouge">sg_table</code> with another one that I can free easily, for example, making another call to <code class="language-plaintext highlighter-rouge">IOCTL_KGSL_GPUOBJ_IMPORT</code> will give me a handle to a <code class="language-plaintext highlighter-rouge">kgsl_mem_entry</code> object, which allocates and owns a <code class="language-plaintext highlighter-rouge">sg_table</code>. Making this call immediately after step one will ensure that the newly created <code class="language-plaintext highlighter-rouge">sg_table</code> replaces the one that was free’d in step one. To free this new <code class="language-plaintext highlighter-rouge">sg_table</code>, I can call <code class="language-plaintext highlighter-rouge">IOCTL_KGSL_GPUMEM_FREE_ID</code> with the handle of the <code class="language-plaintext highlighter-rouge">kgsl_mem_entry</code>, which will free the <code class="language-plaintext highlighter-rouge">kgsl_mem_entry</code> and in turn frees the <code class="language-plaintext highlighter-rouge">sg_table</code>. In practice, a little bit more heap manipulation is needed as <code class="language-plaintext highlighter-rouge">IOCTL_KGSL_GPUOBJ_IMPORT</code> will allocate another object of similar size before allocating a <code class="language-plaintext highlighter-rouge">sg_table</code>.</li>
  <li>Set up a <code class="language-plaintext highlighter-rouge">SCHED_NORMAL</code> task on, say, <code class="language-plaintext highlighter-rouge">cpu_1</code> that is listening to an empty pipe.</li>
  <li>Set up a <code class="language-plaintext highlighter-rouge">SCHED_IDLE</code> task on the same cpu and have it wait until I signal it to run <code class="language-plaintext highlighter-rouge">DMA_BUF_IOCTL_SYNC</code> on the DMA buffer that contains the <code class="language-plaintext highlighter-rouge">sg_table</code> in step two.</li>
  <li>The main task signals the <code class="language-plaintext highlighter-rouge">SCHED_IDLE</code> task to run <code class="language-plaintext highlighter-rouge">DMA_BUF_IOCTL_SYNC</code>.</li>
  <li>The main task waits a suitable amount of time until <code class="language-plaintext highlighter-rouge">sgl</code> is cached in registry, then send data to the pipe that the <code class="language-plaintext highlighter-rouge">SCHED_NORMAL</code> task is waiting on.</li>
  <li>Once it receives data, the <code class="language-plaintext highlighter-rouge">SCHED_NORMAL</code> task goes into a busy loop to keep the <code class="language-plaintext highlighter-rouge">DMA_BUF_IOCTL_SYNC</code> task from continuing.</li>
  <li>The main task then calls <code class="language-plaintext highlighter-rouge">IOCTL_KGSL_GPUMEM_FREE_ID</code> to free up the <code class="language-plaintext highlighter-rouge">sg_table</code>, which will also free the object pointed to by <code class="language-plaintext highlighter-rouge">sgl</code> that is now cached in the registry. The main task then replaces this object by controlled data using <code class="language-plaintext highlighter-rouge">sendmsg</code> heap spraying. This gives control of both <code class="language-plaintext highlighter-rouge">dma_address</code> and <code class="language-plaintext highlighter-rouge">dma_length</code> in <code class="language-plaintext highlighter-rouge">sgl</code>, which are used as arguments to <code class="language-plaintext highlighter-rouge">memcpy</code>.</li>
  <li>The main task signals the <code class="language-plaintext highlighter-rouge">SCHED_NORMAL</code> task on <code class="language-plaintext highlighter-rouge">cpu_1</code> to stop so that the <code class="language-plaintext highlighter-rouge">DMA_BUF_IOCTL_SYNC</code> task can resume.</li>
</ol>

<p>The following figure illustrates what happens in an ideal world.</p>

<p><img src="./One day short of a full chain_ Part 1 - Android Kernel arbitrary code execution _ GitHub Security Lab_files/swap.png" alt="figure"></p>

<p>The following figure illustrates what happens in the real world.</p>

<p><img src="./One day short of a full chain_ Part 1 - Android Kernel arbitrary code execution _ GitHub Security Lab_files/castlevania.png" alt="figure"></p>

<p>Crazy as it seems, the race can actually be won almost every time, and the same parameters that control the timing would even work on both the Galaxy A71 and Pixel 4. Even when the race failed, it does not result in a crash. It can, however, crash, if the <code class="language-plaintext highlighter-rouge">SCHED_IDLE</code> task resumes too quickly. For some reason, I only managed to hold that task for about 10-20ms, and sometimes this is not long enough for the object replacement to complete.</p>

<h2 id="the-ion-heap">The ion heap</h2>

<p>Now that I’m able to replace the <code class="language-plaintext highlighter-rouge">scatterlist</code> with controlled data and make use of the read/write primitives in the section <a href="https://securitylab.github.com/research/one_day_short_of_a_fullchain_android/#allocating_swiotlb">Allocating a SWIOTLB</a>, it is time to think about what data I can place behind the DMA buffers.</p>

<p>To allocate DMA buffers, I need to use the ion allocator, which will allocate from the ion heap. There are different types of ion heaps, but not all of them are suitable, because I need one that would allocate buffers with addresses greater than 32 bit. The locations of various ion heap can be seen from the kernel log during a boot, the following is from Galaxy A71:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[    0.626370] ION heap system created
[    0.626497] ION heap qsecom created at 0x000000009e400000 with size 2400000
[    0.626515] ION heap qsecom_ta created at 0x00000000fac00000 with size 2000000
[    0.626524] ION heap spss created at 0x00000000f4800000 with size 800000
[    0.626531] ION heap secure_display created at 0x00000000f5000000 with size 5c00000
[    0.631648] platform soc:qcom,ion:qcom,ion-heap@14: ion_secure_carveout: creating heap@0xa4000000, size 0xc00000
[    0.631655] ION heap secure_carveout created
[    0.631669] ION heap secure_heap created
[    0.634265] cleancache enabled for rbin cleancache
[    0.634512] ION heap camera_preview created at 0x00000000c2000000 with size 25800000
</code></pre></div></div>

<p>As we can see, some ion heap are created at fixed locations with fixed sizes. The addresses of these heaps are also smaller than 32 bits. However, there are other ion heaps, such as the system heap, that does not have a fixed address. These are the heaps that have addresses higher than 32 bits. For the exploit, I’ll use the system heap.</p>

<p>DMA buffers allocated on the system heap is allocated via the <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/drivers/staging/android/ion/ion_system_heap.c#265"><code class="language-plaintext highlighter-rouge">ion_system_heap_allocate</code></a> function call. It’ll first try to allocate a buffer from a preallocated <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/drivers/staging/android/ion/ion_system_heap.c#64">memory pool</a>. If the pool is full, then it’ll allocate more pages using <code class="language-plaintext highlighter-rouge">alloc_pages</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">ion_page_pool_alloc_pages</span><span class="p">(</span><span class="k">struct</span> <span class="nc">ion_page_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="nc">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">);</span>
    <span class="p">...</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>and recycle the pages back to the pool after the buffer is freed.</p>

<p>This later case is more interesting because if the memory is allocated from the initial pool, then any out-of-bounds read/write are likely to just be reading and writing other ion buffers, which is only going to be user space data. So let’s take a look at <code class="language-plaintext highlighter-rouge">alloc_pages</code>.</p>

<p>The function <code class="language-plaintext highlighter-rouge">alloc_pages</code> allocates memory with page granularity using the <a href="https://www.kernel.org/doc/gorman/html/understand/understand009.html">buddy allocator</a>. When using <code class="language-plaintext highlighter-rouge">alloc_pages</code>, the second parameter <code class="language-plaintext highlighter-rouge">order</code> specifies the size of the requested memory and the allocator will return a memory block consisting of <code class="language-plaintext highlighter-rouge">2^order</code> contiguous pages. In order to exploit overflow of memory allocated by the buddy allocator, (a DMA buffer from the system heap), I’ll use the results from <a href="https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html">Exploiting the Linux kernel via packet sockets</a> by Andrey Konovalov. The key point is that, while objects allocated from <code class="language-plaintext highlighter-rouge">kmalloc</code> and co. (i.e. <code class="language-plaintext highlighter-rouge">kmalloc</code>, <code class="language-plaintext highlighter-rouge">kzalloc</code> and <code class="language-plaintext highlighter-rouge">kcalloc</code>) are allocated via the <a href="https://www.kernel.org/doc/gorman/html/understand/understand011.html">slab allocator</a>, which uses preallocated memory blocks (slabs) to allocate small objects, when the slabs run out, the slab allocator will use the buddy allocator to allocate a new slab. The output of <code class="language-plaintext highlighter-rouge">proc/slabinfo</code> gives an indication of the size of slabs in pages.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kmalloc-8192        1036   1036   8192    4    8 : tunables    0    0    0 : slabdata    262    262      0
...
kmalloc-128       378675 384000    128   32    1 : tunables    0    0    0 : slabdata  12000  12000      0
</code></pre></div></div>
<p>In the above, the <code class="language-plaintext highlighter-rouge">5th</code> column indicates the size of the slabs in pages. So for example, if the size 8192 bucket runs out, the slab allocator will ask the buddy allocator for a memory block of 8 pages, which is order 3 (<code class="language-plaintext highlighter-rouge">2^3=8</code>), to use as a new slab. So by exhausting the slab, I can cause a new slab to be allocated in the same region as the ion system heap, which could allow me to over read/write kernel objects allocated via <code class="language-plaintext highlighter-rouge">kmalloc</code> and co.</p>

<h3 id="manipulating-the-buddy-allocator-heap">Manipulating the buddy allocator heap</h3>

<p>As mentioned in <a href="https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html">Exploiting the Linux kernel via packet sockets</a>, for each order, the buddy allocator maintains a freelist and use it to allocate memory of the appropriate order. When a certain order (<code class="language-plaintext highlighter-rouge">n</code>) runs out of memory, it’ll try to look for free blocks in the next order up, split it in half and add it to the freelist in the requested order. If the next order is also full, it’ll try to find space in the next higher up order, and so on. So by keep allocating pages of order <code class="language-plaintext highlighter-rouge">2^n</code>, eventually the freelist will be exhausted and larger blocks will be broken up, which means that consecutive allocations will be adjacent to each other.</p>

<p>In fact, after some experimentation on Pixel 4, it seems that after allocating a certain amount of DMA buffers from the ion system heap, the allocation will follow a very predicatble pattern.</p>

<ol>
  <li>The addresses of the allocated buffers are grouped in blocks of 4MB, which corresponds to order 10, the highest order block on Android.</li>
  <li>Within each block, a new allocations will be adjacent to the previous one, with a higher address.</li>
  <li>When a 4MB block is filled, allocations will start in the beginning of the next block, which is right below the current 4MB block.</li>
</ol>

<p>The following figure illustrates this pattern.</p>

<p><img src="./One day short of a full chain_ Part 1 - Android Kernel arbitrary code execution _ GitHub Security Lab_files/ion_heap.png" alt="figure"></p>

<p>So by simply creating a large amount of DMA buffers in the ion system heap, the likelihood would be that the last allocated buffer will be allocated in front of a “hole” of free memory, and the next allocation from the buddy allocator is likely to be inside this hole, provided the requested number of pages fits in this hole.</p>

<p>The heap spraying strategy is then very simple. First allocate a sufficient amount of DMA buffers in the ion heap to cause larger blocks to break up, then allocate a large amount of objects using <code class="language-plaintext highlighter-rouge">kmalloc</code> and co. to cause a new slab to be created. This new slab is then likely to fall into the hole behind the last allocated DMA buffer. Using the use-after-free to overflow this buffer then allows me to gain arbitrary read/write of the newly created slab.</p>

<h2 id="defeating-kaslr-and-leaking-address-to-dma-buffer">Defeating KASLR and leaking address to DMA buffer</h2>

<p>Initially, I was experimenting with the <code class="language-plaintext highlighter-rouge">binder_open</code> call, as it is easy to reach (just do <code class="language-plaintext highlighter-rouge">open("/dev/binder")</code>) and will allocate a <code class="language-plaintext highlighter-rouge">binder_proc</code> struct:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">binder_open</span><span class="p">(</span><span class="k">struct</span> <span class="nc">inode</span> <span class="o">*</span><span class="n">nodp</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
	<span class="n">proc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">proc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</code></pre></div></div>

<p>which is of size 560 and will persist until the <code class="language-plaintext highlighter-rouge">/dev/binder</code> file is closed. So it should be relatively easy to exhaust the <code class="language-plaintext highlighter-rouge">kmalloc-1024</code> slab with this. However, after dumping the results of the out-of-bounds read, I noticed that a recurring memory pattern:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00011020: 68b2 8e68 c1ff ffff 08af 5109 80ff ffff  h..h......Q.....
00011030: 0000 0000 0000 0000 0100 0000 0000 0000  ................
00011040: 0000 0200 1d00 0000 0000 0000 0000 0000  ................
...
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">08af 5109 80ff ffff</code> in the second part of the first line looks like an address that corresponds to kernel code. Indeed, it is the address of <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/drivers/android/binder.c#6040"><code class="language-plaintext highlighter-rouge">binder_fops</code></a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># echo 0 &gt; /proc/sys/kernel/kptr_restrict                                                                                                                                                
# cat /proc/kallsyms | grep ffffff800951af08                                                                                                                                                 
ffffff800951af08 r binder_fops
</code></pre></div></div>

<p>So looks like these are <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/include/linux/fs.h#864"><code class="language-plaintext highlighter-rouge">file struct</code></a> of the binder files that I opened and what I’m seeing here is the field <code class="language-plaintext highlighter-rouge">f_ops</code> that points to the <code class="language-plaintext highlighter-rouge">binder_fops</code>. Moreover, the 32 bytes after <code class="language-plaintext highlighter-rouge">f_ops</code> are the same for every file struct of the same type, which offers a pattern to identify these files. So by reading the memory behind the DMA buffer and looking for this pattern, I can locate the <code class="language-plaintext highlighter-rouge">file</code> structs that belong to the binder devices that I opened.</p>

<p>Moreover, the <code class="language-plaintext highlighter-rouge">file</code> struct contains a <code class="language-plaintext highlighter-rouge">mutex</code> <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/include/linux/fs.h#875"><code class="language-plaintext highlighter-rouge">f_pos_lock</code></a>, which contains a field <code class="language-plaintext highlighter-rouge">wait_list</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">mutex</span> <span class="p">{</span>
	<span class="n">atomic_long_t</span>		<span class="n">owner</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">wait_lock</span><span class="p">;</span>
    <span class="p">...</span>
	<span class="k">struct</span> <span class="nc">list_head</span>	<span class="n">wait_list</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>
<p>which is a standard doubly linked list in linux:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">list_head</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="nc">list_head</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>When <code class="language-plaintext highlighter-rouge">wait_list</code> is initialized, the head of the list will just be a pointer to itself, which means that by reading the <code class="language-plaintext highlighter-rouge">next</code> or <code class="language-plaintext highlighter-rouge">prev</code> pointer of the <code class="language-plaintext highlighter-rouge">wait_list</code>, I can obtain the address of the <code class="language-plaintext highlighter-rouge">file</code> struct itself. This will then allow me to work out the address of the DMA buffer which I can control because the offset between the <code class="language-plaintext highlighter-rouge">file</code> struct and the buffer is known. (By looking at its offset in the data that I dumped, in this example, the offset is <code class="language-plaintext highlighter-rouge">0x11020</code>).</p>

<p>By using the address of <code class="language-plaintext highlighter-rouge">binder_fops</code>, it is easy to work out the KASLR slide and defeat KASLR, and by knowing the address of a controlled DMA buffer, I can use it to store a fake <a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-coral-4.14-android10/include/linux/fs.h#1711"><code class="language-plaintext highlighter-rouge">file_operations</code></a> (“vtable” of <code class="language-plaintext highlighter-rouge">file</code> struct) and overwrite <code class="language-plaintext highlighter-rouge">f_ops</code> of my <code class="language-plaintext highlighter-rouge">file</code> struct to point to it. The path to arbitrary code execution is now clear.</p>

<ol>
  <li>Use the out-of-bounds read primitive gained from the use-after-free to dump memory behind a DMA buffer that I controlled.</li>
  <li>Search for binder <code class="language-plaintext highlighter-rouge">file</code> structs within the memory using the predictable pattern and get the offset of the <code class="language-plaintext highlighter-rouge">file</code> struct.</li>
  <li>Use the identified <code class="language-plaintext highlighter-rouge">file</code> struct to obtain the address of <code class="language-plaintext highlighter-rouge">binder_fops</code> and the address of the <code class="language-plaintext highlighter-rouge">file</code> struct itself from the <code class="language-plaintext highlighter-rouge">wait_list</code> field.</li>
  <li>Use the <code class="language-plaintext highlighter-rouge">binder_fops</code> address to work out the KASLR slide and use the address of the <code class="language-plaintext highlighter-rouge">file</code> struct, together with the offset identified in step two to work out the address of the DMA buffer.</li>
  <li>Use the out-of-bounds write primitive gained from the use-after-free to overwrite the <code class="language-plaintext highlighter-rouge">f_ops</code> pointer to the file that corresponds to this <code class="language-plaintext highlighter-rouge">file</code> struct (which I owned), so that it now points to a fake <code class="language-plaintext highlighter-rouge">file_operation</code> struct stored in my DMA buffer. Using file operations on this file will then execute functions of my choice.</li>
</ol>

<p>Since there is nothing special about <code class="language-plaintext highlighter-rouge">binder</code> files, in the actual exploit, I used <code class="language-plaintext highlighter-rouge">/dev/null</code> instead of <code class="language-plaintext highlighter-rouge">/dev/binder</code>, but the idea is the same. I’ll now explain how to do the last step in the above to gain arbitrary kernel code execution.</p>

<h2 id="getting-arbitrary-kernel-code-execution">Getting arbitrary kernel code execution</h2>

<p>To complete the exploit, I’ll use “the ultimate ROP gadget” that was used in <a href="https://googleprojectzero.blogspot.com/2020/12/an-ios-hacker-tries-android.html">An iOS hacker tries Android</a> of Brandon Azad (and I in fact stole a large chunk of code from his exploit). As explained in that post, the function <code class="language-plaintext highlighter-rouge">__bpf_prog_run32</code> can be used to invoke eBPF bytecode supplied through the second argument:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__bpf_prog_run32</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">bpf_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">)</span>
</code></pre></div></div>

<p>to invoke eBPF bytecode, I need to set the second argument to point to the location of the bytecode. As I already know the address of a DMA buffer that I control, I can simply store the bytecode in the buffer and use its address as the second argument to this call. This would allow us to perform arbitrary memory load/store and call arbitrary kernel functions with up to five arguments and a 64 bit return value.</p>

<p>There is, however one more detail that needs taking care of. Samsung devices implement an extra protection mechanism called the Realtime Kernel Protection (RKP), which is part of <a href="https://www.samsungknox.com/en">Samsung KNOX</a>. Research on the topic is widely available, for example, <a href="https://googleprojectzero.blogspot.com/2017/02/lifting-hyper-visor-bypassing-samsungs.html">Lifting the (Hyper) Visor: Bypassing Samsung’s Real-Time Kernel Protection</a> by Gal Beniamini and <a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Shen-Defeating-Samsung-KNOX-With-Zero-Privilege.pdf">Defeating Samsung KNOX with zero privilege</a> by Di Shen.</p>

<p>For the purpose of our exploit, the more recent <a href="https://blog.longterm.io/samsung_rkp.html#description">A Samsung RKP Compendium</a> by Alexandre Adamski and <a href="http://www.powerofcommunity.net/poc2019/x82.pdf">KNOX Kernel Mitigation Byapsses</a> by Dong-Hoon You are relevant. In particular, A Samsung RKP Compendium offers a thorough and comprehensive description of various aspects of RKP.</p>

<p>Without going into much details about RKP, the two parts that are relevant to our situation are:</p>

<ol>
  <li>RKP implements a form of CFI (control flow integrity) check to make sure that all function calls can only jump to the beginning of another function (JOPP, jump-oriented programming prevention).</li>
  <li>RKP protects important data structure such as the credentials of a process so they are effectively read only.</li>
</ol>

<p>Point one means that even though I can hijack the <code class="language-plaintext highlighter-rouge">f_ops</code> pointer of my file struct, I cannot jump to an arbitrary location. However, it is still possible to jump to the start of any function. The practical implication is that while I can control the function that I call, I may not be able to control call arguments. Point two means that the usual shortcut of overwriting credentials of my own process to that of a root process would not work. There are other post-exploitation techniques that can be used to overcome this, which I’ll briefly explain later, but for the exploit of this post, I’ll just stop short at arbitrary kernel code execution.</p>

<p>In our situation, point one is actually not a big obstacle. The fact that I am able to hijack the <code class="language-plaintext highlighter-rouge">file_operations</code>, which contains a whole array of possible calls that are thin wrappers of various syscalls means that it is likely to find a file operation with a 64 bit second argument which I can control by making the appropriate syscall. In fact, I don’t even need to look that far. The first operation, <code class="language-plaintext highlighter-rouge">llseek</code> fits the bill:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">file_operations</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="nc">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="p">(</span><span class="o">*</span><span class="n">llseek</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="p">...</span>
</code></pre></div></div>

<p>This function takes a 64 bit integer, <code class="language-plaintext highlighter-rouge">loff_t</code> as the second argument and can be invoked by calling the <a href="https://linux.die.net/man/3/lseek64"><code class="language-plaintext highlighter-rouge">lseek64</code></a> syscall:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">off_t</span> <span class="nf">lseek64</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whence</span><span class="p">);</span>
</code></pre></div></div>

<p>where <code class="language-plaintext highlighter-rouge">offset</code> translates directly into <code class="language-plaintext highlighter-rouge">loff_t</code> in <code class="language-plaintext highlighter-rouge">llseek</code>. So by overwriting the <code class="language-plaintext highlighter-rouge">f_ops</code> pointer of my file to have its <code class="language-plaintext highlighter-rouge">llseek</code> field point to <code class="language-plaintext highlighter-rouge">__bpf_prog_run32</code>, I can invoke any eBPF program of my choice any time I call <code class="language-plaintext highlighter-rouge">lseek64</code>, without even the need to trigger the bug again. This gives me arbitrary kernel memory read/write and code execution.</p>

<p>As explained before, because of RKP, it is not possible to simply overwrite process credentials to become root even with arbitrary kernel code execution. However, as pointed out in <a href="https://googleprojectzero.blogspot.com/2020/02/mitigations-are-attack-surface-too.html">Mitigations are attack surface, too</a> by Jann Horn, once we have arbitrary kernel memory read and write, all the userspace data and processes are essentially under control and there are many ways to gain control over privileged user processes, such as those with system privilege to effectively gain system privileges. Apart from the concrete technique mentioned in that post for accessing sensitive data, another concrete technique mentioned in <a href="https://github.com/vngkv123/articles/blob/main/Galaxy&#39;s%20Meltdown%20-%20Exploiting%20SVE-2020-18610.md#getting-root-privilege">Galaxy’s Meltdown - Exploiting SVE-2020-18610</a> is to overwrite the kernel stack of privileged processes to gain arbitrary kernel code execution as a privileged process. In short, there are many post exploitation techniques available at this stage to effectively root the phone.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In this post I looked at a use-after-free bug in the Qualcomm kgsl driver. The bug was a result of a mismatch between the user supplied memory type and the actual type of the memory object created by the kernel, which led to incorrect clean up logic being applied when an error happens. In this case, two common software errors, the ambiguity in the role of a type, and incorrect handling of errors, played together to cause a serious security issue that can be exploited to gain arbitrary kernel code execution from a third-party app.</p>

<p>While great progress has been made in sandboxing the userspace services in Android, the kernel, in particular vendor drivers, remain a dangerous attack surface. A successful exploit of a memory corruption issue in a kernel driver can escalate to gain the full power of the kernel, which often result in a much shorter exploit bug chain.</p>

<p>The full exploit can be found <a href="https://github.com/github/securitylab/tree/main/SecurityExploits/Android/Qualcomm/CVE-2020-11239">here</a> with some set up notes.</p>

<p>Next week I’ll be going through the exploit of <a href="https://bugs.chromium.org/p/chromium/issues/detail?1125614">Chrome issue 1125614</a> (<a href="https://securitylab.github.com/advisories/GHSL-2020-165-chrome/">GHSL-2020-165</a>) to escape the Chrome sandbox from a beta version of Chrome.</p>

    </main>
  </div>



  <footer class="sc-dVhcbM cBEMHy footer mt-6">
  <div class="container-xl p-responsive">
    <div class="d-flex flex-wrap py-5 mb-5">
      <div class="col-12 col-lg-4 mb-5">
        <a href="https://github.com/" data-ga-click="Footer, go to home, text:home" class="text-gray-dark" aria-label="Go to GitHub homepage">
          <svg height="30" class="octicon octicon-logo-github" viewBox="0 0 45 16" version="1.1" width="84" aria-hidden="true">
            <path fill-rule="evenodd" d="M18.53 12.03h-.02c.009 0 .015.01.024.011h.006l-.01-.01zm.004.011c-.093.001-.327.05-.574.05-.78 0-1.05-.36-1.05-.83V8.13h1.59c.09 0 .16-.08.16-.19v-1.7c0-.09-.08-.17-.16-.17h-1.59V3.96c0-.08-.05-.13-.14-.13h-2.16c-.09 0-.14.05-.14.13v2.17s-1.09.27-1.16.28c-.08.02-.13.09-.13.17v1.36c0 .11.08.19.17.19h1.11v3.28c0 2.44 1.7 2.69 2.86 2.69.53 0 1.17-.17 1.27-.22.06-.02.09-.09.09-.16v-1.5a.177.177 0 00-.146-.18zM42.23 9.84c0-1.81-.73-2.05-1.5-1.97-.6.04-1.08.34-1.08.34v3.52s.49.34 1.22.36c1.03.03 1.36-.34 1.36-2.25zm2.43-.16c0 3.43-1.11 4.41-3.05 4.41-1.64 0-2.52-.83-2.52-.83s-.04.46-.09.52c-.03.06-.08.08-.14.08h-1.48c-.1 0-.19-.08-.19-.17l.02-11.11c0-.09.08-.17.17-.17h2.13c.09 0 .17.08.17.17v3.77s.82-.53 2.02-.53l-.01-.02c1.2 0 2.97.45 2.97 3.88zm-8.72-3.61h-2.1c-.11 0-.17.08-.17.19v5.44s-.55.39-1.3.39-.97-.34-.97-1.09V6.25c0-.09-.08-.17-.17-.17h-2.14c-.09 0-.17.08-.17.17v5.11c0 2.2 1.23 2.75 2.92 2.75 1.39 0 2.52-.77 2.52-.77s.05.39.08.45c.02.05.09.09.16.09h1.34c.11 0 .17-.08.17-.17l.02-7.47c0-.09-.08-.17-.19-.17zm-23.7-.01h-2.13c-.09 0-.17.09-.17.2v7.34c0 .2.13.27.3.27h1.92c.2 0 .25-.09.25-.27V6.23c0-.09-.08-.17-.17-.17zm-1.05-3.38c-.77 0-1.38.61-1.38 1.38 0 .77.61 1.38 1.38 1.38.75 0 1.36-.61 1.36-1.38 0-.77-.61-1.38-1.36-1.38zm16.49-.25h-2.11c-.09 0-.17.08-.17.17v4.09h-3.31V2.6c0-.09-.08-.17-.17-.17h-2.13c-.09 0-.17.08-.17.17v11.11c0 .09.09.17.17.17h2.13c.09 0 .17-.08.17-.17V8.96h3.31l-.02 4.75c0 .09.08.17.17.17h2.13c.09 0 .17-.08.17-.17V2.6c0-.09-.08-.17-.17-.17zM8.81 7.35v5.74c0 .04-.01.11-.06.13 0 0-1.25.89-3.31.89-2.49 0-5.44-.78-5.44-5.92S2.58 1.99 5.1 2c2.18 0 3.06.49 3.2.58.04.05.06.09.06.14L7.94 4.5c0 .09-.09.2-.2.17-.36-.11-.9-.33-2.17-.33-1.47 0-3.05.42-3.05 3.73s1.5 3.7 2.58 3.7c.92 0 1.25-.11 1.25-.11v-2.3H4.88c-.11 0-.19-.08-.19-.17V7.35c0-.09.08-.17.19-.17h3.74c.11 0 .19.08.19.17z"></path>
          </svg>
        </a>
      </div>
      <div class="col-6 col-sm-3 col-lg-2 mb-6 mb-md-2 pr-3 pr-lg-0 pl-lg-4">
        <h2 class="h5 mb-3 text-mono text-gray-light text-normal">Product</h2>
        <ul class="list-style-none text-gray f5">
          <li class="lh-condensed mb-3"><a href="https://github.com/features" data-ga-click="Footer, go to features, text:features" class="link-gray">Features</a></li>
          <li class="lh-condensed mb-3"><a href="https://github.com/security" data-ga-click="Footer, go to security, text:security" class="link-gray">Security</a></li>
          <li class="lh-condensed mb-3"><a href="https://github.com/enterprise" data-ga-click="Footer, go to enterprise, text:enterprise" class="link-gray">Enterprise</a></li>
          <li class="lh-condensed mb-3"><a href="https://github.com/customer-stories?type=enterprise" data-ga-click="Footer, go to customer stories, text:customer stories" class="link-gray">Customer stories</a></li>
          <li class="lh-condensed mb-3"><a href="https://github.com/pricing" data-ga-click="Footer, go to pricing, text:pricing" class="link-gray">Pricing</a></li>
          <li class="lh-condensed mb-3"><a href="https://resources.github.com/" data-ga-click="Footer, go to resources, text:resources" class="link-gray">Resources</a></li>
        </ul>
      </div>
      <div class="col-6 col-sm-3 col-lg-2 mb-6 mb-md-2 pr-3 pr-md-0 pl-md-4">
        <h2 class="h5 mb-3 text-mono text-gray-light text-normal">Platform</h2>
        <ul class="list-style-none f5">
          <li class="lh-condensed mb-3"><a href="https://developer.github.com/" data-ga-click="Footer, go to api, text:api" class="link-gray">Developer API</a></li>
          <li class="lh-condensed mb-3"><a href="http://partner.github.com/" data-ga-click="Footer, go to partner, text:partner" class="link-gray ">Partners</a></li>
          <li class="lh-condensed mb-3"><a href="https://atom.io/" data-ga-click="Footer, go to atom, text:atom" class="link-gray ">Atom</a></li>
          <li class="lh-condensed mb-3"><a href="http://electron.atom.io/" data-ga-click="Footer, go to electron, text:electron" class="link-gray ">Electron</a></li>
          <li class="lh-condensed mb-3"><a href="https://desktop.github.com/" data-ga-click="Footer, go to desktop, text:desktop" class="link-gray ">GitHub Desktop</a></li>
        </ul>
      </div>
      <div class="col-6 col-sm-3 col-lg-2 mb-6 mb-md-2 pr-3 pr-md-0 pl-md-4">
        <h2 class="h5 mb-3 text-mono text-gray-light text-normal">Support</h2>
        <ul class="list-style-none f5">
          <li class="lh-condensed mb-3"><a data-ga-click="Footer, go to help, text:docs" class="link-gray " href="https://docs.github.com/">Docs</a></li>
          <li class="lh-condensed mb-3"><a href="https://github.community/" data-ga-click="Footer, go to community, text:community" class="link-gray ">Community Forum</a></li>
          <li class="lh-condensed mb-3"><a href="https://services.github.com/" data-ga-click="Footer, go to professional services, text:professional services" class="link-gray ">Professional Services</a></li>
          <li class="lh-condensed mb-3"><a href="https://githubstatus.com/" data-ga-click="Footer, go to status, text:status" class="link-gray ">Status</a></li>
          <li class="lh-condensed mb-3"><a data-ga-click="Footer, go to contact, text:contact" class="link-gray " href="https://support.github.com/">Contact GitHub</a></li>
        </ul>
      </div>
      <div class="col-6 col-sm-3 col-lg-2 mb-6 mb-md-2 pr-3 pr-md-0 pl-md-4">
        <h2 class="h5 mb-3 text-mono text-gray-light text-normal">Company</h2>
        <ul class="list-style-none f5">
          <li class="lh-condensed mb-3"><a data-ga-click="Footer, go to about, text:about" class="link-gray " href="https://github.com/about">About</a></li>
          <li class="lh-condensed mb-3"><a href="https://github.blog/" data-ga-click="Footer, go to blog, text:blog" class="link-gray">Blog</a></li>
          <li class="lh-condensed mb-3"><a href="https://github.com/about/careers" data-ga-click="Footer, go to careers, text:careers" class="link-gray">Careers</a></li>
          <li class="lh-condensed mb-3"><a href="https://github.com/about/press" data-ga-click="Footer, go to press, text:press" class="link-gray">Press</a></li>
          <li class="lh-condensed mb-3"><a href="https://shop.github.com/" data-ga-click="Footer, go to shop, text:shop" class="link-gray">Shop</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="bg-gray-light">
    <div class="container-xl p-responsive f6 py-4 d-sm-flex flex-justify-between flex-row-reverse flex-items-center">
      <ul class="list-style-none d-flex flex-items-center mb-3 mb-sm-0 lh-condensed-ultra social-icons">
        <li class="mr-3">
          <a href="https://twitter.com/github" data-ga-click="Footer, go to Twitter, text:twitter" title="GitHub on Twitter">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 273.5 222.3" class="d-block" height="18">
              <path d="M273.5 26.3a109.77 109.77 0 0 1-32.2 8.8 56.07 56.07 0 0 0 24.7-31 113.39 113.39 0 0 1-35.7 13.6 56.1 56.1 0 0 0-97 38.4 54 54 0 0 0 1.5 12.8A159.68 159.68 0 0 1 19.1 10.3a56.12 56.12 0 0 0 17.4 74.9 56.06 56.06 0 0 1-25.4-7v.7a56.11 56.11 0 0 0 45 55 55.65 55.65 0 0 1-14.8 2 62.39 62.39 0 0 1-10.6-1 56.24 56.24 0 0 0 52.4 39 112.87 112.87 0 0 1-69.7 24 119 119 0 0 1-13.4-.8 158.83 158.83 0 0 0 86 25.2c103.2 0 159.6-85.5 159.6-159.6 0-2.4-.1-4.9-.2-7.3a114.25 114.25 0 0 0 28.1-29.1" fill="currentColor"></path>
            </svg>
          </a>
        </li>
        <li class="mr-3">
          <a href="https://www.facebook.com/GitHub" data-ga-click="Footer, go to Facebook, text:facebook" title="GitHub on Facebook">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.3 15.4" class="d-block" height="18">
              <path d="M14.5 0H.8a.88.88 0 0 0-.8.9v13.6a.88.88 0 0 0 .8.9h7.3v-6h-2V7.1h2V5.4a2.87 2.87 0 0 1 2.5-3.1h.5a10.87 10.87 0 0 1 1.8.1v2.1h-1.3c-1 0-1.1.5-1.1 1.1v1.5h2.3l-.3 2.3h-2v5.9h3.9a.88.88 0 0 0 .9-.8V.8a.86.86 0 0 0-.8-.8z" fill="currentColor"></path>
            </svg>
          </a>
        </li>
        <li class="mr-3">
          <a href="https://www.youtube.com/github" data-ga-click="Footer, go to YouTube, text:youtube" title="GitHub on YouTube">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.17 13.6" class="d-block" height="16">
              <path d="M18.77 2.13A2.4 2.4 0 0 0 17.09.42C15.59 0 9.58 0 9.58 0a57.55 57.55 0 0 0-7.5.4A2.49 2.49 0 0 0 .39 2.13 26.27 26.27 0 0 0 0 6.8a26.15 26.15 0 0 0 .39 4.67 2.43 2.43 0 0 0 1.69 1.71c1.52.42 7.5.42 7.5.42a57.69 57.69 0 0 0 7.51-.4 2.4 2.4 0 0 0 1.68-1.71 25.63 25.63 0 0 0 .4-4.67 24 24 0 0 0-.4-4.69zM7.67 9.71V3.89l5 2.91z" fill="currentColor"></path>
            </svg>
          </a>
        </li>
        <li class="mr-3 flex-self-start">
          <a href="https://www.linkedin.com/company/github" data-ga-click="Footer, go to Linkedin, text:linkedin" title="GitHub on Linkedin">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19 18" class="d-block" height="18">
              <path d="M3.94 2A2 2 0 1 1 2 0a2 2 0 0 1 1.94 2zM4 5.48H0V18h4zm6.32 0H6.34V18h3.94v-6.57c0-3.66 4.77-4 4.77 0V18H19v-7.93c0-6.17-7.06-5.94-8.72-2.91z" fill="currentColor"></path>
            </svg>
          </a>
        </li>
        <li>
          <a href="https://github.com/github" data-ga-click="Footer, go to github&#39;s org, text:github" title="GitHub&#39;s organization">
            <svg height="20" class="octicon octicon-mark-github d-block" viewBox="0 0 16 16" version="1.1" width="20" aria-hidden="true">
              <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
            </svg>
          </a>
        </li>
      </ul>
      <ul class="list-style-none d-flex text-gray">
        <li class="mr-3">
          © <!-- -->2021<!-- --> GitHub, Inc.
        </li>
        <li class="mr-3"><a href="https://docs.github.com/en/github/site-policy/github-terms-of-service" data-ga-click="Footer, go to terms, text:terms" class="link-gray">Terms</a></li>
        <li class="mr-3"><a href="https://docs.github.com/en/github/site-policy/github-privacy-statement" data-ga-click="Footer, go to privacy, text:privacy" class="link-gray">Privacy</a></li>
        <li><a href="https://securitylab.github.com/research/one_day_short_of_a_fullchain_android/#" class="link-gray">Cookie settings</a></li>
      </ul>
    </div>
  </div>
</footer>


  <!-- JAVASCRIPT -->
  <script src="./One day short of a full chain_ Part 1 - Android Kernel arbitrary code execution _ GitHub Security Lab_files/main.js.下載"></script>


</body></html>