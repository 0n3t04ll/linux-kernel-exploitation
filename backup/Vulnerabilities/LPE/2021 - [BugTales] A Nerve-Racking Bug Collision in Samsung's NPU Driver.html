<!DOCTYPE html>
<!-- saved from url=(0073)https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    

<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="HandheldFriendly" content="True">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
<meta name="generator" content="Hugo 0.78.2">



<link rel="shortcut icon" href="https://labs.taszk.io/images/favicon.png" type="image/x-icon">
<link rel="icon" href="https://labs.taszk.io/images/favicon.ico" type="image/x-icon">



<title>[BugTales] A Nerve-Racking Bug Collision in Samsung's NPU Driver - taszk.io labs</title>



<meta name="description" content="Last summer I have discovered several vulnerabilities in the implementation of Samsung&#39;s NPU device driver. While I was working on completing my proof of concept exploit">



<meta property="og:title" content="[BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver">
<meta name="twitter:title" content="[BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver">
<meta property="og:type" content="article">
<meta property="og:url" content="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/"><meta property="og:description" content="Last summer I have discovered several vulnerabilities in the implementation of Samsung&#39;s NPU device driver. While I was working on completing my proof of concept exploit">
<meta name="twitter:description" content="Last summer I have discovered several vulnerabilities in the implementation of Samsung&#39;s NPU device driver. While I was working on completing my proof of concept exploit"><meta property="og:image" content="https://labs.taszk.io/images/blog/ss_npu_drv/05_vmemmap.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://labs.taszk.io/images/blog/ss_npu_drv/05_vmemmap.png"><meta property="article:published_time" content="2021-06-08T00:00:00+00:00"><meta property="article:modified_time" content="2021-06-08T00:00:00+00:00">



<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

     
</style>



<!-- Bootstrap -->

<link rel="stylesheet" href="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/bootstrap.min.css">



<link rel="stylesheet" href="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/fuji.min.css">


<link rel="stylesheet" href="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/all.min.css">








<style type="text/css">.medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}</style></head>

<body data-theme="dark">
    <script data-cfasync="false">
  
  var fujiThemeData = localStorage.getItem('fuji_data-theme');
  
  if (fujiThemeData) {
    fujiThemeData = fujiThemeData === 'light' ? 'light' : 'dark';
    document.body.setAttribute('data-theme', fujiThemeData);
  }
</script>

    <nav class="navbar navbar-expand-lg site-navigation">
  <div class="container">
    <a class="navbar-brand" href="https://labs.taszk.io/">
      <img src="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/taszk_logo.png" class="show-theme show-theme-none show-theme-light" alt="logo">
      <img src="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/taszk_logo_white.png" class="show-theme show-theme-dark" alt="logo">
    </a>
    <button class="navbar-toggler collapsed" type="button" data-toggle="collapse" data-target="#sitenavbar">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>

    <div class="collapse navbar-collapse" id="sitenavbar">
      <ul class="navbar-nav ml-auto main-nav">
        
        
        
          
          <li class="nav-item">
            <a class="nav-link nav-link-normal" href="https://labs.taszk.io/">Home</a>
          </li>
          
        
          
          <li class="nav-item">
            <a class="nav-link nav-link-normal" href="https://labs.taszk.io/articles">Articles</a>
          </li>
          
        
          
          <li class="nav-item">
            <a class="nav-link nav-link-normal" href="https://labs.taszk.io/blog">Advisories</a>
          </li>
          
        
          
          <li class="nav-item">
            <a class="nav-link nav-link-btn btn btn-sm btn-primary btn-sm-rounded" href="https://taszk.io/contact">
              <span class="btn-area">
                <span data-text="Get in touch">
                  Get in touch
                </span>
              </span>
            </a>
          </li>
          
        
      </ul>
    </div>
  </div>
</nav>


    <main>
        <div class="container clearfix">
          <div class="container-inner">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/">[BugTales] A Nerve-Racking Bug Collision in Samsung's NPU Driver</a>
    </h2>
    <div class="post-item post-meta">
        <span><i class="fontawesome fas fa-calendar-day"></i>&nbsp;2021-06-08</span>
    <span><i class="fontawesome fas fa-pencil-alt"></i>&nbsp;by Gyorgy Miru</span>


<span><i class="fontawesome fas fa-tags"></i>&nbsp;<a href="https://labs.taszk.io/articles/tags/samsung">samsung</a>&nbsp;<a href="https://labs.taszk.io/articles/tags/kernel">kernel</a>&nbsp;</span>

    </div>
    
    <div class="post-content markdown-body">
        <h1 id="introduction">Introduction</h1>
<p>Last summer I have discovered several vulnerabilities in the implementation of Samsung’s NPU device driver.
While I was working on completing my proof of concept exploit, Ben Hawkes from Google’s Project Zero <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2073" target="_blank">reported</a> the same vulnerabilities to Samsung.
Later that year Brandon Azad released an <a href="https://googleprojectzero.blogspot.com/2020/12/an-ios-hacker-tries-android.html" target="_blank">article</a> documenting his approach of turning these bugs into an arbitrary kernel code execution exploit.
At the same time, the team of <a href="https://twitter.com/vngkv123" target="_blank">aSiagaming</a>, <a href="https://twitter.com/yeonn1c" target="_blank">yeonnic</a>, and <a href="https://twitter.com/say___2" target="_blank">say2</a> also found the same bugs and published a <a href="https://github.com/vngkv123/articles/blob/main/Galaxy%27s%20Meltdown%20-%20Exploiting%20SVE-2020-18610.md" target="_blank">writeup</a>, focusing on their method of exploitation and the post exploitation steps required to obtain root.</p>
<p>What makes the initial bugs interesting, besides the triple collision, is that they provide two very distinct avenues for exploitation.
Both Brandon Azad and aSiagaming et al. decided to leverage the vmap out-of-bound write to compromize the kernel.
My proof of concept exploit utilizes the race condition and the consequential heap overflow to achieve arbitrary kernel read-write.
Kmalloc overflow exploitation is not a novel concept, but the combination of modern Android kernel mitigations and limitations of the original exploit primitive provided by the vulnerability created interesting challenges.</p>
<p>In this blog post I briefly introduce the vulnerabilities in the NPU driver and detail my journey through the exploitation process.
I will focus on where previously published techniques fall short and how surprisingly old techniques remain applicable.
I will also discuss the kernel instrumentation I have created to assist the kernel heap exploit development in a constrained environment that is a production Samsung Android phone.</p>
<p><em>I’ve finished this proof of concept exploit during Fall 2020, but this publication was delayed until we finally got the website up and got around to writing the story.</em></p>
<h2 id="sve-2020-18610">SVE-2020-18610</h2>
<p>The Samsung NPU (Neural Processing Unit) is an additional processing core within the Exynos SoC that allows efficient, hardware accelerated execution of pretrained neural network models.
It allows features such as Shot Suggestion, Scene Optimizer, AI Gallery, and so on to function in real time, while processing the image data coming from the camera.
As far as I know, the NPU was first introduced on the S9 series devices, in a preliminary form, and it was significantly improved and overhauled for the S10 and S20 series phones.
Originally, Samsung released an <a href="https://developer.samsung.com/neural/overview.html" target="_blank">SDK</a> that allowed applications to exercise the capabilities of this core but since last year it is no longer available to third parties.
For the interested reader, Maxime Peterlin does a fantastic job documenting the inner workings of the NPU firmware, the inter-chip IPC communication and the kernel driver in his <a href="https://blog.longterm.io/samsung_npu.html" target="_blank">article</a>.</p>
<p>The NPU is exposed to the user space through the <kbd>/dev/vertex10</kbd> character device, which implements a lightweight V4L2 (Video4Linux2) <a href="https://www.kernel.org/doc/html/v4.19/media/kapi/v4l2-videobuf.html" target="_blank">Videbuf2</a> inspired streaming API.
This kernel driver provides ioctl handlers to upload neural network models, set image parameters, allocate buffers and manage streams.
The vulnerabilities are in the <kbd>VS4L_VERTEXIOC_S_GRAPH</kbd> ioctl implementation, inside the <kbd>npu_vertex_s_graph()</kbd> function.
This ioctl is used to initialize a new graph representing a neural network model.
Vaguely described, it receives an ION buffer fd, maps it into the kernel virtual address space and processes the graph data from it.</p>
<p>The ION allocator is used to request physically contiguous memory, represented by a file descriptor, that can be shared between user space applications, the kernel, and external cores.
In the case of the vulnerable ioctl, user space allocates the buffer, mmaps it into its own address space, initializes the content of it and passes the fd to the kernel driver.
The kernel driver calls <kbd>__get_session_info()</kbd> to receive the input data, and map the ION buffer into kernel and device memory (by invoking <kbd>__ncp_ion_map()</kbd>).
The main takeaway is that the content of the ION buffer is supplied by user space and the kernel does not have exclusive access to this memory while operating on it.</p>
<p>The subsequent <kbd>__config_session_info</kbd> function is responsible for the parsing of the graph data.</p>
<pre class="  language-c"><code class="  language-c"><span class="token keyword">int</span> <span class="token function">__config_session_info</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">npu_session</span> <span class="token operator">*</span>session<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
  <span class="token keyword">struct</span> <span class="token class-name">temp_av</span> <span class="token operator">*</span>temp_IFM_av<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">temp_av</span> <span class="token operator">*</span>temp_OFM_av<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">temp_av</span> <span class="token operator">*</span>temp_IMB_av<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">addr_info</span> <span class="token operator">*</span>WGT_av<span class="token punctuation">;</span>

  ret <span class="token operator">=</span> <span class="token function">__pilot_parsing_ncp</span><span class="token punctuation">(</span>session<span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp_IFM_cnt<span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp_OFM_cnt<span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp_IMB_cnt<span class="token punctuation">,</span> <span class="token operator">&amp;</span>WGT_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>

  temp_IFM_av <span class="token operator">=</span> <span class="token function">kcalloc</span><span class="token punctuation">(</span>temp_IFM_cnt<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">temp_av</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
  temp_OFM_av <span class="token operator">=</span> <span class="token function">kcalloc</span><span class="token punctuation">(</span>temp_OFM_cnt<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">temp_av</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
  temp_IMB_av <span class="token operator">=</span> <span class="token function">kcalloc</span><span class="token punctuation">(</span>temp_IMB_cnt<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">temp_av</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
  WGT_av <span class="token operator">=</span> <span class="token function">kcalloc</span><span class="token punctuation">(</span>WGT_cnt<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">addr_info</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
  ret <span class="token operator">=</span> <span class="token function">__second_parsing_ncp</span><span class="token punctuation">(</span>session<span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp_IFM_av<span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp_OFM_av<span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp_IMB_av<span class="token punctuation">,</span> <span class="token operator">&amp;</span>WGT_av<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>First, the <kbd>__pilot_parsing_ncp()</kbd> function is used to count all the input, output, intermediate feature map descriptors and weight structures within the shared memory.
After that, memory is reserved for them from the kernel heap.
Finally <kbd>__second_parsing_ncp()</kbd> iterates over the same data and extract values into the freshly allocated structures.
Let’s take a closer look at that:</p>
<pre class="  language-c"><code class="  language-c"><span class="token keyword">int</span> <span class="token function">__second_parsing_ncp</span><span class="token punctuation">(</span>
  <span class="token keyword">struct</span> <span class="token class-name">npu_session</span> <span class="token operator">*</span>session<span class="token punctuation">,</span>
  <span class="token keyword">struct</span> <span class="token class-name">temp_av</span> <span class="token operator">*</span><span class="token operator">*</span>temp_IFM_av<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">temp_av</span> <span class="token operator">*</span><span class="token operator">*</span>temp_OFM_av<span class="token punctuation">,</span>
  <span class="token keyword">struct</span> <span class="token class-name">temp_av</span> <span class="token operator">*</span><span class="token operator">*</span>temp_IMB_av<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">addr_info</span> <span class="token operator">*</span><span class="token operator">*</span>WGT_av<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
  <span class="token comment">// [1]</span>
  ncp_vaddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>session<span class="token operator">-&gt;</span>ncp_mem_buf<span class="token operator">-&gt;</span>vaddr<span class="token punctuation">;</span>
  ncp_daddr <span class="token operator">=</span> session<span class="token operator">-&gt;</span>ncp_mem_buf<span class="token operator">-&gt;</span>daddr<span class="token punctuation">;</span>
  ncp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ncp_header</span> <span class="token operator">*</span><span class="token punctuation">)</span>ncp_vaddr<span class="token punctuation">;</span>

  address_vector_offset <span class="token operator">=</span> ncp<span class="token operator">-&gt;</span>address_vector_offset<span class="token punctuation">;</span>
  address_vector_cnt <span class="token operator">=</span> ncp<span class="token operator">-&gt;</span>address_vector_cnt<span class="token punctuation">;</span>

  session<span class="token operator">-&gt;</span>ncp_info<span class="token punctuation">.</span>address_vector_cnt <span class="token operator">=</span> address_vector_cnt<span class="token punctuation">;</span>

  memory_vector_offset <span class="token operator">=</span> ncp<span class="token operator">-&gt;</span>memory_vector_offset<span class="token punctuation">;</span>
  <span class="token comment">// [2]</span>
  memory_vector_cnt <span class="token operator">=</span> ncp<span class="token operator">-&gt;</span>memory_vector_cnt<span class="token punctuation">;</span>

  mv <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">memory_vector</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ncp_vaddr <span class="token operator">+</span> memory_vector_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
  av <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">address_vector</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ncp_vaddr <span class="token operator">+</span> address_vector_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> memory_vector_cnt<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    u32 memory_type <span class="token operator">=</span> <span class="token punctuation">(</span>mv <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token operator">-&gt;</span>type<span class="token punctuation">;</span>
    u32 address_vector_index<span class="token punctuation">;</span>
    u32 weight_offset<span class="token punctuation">;</span>

    <span class="token keyword">switch</span> <span class="token punctuation">(</span>memory_type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> MEMORY_TYPE_IN_FMAP<span class="token operator">:</span>
      <span class="token punctuation">{</span>
        <span class="token comment">// [3]</span>
        address_vector_index <span class="token operator">=</span> <span class="token punctuation">(</span>mv <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token operator">-&gt;</span>address_vector_index<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">EVER_FIND_FM</span><span class="token punctuation">(</span>IFM_cnt<span class="token punctuation">,</span> <span class="token operator">*</span>temp_IFM_av<span class="token punctuation">,</span> address_vector_index<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token punctuation">(</span><span class="token operator">*</span>temp_IFM_av <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>IFM_cnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>index <span class="token operator">=</span> address_vector_index<span class="token punctuation">;</span>
          <span class="token punctuation">(</span><span class="token operator">*</span>temp_IFM_av <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>IFM_cnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>size <span class="token operator">=</span> <span class="token punctuation">(</span>av <span class="token operator">+</span> address_vector_index<span class="token punctuation">)</span><span class="token operator">-&gt;</span>size<span class="token punctuation">;</span>
          <span class="token punctuation">(</span><span class="token operator">*</span>temp_IFM_av <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>IFM_cnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>pixel_format <span class="token operator">=</span> <span class="token punctuation">(</span>mv <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token operator">-&gt;</span>pixel_format<span class="token punctuation">;</span>
          <span class="token punctuation">(</span><span class="token operator">*</span>temp_IFM_av <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>IFM_cnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>width <span class="token operator">=</span> <span class="token punctuation">(</span>mv <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token operator">-&gt;</span>width<span class="token punctuation">;</span>
          <span class="token punctuation">(</span><span class="token operator">*</span>temp_IFM_av <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>IFM_cnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>height <span class="token operator">=</span> <span class="token punctuation">(</span>mv <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token operator">-&gt;</span>height<span class="token punctuation">;</span>
          <span class="token punctuation">(</span><span class="token operator">*</span>temp_IFM_av <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>IFM_cnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>channels <span class="token operator">=</span> <span class="token punctuation">(</span>mv <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token operator">-&gt;</span>channels<span class="token punctuation">;</span>
          <span class="token punctuation">(</span>mv <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token operator">-&gt;</span>stride <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
          <span class="token punctuation">(</span><span class="token operator">*</span>temp_IFM_av <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>IFM_cnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>stride <span class="token operator">=</span> <span class="token punctuation">(</span>mv <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token operator">-&gt;</span>stride<span class="token punctuation">;</span>

          <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>

          <span class="token punctuation">(</span><span class="token operator">*</span>IFM_cnt<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token keyword">case</span> MEMORY_TYPE_OT_FMAP<span class="token operator">:</span>
      <span class="token punctuation">{</span>
        <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token keyword">case</span> MEMORY_TYPE_IM_FMAP<span class="token operator">:</span>
      <span class="token punctuation">{</span>
        <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token keyword">case</span> MEMORY_TYPE_CUCODE<span class="token operator">:</span>
    <span class="token keyword">case</span> MEMORY_TYPE_WEIGHT<span class="token operator">:</span>
    <span class="token keyword">case</span> MEMORY_TYPE_WMASK<span class="token operator">:</span>
      <span class="token punctuation">{</span>
        <span class="token comment">// update address vector, m_addr with ncp_alloc_daddr + offset</span>
        address_vector_index <span class="token operator">=</span> <span class="token punctuation">(</span>mv <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token operator">-&gt;</span>address_vector_index<span class="token punctuation">;</span>
        <span class="token comment">// [4]</span>
        weight_offset <span class="token operator">=</span> <span class="token punctuation">(</span>av <span class="token operator">+</span> address_vector_index<span class="token punctuation">)</span><span class="token operator">-&gt;</span>m_addr<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>weight_offset <span class="token operator">&gt;</span> <span class="token punctuation">(</span>u32<span class="token punctuation">)</span>session<span class="token operator">-&gt;</span>ncp_mem_buf<span class="token operator">-&gt;</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          ret <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
          <span class="token function">npu_uerr</span><span class="token punctuation">(</span><span class="token string">"weight_offset is invalid, offset(0x%x), ncp_daddr(0x%x)\n"</span><span class="token punctuation">,</span>
            session<span class="token punctuation">,</span> <span class="token punctuation">(</span>u32<span class="token punctuation">)</span>weight_offset<span class="token punctuation">,</span> <span class="token punctuation">(</span>u32<span class="token punctuation">)</span>session<span class="token operator">-&gt;</span>ncp_mem_buf<span class="token operator">-&gt;</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">goto</span> p_err<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// [5]</span>
        <span class="token punctuation">(</span>av <span class="token operator">+</span> address_vector_index<span class="token punctuation">)</span><span class="token operator">-&gt;</span>m_addr <span class="token operator">=</span> weight_offset <span class="token operator">+</span> ncp_daddr<span class="token punctuation">;</span>

        <span class="token punctuation">(</span><span class="token operator">*</span>WGT_av <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>WGT_cnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>av_index <span class="token operator">=</span> address_vector_index<span class="token punctuation">;</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>WGT_av <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>WGT_cnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>size <span class="token operator">=</span> <span class="token punctuation">(</span>av <span class="token operator">+</span> address_vector_index<span class="token punctuation">)</span><span class="token operator">-&gt;</span>size<span class="token punctuation">;</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>WGT_av <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>WGT_cnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>daddr <span class="token operator">=</span> weight_offset <span class="token operator">+</span> ncp_daddr<span class="token punctuation">;</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>WGT_av <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>WGT_cnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>vaddr <span class="token operator">=</span> weight_offset <span class="token operator">+</span> ncp_vaddr<span class="token punctuation">;</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>WGT_av <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>WGT_cnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>memory_type <span class="token operator">=</span> memory_type<span class="token punctuation">;</span>
        <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>WGT_cnt<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  session<span class="token operator">-&gt;</span>IOFM_cnt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>IFM_cnt<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>OFM_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
p_err<span class="token operator">:</span>
  <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The pointer retrieved at [1] is the kernel virtual address of the shared ION buffer.
The number of feature maps and weights is read again from the shared memory at [2] and then they are processed.
The different types of feature maps are marshalled into the previously allocated <kbd>struct temp_av</kbd> arrays, just like at [3].
Meanwhile the weight structures are extracted into the <kbd>struct addr_info</kbd> array at [4].
I will refer to these descriptors together as memory vectors from now on like the code does.</p>
<p>There are at least two exploitable issues within the presented code.
The <kbd>address_vector_index</kbd>, read from the ION buffer at [4], is not bound checked and used as an offset into the same buffer.
The value at the offset is incremented with the bus address (physical address) of the ION buffer at [5], resulting in an out of bounds write primitive.
Internally, the ION subsystem implements the <a href="https://www.kernel.org/doc/html/v4.19/driver-api/dma-buf.html" target="_blank">DMA Buffer Sharing API</a> and the <kbd>dma_buf_vmap()</kbd> function is used to assign kernel virtual addresses for ION buffers.
After multiple indirections, the <kbd>ion_heap_map_kernel()</kbd> calls <kbd>vmap()</kbd> to map the buffer pages to a contiguous virtual address range.
Vmap uses the same <kbd>__get_vm_area_node()</kbd> function as vmalloc to reserve kernel virtual addresses.
As a result this bug can be leveraged to corrupt kernel memory allocated with vmalloc or mapped with vmap.
Both Brandon Azad and aSiagaming rely on this primitive in their exploits.</p>
<p>The other vulnerability is a direct result of the shared nature of the ION buffer.
Remember that in <kbd>__pilot_parsing_ncp()</kbd>, the different memory vectors are counted and kernel heap allocations are made based on the result.
However, in <kbd>__second_parsing_ncp()</kbd> the number of descriptors is read again ([2]) from the shared memory and the kernel heap arrays are filled based on that value.
This creates a TOCTOU race window where the count used for the allocation can be different from the count used to fill the buffers, potentially causing a kmalloc overflow.
The rest of this blog post discusses how to exploit this vulnerability.</p>
<p>At the time of research the <kbd>/dev/vertex10</kbd> device was readable by every user on the system and it had a very relaxed selinux permission set.
Even untrusted applications were allowed to issue ioctl calls to this device.
After the vulnerability was reported, Samsung restricted selinux access to platform apps and the camera server.</p>
<h2 id="research-setup">Research Setup</h2>
<p>Since the vulnerability is in a kernel driver of a complex proprietary device, virtualization did not seem a  practical approach for exploit development.
Even though the number of steps and data wipes required increases with each model, Samsung phones are still shipped with an option to enable bootloader unlocking.
After turning the phone towards Seoul and humming the Samsung notification sound backwards (or a series of similarly obscure steps) the OEM Unlock option appears in the developer menu.
Samsung also <a href="https://opensource.samsung.com/uploadList?menuItem=mobile&amp;classification1=mobile_phone" target="_blank">releases</a> the kernel sources for each firmware version.
These can be built and flashed onto the devices, once the bootloader is unlocked.</p>
<p>In my experience heap exploit development often requires deeper insight into the inner workings of the allocator than what is provided by the kernel logs.
Even though Linux provides very flexible and extensive <a href="https://www.kernel.org/doc/html/latest/trace/index.html" target="_blank">tracing APIs</a> I opted to simply patch the kernel to instrument the <kbd>__kmalloc</kbd> and <kbd>kfree</kbd> functions.
The patches enable tracing allocations from selected kmalloc caches or allocations made by a selected process.
I wrote a QT application to visualize these traces, the figures in this blog post about the heap layouts are extracted from this tool.
The X axis represents the spatial domain and the Y axis represents the time domain, growing down.
Each row captures the state of the heap (or part of it) at a given time, while columns describe whether a selected object is allocated or not over the course of time.
Generally, colored boxes are allocated objects, the grey ones are freed objects while the dashed objects signal an unknown state, where no event was observed for the specific slot before.
The red border is used to highlight the current event in the row.</p>
<p><img class="img-zoomable medium-zoom-image" src="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/01_viz_example.png" alt="Heap Viz">
</p>
<p>During the PoC development I used a Galaxy S10 with a rooted and instrumented kernel and a pristine Galaxy S20 to verify steps from application context.
The bugs were the same on both models and the techniques I used worked on both devices.</p>
<h2 id="initial-primitive">Initial Primitive</h2>
<p>Before going any further let’s explore the race condition and the kmalloc overflow a bit deeper.
The root cause of the overflow is the fact, that the number of memory vectors is read first for the allocation, and then read again from shared memory during processing.
While there is no synchronization event observable by user space between these two events, it is still a fairly trivial race to win.
By continuously alternating two X and Y values, where X &lt; Y, used as memory vector count, the race can be reliably won.
The following scenarios can occur:</p>
<ol>
<li>Y is used for allocation and X or Y is used for copy</li>
<li>X is used for allocation and X is used for copy</li>
<li>X is used for allocation and Y is used for copy</li>
</ol>
<p>The first scenario is the most simple as the allocation would land in a larger cache than the victim, there is no memory corruption or side effect.
The second scenario causes an allocation in the same cache where the victim is, but there is no overflow.
If the memory vectors are one of the feature map types, the allocation is immediately released causing no side effect.
If they are weight types the allocation is not released, filling up a slot in the target cache, but no corruption occurs.
This is still a minor side effect that would not prevent further retries.
The third case is the ideal scenario when the allocation size is smaller than the copy size, so the overflow is triggered.
As a result if the race is not won it can be attempted again, arbitrary times.</p>
<p>Now that it is established that the overflow can happen, let’s take a closer look at what is actually written.
If the memory vectors are feature map type, they are unpacked into <kbd>struct temp_av</kbd> structures (at [3] in the previous listing).
Whereas if the type is a weight type they are marshalled into <kbd>struct addr_info</kbd> structures (at [5]).
These structures both differ in size and layout, in both cases only a limited set of fields are controlled.</p>
<p>The <kbd>struct temp_av</kbd> is 64 bytes, with the following fields:</p>
<pre><code>offset - size - name 
 0 - 4 - index : Semi controlled, values are restricted
 4 - 4 - hole : Untouched (compiler gap)
 8 - 8 - size : Least significant 4 bytes are controlled, rest is zeroed
16 - 4 - memory_type: Untouched
20 - 4 - hole : Untouched (compiler gap)
24 - 8 - vaddr: Untouched
32 - 8 - daddr: Untouched
40 - 4 - pixelf_format: Controlled
44 - 4 - width: Controlled
48 - 4 - hieght: Controlled
52 - 4 - channels: Controlled
56 - 4 - strize: Zeroed
60 - 4 - cstride: Untouched
</code></pre>
<p>The <kbd>struct addr_info</kbd> is 56 bytes, with the following fields:</p>
<pre><code>offset - size - name 
 0 - 4 - memory_type : Zeroed
 4 - 4 - av_index : Semi controlled, values are restricted
 8 - 8 - vaddr : Kernel pointer into the ION buffer at controlled offset
16 - 8 - daddr : Bus address of the ION buffer at controlled offset
24 - 8 - size : Least significant 4 bytes are controlled, rest is zeroed
32 - 4 - pixelf_format: Untouched
36 - 4 - width: Untouched
40 - 4 - hieght: Untouched
44 - 4 - channels: Untouched
48 - 4 - strize: Untouched
52 - 4 - cstride: Untouched
</code></pre>
<p>While neither of these layouts are ideal, as they contain uncontrolled fields and unchanged holes, they both provide interesting primitives.
The <kbd>temp_av</kbd> structure has a 16 byte region where data is fully controlled and <kbd>addr_info</kbd> contains a kernel pointer into the shared ION buffer.</p>
<p>The overflown heap buffer is allocated to hold an array of one of these structures and the size of it can be chosen.
The number of overflown elements can also be arbitrary.</p>
<h2 id="heap-feng-shui">Heap Feng Shui</h2>
<p>Due to the size constraints of this publication I will refrain from discussing the kmalloc allocator in detail, except for a brief introduction of terminology.
For the interested reader there are plenty of resources documenting the SLUB allocator (<a href="https://events.static.linuxfound.org/sites/events/files/slides/slaballocators.pdf" target="_blank">1</a>, <a href="https://ruffell.nz/programming/writeups/2019/02/15/looking-at-kmalloc-and-the-slub-memory-allocator.html" target="_blank">2</a>, <a href="https://www.kernel.org/doc/gorman/html/understand/understand011.html" target="_blank">3</a>, <a href="https://www.kernel.org/doc/html/v4.19/vm/slub.html" target="_blank">4</a>, <a href="https://hammertux.github.io/slab-allocator" target="_blank">5</a>)
and even more on exploitation techniques (<a href="http://www.ouah.org/kmallocstory.html" target="_blank">1</a>, <a href="http://phrack.org/archives/issues/64/6.txt" target="_blank">2</a>, <a href="https://argp.github.io/2012/01/03/linux-kernel-heap-exploitation/" target="_blank">3</a>, <a href="https://resources.infosecinstitute.com/topic/exploiting-linux-kernel-heap-corruptions-slub-allocator/" target="_blank">4</a>, <a href="https://ruxcon.org.au/assets/2016/slides/ruxcon2016-Vitaly.pdf" target="_blank">5</a>, <a href="https://dangokyo.me/2018/10/30/linux-kernel-exploitation-buddy-allocator-and-slub-allocator/" target="_blank">6</a>,
<a href="https://i.blackhat.com/eu-19/Wednesday/eu-19-Chen-Hands-Off-And-Putting-SLAB-SLUB-Feng-Shui-In-A-Blackbox.pdf" target="_blank">7</a>).
SLUB is the default allocator used by kmalloc on modern Android phones.
It is a slot based allocator, where general allocation requests are rounded up to the next power of 2 size and allocated from the appropriate <em>caches</em>.
Some of the more frequently used structures have their own dedicated caches.
Each cache can hold multiple <em>slabs</em> which are contiguous sets of pages containing the allocated or freed <em>objects</em> (slots).
In <em>partial</em> slabs (where free and allocated objects are mixed), the free objects are tracked by a single linked, inline <em>freelist</em>.</p>
<p>The main difference between Samsung and other Android devices is that on Samsung the smallest general kmalloc cache is 128 bytes.
Further caches increase in size as power of 2 (256, 512, 1024, 2048, 4096, 8192).
Since the memory vector arrays are allocated from the general cache and the allocation size is controlled, it is possible to target any of these caches.</p>
<p>Generally when exploiting heap overflows we want to create a layout where the victim object is preceded by a suitable free slot, that can be claimed by the overflow object.
To increase the reliability of the exploit it is better to have a checkered layout where such free slots and victim objects alternate.</p>
<p><img class="img-zoomable medium-zoom-image" src="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/02_checkered_layout.png" alt="Heap Checkered">
</p>
<p><em>Visualization of the checkered layout. Green boxes represent allocated objects, while the grey ones are freed.</em></p>
<p>This way sporadic, random allocations would not prevent a successful overwrite of the victim object.
Samsung kernels on the S10 and S20 are compiled with <kbd>CONFIG_SLAB_FREELIST_RANDOM</kbd> disabled, without <a href="https://medium.com/@mxatone/randomizing-the-linux-kernel-heap-freelists-b899bb99c767" target="_blank">freelist randomization</a> the order of allocations is deterministic.
To achieve this checkered layout a victim object is required that can be allocated multiple times, can also be individually released on demand (lifetime is controlled), and the allocation should be free of side effects in the given cache.
Since the overflow primitive already puts a lot of constraints on the victim object it is better to use a separate object for heap shaping.
The same layout can be achieved by first spraying the shaping object, then releasing every second one to spray the victim objects and finally releasing the rest of the shaping objects.</p>
<p><img class="img-zoomable medium-zoom-image" src="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/03_victim_spray.png" alt="Heap Victim">
</p>
<p><em>Visualization of the victim spraying. Green boxes represent the shaping object, the yellow ones are the victim object and the red one is the overflow object.</em></p>
<p>While it is possible to target any of the general kmalloc caches they are not all equally suitable for exploitation.
According to my observations the smallest <kbd>kmalloc-128</kbd> cache is very noisy, it is used very frequently even on an idle system.
Large bursts of allocations are frequent which would make reliable exploitation harder.
On the other end, large object sizes make intra slab overflows less likely.
The overflow object is more likely to end up at the end of slab overwriting different slabs or unrelated pages.
This issue can be mitigated by sufficient amount of spraying, but it won’t be completely eliminated.</p>
<p>To summarize, this exploit approach would require two different objects that satisfy the following conditions:</p>
<p>A shaping object:</p>
<ul>
<li>Can be allocated arbitrary number of times</li>
<li>Side effect free (does not cause further allocations or frees) in the target cache</li>
<li>Can be freed on demand</li>
<li>Available on the Galaxy kernel and can be triggered from untrusted application context</li>
</ul>
<p>A victim object:</p>
<ul>
<li>Has an interesting field that overlaps with a controlled field of the overflow structures</li>
<li>There are no fields in it that would be corrupted by the uncontrolled overflow fields in a way that would prevent exploitation</li>
<li>Resilient to Samsung specific protection features (RKP, debug linked lists)</li>
<li>Lifetime is controlled or long enough that the overflow can happen and the overwritten field can be accessed</li>
<li>Preferably can be allocated multiple times</li>
<li>Preferably allocated from the <kbd>kmalloc-256</kbd> or <kbd>kmalloc-512</kbd> caches</li>
<li>Available on the Galaxy kernel and can be triggered from untrusted application context</li>
</ul>
<h3 id="shaping-object">Shaping Object</h3>
<p>In the proof of concept exploit I used the <kbd>timerfd_ctx</kbd> structure for heap shaping.
It is allocated by the <a href="https://man7.org/linux/man-pages/man2/timerfd_create.2.html" target="_blank">timerfd_create</a> system call and satisfies all the required conditions.
The number of objects that can be sprayed is only limited by <a href="https://ss64.com/bash/ulimit.html" target="_blank">ulimit</a>, that restricts the number of file descriptors that can be opened by an application at the same time to 32768.
This value is sufficiently large for our spraying requirements.
The size of <kbd>timerfd_ctx</kbd> is 216 bytes so it is allocated from the <kbd>kmalloc-256</kbd> cache and <kbd>timerfd_create()</kbd> causes no further allocations in this cache.
The system call can be invoked by any process on the system (unless the process is in a seccomp jail), it has no explicit permission checks.</p>
<p>The allocated <kbd>timerfd_ctx</kbd> object can be freed by closing the associated file descriptor.
The close system call does not release resources immediately, it simply decrements the reference counter for the file object and sets up a <a href="https://lwn.net/Articles/494158/" target="_blank">deferred work</a>.
This deferred task work should run in the same context as the original process but it might sleep or willingly give up CPU time.
The issue with that is SLUB has per CPU freelists, if a kfree is executed on a different core than the consecutive allocations, they would be satisfied from a different slab.
Obviously, this is undesirable as it could ruin the determinism of the allocation sequence.
I found that this problem can be solved reliably by pinning the heap exploit thread to a CPU and by keeping other cores busy at the same time.</p>
<h3 id="victim-object">Victim Object</h3>
<p>I spent a significant amount of time searching for a suitable victim object, mostly looking for a primitive to leak kernel data to break KASLR.
The <kbd>temp_av</kbd> structure provides more control over the fields written so I was focusing mostly on that.
I began by testing objects that were used in previous Linux LPE exploits, but they were either in subsystems not compiled on Android, not available from untrusted applications, or they have been extended with further hardening (<kbd>struct iovec</kbd>, <kbd>struct cred</kbd>).
I continued by exploring the allocations made by the NPU driver, since I was already familiar with the code, however the uncontrolled overflow fields were causing crashes before any meaningful corruption could be triggered.</p>
<p>At the time of writing <a href="https://securitylab.github.com/tools/codeql/" target="_blank">CodeQL</a> was freshly released.
CodeQL is a static analysis framework, designed to run various queries on large codebases.
It has a clang based backend that supports C and C++ projects.
I was curious to find out how this tool functions with a complex and large project such as the kernel, and whether I could write a query that assists in finding a victim candidate.
I found that the setup was very straightforward and the queries were efficient, however the complex examples available at the time were limited.
The query below lists all the kmalloc family allocations that have a fixed size, a size that falls into a selected range, and have a possible call chain to them from a system call handler or a <kbd>struct file_operations</kbd> callback.</p>
<pre class="  language-c"><code class="  language-c">import cpp

<span class="token comment">// Check if the function is set as a fielf of </span>
<span class="token comment">// struct file_operations</span>
predicate <span class="token function">isFopsHandler</span><span class="token punctuation">(</span>Function f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">exists</span><span class="token punctuation">(</span>Initializer i <span class="token operator">|</span>
    i<span class="token punctuation">.</span><span class="token function">getDeclaration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span>Variable<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getUnspecifiedType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasName</span><span class="token punctuation">(</span><span class="token string">"file_operations"</span><span class="token punctuation">)</span> and
    f <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">getExpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAChild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span>Access<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// Can the function be called from system call handler</span>
<span class="token comment">// or from a file_operations callback</span>
predicate <span class="token function">isSysHandler</span><span class="token punctuation">(</span>Function f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  f<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">"sys_%"</span><span class="token punctuation">)</span>
  or
  <span class="token function">isFopsHandler</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
  or 
  <span class="token comment">// Apply this recursively to previous functions in the control flow</span>
  <span class="token function">isSysHandler</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">getACallToThisFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getControlFlowScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// Return the name of the calling function</span>
string <span class="token function">getSysHandler</span><span class="token punctuation">(</span>Function f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">"sys_%"</span><span class="token punctuation">)</span> and result <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token function">or</span>
  <span class="token punctuation">(</span><span class="token function">isFopsHandler</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> and result <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  or 
  result <span class="token operator">=</span> <span class="token function">getSysHandler</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">getACallToThisFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getControlFlowScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>


from FunctionCall fc<span class="token punctuation">,</span> Function f<span class="token punctuation">,</span> string sys
where
  <span class="token comment">// Match kmalloc family allocations</span>
  fc<span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">regexpMatch</span><span class="token punctuation">(</span><span class="token string">"k[a-z]*alloc"</span><span class="token punctuation">)</span> and
  <span class="token comment">// With a given size</span>
  <span class="token punctuation">(</span>fc<span class="token punctuation">.</span><span class="token function">getArgument</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">128</span> and fc<span class="token punctuation">.</span><span class="token function">getArgument</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">256</span><span class="token punctuation">)</span> and 
  <span class="token comment">// Reachable from system call or file operation</span>
  <span class="token function">isSysHandler</span><span class="token punctuation">(</span>fc<span class="token punctuation">.</span><span class="token function">getControlFlowScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> and sys <span class="token operator">=</span> <span class="token function">getSysHandler</span><span class="token punctuation">(</span>fc<span class="token punctuation">.</span><span class="token function">getControlFlowScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

select fc<span class="token punctuation">,</span> <span class="token string">"Callsite of fitting K*alloc: "</span> <span class="token operator">+</span> fc<span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"("</span> <span class="token operator">+</span> fc<span class="token punctuation">.</span><span class="token function">getArgument</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">") by "</span> <span class="token operator">+</span> fc<span class="token punctuation">.</span><span class="token function">getControlFlowScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" from "</span> <span class="token operator">+</span> sys
</code></pre>
<p>This query takes around 20 minutes to execute and provides a list of 50-60 victim candidates on the S10 and S20 kernels.
It could be further optimized to include variable size allocations, where the size is potentially controlled by the user, or to include constraints on the allocated type.
Overall I was satisfied with CodeQL, it found a series of structures that were used in previously published exploits (e.g. <kbd>struct binder_transaction</kbd>, <kbd>struct seq_file</kbd>) and some really promising new ones (<kbd>struct ion_buffer</kbd>).
Unfortunately, they all had the same fundamental issue as previous candidates: the uncontrolled overflow fields would cause undesirable crashes around when the overwritten field was accessed.
At this point I have decided to explore a different approach.</p>
<h2 id="what-is-old-is-new-again-and-again-and-again">What is Old is New Again and Again and Again</h2>
<p>As previously mentioned, the SLUB allocator maintains a single linked list of free objects within partial slabs.
The address of the first free object is either retrieved from the per CPU cache or stored within the associated <kbd>struct page</kbd> descriptor.
The pointers of consecutive list elements are stored inline, on the first 8 bytes, of the free objects.
The kernel inherently trusts these values, when they are retrieved by <kbd>get_freepointer()</kbd> there are no sanity checks.
These freelist pointers can be abused to smuggle in arbitrary objects, that would be returned during future allocations.
This technique was already documented in 2009 and mitigations were suggested by Larry H in <a href="http://phrack.org/issues/66/15.html#article" target="_blank">Linux Kernel Heap Tampering Detection</a>.</p>
<p>In kernel version 4.14 the <kbd>CONFIG_SLAB_FREELIST_HARDENED</kbd> option was introduced in the upstream kernel.
The goal of this patch was to prevent exactly these types of freelist overwrite attacks.
This is achieved by XORing the pointer value with the pointer’s location and a per-cache random cookie, and storing the result in the free object.
The kernels on Galaxy S10 and S20 are compiled without this hardening feature, enabling potential freelist poisoning attacks.
The question remains if the overflow object can align with the freelist pointer in a way to control it.</p>
<p>The two overflow primitives provide two different ways to exploit this vulnerability.
If the <kbd>temp_av</kbd> structure is used the freelist pointer could potentially be overwritten with a fully controlled value.
However, we would first need to construct some KASLR leak to use this.
The <kbd>addr_info</kbd> structure, however, contains a kernel pointer into the shared ION memory.
This pointer is filled by the kernel when the structure is initialized during the overflow ([8]).
If this field would overlap with a freelist pointer, a consecutive allocation would return memory from the shared buffer.
This would be an extremely strong primitive as it would allow unlimited read/write access to the kmalloc allocated object from user space while defeating KASLR as well (i.e. we don’t need to figure out the kernel VA of the shared ION memory ourselves in order to hijack the kmalloc allocation into it).</p>
<pre class="  language-c"><code class="  language-c"><span class="token keyword">int</span> <span class="token function">__second_parsing_ncp</span><span class="token punctuation">(</span>
  <span class="token keyword">struct</span> <span class="token class-name">npu_session</span> <span class="token operator">*</span>session<span class="token punctuation">,</span>
  <span class="token keyword">struct</span> <span class="token class-name">temp_av</span> <span class="token operator">*</span><span class="token operator">*</span>temp_IFM_av<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">temp_av</span> <span class="token operator">*</span><span class="token operator">*</span>temp_OFM_av<span class="token punctuation">,</span>
  <span class="token keyword">struct</span> <span class="token class-name">temp_av</span> <span class="token operator">*</span><span class="token operator">*</span>temp_IMB_av<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">addr_info</span> <span class="token operator">*</span><span class="token operator">*</span>WGT_av<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
  <span class="token comment">// [6]</span>
  ncp_vaddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>session<span class="token operator">-&gt;</span>ncp_mem_buf<span class="token operator">-&gt;</span>vaddr<span class="token punctuation">;</span>
  <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>

    <span class="token keyword">case</span> MEMORY_TYPE_CUCODE<span class="token operator">:</span>
    <span class="token keyword">case</span> MEMORY_TYPE_WEIGHT<span class="token operator">:</span>
    <span class="token keyword">case</span> MEMORY_TYPE_WMASK<span class="token operator">:</span>
      <span class="token punctuation">{</span>
        <span class="token comment">// update address vector, m_addr with ncp_alloc_daddr + offset</span>
        address_vector_index <span class="token operator">=</span> <span class="token punctuation">(</span>mv <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token operator">-&gt;</span>address_vector_index<span class="token punctuation">;</span>
        <span class="token comment">// [7]</span>
        weight_offset <span class="token operator">=</span> <span class="token punctuation">(</span>av <span class="token operator">+</span> address_vector_index<span class="token punctuation">)</span><span class="token operator">-&gt;</span>m_addr<span class="token punctuation">;</span>

        <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
        <span class="token comment">// [8]</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>WGT_av <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>WGT_cnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>vaddr <span class="token operator">=</span> weight_offset <span class="token operator">+</span> ncp_vaddr<span class="token punctuation">;</span>
</code></pre>
<p>The <kbd>weight_offset</kbd> can be adjusted ([7]) to control the exact location of the allocation within the shared memory buffer.
The <kbd>vaddr</kbd> field is at an 8 byte offset in the <kbd>addr_info</kbd> structure, so a cache size and count pair is needed for which the following can be satisfied:</p>

<span><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>n</mi><mo>×</mo><mi>c</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>≡</mo><mn>8</mn><mspace></mspace><mspace width="1em"></mspace><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"></mspace><mn>56</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n \times cache\_size \equiv 8 \pmod{56}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.00444em; vertical-align: -0.31em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord" style="margin-right: 0.02778em;">_</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">8</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right: 1em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right: 0.333333em;"></span><span class="mord">5</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></span></span>

<p>The kmalloc-512 cache with n = 1 and the kmalloc-256 cache with n = 2 satisfy these constraints.
In other words, the vaddr field of 10th element of an <kbd>addr_info</kbd> array would overlap a freelist pointer in these caches, as it falls at a 512 byte offset.</p>
<p>I found that the most reliable way to overflow this pointer was to use the kmalloc-256 cache and forgo any advanced heap shaping.
If the overflow allocation lands in a cache that has at least two free objects after it, the vaddr field overlaps the free pointer in the second object.
Luckily at offset 32 within <kbd>addr_info</kbd> there is a hole, that is not touched, so the freelist pointer in the first object is not corrupted (256 % 56 = 32).
The only problem is when the overflow object lands at the end of the slab and corrupts something unintentional, but the chances of that can be minimized by sufficient amount of spraying.</p>
<p><img class="img-zoomable medium-zoom-image" src="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/04_pipe_alloc.png" alt="Heap Pipe">
</p>
<p><em>Visualization of successful freelist poisoning. The red objects are used for the overflow then the yellow victim objects are allocated. The third victim lands in the shared memory, due to the corrupted free list.</em></p>
<h2 id="not-all-memory-created-equal">Not All Memory Created Equal</h2>
<p>The freelist overwrite allows an arbitrary object from the kmalloc-256 or kmalloc-512 caches to be allocated in the shared memory, providing complete control over it.
The only question that remains is which object to use to create a convenient arbitrary read write primitive.</p>
<p>Initially I tried to utilise the <kbd>seq_file</kbd> structure.
It is created in <kbd>seq_open()</kbd> when a file is opened from the procfs virtual file system.
By controlling this structure, and the content of the opened file, <kbd>seq_read()</kbd> can be leveraged to achieve both arbitrary read and write.
The content of some procfs files, such as <kbd>/proc/self/comm</kbd>, can always be written by the owner process.
The <kbd>seq_file</kbd> structure has a <kbd>buf</kbd> pointer that serves as an intermediate buffer between user space and the file.
Depending on the request size and read position (stored in the same structure), the buffer is either just copied to user space, or filled in by the file specific <kbd>show()</kbd> callback.
In case of <kbd>/proc/self/comm</kbd> this callback (<kbd>comm_show()</kbd>) simply copies the processes comm string to the buffer, which can be set by writing the same file.</p>
<p>This could be the ideal structure to finish the exploit, however there is just one obstacle.
Remember that the ION buffer is shared with the device, so it is either outer shared or system shared memory.
When executing an atomic instruction in this memory (e.g. <kbd>ldadd</kbd>) a bus fault is generated and the kernel panics.
I could not find the root cause of this behavior in the ARM documentation.
It is specified that if the atomic operation misses all the caches in the system (including L3) and CHI (Coherent Hub Interface) is used, the request is sent out to the interconnect to perform the operation.
I suspect this is the case here, but I don’t know what is supposed to happen if the interconnect cannot ensure coherency or fails to carry out the operation.
These atomic instructions are used when implementing reference counting or locking in the Linux kernel.
As a result, structures that contain such fields cannot be used in the shared memory.</p>
<p>While reviewing the code in fs/pipe.c for the <kbd>iovec</kbd> overwrite attempt, I took a notice of the <kbd>struct pipe_buffer</kbd> array.
When the <a href="https://man7.org/linux/man-pages/man7/pipe.7.html" target="_blank">pipe</a> is created an array of <kbd>pipe_buffer</kbd>-s is allocated from the kernel heap, containing a structure for each buffer page belonging to the pipe.
Let’s take a closer look how this structure is defined and used.</p>
<pre class="  language-c"><code class="  language-c"><span class="token keyword">struct</span> <span class="token class-name">pipe_buffer</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>              page<span class="token punctuation">;</span>                 <span class="token comment">/*     0     8 */</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>               offset<span class="token punctuation">;</span>               <span class="token comment">/*     8     4 */</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>               len<span class="token punctuation">;</span>                  <span class="token comment">/*    12     4 */</span>
  <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pipe_buf_operations</span>  <span class="token operator">*</span> ops<span class="token punctuation">;</span>         <span class="token comment">/*    16     8 */</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>               flags<span class="token punctuation">;</span>                <span class="token comment">/*    24     4 */</span>
  <span class="token comment">/* XXX 4 bytes hole*/</span>
  <span class="token keyword">long</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span>          private<span class="token punctuation">;</span>              <span class="token comment">/*    32     8 */</span>
  <span class="token comment">/* size: 40, cachelines: 1, members: 6 */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>The <kbd>page</kbd> field is a pointer to the <a href="https://lwn.net/Articles/789304/" target="_blank">vmemmap</a> array entry, that represents the page that is allocated for the pipe buffer (with <kbd>alloc_page()</kbd>).
The offset and len fields are used to determine whether there is enough data or free space within the buffer to satisfy a read or write request.
In <kbd>pipe_write()</kbd>, data from user space is written to the pointed page, if there is enough room, while <kbd>pipe_read()</kbd> returns data to user space from the page.
Both of these functions map the selected page into kernel virtual memory if it is not already.
By controlling the page, offset and len fields it is possible to read and write arbitrary data within arbitrary pages.</p>
<p><img class="img-zoomable medium-zoom-image" src="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/05_vmemmap.png" alt="Pipe Buffer">
</p>
<p><em>Connection between vmemmap and the physical and virtual memory</em></p>
<p>To understand the exact consequences of this we need to explore the vmemmap array and the kernel physical memory management a bit deeper.
Vmemmap is a virtual mapping of all memory maps, basically a virtually contiguous <kbd>struct page</kbd> array, where each physical memory page is represented by an array entry.
The <kbd>struct page</kbd> belonging to the N-th physical page is located at <kbd>vmemmap[N - 1]</kbd>.
The purpose of this is to make PFN (Page Frame Number) conversion to and from <kbd>struct page</kbd> easy and efficient.
Sections of the physical memory address space, that are not managed by kernel, are simply not mapped in this array.
Since linear kernel memory addresses are not randomized on Samsung kernels, the virtual address of this array is constant.
On ARM64 architecture any page can be read or written through this primitive, that is accessible for the kernel, if the PFN number for the page is known.</p>
<p>Translating any linear address (including kernel heap addresses) to the corresponding PFN number is trivial, it is done by applying a constant offset and then dividing by the page size.
The PFN of the base image of the kernel can be found by searching the memory, from the beginning, for the kernel magic.
This process is very fast, as the physical memory KASLR is fairly limited, only a couple of pages need to be accessed.
Once the base image and global page table is found, any kernel virtual address can be translated to a PFN number.
As a result, the <kbd>pipe_buffer</kbd> control allows arbitrary access to any physical page, managed by the kernel, including pages of user space application swapped into physical memory.
The only limitation is that the read only parts of the kernel image cannot be patched, as they are also mapped read only in the linear address space.
When the pages are mapped for access their linear kernel address is returned.</p>
<p>The <kbd>ops</kbd> field of the <kbd>pipe_buffer</kbd> can be used to redirect control flow to achieve actual kernel code execution if someone has those kind of fetishes.</p>
<p>My proof of concept exploit first preallocates the pipe with the default number of 16 buffer pages.
Then it sprays the heap with <kbd>timerfd_create</kbd> to fill up any holes in the kmalloc-256 cache.
It triggers the race condition multiple times while trying to allocate 4 memory vector and overflow with 10.
Then the <kbd>F_SETPIPE_SZ</kbd> <a href="https://man7.org/linux/man-pages/man2/fcntl.2.html" target="_blank">fcntl</a> is called on the pipe with the size of 4 pages.
This causes the <kbd>pipe_buffer</kbd> array to be reallocated in the target cache (40x4=160), ideally this allocation lands in the shared memory.
If the overflow was not successful it can be reattempted after a bit more spraying.
Once the <kbd>pipe_buffer</kbd> is controlled it can be used to read or write any pages based on the PFN number.
The PoC scans the memory for the kernel magic, locates the kernel base image and overwrites the kernel version info string.</p>
<h2 id="demo">Demo</h2>
<p>Here is a video demo of the exploit in action on an S10!</p>
<video controls="">
  <source src="/images/blog/ss_npu_drv/06_demo_live.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>
<h2 id="closing-thoughts">Closing Thoughts</h2>
<p>In this blog post I detailed how a kernel heap overflow can be exploited on a modern Android device.
While there is strong access control (selinux) that significantly reduces the available objects to untrusted applications and there are mitigations to protect certain kernel structures (RKP, debug linked lists, iovec hardening), the kernel is still large and complex enough to provide suitable objects for exploitation.
As demonstrated in this article it is still possible to reliably exploit even a suboptimal heap overflow where the overflown data is only partially controlled.</p>

    </div>
</article>




            </div>
            

<aside class="col-12 col-md-3 float-left sidebar">
  
  <div class="sidebar-item sidebar-search">
      <h3>Search</h3>
      <form class="search-form" method="GET" action="https://labs.taszk.io/articles/search/">
          <div class="search-input">
              <input name="s" type="search" autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false">
              <button type="submit"><i class="fontawesome fas fa-search"></i></button>
          </div>
      </form>
  </div>

  
  <div class="sidebar-item sidebar-tags">
    <h3>Tags</h3>
    <div>
      
        <span>
                <a href="https://labs.taszk.io/articles/tags/bootloader/">bootloader</a>
            </span>
      
        <span>
                <a href="https://labs.taszk.io/articles/tags/huawei/">Huawei</a>
            </span>
      
        <span>
                <a href="https://labs.taszk.io/articles/tags/kernel/">kernel</a>
            </span>
      
        <span>
                <a href="https://labs.taszk.io/articles/tags/ota/">ota</a>
            </span>
      
        <span>
                <a href="https://labs.taszk.io/articles/tags/samsung/">samsung</a>
            </span>
      
        <span>
                <a href="https://labs.taszk.io/articles/tags/trustzone/">trustzone</a>
            </span>
      
    </div>
  </div>
  
  <div class="sidebar-item sidebar-archives">
    <h3>Archives</h3>
    <div>
      
        <span>
          <a href="https://labs.taszk.io/articles/archives/2018/">2018</a>
        </span>
      
        <span>
          <a href="https://labs.taszk.io/articles/archives/2021/">2021</a>
        </span>
      
    </div>
  </div>
  
  <div class="sidebar-item sidebar-authors">
    <h3>Authors</h3>
    <div>
      
        <span>
          <a href="https://labs.taszk.io/articles/author/gyorgy-miru/">Gyorgy Miru</a>
        </span>
      
        <span>
          <a href="https://labs.taszk.io/articles/author/kutyacica/">kutyacica</a>
        </span>
      
        <span>
          <a href="https://labs.taszk.io/articles/author/lorant-szabo/">Lorant Szabo</a>
        </span>
      
    </div>
  </div>
    <div class="sidebar-item sidebar-toc">
        <h3>TOC</h3><nav id="TableOfContents">
  <ul>
    <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#sve-2020-18610">SVE-2020-18610</a></li>
    <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#research-setup">Research Setup</a></li>
    <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#initial-primitive">Initial Primitive</a></li>
    <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#heap-feng-shui">Heap Feng Shui</a>
      <ul>
        <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#shaping-object">Shaping Object</a></li>
        <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#victim-object">Victim Object</a></li>
      </ul>
    </li>
    <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#what-is-old-is-new-again-and-again-and-again">What is Old is New Again and Again and Again</a></li>
    <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#not-all-memory-created-equal">Not All Memory Created Equal</a></li>
    <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#demo">Demo</a></li>
    <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#closing-thoughts">Closing Thoughts</a></li>
  </ul>
</nav></div>
</aside>



          </div>
        </div>
        <div class="floating-control-panel">
    <div class="btn-menu" id="btn-menu">
        <i class="fontawesome fas fa-th"></i>
    </div>
    <div class="btn-toggle-mode">
        <i class="fontawesome fas fa-adjust"></i>
    </div>
    <div class="btn-scroll-top">
        <i class="fontawesome fas fa-chevron-circle-up"></i>
    </div>
</div>
<aside class="sidebar-mobile" style="display: none;">
  <div class="sidebar-wrapper">
    
    <div class="sidebar-item sidebar-pages">
        <h3>Pages</h3>
        <ul>
            
            <li>
                <a href="https://labs.taszk.io/">Home</a>
            </li>
            
            <li>
                <a href="https://labs.taszk.io/articles">Articles</a>
            </li>
            
            <li>
                <a href="https://labs.taszk.io/blog">Advisories</a>
            </li>
            
            <li>
                <a href="https://taszk.io/contact">Get in touch</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>Links</h3>
        <ul>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>Tags</h3>
        <div>
            
        </div>
    </div>
    
    
    
    <div class="sidebar-item sidebar-toc">
        <h3>TOC</h3>
        <nav id="TableOfContents">
  <ul>
    <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#sve-2020-18610">SVE-2020-18610</a></li>
    <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#research-setup">Research Setup</a></li>
    <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#initial-primitive">Initial Primitive</a></li>
    <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#heap-feng-shui">Heap Feng Shui</a>
      <ul>
        <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#shaping-object">Shaping Object</a></li>
        <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#victim-object">Victim Object</a></li>
      </ul>
    </li>
    <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#what-is-old-is-new-again-and-again-and-again">What is Old is New Again and Again and Again</a></li>
    <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#not-all-memory-created-equal">Not All Memory Created Equal</a></li>
    <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#demo">Demo</a></li>
    <li><a href="https://labs.taszk.io/articles/post/bug_collision_in_samsungs_npu_driver/#closing-thoughts">Closing Thoughts</a></li>
  </ul>
</nav>
    </div>
    
    
  </div>
</aside>

    </main>

    <footer class="site-footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="site-footer-logo">
            <a href="https://labs.taszk.io/">
                <img src="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/taszk_logo_white.png" class="show-theme show-theme-none show-theme-dark" alt="logo-footer">
                <img src="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/taszk_logo.png" class="show-theme show-theme-light" alt="logo-footer">
            </a>
        </div>
      </div>
      
      <div class="col-lg-3 col-md-6">
        <div class="site-footer-widget">
          <h5 class="site-footer-widget-title">Company</h5>
          <div class="site-footer-widget-contact">
            <div class="site-footer-widget-contact-address">
              TASZK Security Labs SL<br>Rambla de Catalunya 124, 1-2<br>08008 Barcelona, Spain<br>
            </div>
            <div>
              <a href="mailto:contact@taszk.io">contact@taszk.io</a>
            </div>
            <div class="site-footer-widget-contact-pgp">
              <div class="site-footer-widget-contact-pgp-column site-footer-widget-contact-pgp-title">pgp:</div>
              <a class="site-footer-widget-contact-pgp-column site-footer-widget-contact-pgp-key" href="https://labs.taszk.io/taszk.asc" download="">
                CA86&nbsp;EB1A&nbsp;E756&nbsp;13A6&nbsp;EB30<br>073F&nbsp;6BB2&nbsp;BD92&nbsp;0E93&nbsp;5D90<br>
              </a>
            </div>
          </div>
        </div>
      </div>
      
      
      <div class="col-lg-2 col-md-6">
        <div class="site-footer-widget">
          <h5 class="site-footer-widget-title">Sitemap</h5>
          <ul class="site-footer-widget-links">
            
            <li><a href="https://labs.taszk.io/articles">Articles</a></li>
            
            <li><a href="https://labs.taszk.io/advisories">Advisories</a></li>
            
          </ul>
        </div>
      </div>
      
      
      <div class="col-lg-2 col-md-6">
        <div class="site-footer-widget">
          <h5 class="site-footer-widget-title">Community</h5>
          <ul class="site-footer-widget-links">
            
              <li><a href="https://github.com/TaszkSecLabs">Github</a></li>
            
              <li><a href="https://twitter.com/TaszkSecLabs">Twitter</a></li>
            
          </ul>
        </div>
      </div>
      
      
      <div class="col-lg-3 col-md-6 d-none d-sm-block">
        <div class="site-footer-widget">
          <h5 class="site-footer-widget-title">We provide clients:</h5>
          <p class="site-footer-widget-description">
            customized solutions for unique challenges in the embedded, mobile, automotive, wireless, and telecommunication technology sectors
          </p>
        </div>
      </div>
      
      
      <div class="col-lg-2 col-md-6">
        <div class="site-footer-widget">
          <h5 class="site-footer-widget-title">Fineprint</h5>
          <ul class="site-footer-widget-links">
            
            <li><a href="https://taszk.io/legal">Privacy Policy</a></li>
            
            <li><a href="https://taszk.io/disclosure">Disclosure Policy</a></li>
            
          </ul>
        </div>
      </div>
      
    </div>
  </div>
</footer>

    
<script defer="" src="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/medium-zoom.min.js.下載"></script>
<script defer="" src="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/lazysizes.min.js.下載"></script>
<script defer="" src="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/prism-core.min.js.下載"></script>
<script defer="" src="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/prism-autoloader.min.js.下載"></script>











<script defer="" src="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/bundle.js.下載"></script>


<link rel="stylesheet" href="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/katex.min.css">
<script defer="" src="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/katex.min.js.下載"></script>
<script defer="" src="./2021 - [BugTales] A Nerve-Racking Bug Collision in Samsung&#39;s NPU Driver_files/auto-render.min.js.下載" onload="renderMathInElement(document.body);"></script>







</body></html>