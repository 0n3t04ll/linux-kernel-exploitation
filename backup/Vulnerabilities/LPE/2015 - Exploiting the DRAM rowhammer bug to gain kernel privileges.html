<!DOCTYPE html>
<!-- saved from url=(0089)https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html -->
<html class="v2" dir="ltr" lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:b="http://www.google.com/2005/gml/b" xmlns:data="http://www.google.com/2005/gml/data" xmlns:expr="http://www.google.com/2005/gml/expr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/1529571102-css_bundle_v2.css" rel="stylesheet" type="text/css">
<meta content="width=1100" name="viewport">

<meta content="blogger" name="generator">
<link href="https://googleprojectzero.blogspot.com/favicon.ico" rel="icon" type="image/x-icon">
<link href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html" rel="canonical">
<link rel="alternate" type="application/atom+xml" title="Project Zero - Atom" href="https://googleprojectzero.blogspot.com/feeds/posts/default">
<link rel="alternate" type="application/rss+xml" title="Project Zero - RSS" href="https://googleprojectzero.blogspot.com/feeds/posts/default?alt=rss">
<link rel="service.post" type="application/atom+xml" title="Project Zero - Atom" href="https://www.blogger.com/feeds/4838136820032157985/posts/default">

<link rel="alternate" type="application/atom+xml" title="Project Zero - Atom" href="https://googleprojectzero.blogspot.com/feeds/4216316467888599950/comments/default">
<!--[if IE]><script type="text/javascript" src="https://www.blogger.com/static/v1/jsbin/1155466832-ieretrofit.js"></script>
<![endif]-->
<meta content="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html" property="og:url">
<meta content="Exploiting the DRAM rowhammer bug to gain kernel privileges" property="og:title">
<meta content="   Rowhammer blog post (draft)         Posted by Mark Seaborn, sandbox builder and breaker, with contributions by Thomas Dullien, reverse en..." property="og:description">
<!--[if IE]> <script> (function() { var html5 = ("abbr,article,aside,audio,canvas,datalist,details," + "figure,footer,header,hgroup,mark,menu,meter,nav,output," + "progress,section,time,video").split(','); for (var i = 0; i < html5.length; i++) { document.createElement(html5[i]); } try { document.execCommand('BackgroundImageCache', false, true); } catch(e) {} })(); </script> <![endif]-->
<title>Project Zero: Exploiting the DRAM rowhammer bug to gain kernel privileges</title>
<style type="text/css">@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:100%;src:url(//fonts.gstatic.com/s/opensans/v27/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4taVIGxA.woff2)format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F;}@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:100%;src:url(//fonts.gstatic.com/s/opensans/v27/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4kaVIGxA.woff2)format('woff2');unicode-range:U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116;}@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:100%;src:url(//fonts.gstatic.com/s/opensans/v27/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4saVIGxA.woff2)format('woff2');unicode-range:U+1F00-1FFF;}@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:100%;src:url(//fonts.gstatic.com/s/opensans/v27/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4jaVIGxA.woff2)format('woff2');unicode-range:U+0370-03FF;}@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:100%;src:url(//fonts.gstatic.com/s/opensans/v27/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4iaVIGxA.woff2)format('woff2');unicode-range:U+0590-05FF,U+20AA,U+25CC,U+FB1D-FB4F;}@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:100%;src:url(//fonts.gstatic.com/s/opensans/v27/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4vaVIGxA.woff2)format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB;}@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:100%;src:url(//fonts.gstatic.com/s/opensans/v27/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4uaVIGxA.woff2)format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;}@font-face{font-family:'Open Sans';font-style:normal;font-weight:400;font-stretch:100%;src:url(//fonts.gstatic.com/s/opensans/v27/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4gaVI.woff2)format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;}</style>
<style id="page-skin-1" type="text/css"><!--
/*
-----------------------------------------------
Blogger Template Style
Name:     Simple
Designer: Blogger
URL:      www.blogger.com
----------------------------------------------- */
/* Content
----------------------------------------------- */
body {
font: normal normal 12px Open Sans;
color: #000000;
background: #eeeeee none repeat scroll top left;
padding: 0 0 0 0;
}
html body .region-inner {
min-width: 0;
max-width: 100%;
width: auto;
}
h2 {
font-size: 22px;
}
a:link {
text-decoration:none;
color: #2288bb;
}
a:visited {
text-decoration:none;
color: #888888;
}
a:hover {
text-decoration:underline;
color: #33aaff;
}
.body-fauxcolumn-outer .fauxcolumn-inner {
background: transparent none repeat scroll top left;
_background-image: none;
}
.body-fauxcolumn-outer .cap-top {
position: absolute;
z-index: 1;
height: 400px;
width: 100%;
}
.body-fauxcolumn-outer .cap-top .cap-left {
width: 100%;
background: transparent none repeat-x scroll top left;
_background-image: none;
}
.content-outer {
-moz-box-shadow: 0 0 0 rgba(0, 0, 0, .15);
-webkit-box-shadow: 0 0 0 rgba(0, 0, 0, .15);
-goog-ms-box-shadow: 0 0 0 #333333;
box-shadow: 0 0 0 rgba(0, 0, 0, .15);
margin-bottom: 1px;
}
.content-inner {
padding: 10px 40px;
}
.content-inner {
background-color: #ffffff;
}
/* Header
----------------------------------------------- */
.header-outer {
background: transparent none repeat-x scroll 0 -400px;
_background-image: none;
}
.Header h1 {
font: normal normal 40px Open Sans;
color: #000000;
text-shadow: 0 0 0 rgba(0, 0, 0, .2);
}
.Header h1 a {
color: #000000;
}
.Header .description {
font-size: 18px;
color: #000000;
}
.header-inner .Header .titlewrapper {
padding: 22px 0;
}
.header-inner .Header .descriptionwrapper {
padding: 0 0;
}
/* Tabs
----------------------------------------------- */
.tabs-inner .section:first-child {
border-top: 0 solid #dddddd;
}
.tabs-inner .section:first-child ul {
margin-top: -1px;
border-top: 1px solid #dddddd;
border-left: 1px solid #dddddd;
border-right: 1px solid #dddddd;
}
.tabs-inner .widget ul {
background: transparent none repeat-x scroll 0 -800px;
_background-image: none;
border-bottom: 1px solid #dddddd;
margin-top: 0;
margin-left: -30px;
margin-right: -30px;
}
.tabs-inner .widget li a {
display: inline-block;
padding: .6em 1em;
font: normal normal 12px Open Sans;
color: #000000;
border-left: 1px solid #ffffff;
border-right: 1px solid #dddddd;
}
.tabs-inner .widget li:first-child a {
border-left: none;
}
.tabs-inner .widget li.selected a, .tabs-inner .widget li a:hover {
color: #000000;
background-color: #eeeeee;
text-decoration: none;
}
/* Columns
----------------------------------------------- */
.main-outer {
border-top: 0 solid transparent;
}
.fauxcolumn-left-outer .fauxcolumn-inner {
border-right: 1px solid transparent;
}
.fauxcolumn-right-outer .fauxcolumn-inner {
border-left: 1px solid transparent;
}
/* Headings
----------------------------------------------- */
div.widget > h2,
div.widget h2.title {
margin: 0 0 1em 0;
font: normal bold 11px 'Trebuchet MS',Trebuchet,Verdana,sans-serif;
color: #000000;
}
/* Widgets
----------------------------------------------- */
.widget .zippy {
color: #999999;
text-shadow: 2px 2px 1px rgba(0, 0, 0, .1);
}
.widget .popular-posts ul {
list-style: none;
}
/* Posts
----------------------------------------------- */
h2.date-header {
font: normal bold 11px Arial, Tahoma, Helvetica, FreeSans, sans-serif;
}
.date-header span {
background-color: #bbbbbb;
color: #ffffff;
padding: 0.4em;
letter-spacing: 3px;
margin: inherit;
}
.main-inner {
padding-top: 35px;
padding-bottom: 65px;
}
.main-inner .column-center-inner {
padding: 0 0;
}
.main-inner .column-center-inner .section {
margin: 0 1em;
}
.post {
margin: 0 0 45px 0;
}
h3.post-title, .comments h4 {
font: normal normal 22px Open Sans;
margin: .75em 0 0;
}
.post-body {
font-size: 110%;
line-height: 1.4;
position: relative;
}
.post-body img, .post-body .tr-caption-container, .Profile img, .Image img,
.BlogList .item-thumbnail img {
padding: 2px;
background: #ffffff;
border: 1px solid #eeeeee;
-moz-box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);
-webkit-box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);
box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);
}
.post-body img, .post-body .tr-caption-container {
padding: 5px;
}
.post-body .tr-caption-container {
color: #666666;
}
.post-body .tr-caption-container img {
padding: 0;
background: transparent;
border: none;
-moz-box-shadow: 0 0 0 rgba(0, 0, 0, .1);
-webkit-box-shadow: 0 0 0 rgba(0, 0, 0, .1);
box-shadow: 0 0 0 rgba(0, 0, 0, .1);
}
.post-header {
margin: 0 0 1.5em;
line-height: 1.6;
font-size: 90%;
}
.post-footer {
margin: 20px -2px 0;
padding: 5px 10px;
color: #666666;
background-color: #eeeeee;
border-bottom: 1px solid #eeeeee;
line-height: 1.6;
font-size: 90%;
}
#comments .comment-author {
padding-top: 1.5em;
border-top: 1px solid transparent;
background-position: 0 1.5em;
}
#comments .comment-author:first-child {
padding-top: 0;
border-top: none;
}
.avatar-image-container {
margin: .2em 0 0;
}
#comments .avatar-image-container img {
border: 1px solid #eeeeee;
}
/* Comments
----------------------------------------------- */
.comments .comments-content .icon.blog-author {
background-repeat: no-repeat;
background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEgAACxIB0t1+/AAAAAd0SU1FB9sLFwMeCjjhcOMAAAD+SURBVDjLtZSvTgNBEIe/WRRnm3U8RC1neQdsm1zSBIU9VVF1FkUguQQsD9ITmD7ECZIJSE4OZo9stoVjC/zc7ky+zH9hXwVwDpTAWWLrgS3QAe8AZgaAJI5zYAmc8r0G4AHYHQKVwII8PZrZFsBFkeRCABYiMh9BRUhnSkPTNCtVXYXURi1FpBDgArj8QU1eVXUzfnjv7yP7kwu1mYrkWlU33vs1QNu2qU8pwN0UpKoqokjWwCztrMuBhEhmh8bD5UDqur75asbcX0BGUB9/HAMB+r32hznJgXy2v0sGLBcyAJ1EK3LFcbo1s91JeLwAbwGYu7TP/3ZGfnXYPgAVNngtqatUNgAAAABJRU5ErkJggg==);
}
.comments .comments-content .loadmore a {
border-top: 1px solid #999999;
border-bottom: 1px solid #999999;
}
.comments .comment-thread.inline-thread {
background-color: #eeeeee;
}
.comments .continue {
border-top: 2px solid #999999;
}
/* Accents
---------------------------------------------- */
.section-columns td.columns-cell {
border-left: 1px solid transparent;
}
.blog-pager {
background: transparent url(//www.blogblog.com/1kt/simple/paging_dot.png) repeat-x scroll top center;
}
.blog-pager-older-link, .home-link,
.blog-pager-newer-link {
background-color: #ffffff;
padding: 5px;
}
.footer-outer {
border-top: 1px dashed #bbbbbb;
}
/* Mobile
----------------------------------------------- */
body.mobile  {
background-size: auto;
}
.mobile .body-fauxcolumn-outer {
background: transparent none repeat scroll top left;
}
.mobile .body-fauxcolumn-outer .cap-top {
background-size: 100% auto;
}
.mobile .content-outer {
-webkit-box-shadow: 0 0 3px rgba(0, 0, 0, .15);
box-shadow: 0 0 3px rgba(0, 0, 0, .15);
}
.mobile .tabs-inner .widget ul {
margin-left: 0;
margin-right: 0;
}
.mobile .post {
margin: 0;
}
.mobile .main-inner .column-center-inner .section {
margin: 0;
}
.mobile .date-header span {
padding: 0.1em 10px;
margin: 0 -10px;
}
.mobile h3.post-title {
margin: 0;
}
.mobile .blog-pager {
background: transparent none no-repeat scroll top center;
}
.mobile .footer-outer {
border-top: none;
}
.mobile .main-inner, .mobile .footer-inner {
background-color: #ffffff;
}
.mobile-index-contents {
color: #000000;
}
.mobile-link-button {
background-color: #2288bb;
}
.mobile-link-button a:link, .mobile-link-button a:visited {
color: #ffffff;
}
.mobile .tabs-inner .section:first-child {
border-top: none;
}
.mobile .tabs-inner .PageList .widget-content {
background-color: #eeeeee;
color: #000000;
border-top: 1px solid #dddddd;
border-bottom: 1px solid #dddddd;
}
.mobile .tabs-inner .PageList .widget-content .pagelist-arrow {
border-left: 1px solid #dddddd;
}

--></style>
<style id="template-skin-1" type="text/css"><!--
body {
min-width: 1120px;
}
.content-outer, .content-fauxcolumn-outer, .region-inner {
min-width: 1120px;
max-width: 1120px;
_width: 1120px;
}
.main-inner .columns {
padding-left: 0;
padding-right: 310px;
}
.main-inner .fauxcolumn-center-outer {
left: 0;
right: 310px;
/* IE6 does not respect left and right together */
_width: expression(this.parentNode.offsetWidth -
parseInt("0") -
parseInt("310px") + 'px');
}
.main-inner .fauxcolumn-left-outer {
width: 0;
}
.main-inner .fauxcolumn-right-outer {
width: 310px;
}
.main-inner .column-left-outer {
width: 0;
right: 100%;
margin-left: -0;
}
.main-inner .column-right-outer {
width: 310px;
margin-right: -310px;
}
#layout {
min-width: 0;
}
#layout .content-outer {
min-width: 0;
width: 800px;
}
#layout .region-inner {
min-width: 0;
width: auto;
}
body#layout div.add_widget {
padding: 8px;
}
body#layout div.add_widget a {
margin-left: 32px;
}
--></style>
<link href="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/authorization.css" media="all" onload="if(media!=&#39;all&#39;)media=&#39;all&#39;" rel="stylesheet"><noscript><link href='https://www.blogger.com/dyn-css/authorization.css?targetBlogID=4838136820032157985&amp;zx=f95ae7d3-0fc1-4592-a0f5-cd7d7ae2d9a1' rel='stylesheet'/></noscript>
<meta name="google-adsense-platform-account" content="ca-host-pub-1556223355139109">
<meta name="google-adsense-platform-domain" content="blogspot.com">

<script type="text/javascript" src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/f.txt"></script><style>.gc-bubbleDefault{table-layout:auto!important}.gc-bubbleDefault,.gc-reset{background-color:transparent!important;text-align:left;padding:0!important;margin:0!important;border:0!important}.pls-bubbleTop{border-bottom:1px solid #ccc!important}.pls-contentLeft,.pls-topTail,.pls-vertShimLeft{background-image:url(//ssl.gstatic.com/s2/oz/images/stars/po/bubblev1/border_3.gif)!important}.pls-topTail{background-repeat:repeat-x!important;background-position:bottom!important}.pls-vertShim{background-color:#fff!important;text-align:right}.tbl-grey .pls-vertShim{background-color:#f5f5f5!important}.pls-vertShimLeft{background-repeat:repeat-y!important;background-position:100%!important;height:4px}.pls-vertShimRight{height:4px}.pls-confirm-container .pls-vertShim{background-color:#fff3c2!important}.pls-contentWrap{background-color:#fff!important;position:relative!important;vertical-align:top}.pls-contentLeft{background-repeat:repeat-y;background-position:100%;vertical-align:top}.pls-dropRight{background-image:url(//ssl.gstatic.com/s2/oz/images/stars/po/bubblev1/bubbleDropR_3.png)!important;background-repeat:repeat-y!important}.pls-dropBL,.pls-dropBottom,.pls-dropRight,.pls-dropTR .pls-dropBR,.pls-tailleft,.pls-vert,.pls-vert img{vertical-align:top}.pls-dropBottom{background-image:url(//ssl.gstatic.com/s2/oz/images/stars/po/bubblev1/bubbleDropB_3.png)!important;background-repeat:repeat-x!important;width:100%}.pls-topLeft{text-align:right}.pls-topLeft,.pls-topRight{background:inherit!important;vertical-align:bottom}.pls-topRight{text-align:left}.pls-bottomLeft{background:inherit!important;text-align:right}.pls-bottomRight{background:inherit!important;text-align:left;vertical-align:top}.pls-tailbottom,.pls-tailleft,.pls-tailright,.pls-tailtop{display:none;position:relative}.pls-dropBL,.pls-dropBR,.pls-dropTR,.pls-tailbottom,.pls-tailleft,.pls-tailright,.pls-tailtop{background-image:url(//ssl.gstatic.com/s2/oz/images/stars/po/bubblev1/bubbleSprite_3.png)!important;background-repeat:no-repeat}.tbl-grey .pls-dropBL,.tbl-grey .pls-dropBR,.tbl-grey .pls-dropTR,.tbl-grey .pls-tailbottom,.tbl-grey .pls-tailleft,.tbl-grey .pls-tailright,.tbl-grey .pls-tailtop{background-image:url(//ssl.gstatic.com/s2/oz/images/stars/po/bubblev1/bubbleSprite-grey.png)!important}.pls-tailbottom{background-position:-23px 0}.pls-confirm-container .pls-tailbottom{background-position:-23px -10px}.pls-tailtop{background-position:-19px -20px}.pls-tailright{background-position:0 0}.pls-tailleft{background-position:-10px 0}.pls-tailtop{vertical-align:top}.gc-bubbleDefault td{line-height:0;font-size:0}.pls-tailbottom,.pls-topLeft img,.pls-topRight img{vertical-align:bottom}.bubbleDropTR,.pls-bottomLeft,.pls-bottomLeft img,.pls-dropBottom img,.pls-dropBottomL img,.pls-dropBottomR img{vertical-align:top}.pls-dropTR{background-position:0 -22px}.pls-dropBR{background-position:0 -27px}.pls-dropBL{background-position:0 -16px}.pls-spacerbottom,.pls-spacerleft,.pls-spacerright,.pls-spacertop{position:static!important}.pls-spinner{bottom:0;position:absolute;left:0;margin:auto;right:0;top:0}</style></head>
<body class=" variant-simplysimple">
<div class="navbar section" id="navbar" name="Navbar"><div class="widget Navbar" data-version="1" id="Navbar1"><script src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/cb=gapi.loaded_1" async=""></script><script src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/cb=gapi(1).loaded_0" async=""></script><script type="text/javascript">
    function setAttributeOnload(object, attribute, val) {
      if(window.addEventListener) {
        window.addEventListener('load',
          function(){ object[attribute] = val; }, false);
      } else {
        window.attachEvent('onload', function(){ object[attribute] = val; });
      }
    }
  </script>
<div id="navbar-iframe-container"><iframe ng-non-bindable="" frameborder="0" hspace="0" marginheight="0" marginwidth="0" scrolling="no" style="" tabindex="0" vspace="0" width="100%" id="navbar-iframe" name="navbar-iframe" src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/navbar.html"></iframe></div>
<script type="text/javascript" src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/plusone.js.下載" gapi_processed="true"></script>
<script type="text/javascript">
      gapi.load("gapi.iframes:gapi.iframes.style.bubble", function() {
        if (gapi.iframes && gapi.iframes.getContext) {
          gapi.iframes.getContext().openChild({
              url: 'https://www.blogger.com/navbar.g?targetBlogID\x3d4838136820032157985\x26blogName\x3dProject+Zero\x26publishMode\x3dPUBLISH_MODE_BLOGSPOT\x26navbarType\x3dLIGHT\x26layoutType\x3dLAYOUTS\x26searchRoot\x3dhttps://googleprojectzero.blogspot.com/search\x26blogLocale\x3den\x26v\x3d2\x26homepageUrl\x3dhttps://googleprojectzero.blogspot.com/\x26targetPostID\x3d4216316467888599950\x26blogPostOrPageUrl\x3dhttps://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html\x26vt\x3d-3678287074125469345',
              where: document.getElementById("navbar-iframe-container"),
              id: "navbar-iframe"
          });
        }
      });
    </script><script type="text/javascript">
(function() {
var script = document.createElement('script');
script.type = 'text/javascript';
script.src = '//pagead2.googlesyndication.com/pagead/js/google_top_exp.js';
var head = document.getElementsByTagName('head')[0];
if (head) {
head.appendChild(script);
}})();
</script>
</div></div>
<div class="body-fauxcolumns">
<div class="fauxcolumn-outer body-fauxcolumn-outer">
<div class="cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left">
<div class="fauxborder-right"></div>
<div class="fauxcolumn-inner">
</div>
</div>
<div class="cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
</div>
<div class="content">
<div class="content-fauxcolumns">
<div class="fauxcolumn-outer content-fauxcolumn-outer">
<div class="cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left">
<div class="fauxborder-right"></div>
<div class="fauxcolumn-inner">
</div>
</div>
<div class="cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
</div>
<div class="content-outer">
<div class="content-cap-top cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left content-fauxborder-left">
<div class="fauxborder-right content-fauxborder-right"></div>
<div class="content-inner">
<header>
<div class="header-outer">
<div class="header-cap-top cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left header-fauxborder-left">
<div class="fauxborder-right header-fauxborder-right"></div>
<div class="region-inner header-inner">
<div class="header section" id="header" name="Header"><div class="widget Header" data-version="1" id="Header1">
<div id="header-inner">
<div class="titlewrapper">
<h1 class="title">
<a href="https://googleprojectzero.blogspot.com/">
Project Zero
</a>
</h1>
</div>
<div class="descriptionwrapper">
<p class="description"><span>News and updates from the Project Zero team at Google</span></p>
</div>
</div>
</div></div>
</div>
</div>
<div class="header-cap-bottom cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
</header>
<div class="tabs-outer">
<div class="tabs-cap-top cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left tabs-fauxborder-left">
<div class="fauxborder-right tabs-fauxborder-right"></div>
<div class="region-inner tabs-inner">
<div class="tabs no-items section" id="crosscol" name="Cross-Column"></div>
<div class="tabs no-items section" id="crosscol-overflow" name="Cross-Column 2"></div>
</div>
</div>
<div class="tabs-cap-bottom cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
<div class="main-outer">
<div class="main-cap-top cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left main-fauxborder-left">
<div class="fauxborder-right main-fauxborder-right"></div>
<div class="region-inner main-inner">
<div class="columns fauxcolumns">
<div class="fauxcolumn-outer fauxcolumn-center-outer">
<div class="cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left">
<div class="fauxborder-right"></div>
<div class="fauxcolumn-inner">
</div>
</div>
<div class="cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
<div class="fauxcolumn-outer fauxcolumn-left-outer">
<div class="cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left">
<div class="fauxborder-right"></div>
<div class="fauxcolumn-inner">
</div>
</div>
<div class="cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
<div class="fauxcolumn-outer fauxcolumn-right-outer">
<div class="cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left">
<div class="fauxborder-right"></div>
<div class="fauxcolumn-inner">
</div>
</div>
<div class="cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
<!-- corrects IE6 width calculation -->
<div class="columns-inner">
<div class="column-center-outer">
<div class="column-center-inner">
<div class="main section" id="main" name="Main"><div class="widget Blog" data-version="1" id="Blog1">
<div class="blog-posts hfeed">

          <div class="date-outer">
        
<h2 class="date-header"><span>Monday, March 9, 2015</span></h2>

          <div class="date-posts">
        
<div class="post-outer">
<div class="post hentry uncustomized-post-template" itemprop="blogPost" itemscope="itemscope" itemtype="http://schema.org/BlogPosting">
<meta content="4838136820032157985" itemprop="blogId">
<meta content="4216316467888599950" itemprop="postId">
<a name="4216316467888599950"></a>
<h3 class="post-title entry-title" itemprop="name">
Exploiting the DRAM rowhammer bug to gain kernel privileges
</h3>
<div class="post-header">
<div class="post-header-line-1"></div>
</div>
<div class="post-body entry-content" id="post-body-4216316467888599950" itemprop="description articleBody">



<title>Rowhammer blog post (draft)</title>


<style>

table {
  border-collapse: collapse;
}

td, th {
  border-width: 1pt;
  border-style: solid;
  width: 85.5pt;
  padding: 5pt;
  vertical-align: bottom;
}

</style>




<p>Posted by Mark Seaborn, sandbox builder and breaker, with contributions by Thomas Dullien, reverse engineer</p>

<p><i>[This guest post continues Project Zero’s practice of promoting excellence in security research on the Project Zero blog]</i></p>

<h1>Overview</h1>

<p>“Rowhammer” is a problem with some recent DRAM devices in which repeatedly accessing a row of memory can cause bit flips in adjacent rows.  We tested a selection of laptops and found that a subset of them exhibited the problem.  We built two working privilege escalation exploits that use this effect.  One exploit uses rowhammer-induced bit flips to gain kernel privileges on x86-64 Linux when run as an unprivileged userland process.  When run on a machine vulnerable to the rowhammer problem, the process was able to induce bit flips in page table entries (PTEs).  It was able to use this to gain write access to its own page table, and hence gain read-write access to all of physical memory.</p>

<p>We don’t know for sure how many machines are vulnerable to this attack, or how many existing vulnerable machines are fixable.  Our exploit uses the x86 <tt>CLFLUSH</tt> instruction to generate many accesses to the underlying DRAM, but other techniques might work on non-x86 systems too.</p>

<p>We expect our PTE-based exploit could be made to work on other operating systems; it is not inherently Linux-specific.  Causing bit flips in PTEs is just one avenue of exploitation; other avenues for exploiting bit flips can be practical too.  Our other exploit demonstrates this by escaping from the Native Client sandbox.</p>

<h1>Introduction to the rowhammer problem</h1>

<p>We learned about the rowhammer problem from Yoongu Kim et al’s paper, “<a href="http://users.ece.cmu.edu/~yoonguk/papers/kim-isca14.pdf">Flipping Bits in Memory Without Accessing Them: An Experimental Study of DRAM Disturbance Errors</a>” (Yoongu Kim, Ross Daly, Jeremie Kim, Chris Fallin, Ji Hye Lee, Donghyuk Lee, Chris Wilkerson, Konrad Lai, Onur Mutlu).</p>

<p>They demonstrate that, by repeatedly accessing two “aggressor” memory locations within the process’s virtual address space, they can cause bit flips in a third, “victim” location.  The victim location is potentially outside the virtual address space of the process — it is in a different DRAM row from the aggressor locations, and hence in a different 4k page (since rows are larger than 4k in modern systems).</p>

<p>This works because DRAM cells have been getting smaller and closer together.  As DRAM manufacturing scales down chip features to smaller physical dimensions, to fit more memory capacity onto a chip, it has become harder to prevent DRAM cells from interacting electrically with each other.  As a result, accessing one location in memory can disturb neighbouring locations, causing charge to leak into or out of neighbouring cells.  With enough accesses, this can change a cell’s value from 1 to 0 or vice versa.</p>

<p>The paper explains that this tiny snippet of code can cause bit flips:</p>

<pre>code1a:
  mov (X), %eax  // Read from address X
  mov (Y), %ebx  // Read from address Y
  clflush (X)  // Flush cache for address X
  clflush (Y)  // Flush cache for address Y
  jmp code1a</pre>

<p>Two ingredients are required for this routine to cause bit flips:</p>

<ul><li>

<p><strong>Address selection:</strong>  For <tt>code1a</tt> to cause bit flips, addresses X and Y must map to different rows of DRAM in the same bank.</p>

<p>Some background:  Each DRAM chip contains many rows of cells.  Accessing a byte in memory involves transferring data from the row into the chip’s “row buffer” (discharging the row’s cells in the process), reading or writing the row buffer’s contents, and then copying the row buffer’s contents back to the original row’s cells (recharging the cells).</p>

<p>It is this process of “activating” a row (discharging and recharging it) that can disturb adjacent rows.  If this is done enough times, in between automatic refreshes of the adjacent rows (which usually occur every 64ms), this can cause bit flips in the adjacent rows.</p>

<p>The row buffer acts as a cache, so if addresses X and Y point to the same row, then <tt>code1a</tt> will just read from the row buffer without activating the row repeatedly.</p>

<p>Furthermore, each bank of DRAM has its own notion of a “currently activated row”.  So if addresses X and Y point to different banks, <tt>code1a</tt> will just read from those banks’ row buffers without activating rows repeatedly.  (Banks are groups of DRAM chips whose rows are activated in lockstep.)</p>

<p>However, if X and Y point to different rows in the same bank, <tt>code1a</tt> will cause X and Y’s rows to be repeatedly activated.  This is termed “row hammering”.</p>
</li>

<li>
<p><strong>Bypassing the cache:</strong>  Without <tt>code1a</tt>’s <tt>CLFLUSH</tt> instructions, the memory reads (<tt>MOV</tt>s) will be served from the CPU’s cache.  Flushing the cache using <tt>CLFLUSH</tt> forces the memory accesses to be sent to the underlying DRAM, which is necessary to cause the rows to be repeatedly activated.</p>

<p>Note that the paper’s version of <tt>code1a</tt> also includes an <tt>MFENCE</tt> instruction.  However, we found that using <tt>MFENCE</tt> was unnecessary and actually reduced the number of bit flips we saw.  Yoongu Kim’s modified memtest also omits the <tt>MFENCE</tt> from its row hammering code.</p>
</li>

</ul>

<h1>Refining the selection of addresses to hammer</h1>

<h3>Using the physical address mapping</h3>

<p>How can we pick pairs of addresses that satisfy the “different row, same bank” requirements?</p>

<p>One possibility is to use knowledge of how the CPU’s memory controller maps physical addresses to DRAM’s row, column and bank numbers, along with knowledge of either:</p>

<ul><li>The absolute physical addresses of memory we have access to.  Linux allows this via <tt>/proc/<em>PID</em>/pagemap</tt>.</li>

<li>The relative physical addresses of memory we have access to.  Linux can allow this via its support for “huge pages”, which cover 2MB of contiguous physical address space per page.  Whereas a normal 4k page is smaller than a typical DRAM row, a 2MB page will typically cover multiple rows, some of which will be in the same bank.</li>

</ul>

<p>Yoongu Kim et al take this approach.  They pick Y = X + 8MByte based on knowledge of the physical address mapping used by the memory controllers in Intel and AMD’s CPUs.</p>

<h3>Random address selection</h3>

<p>The CPU’s physical address mapping can be difficult to determine, though, and features such as <tt>/proc/<em>PID</em>/pagemap</tt> and huge pages are not available everywhere.  Furthermore, if our guesses about the address mapping are wrong, we might pick an offset that pessimises our chances of successful row hammering.  (For example, Y = X + 8 kByte might always give addresses in different banks.)</p>

<p>A simpler approach is to pick address pairs at random.  We allocate a large block of memory (e.g. 1GB) and then pick random virtual addresses within that block.  On a machine with 16 DRAM banks (as one of our test machines has: 2 DIMMs with 8 banks per DIMM), this gives us a 1/16 chance that the chosen addresses are in the same bank, which is quite high.  (The chance of picking two addresses in the same row is negligible.)</p>

<p>Furthermore, we can increase our chances of successful row hammering by modifying <tt>code1a</tt> to hammer more addresses per loop iteration.  We find we can hammer 4 or 8 addresses without slowing down the time per iteration.</p>

<h3>Selecting addresses using timing</h3>

<p>Another way to determine whether a pair of addresses has the “different row, same bank” property would be to time uncached accesses to those addresses using a fine-grained timer such as the <tt>RDTSC</tt> instruction.  The access time will be slower for pairs that satisfy this property than those that don’t.</p>

<h3>Double-sided hammering</h3>

<p>We have found that we can increase the chances of getting bit flips in row N by row-hammering both of its neighbours (rows N-1 and N+1), rather than by hammering one neighbour and a more-distant row.  We dub this “double-sided hammering”.</p>

<p>For many machines, double-sided hammering is the only way of producing bit flips in reasonable time.  For machines where random selection is already sufficient to cause bit flips, double-sided hammering can lead to a vastly increased number of bits flipped.  We have observed 25+ bits flipped in one row on one particularly fragile machine.</p>

<p>Performing double-sided hammering is made more complicated by the underlying memory geometry.  It requires the attacker to know or guess what the offset will be, in physical address space, between two rows that are in the same bank <em>and</em> are adjacent.  Let’s call this the “row offset”.</p>

<p>From our testing, we were able to naively extrapolate that the row offset for laptop Model #4 (see the table below) is 256k.  We did this by observing the likelihood of bit flips relative to the distance the selected physical memory pages had from the victim page.  This likelihood was maximized when we hammered the locations 256k below and above a given target row.</p>

<p>This “256k target memory area, 256k victim memory area, 256k target memory area” setup has shown itself to be quite effective on other laptops by the same vendor.  It is likely that this setup needs to be tweaked for other vendors. </p>

<p>This 256k row offset could probably be explained as being a product of the row size (number of columns), number of banks, number of channels, etc., of the DRAM in this machine, though this requires further knowledge of how the hardware maps physical addresses to row and bank numbers.</p>

<p>Doing double-sided hammering does require that we can pick physically-contiguous pages (e.g. via <tt>/proc/<em>PID</em>/pagemap</tt> or huge pages).</p>

<h1>Exploiting rowhammer bit flips</h1>

<p>Yoongu Kim et al say that “With some engineering effort, we believe we can develop Code 1a into a disturbance attack that … hijacks control of the system”, but say that they leave this research task for the future.  We took on this task!</p>

<p>We found various machines that exhibit bit flips (see the experimental results below).  Having done that, we wrote two exploits:</p>

<ul><li><a href="https://code.google.com/p/google-security-research/issues/detail?id=284">The first</a> runs as a <a href="https://developer.chrome.com/native-client">Native Client</a> (NaCl) program and escalates privilege to escape from NaCl’s x86-64 sandbox, acquiring the ability to call the host OS’s syscalls directly.  We have mitigated this by changing NaCl to disallow the <tt>CLFLUSH</tt> instruction.  (I picked NaCl as the first exploit target because I work on NaCl and have written proof-of-concept NaCl sandbox escapes before.)</li>

<li><a href="https://code.google.com/p/google-security-research/issues/detail?id=283">The second</a> runs as a normal x86-64 process on Linux and escalates privilege to gain access to all of physical memory.  This is harder to mitigate on existing machines.</li>

</ul>

<h3>NaCl sandbox escape</h3>

<p>Native Client is a sandboxing system that allows running a subset of x86-64 machine code (among other architectures) inside a sandbox.  Before running an x86-64 executable, NaCl uses a validator to check that its code conforms to <a href="https://developer.chrome.com/native-client/reference/sandbox_internals/x86-64-sandbox#x86-64-sandbox">a subset of x86 instructions that NaCl deems to be safe</a>.</p>

<p>However, NaCl assumes that the hardware behaves correctly.  It assumes that memory locations don’t change without being written to!  NaCl’s approach of validating machine code is particularly vulnerable to bit flips, because:</p>

<ul><li>A bit flip in validated code can turn a safe instruction sequence into an unsafe one.</li>

<li>Under NaCl, the sandboxed program’s code segment is readable by the program.  This means the program can check whether a bit flip has occurred and determine whether or how it can exploit the change.</li>

</ul>

<p>Our exploit targets NaCl’s instruction sequence for sandboxed indirect jumps, which looks like this:</p>

<pre>  andl $~31, %eax  // Truncate address to 32 bits and mask to be 32-byte-aligned.
  addq %r15, %rax  // Add %r15, the sandbox base address.
  jmp *%rax  // Indirect jump.</pre>

<p>The exploit works by triggering bit flips in that code sequence.  It knows how to exploit 13% of the possible bit flips.  Currently it only handles bit flips that modify register numbers.  (With more work, it could handle more exploitable cases, such as opcode changes.)  For example, if a bit flip occurs in bit 0 of the register number in “<tt>jmp *%rax</tt>”, this morphs to “<tt>jmp *%rcx</tt>”, which is easily exploitable — since <tt>%rcx</tt> is unconstrained, this allows jumping to any address.  Normally NaCl only allows indirect jumps to 32-byte-aligned addresses (and it ensures that instructions do not cross 32-byte bundle boundaries).  Once a program can jump to an unaligned address, it can escape the sandbox, because it is possible to hide unsafe x86 instructions inside safe ones.  For example:</p>

<pre>  20ea0:       48 b8 0f 05 eb 0c f4 f4 f4 f4    movabs $0xf4f4f4f40ceb050f,%rax</pre>

<p>This hides a <tt>SYSCALL</tt> instruction (<tt>0f 05</tt>) at address 0x20ea2.</p>

<p>Our NaCl exploit does the following:</p>

<ul>
<li>
It fills the sandbox’s dynamic code area with 250MB of NaClized indirect jump instruction sequences using NaCl’s <tt>dyncode_create()</tt> API.
</li>

<li>
In a loop:

<ul>
<li>It row-hammers the dynamic code area using <tt>CLFLUSH</tt>, picking random pairs of addresses.</li>

<li>It searches the dynamic code area for bit flips.  If it sees an exploitable bit flip, it uses it to jump to shell code hidden inside NaCl-validated instructions.  Otherwise, if the bit flip isn’t exploitable, it continues.</li>
</ul>

</li>
</ul>

<p>We have mitigated this by changing NaCl’s x86 validator to disallow the <tt>CLFLUSH</tt> instruction (tracked by CVE-2015-0565).  However, there might be other ways to cause row hammering besides <tt>CLFLUSH</tt> (see below).</p>

<p>Prior to disallowing <tt>CLFLUSH</tt> in NaCl, it may have been possible to chain this NaCl exploit together with the kernel privilege escalation below so that a NaCl app in the Chrome Web Store app could gain kernel privileges, using just one underlying hardware bug for the whole chain.  To our knowledge there was no such app in the Chrome Web Store.  PNaCl — which is available on the open web — has an extra layer of protection because an attacker would have had to find an exploit in the PNaCl translator before being able to emit a <tt>CLFLUSH</tt> instruction.</p>

<h3>Kernel privilege escalation</h3>

<p>Our kernel privilege escalation works by using row hammering to induce a bit flip in a page table entry (PTE) that causes the PTE to point to a physical page containing a page table of the attacking process.  This gives the attacking process read-write access to one of its own page tables, and hence to all of physical memory.</p>

<p>There are two things that help ensure that the bit flip has a high probability of being exploitable:</p>

<ol>

<li>
<p>Rowhammer-induced bit flips tend to be repeatable.  This means we can tell in advance if a DRAM cell tends to flip and whether this bit location will be useful for the exploit.</p>

<p>For example, bit 51 in a 64-bit word is the top bit of the physical page number in a PTE on x86-64.  If this changes from 0 to 1, that will produce a page number that's bigger than the system's physical memory, which isn't useful for our exploit, so we can skip trying to use this bit flip.  However, bit 12 is the bottom bit of the PTE's physical page number.  If that changes from 0 to 1 or from 1 to 0, the PTE will still point to a valid physical page.</p>
</li>

<li>
<p>We spray most of physical memory with page tables.  This means that when a PTE's physical page number changes, there's a high probability that it will point to a page table for our process.</p>

<p>We do this spraying by <tt>mmap()</tt>ing the same file repeatedly.  This can be done quite quickly: filling 3GB of memory with page tables takes about 3 seconds on our test machine.</p>
</li>

</ol>

<p>There are two caveats:</p>

<ul><li>Our exploit runs in a normal Linux process.  More work may be required for this to work inside a sandboxed Linux process (such as a Chromium renderer process).</li>

<li>We tested on a machine with low memory pressure.  Making this work on a heavily-loaded machine may involve further work.</li>

</ul>

<h4>Break it down: exploit steps</h4>

<p>The first step is to search for aggressor/victim addresses that produce useful bit flips:</p>

<ul><li><tt>mmap()</tt> a large block of memory.</li>

<li>Search this block for aggressor/victim addresses by row-hammering random address pairs.  Alternatively, we can use aggressor/victim physical addresses that were discovered and recorded on a previous run; we use <tt>/proc/self/pagemap</tt> to search for these in memory.</li>

<li>If we find aggressor/victim addresses where the bit flipped within the 64-bit word isn’t useful for the exploit, just skip that address set.</li>

<li>Otherwise, <tt>munmap()</tt> all but the aggressor and victim pages and begin the exploit attempt.</li>

</ul>

<p>In preparation for spraying page tables, we create a file in <tt>/dev/shm</tt> (a shared memory segment) that we will <tt>mmap()</tt> repeatedly.  (See later for how we determine its size.)  We write a marker value at the start of each 4k page in the file so that we can easily identify these pages later, when checking for PTE changes.</p>

<p>Note that we don’t want these data pages to be allocated from sequential physical addresses, because then flips in the lower bits of physical page numbers would tend to be unexploitable:  A PTE pointing to one data page would likely change to pointing to another data page.</p>

<p>To avoid that problem, we first deliberately fragment physical memory so that the kernel’s allocations from physical memory are randomised:</p>

<ul><li><tt>mmap()</tt> (with <tt>MAP_POPULATE</tt>) a block of memory that’s a large fraction of the machine’s physical memory size.</li>

<li>Later, whenever we do something that will cause the kernel to allocate a 4k page (such as a page table), we release a page from this block using <tt>madvise()</tt> + <tt>MADV_DONTNEED</tt>.</li>

</ul>

<p>We are now ready to spray memory with page tables.  To do this, we <tt>mmap()</tt> the data file repeatedly:</p>

<ul><li>We want each mapping to be at a 2MB-aligned virtual address, since each 4k page table covers a 2MB region of virtual address space.  We use <tt>MAP_FIXED</tt> for this.</li>

<li>We cause the kernel to populate some of the PTEs by accessing their corresponding pages.  We only need to populate one PTE per page table:  We know our bit flip hits the Nth PTE in a page table, so, for speed, we only fault in the Nth 4k page in each 2MB chunk.</li>

<li>Linux imposes a limit of about 2^16 on the number of VMAs (<tt>mmap()</tt>’d regions) a process can have.  This means that our <tt>/dev/shm</tt> data file must be large enough such that, when mapped 2^16 times, the mappings create enough page tables to fill most of physical memory.  At the same time, we want to keep the data file as small as possible so as not to waste memory that could instead be filled with page tables.  We pick its size accordingly.</li>

<li>In the middle of this, we <tt>munmap()</tt> the victim page.  With a high probability, the kernel will reuse this physical page as a page table.  We can’t touch this page directly any more, but we can potentially modify it via row hammering.</li>

</ul>

<p>Having finished spraying, it’s hammer time.  We hammer the aggressor addresses.  Hopefully this induces the bit flip in the victim page.  We can’t observe the bit flip directly (unlike in the NaCl exploit).</p>

<p>Now we can check whether PTEs changed exploitably.  We scan the large region we mapped to see whether any of the PTEs now point to pages other than our data file.  Again, for speed, we only need to check the Nth page within each 2MB chunk.  We can check for the marker value we wrote earlier.  If we find no marker mismatches, our attempt failed (and we could retry).</p>

<p>If we find a marker mismatch, then we have gained illicit access to a physical page.  Hopefully this is one of the page tables for our address space.  If we want to be careful, we can verify whether this page looks like one of our page tables.  The Nth 64-bit field should look like a PTE (certain bits will be set or unset) and the rest should be zero.  If not, our attempt failed (and we could retry).</p>

<p>At this point, we have write access to a page table, probably our own.  However, we don’t yet know which virtual address this is the page table for.  We can determine that as follows:</p>

<ul><li>Write a PTE to the page (e.g. pointing to physical page 0).</li>

<li>Do a second scan of address space to find a second virtual page that now points to somewhere other than our data file.  If we don’t find it, our attempt failed (and we could retry).</li>

</ul>

<h4>Exploiting write access to page tables</h4>

<p>We now have write access to one of our process’s page tables.  By modifying the page table, we can get access to any page in physical memory.  We now have many options for how to exploit that, varying in portability, convenience and speed.  The portable options work without requiring knowledge of kernel data structures.  Faster options work in O(1) time, whereas slower options might require scanning all of physical memory to locate a data structure.</p>

<p>Some options are:</p>

<ul><li>Currently implemented option:  Modify a SUID-root executable such as <tt>/bin/ping</tt>, overwriting its entry point with our shell code, and then run it.  Our shell code will then run as root.  This approach is fast and portable, but it does require access to <tt>/proc/<em>PID</em>/pagemap</tt>:  We load <tt>/bin/ping</tt> (using <tt>open()</tt> and <tt>mmap()</tt>+<tt>MAP_POPULATE</tt>) and query which physical pages it was loaded into using <tt>/proc/self/pagemap</tt>.</li>

<li>A similar approach is to modify a library that a SUID executable uses, such as <tt>/lib64/ld-linux-x86-64.so.2</tt>.  (On some systems, SUID executables such as <tt>/bin/ping</tt> can’t be <tt>open()</tt>’d because their permissions have been locked down.)</li>

<li>
Other, less portable approaches are to modify kernel code or kernel data structures.

<ul>
<li>We could modify our process’s UID field.  This would require locating the “struct cred” for the current process and knowing its layout.</li>
<li>We could modify the kernel’s syscall handling code.  We can quickly determine its physical address using the SIDT instruction, which is exposed to unprivileged code.</li>
</ul>

</li>
</ul>

<h1>Routes for causing row hammering</h1>

<p>Our proof-of-concept exploits use the x86 <tt>CLFLUSH</tt> instruction, because it’s the easiest way to force memory accesses to be sent to the underlying DRAM and thus cause row hammering.</p>

<p>The fact that <tt>CLFLUSH</tt> is usable from unprivileged code is surprising, because the number of legitimate uses for it outside of a kernel or device driver is probably very small.  For comparison, ARM doesn’t have an unprivileged cache-flush instruction.  (ARM Linux does have a <tt>cacheflush()</tt> syscall, used by JITs, for synchronising instruction and data caches.  On x86, the i-cache and d-cache are synchronised automatically, so <tt>CLFLUSH</tt> isn’t needed for this purpose.)</p>

<p>We have changed NaCl’s x86 validator to disallow <tt>CLFLUSH</tt>.  Unfortunately, kernels can’t disable <tt>CLFLUSH</tt> for normal userland code.  Currently, <tt>CLFLUSH</tt> can’t be intercepted or disabled, even using VMX (x86 virtualisation).  (For example, <tt>RDTSC</tt> can be intercepted without VMX support.  VMX allows intercepting more instructions, including <tt>WBINVD</tt> and <tt>CPUID</tt>, but not <tt>CLFLUSH</tt>.)  There might be a case for changing the x86 architecture to allow <tt>CLFLUSH</tt> to be intercepted.  From a security engineering point of view, removing unnecessary attack surface is good practice.</p>

<p>However, there might be ways of causing row hammering without <tt>CLFLUSH</tt>, which might work on non-x86 architectures too:</p>

<ul>

<li>
<p><strong>Normal memory accesses:</strong>  Is it possible that normal memory accesses, in sufficient quantity or in the right pattern, can trigger enough cache misses to cause rowhammer-induced bit flips?  This would require generating cache misses at every cache level (L1, L2, L3, etc.).  Whether this is feasible could depend on the associativity of these caches.</p>

<p>If this is possible, it would be a serious problem, because it might be possible to generate bit flips from JavaScript code on the open web, perhaps via JavaScript typed arrays.</p>
</li>

<li>
<p><strong>Non-temporal memory accesses:</strong>  On x86, these include non-temporal stores (<tt>MOVNTI</tt>, <tt>MOVNTQ</tt>, <tt>MOVNTDQ(A)</tt>, <tt>MOVNTPD</tt>, <tt>MOVNTSD</tt> and <tt>MOVNTSS</tt>) and non-temporals reads (via prefetches — <tt>PREFETCHNTA</tt>).</p>
</li>

<li>
<p><strong>Atomic memory accesses:</strong>  Some reports claim that non-malicious use of spinlocks can cause row hammering, although the reports have insufficient detail and we’ve not been able to verify this.  (See “<a href="http://www.futureplus.com/images/FS2800/The%20Known%20Failure%20Mechanism%20in%20DDR3%20memory%20called%20Row%20Hammer.pdf">The Known Failure Mechanism in DDR3 memory called ‘Row Hammer’</a>”, Barbara Aichinger.)  This seems unlikely on a multi-core system where cores share the highest-level cache.  However, it might be possible on multi-socket systems where some pairs of cores don’t share any cache.</p>
</li>

<li>
<p><strong>Misaligned atomic memory accesses:</strong>  x86 CPUs guarantee that instructions with a <tt>LOCK</tt> prefix access memory atomically, even if the address being accessed is misaligned, and even if it crosses a cache line boundary.  (See section 8.1.2.2, “Software Controlled Bus Locking”, in <a href="http://download.intel.com/products/processor/manual/325462.pdf">Intel’s architecture reference</a>, which says “The integrity of a bus lock is not affected by the alignment of the memory field”.)  This is done for backwards compatibility.  In this case, the CPU doesn’t use modern cache coherency protocols for atomicity.  Instead, the CPU falls back to the older mechanism of locking the bus, and we believe it might use uncached memory accesses.  (On some multi-CPU-socket NUMA machines, this locking is <a href="http://www.drdobbs.com/parallel/quickpath-interconnect-rules-of-the-rev/221600290?pgno=5">implemented via the QPI protocol</a> rather than via a physical #LOCK pin.)</p>

<p>If misaligned atomic ops generate uncached DRAM accesses, they might be usable for row hammering.</p>

<p>Initial investigation suggests that these atomic ops do bypass the cache, but that they are too slow for this to generate enough memory accesses, within a 64ms refresh period, to generate bit flips.</p>
</li>

<li>
<p><strong>Uncached pages:</strong>  For example, Windows’ <tt>CreateFileMapping()</tt> API has a <tt>SEC_NOCACHE</tt> flag for requesting a non-cacheable page mapping.</p>
</li>

<li>
<p><strong>Other OS interfaces:</strong>  There might be cases in which kernels or device drivers, such as GPU drivers, do uncached memory accesses on behalf of userland code.</p>
</li>

</ul>

<h1>Experimental results</h1>

<p>We tested a selection of x86 laptops that were readily available to us (all with non-ECC memory) using <tt>CLFLUSH</tt> with the “random address selection” approach above.  We found that a large subset of these machines exhibited rowhammer-induced bit flips.  The results are shown in the table below.</p>

<p>The testing was done using the <tt>rowhammer-test</tt> program available here:
<br><a href="https://github.com/google/rowhammer-test">https://github.com/google/rowhammer-test</a></p>

<p>Note that:</p>

<ul><li>Our sample size was not large enough that it can be considered representative.</li>

<li>A negative result (an absence of bit flips) on a given machine does not definitively mean that it is not possible for rowhammer to cause bit flips on that machine.  We have not performed enough testing to determine that a given machine is not vulnerable.</li>

</ul>

<p>As a result, we have decided to anonymize our results below.</p>

<p>All of the machines tested used DDR3 DRAM.  It was not possible to identify the age of the DRAM in all cases.</p>

<table cellpadding="0" cellspacing="0"><tbody><tr><th></th>
<th>Laptop model</th>
<th>Laptop year</th>
<th>CPU family (microarchitecture)</th>
<th>DRAM manufacturer</th>
<th>Saw bit flip</th>
</tr>

<tr><td>1</td>
<td>Model #1</td>
<td>2010</td>
<td>Family V</td>
<td>DRAM vendor E</td>
<td>yes</td>
</tr>

<tr><td>2</td>
<td>Model #2</td>
<td>2011</td>
<td>Family W</td>
<td>DRAM vendor A</td>
<td>yes</td>
</tr>

<tr><td>3</td>
<td>Model #2</td>
<td>2011</td>
<td>Family W</td>
<td>DRAM vendor A</td>
<td>yes</td>
</tr>

<tr><td>4</td>
<td>Model #2</td>
<td>2011</td>
<td>Family W</td>
<td>DRAM vendor E</td>
<td>no</td>
</tr>

<tr><td>5</td>
<td>Model #3</td>
<td>2011</td>
<td>Family W</td>
<td>DRAM vendor A</td>
<td>yes</td>
</tr>

<tr><td>6</td>
<td>Model #4</td>
<td>2012</td>
<td>Family W</td>
<td>DRAM vendor A</td>
<td>yes</td>
</tr>

<tr><td>7</td>
<td>Model #5</td>
<td>2012</td>
<td>Family X</td>
<td>DRAM vendor C</td>
<td>no</td>
</tr>

<tr><td>8</td>
<td>Model #5</td>
<td>2012</td>
<td>Family X</td>
<td>DRAM vendor C</td>
<td>no</td>
</tr>

<tr><td>9</td>
<td>Model #5</td>
<td>2013</td>
<td>Family X</td>
<td>DRAM vendor B</td>
<td>yes</td>
</tr>

<tr><td>10</td>
<td>Model #5</td>
<td>2013</td>
<td>Family X</td>
<td>DRAM vendor B</td>
<td>yes</td>
</tr>

<tr><td>11</td>
<td>Model #5</td>
<td>2013</td>
<td>Family X</td>
<td>DRAM vendor B</td>
<td>yes</td>
</tr>

<tr><td>12</td>
<td>Model #5</td>
<td>2013</td>
<td>Family X</td>
<td>DRAM vendor B</td>
<td>yes</td>
</tr>

<tr><td>13</td>
<td>Model #5</td>
<td>2013</td>
<td>Family X</td>
<td>DRAM vendor B</td>
<td>yes</td>
</tr>

<tr><td>14</td>
<td>Model #5</td>
<td>2013</td>
<td>Family X</td>
<td>DRAM vendor B</td>
<td>yes</td>
</tr>

<tr><td>15</td>
<td>Model #5</td>
<td>2013</td>
<td>Family X</td>
<td>DRAM vendor B</td>
<td>yes</td>
</tr>

<tr><td>16</td>
<td>Model #5</td>
<td>2013</td>
<td>Family X</td>
<td>DRAM vendor B</td>
<td>yes</td>
</tr>

<tr><td>17</td>
<td>Model #5</td>
<td>2013</td>
<td>Family X</td>
<td>DRAM vendor C</td>
<td>no</td>
</tr>

<tr><td>18</td>
<td>Model #5</td>
<td>2013</td>
<td>Family X</td>
<td>DRAM vendor C</td>
<td>no</td>
</tr>

<tr><td>19</td>
<td>Model #5</td>
<td>2013</td>
<td>Family X</td>
<td>DRAM vendor C</td>
<td>no</td>
</tr>

<tr><td>20</td>
<td>Model #5</td>
<td>2013</td>
<td>Family X</td>
<td>DRAM vendor C</td>
<td>no</td>
</tr>

<tr><td>21</td>
<td>Model #5</td>
<td>2013</td>
<td>Family X</td>
<td>DRAM vendor C</td>
<td>yes</td>
</tr>

<tr><td>22</td>
<td>Model #5</td>
<td>2013</td>
<td>Family X</td>
<td>DRAM vendor C</td>
<td>yes</td>
</tr>

<tr><td>23</td>
<td>Model #6</td>
<td>2013</td>
<td>Family Y</td>
<td>DRAM vendor A</td>
<td>no</td>
</tr>

<tr><td>24</td>
<td>Model #6</td>
<td>2013</td>
<td>Family Y</td>
<td>DRAM vendor B</td>
<td>no</td>
</tr>

<tr><td>25</td>
<td>Model #6</td>
<td>2013</td>
<td>Family Y</td>
<td>DRAM vendor B</td>
<td>no</td>
</tr>

<tr><td>26</td>
<td>Model #6</td>
<td>2013</td>
<td>Family Y</td>
<td>DRAM vendor B</td>
<td>no</td>
</tr>

<tr><td>27</td>
<td>Model #6</td>
<td>2013</td>
<td>Family Y</td>
<td>DRAM vendor B</td>
<td>no</td>
</tr>

<tr><td>28</td>
<td>Model #7</td>
<td>2012</td>
<td>Family W</td>
<td>DRAM vendor D</td>
<td>no</td>
</tr>

<tr><td>29</td>
<td>Model #8</td>
<td>2014</td>
<td>Family Z</td>
<td>DRAM vendor A</td>
<td>no</td>
</tr>

</tbody></table>

<p>We also tested some desktop machines, but did not see any bit flips on those.  That could be because they were all relatively high-end machines with ECC memory.  The ECC could be hiding bit flips.</p>

<h3>Testing your own machine</h3>

<p>Users may wish to test their own machines using the <tt>rowhammer-test</tt> tool above.  If a machine produces bit flips during testing, users may wish to adjust security and trust decisions regarding the machine accordingly.</p>

<p>While an absence of bit flips during testing on a given machine does not automatically imply safety, it does provide some baseline assurance that causing bit flips is at least difficult on that machine.</p>

<h1>Mitigations</h1>

<h3>Targeted refreshes of adjacent rows</h3>

<p>Some schemes have been proposed for preventing rowhammer-induced bit flips by changing DRAM, memory controllers, or both.</p>

<p>A system could ensure that, within a given refresh period, it does not activate any given row too many times without also ensuring that neighbouring rows are refreshed.  Yoongu Kim et al discuss this in their paper.  They refer to proposals “to maintain an array of counters” (either in the memory controller or in DRAM) for counting activations.  The paper proposes an alternative, probabilistic scheme called “PARA”, which is stateless and thus does not require maintaining counters.</p>

<p>There are signs that some newer hardware implements mitigations:</p>

<ul>
<li>
<p>JEDEC’s recently-published LPDDR4 standard for DRAM (where “LP” = “Low Power”) specifies two rowhammer mitigation features that a memory controller would be expected to use.  (See <a href="http://www.jedec.org/standards-documents/results/jesd209-4">JEDEC document JESD209-4</a> — registration is required to download specs from the JEDEC site, but it’s free.)</p>

<ul>
<li>“Targeted Row Refresh” (TRR) mode, which allows the memory controller to ask the DRAM device to refresh a row’s neighbours.</li>
<li>A “Maximum Activate Count” (MAC) metadata field, which specifies how many activations a row can safely endure before its neighbours need refreshing.</li>
</ul>

<p>(The LPDDR4 spec does not mention “rowhammer” by name, but it does use the term “victim row”.)</p>
</li>

<li>We found that at least one DRAM vendor indicates, in their public data sheets, that they implement rowhammer mitigations internally within a DRAM device, requiring no special memory controller support.</li>

</ul>

<p>Some of the newer models of laptops that we tested did not exhibit bit flips.  A possible explanation is that these laptops implement some rowhammer mitigations.</p>

<h3>BIOS updates and increasing refresh rates</h3>

<p>Have hardware vendors silently rolled out any BIOS updates to mitigate the rowhammer problem by changing how the BIOS configures the CPU’s memory controller?</p>

<p>As an experiment, we measured the time required to cause a bit flip via double-sided hammering on one Model #4 laptop.  This ran in the “less than 5 minutes” range.  Then we updated the laptop’s BIOS to the latest version and re-ran the hammering test.</p>

<p>We initially thought this BIOS update had fixed the issue.  However, after almost 40 minutes of sequentially hammering memory, some locations exhibited bit flips.</p>

<p>We conjecture that the BIOS update increased the DRAM refresh rate, making it harder — but not impossible — to cause enough disturbance between DRAM refresh cycles.  This fits with data from Yoongu Kim et al’s paper (see Figure 4) which shows that, for some DRAM modules, a refresh period of 32ms is not short enough to reduce the error rate to zero.</p>

<p>We have not done a wider test of BIOS updates on other laptops.</p>

<h3>Monitoring for row hammering using perf counters</h3>

<p>It might be possible to detect row hammering attempts using CPUs’ performance counters.  In order to hammer an area of DRAM effectively, an attacker must generate a large number of accesses to the underlying DRAM in a short amount of time.  Whether this is done using <tt>CLFLUSH</tt> or using only normal memory accesses, it will generate a large number of cache misses.</p>

<p>Modern CPUs provide mechanisms that allow monitoring of cache misses for purposes of performance analysis.  These mechanisms can be repurposed by a defender to monitor the system for sudden bursts of cache misses, as truly cache-pessimal access patterns appear to be rare in typical laptop and desktop workloads.  By measuring “time elapsed per N cache misses” and monitoring for abnormal changes, we have been able to detect aggressive hammering even on systems that were running under a heavy load (a multi-core Linux kernel compile) during the attack.  Unfortunately, while detection seems possible for aggressive hammering, it is unclear what to do in response, and unclear how common false positives will be.</p>

<p>While it is likely that attackers can adapt their attacks to evade such monitoring, this would increase the required engineering effort, making this monitoring somewhat comparable to an intrusion detection system.</p>

<h1>On disclosures</h1>

<p>The computing industry (of which Google is a part) is accustomed to security bugs in software.  It has developed an understanding of the importance of public discussion and disclosure of security issues.  Through these public discussions, it has developed a better understanding of when bugs have security implications.  Though the industry is less accustomed to hardware bugs, hardware security can benefit from the same processes of public discussion and disclosure.</p>

<p>With this in mind, we can draw two lessons:</p>

<ul>

<li>
<p><strong>Exploitability of the bug:</strong>  Looking backward, had there been more public disclosures about the rowhammer problem, it might have been identified as an exploitable security issue sooner.  It appears that vendors have known about rowhammer for a while, as shown by the presence of rowhammer mitigations in LPDDR4.  It may be that vendors only considered rowhammer to be a reliability problem.</p>
</li>

<li>
<p><strong>Evaluating machines:</strong>  Looking forward, the release of more technical information about rowhammer would aid evaluation of which machines are vulnerable and which are not.  At the time of writing, it is difficult to tell which machines are definitely safe from rowhammer.  Testing can show that a machine is vulnerable, but not that it is invulnerable.</p>
</li>

</ul>

<p>We explore these two points in more detail below.</p>

<h3>On exploitability of bugs</h3>

<p>Vendors may have considered rowhammer to be only a reliability issue, and assumed that it is too difficult to exploit.  None of the public material we have seen on rowhammer (except for the paper by Yoongu Kim et al) discusses security implications.</p>

<p>However, many bugs that appear to be difficult to exploit have turned out to be exploitable.  These bugs might initially appear to be “only” reliability issues, but are really security issues.</p>

<p>An extreme example of a hard-to-exploit bug is described in a recent Project Zero blog post (see “<a href="http://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html">The poisoned NUL byte, 2014 edition</a>”).  This shows how an off-by-one NUL byte overwrite could be exploited to gain root privileges from a normal user account.</p>

<p>To many security researchers, especially those who practice writing proof-of-concept exploits, it is well known that bit flips can be exploitable.  For example, a 2003 paper explains how to use random bit flips to escape from a Java VM.  (See “<a href="https://www.cs.princeton.edu/~appel/papers/memerr.pdf">Using Memory Errors to Attack a Virtual Machine</a>” by Sudhakar Govindavajhala and Andrew W. Appel.)</p>

<p>Furthermore, as we have shown, rowhammer-induced bit flips are sometimes more easily exploitable than random bit flips, because they are repeatable.</p>

<h3>On vulnerability of machines</h3>

<p>We encourage vendors to publicly release information about past, current and future devices so that security researchers, and the public at large, can evaluate them with reference to the rowhammer problem.</p>

<p>The following information would be helpful:</p>

<ul>

<li>
<p>For each model of DRAM device:</p>

<ul>
<li>Is the DRAM device susceptible to rowhammer-induced bit flips at the physical level?</li>
<li>What rowhammer mitigations does the DRAM device implement?  Does it implement TRR and MAC?  Does it implement mitigations that require support from the memory controller, or internal mitigations that don't require this?</li>
</ul>

</li>

<li>
<p>For each model of CPU:</p>

<ul>
<li>What mitigations does the CPU's memory controller implement?  Do these mitigations require support from the DRAM devices?</li>

<li>Is there public documentation for how to program the memory controller on machine startup?</li>

<li>Is it possible to read or write the memory controller's settings after startup, to verify mitigations or enable mitigations?</li>

<li>What scheme does the memory controller use for mapping physical addresses to DRAM row, bank and column numbers?  This is useful for determining which memory access patterns can cause row hammering.</li>
</ul>

</li>

<li>
<p>For each BIOS:  What rowhammer mitigations does the BIOS enable in the CPU's memory controller settings?  For example, does the BIOS enable a double refresh rate, or enable use of TRR?  Is it possible to review this?</p>
</li>

</ul>

<p>At the time of writing, we weren't able to find publicly available information on the above in most cases.</p>

<p>If more of this information were available, it would be easier to assess which machines are vulnerable.  It would be easier to evaluate a negative test result, i.e. the absence of bit flips during testing.  We could explain that a negative result for a machine is because (for example) its DRAM implements mitigations internally, or because its DRAM isn't susceptible at the physical level (because it was manufactured using an older process), or because its BIOS enables 2x refresh.  Such an explanation would give us more confidence that the negative test result occurred not because our end-to-end testing was insufficient in some way, but because the machine is genuinely not vulnerable to rowhammer.</p>

<p>We expect researchers will be interested in evaluating the details of rowhammer mitigation algorithms.  For example, does a device count row activations (as the MAC scheme suggests they should), or does it use probabilistic methods like PARA?  Will the mitigations be effective against double-sided row hammering as well as single-sided hammering?  Could there be any problems if both the DRAM device and memory controller independently implement their own rowhammer mitigations?</p>

<h1>Conclusion</h1>

<p>We have shown two ways in which the DRAM rowhammer problem can be exploited to escalate privileges.  History has shown that issues that are thought to be “only” reliability issues often have significant security implications, and the rowhammer problem is a good example of this.  Many layers of software security rest on the assumption the contents of memory locations don't change unless the locations are written to.</p>

<p>The public discussion of software flaws and their exploitation has greatly expanded our industry’s understanding of computer security in past decades, and responsible software vendors advise users when their software is vulnerable and provide updates.  Though the industry is less accustomed to hardware bugs than to software bugs, we would like to encourage hardware vendors to take the same approach:  thoroughly analyse the security impact of “reliability” issues, provide explanations of impact, offer mitigation strategies and — when possible — supply firmware or BIOS updates.  Such discussion will lead to more secure hardware, which will benefit all users.</p>

<h1>Credits</h1>

<ul><li>Matthew Dempsky proposed that bit flips in PTEs could be an effective route for exploiting rowhammer.</li>

<li>Thomas Dullien helped with investigating how many machines are affected, came up with double-sided hammering, ran the BIOS upgrade experiment, and helped fill in the details of the PTE bit flipping exploit.</li>

</ul>


<div style="clear: both;"></div>
</div>
<div class="post-footer">
<div class="post-footer-line post-footer-line-1">
<span class="post-author vcard">
Posted by
<span class="fn" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person">
<span itemprop="name">Unknown</span>
</span>
</span>
<span class="post-timestamp">
at
<meta content="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html" itemprop="url">
<a class="timestamp-link" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html" rel="bookmark" title="permanent link"><abbr class="published" itemprop="datePublished" title="2015-03-09T08:59:00-07:00">8:59 AM</abbr></a>
</span>
<span class="post-comment-link">
</span>
<span class="post-icons">
<span class="item-control blog-admin pid-836442233">
<a href="https://www.blogger.com/post-edit.g?blogID=4838136820032157985&amp;postID=4216316467888599950&amp;from=pencil" title="Edit Post">
<img alt="" class="icon-action" height="18" src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/icon18_edit_allbkg.gif" width="18">
</a>
</span>
</span>
<div class="post-share-buttons goog-inline-block">
<a class="goog-inline-block share-button sb-email" href="https://www.blogger.com/share-post.g?blogID=4838136820032157985&amp;postID=4216316467888599950&amp;target=email" target="_blank" title="Email This"><span class="share-button-link-text">Email This</span></a><a class="goog-inline-block share-button sb-blog" href="https://www.blogger.com/share-post.g?blogID=4838136820032157985&amp;postID=4216316467888599950&amp;target=blog" onclick="window.open(this.href, &quot;_blank&quot;, &quot;height=270,width=475&quot;); return false;" target="_blank" title="BlogThis!"><span class="share-button-link-text">BlogThis!</span></a><a class="goog-inline-block share-button sb-twitter" href="https://www.blogger.com/share-post.g?blogID=4838136820032157985&amp;postID=4216316467888599950&amp;target=twitter" target="_blank" title="Share to Twitter"><span class="share-button-link-text">Share to Twitter</span></a><a class="goog-inline-block share-button sb-facebook" href="https://www.blogger.com/share-post.g?blogID=4838136820032157985&amp;postID=4216316467888599950&amp;target=facebook" onclick="window.open(this.href, &quot;_blank&quot;, &quot;height=430,width=640&quot;); return false;" target="_blank" title="Share to Facebook"><span class="share-button-link-text">Share to Facebook</span></a><a class="goog-inline-block share-button sb-pinterest" href="https://www.blogger.com/share-post.g?blogID=4838136820032157985&amp;postID=4216316467888599950&amp;target=pinterest" target="_blank" title="Share to Pinterest"><span class="share-button-link-text">Share to Pinterest</span></a>
</div>
</div>
<div class="post-footer-line post-footer-line-2">
<span class="post-labels">
</span>
</div>
<div class="post-footer-line post-footer-line-3">
<span class="post-location">
</span>
</div>
</div>
</div>
<div class="comments" id="comments">
<a name="comments"></a>
<h4>40 comments:</h4>
<div class="comments-content">
<script async="async" src="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html" type="text/javascript"></script>
<script type="text/javascript">
    (function() {
      var items = null;
      var msgs = null;
      var config = {};

// <![CDATA[
      var cursor = null;
      if (items && items.length > 0) {
        cursor = parseInt(items[items.length - 1].timestamp) + 1;
      }

      var bodyFromEntry = function(entry) {
        var text = (entry &&
                    ((entry.content && entry.content.$t) ||
                     (entry.summary && entry.summary.$t))) ||
            '';
        if (entry && entry.gd$extendedProperty) {
          for (var k in entry.gd$extendedProperty) {
            if (entry.gd$extendedProperty[k].name == 'blogger.contentRemoved') {
              return '<span class="deleted-comment">' + text + '</span>';
            }
          }
        }
        return text;
      }

      var parse = function(data) {
        cursor = null;
        var comments = [];
        if (data && data.feed && data.feed.entry) {
          for (var i = 0, entry; entry = data.feed.entry[i]; i++) {
            var comment = {};
            // comment ID, parsed out of the original id format
            var id = /blog-(\d+).post-(\d+)/.exec(entry.id.$t);
            comment.id = id ? id[2] : null;
            comment.body = bodyFromEntry(entry);
            comment.timestamp = Date.parse(entry.published.$t) + '';
            if (entry.author && entry.author.constructor === Array) {
              var auth = entry.author[0];
              if (auth) {
                comment.author = {
                  name: (auth.name ? auth.name.$t : undefined),
                  profileUrl: (auth.uri ? auth.uri.$t : undefined),
                  avatarUrl: (auth.gd$image ? auth.gd$image.src : undefined)
                };
              }
            }
            if (entry.link) {
              if (entry.link[2]) {
                comment.link = comment.permalink = entry.link[2].href;
              }
              if (entry.link[3]) {
                var pid = /.*comments\/default\/(\d+)\?.*/.exec(entry.link[3].href);
                if (pid && pid[1]) {
                  comment.parentId = pid[1];
                }
              }
            }
            comment.deleteclass = 'item-control blog-admin';
            if (entry.gd$extendedProperty) {
              for (var k in entry.gd$extendedProperty) {
                if (entry.gd$extendedProperty[k].name == 'blogger.itemClass') {
                  comment.deleteclass += ' ' + entry.gd$extendedProperty[k].value;
                } else if (entry.gd$extendedProperty[k].name == 'blogger.displayTime') {
                  comment.displayTime = entry.gd$extendedProperty[k].value;
                }
              }
            }
            comments.push(comment);
          }
        }
        return comments;
      };

      var paginator = function(callback) {
        if (hasMore()) {
          var url = config.feed + '?alt=json&v=2&orderby=published&reverse=false&max-results=50';
          if (cursor) {
            url += '&published-min=' + new Date(cursor).toISOString();
          }
          window.bloggercomments = function(data) {
            var parsed = parse(data);
            cursor = parsed.length < 50 ? null
                : parseInt(parsed[parsed.length - 1].timestamp) + 1
            callback(parsed);
            window.bloggercomments = null;
          }
          url += '&callback=bloggercomments';
          var script = document.createElement('script');
          script.type = 'text/javascript';
          script.src = url;
          document.getElementsByTagName('head')[0].appendChild(script);
        }
      };
      var hasMore = function() {
        return !!cursor;
      };
      var getMeta = function(key, comment) {
        if ('iswriter' == key) {
          var matches = !!comment.author
              && comment.author.name == config.authorName
              && comment.author.profileUrl == config.authorUrl;
          return matches ? 'true' : '';
        } else if ('deletelink' == key) {
          return config.baseUri + '/delete-comment.g?blogID='
               + config.blogId + '&postID=' + comment.id;
        } else if ('deleteclass' == key) {
          return comment.deleteclass;
        }
        return '';
      };

      var replybox = null;
      var replyUrlParts = null;
      var replyParent = undefined;

      var onReply = function(commentId, domId) {
        if (replybox == null) {
          // lazily cache replybox, and adjust to suit this style:
          replybox = document.getElementById('comment-editor');
          if (replybox != null) {
            replybox.height = '250px';
            replybox.style.display = 'block';
            replyUrlParts = replybox.src.split('#');
          }
        }
        if (replybox && (commentId !== replyParent)) {
          replybox.src = '';
          document.getElementById(domId).insertBefore(replybox, null);
          replybox.src = replyUrlParts[0]
              + (commentId ? '&parentID=' + commentId : '')
              + '#' + replyUrlParts[1];
          replyParent = commentId;
        }
      };

      var hash = (window.location.hash || '#').substring(1);
      var startThread, targetComment;
      if (/^comment-form_/.test(hash)) {
        startThread = hash.substring('comment-form_'.length);
      } else if (/^c[0-9]+$/.test(hash)) {
        targetComment = hash.substring(1);
      }

      // Configure commenting API:
      var configJso = {
        'maxDepth': config.maxThreadDepth
      };
      var provider = {
        'id': config.postId,
        'data': items,
        'loadNext': paginator,
        'hasMore': hasMore,
        'getMeta': getMeta,
        'onReply': onReply,
        'rendered': true,
        'initComment': targetComment,
        'initReplyThread': startThread,
        'config': configJso,
        'messages': msgs
      };

      var render = function() {
        if (window.goog && window.goog.comments) {
          var holder = document.getElementById('comment-holder');
          window.goog.comments.render(holder, provider);
        }
      };

      // render now, or queue to render when library loads:
      if (window.goog && window.goog.comments) {
        render();
      } else {
        window.goog = window.goog || {};
        window.goog.comments = window.goog.comments || {};
        window.goog.comments.loadQueue = window.goog.comments.loadQueue || [];
        window.goog.comments.loadQueue.push(render);
      }
    })();
// ]]>
  </script>
<div id="comment-holder">
<div class="comment-thread toplevel-thread"><ol id="top-ra"><li class="comment" id="c2625455324619866373"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/17939776721560429069" rel="nofollow">Zerith</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1425932302733#c2625455324619866373">March 9, 2015 at 1:18 PM</a></span></div><p class="comment-content">Very impressive. What is scarier is that this problem will remain with us for years to come since it might not be possible to "patch" it</p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="2625455324619866373" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-231370818"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=2625455324619866373">Delete</a></span></span></div><div class="comment-replies"><div id="c2625455324619866373-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c2625455324619866373-ra" class="thread-chrome thread-expanded"><div></div><div id="c2625455324619866373-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="2625455324619866373" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c2625455324619866373-ce"></div></li><li class="comment" id="c8422409742189452931"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/07377707159254963285" rel="nofollow">WANg Gai</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1425932895172#c8422409742189452931">March 9, 2015 at 1:28 PM</a></span></div><p class="comment-content">Does the test results above make a distinction between DDR3 and DDR3L memory?  It seems like that family Y and Z are completely immune to rowhammering, X is a coin-flip, and W is mostly vulnerable.  It should be noted that Intel started supporting the lower voltage DDR3L as an option in Ivy Bridge machines, and then made it mandatory in Haswells and above.  Could this be a factor as well?</p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="8422409742189452931" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-309737988"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=8422409742189452931">Delete</a></span></span></div><div class="comment-replies"><div id="c8422409742189452931-rt" class="comment-thread inline-thread"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c8422409742189452931-ra" class="thread-chrome thread-expanded"><div><li class="comment" id="c8224864756118664234"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/09353075846536678409" rel="nofollow">PhilHibbs</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1425985049104#c8224864756118664234">March 10, 2015 at 3:57 AM</a></span></div><p class="comment-content">There's only one entry for family Z so it's probably not safe to say that it's completely immune.</p><span class="comment-actions secondary-text"><span class="item-control blog-admin blog-admin pid-382432610"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=8224864756118664234">Delete</a></span></span></div><div class="comment-replies"><div id="c8224864756118664234-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c8224864756118664234-ra" class="thread-chrome thread-expanded"><div></div><div id="c8224864756118664234-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="8224864756118664234" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c8224864756118664234-ce"></div></li><li class="comment" id="c9124215791415451884"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/17817528639756561358" rel="nofollow">rasorfishsl</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1426029600926#c9124215791415451884">March 10, 2015 at 4:20 PM</a></span></div><p class="comment-content">It would depend far more on the Silicon' construction techniques used by various memory builders.<br><br>What might be an 'interesting'  test would be to see if it only applies to the complete CRAP they sell into the consumer markets or if it applies to  the high level quality memory used in top end servers.<br><br>This might also be useable in 'fake' Static' rams where the actual internal array is Dram but then it attempts to look like a Static ram externally :-), by having internal refresh circuitry<br><br>If i was running research I would run tests in this area Static ram area as well, I would suspect that it might be more susceptible.</p><span class="comment-actions secondary-text"><span class="item-control blog-admin blog-admin pid-167427958"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=9124215791415451884">Delete</a></span></span></div><div class="comment-replies"><div id="c9124215791415451884-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c9124215791415451884-ra" class="thread-chrome thread-expanded"><div></div><div id="c9124215791415451884-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="9124215791415451884" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c9124215791415451884-ce"></div></li><li class="comment" id="c1350862706523267587"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/17315694220686248753" rel="nofollow">Michael Sporer</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1426639757328#c1350862706523267587">March 17, 2015 at 5:49 PM</a></span></div><p class="comment-content">Rowhammer is a design defect in the memory array. It will show up in all devices in a manufacturers' process node regardless of 2/3/4/3L or LP.  It cannot be screened out.  <br><br>Pseudo-SRAM could also be susceptible if they are built with a defective bitcell design. </p><span class="comment-actions secondary-text"><span class="item-control blog-admin blog-admin pid-33697961"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=1350862706523267587">Delete</a></span></span></div><div class="comment-replies"><div id="c1350862706523267587-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c1350862706523267587-ra" class="thread-chrome thread-expanded"><div></div><div id="c1350862706523267587-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="1350862706523267587" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c1350862706523267587-ce"></div></li></div><div id="c8422409742189452931-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="8422409742189452931" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c8422409742189452931-ce"></div></li><li class="comment" id="c3679234734078602364"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/16914631309336495959" rel="nofollow">Unknown</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1425937633765#c3679234734078602364">March 9, 2015 at 2:47 PM</a></span></div><p class="comment-content">This comment has been removed by the author.</p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="3679234734078602364" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin "><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=3679234734078602364">Delete</a></span></span></div><div class="comment-replies"><div id="c3679234734078602364-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c3679234734078602364-ra" class="thread-chrome thread-expanded"><div></div><div id="c3679234734078602364-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="3679234734078602364" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c3679234734078602364-ce"></div></li><li class="comment" id="c1294716145509609668"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blank.gif" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user">Anonymous</cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1425938286495#c1294716145509609668">March 9, 2015 at 2:58 PM</a></span></div><p class="comment-content">aww you ruined my crowdfunding campaign on Darkleaks</p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="1294716145509609668" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-558445630"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=1294716145509609668">Delete</a></span></span></div><div class="comment-replies"><div id="c1294716145509609668-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c1294716145509609668-ra" class="thread-chrome thread-expanded"><div></div><div id="c1294716145509609668-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="1294716145509609668" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c1294716145509609668-ce"></div></li><li class="comment" id="c2254760499187266083"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/02144567637645740322" rel="nofollow">Passmark</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1425946761409#c2254760499187266083">March 9, 2015 at 5:19 PM</a></span></div><p class="comment-content">For testing the full memory range, outside of an operating system, there is also MemTest86 V6.0, which also implements a row hammer test.</p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="2254760499187266083" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-630037275"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=2254760499187266083">Delete</a></span></span></div><div class="comment-replies"><div id="c2254760499187266083-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c2254760499187266083-ra" class="thread-chrome thread-expanded"><div></div><div id="c2254760499187266083-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="2254760499187266083" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c2254760499187266083-ce"></div></li><li class="comment" id="c5423947724791306278"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blank.gif" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user">Anonymous</cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1425953302581#c5423947724791306278">March 9, 2015 at 7:08 PM</a></span></div><p class="comment-content">Glad desktops have better chances of being safe (although all of my credit cards are in the cloud) :) I turned this off after 500 iterations on desktop with not result while executing on a popular hosting provider exited on the first one!</p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="5423947724791306278" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-558445630"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=5423947724791306278">Delete</a></span></span></div><div class="comment-replies"><div id="c5423947724791306278-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c5423947724791306278-ra" class="thread-chrome thread-expanded"><div></div><div id="c5423947724791306278-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="5423947724791306278" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c5423947724791306278-ce"></div></li><li class="comment" id="c5074148664826706836"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/12583828764274874899" rel="nofollow">Anababa</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1425967759524#c5074148664826706836">March 9, 2015 at 11:09 PM</a></span></div><p class="comment-content">Impressive!!!<br><br>This exploit technology can be definitely applied to hypervisor, and cause privilege escalation to VMX root mode.<br></p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="5074148664826706836" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-1625399489"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=5074148664826706836">Delete</a></span></span></div><div class="comment-replies"><div id="c5074148664826706836-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c5074148664826706836-ra" class="thread-chrome thread-expanded"><div></div><div id="c5074148664826706836-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="5074148664826706836" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c5074148664826706836-ce"></div></li><li class="comment" id="c2298086454882586327"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/06675203936437102219" rel="nofollow">Unknown</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1425972843422#c2298086454882586327">March 10, 2015 at 12:34 AM</a></span></div><p class="comment-content">AMD makes available the information you've requested but were unable to find. See the aptly named BIOS and Kernel Developer's Guides, which have been publicly available for years.<br><br>An example of from their most recent "Steamroller" cores: http://support.amd.com/TechDocs/49125_15h_Models_30h-3Fh_BKDG.pdf<br><br>Of your requests:<br>* "What mitigations does the CPU's memory controller implement? Do these mitigations require support from the DRAM devices?"<br><br>Do you want to know which mitigation schemes from the research paper are available? Likely few! It may not surprise you, but hardware takes a long time to change (assuredly longer than software).<br><br>If you want to know current DRAM refresh time, see D18F2x8C on page 365 for each DRAM controller. Bits 17:16 define the hardware refresh rate. A value of 3 in this field means the refresh rate is double normal. Section 2.9.14 "DRAM On DIMM Thermal Management and Power Capping" explains that the controller may speed refresh rate because of temperature.<br><br>* "Is there public documentation for how to program the memory controller on machine startup?"<br><br>Section 2.9 "DRAM Controllers (DCTs)" contains the subsection 2.9.9, "DCT/DRAM Initialization and Resume".<br><br>* "What scheme does the memory controller use for mapping physical addresses to DRAM row, bank and column numbers?"<br><br>This is set per DRAM controller. See the definition for D18F2x80 on page 363. Also Section 2.9.11 for the Channel and Chip Select interleaving settings. You may also want to read the definition for D18F2x[5C:40] on pages 358-360 to see how chip select is done.<br><br>* "Is it possible to read or write the memory controller's settings after startup, to verify mitigations or enable mitigations?"<br><br>Reading: Yes, MSRs and PCI configuration space values make this available to kernel mode software as shown in BKDG.<br><br>Writing: This is harder. Many DRAM controller settings require BIOS intervention and may break in protected mode. Worth trying!</p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="2298086454882586327" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-753405521"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=2298086454882586327">Delete</a></span></span></div><div class="comment-replies"><div id="c2298086454882586327-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c2298086454882586327-ra" class="thread-chrome thread-expanded"><div></div><div id="c2298086454882586327-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="2298086454882586327" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c2298086454882586327-ce"></div></li><li class="comment" id="c7479657276858226738"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/05554370494427278306" rel="nofollow">Bostjan</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1425973216798#c7479657276858226738">March 10, 2015 at 12:40 AM</a></span></div><p class="comment-content">This comment has been removed by the author.</p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="7479657276858226738" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin "><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=7479657276858226738">Delete</a></span></span></div><div class="comment-replies"><div id="c7479657276858226738-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c7479657276858226738-ra" class="thread-chrome thread-expanded"><div></div><div id="c7479657276858226738-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="7479657276858226738" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c7479657276858226738-ce"></div></li><li class="comment" id="c625395200693166584"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/05554370494427278306" rel="nofollow">Bostjan</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1425973228088#c625395200693166584">March 10, 2015 at 12:40 AM</a></span></div><p class="comment-content">If I understand correctly now everybody knows about the problem and the bad guys can build the special exploit software and exploit the vulnerability and we cannot do anything about it? The DRAM cannot be fixed/patched. Really?</p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="625395200693166584" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-981706958"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=625395200693166584">Delete</a></span></span></div><div class="comment-replies"><div id="c625395200693166584-rt" class="comment-thread inline-thread"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c625395200693166584-ra" class="thread-chrome thread-expanded"><div><li class="comment" id="c309058676108848661"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/17315694220686248753" rel="nofollow">Michael Sporer</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1426639865491#c309058676108848661">March 17, 2015 at 5:51 PM</a></span></div><p class="comment-content">This comment has been removed by the author.</p><span class="comment-actions secondary-text"><span class="item-control blog-admin blog-admin "><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=309058676108848661">Delete</a></span></span></div><div class="comment-replies"><div id="c309058676108848661-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c309058676108848661-ra" class="thread-chrome thread-expanded"><div></div><div id="c309058676108848661-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="309058676108848661" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c309058676108848661-ce"></div></li></div><div id="c625395200693166584-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="625395200693166584" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c625395200693166584-ce"></div></li><li class="comment" id="c5498919133727618957"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/02942942061729107617" rel="nofollow">Albert</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1426084383620#c5498919133727618957">March 11, 2015 at 7:33 AM</a></span></div><p class="comment-content">Hi! Is this also an issue for PPC? Look at section 11.5 here: http://cache.freescale.com/files/32bit/doc/ref_manual/E500CORERM.pdf<br>Could clflush be replaced in the rowhammer-test program by one of those instructions? Which one in that case?</p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="5498919133727618957" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-1118054253"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=5498919133727618957">Delete</a></span></span></div><div class="comment-replies"><div id="c5498919133727618957-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c5498919133727618957-ra" class="thread-chrome thread-expanded"><div></div><div id="c5498919133727618957-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="5498919133727618957" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c5498919133727618957-ce"></div></li><li class="comment" id="c6609721882673162814"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/06902698191585814311" rel="nofollow">Unknown</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1426098457011#c6609721882673162814">March 11, 2015 at 11:27 AM</a></span></div><p class="comment-content">For me this is simply a NOT WORKING memory and it should be retired from the market.</p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="6609721882673162814" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-1010134619"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=6609721882673162814">Delete</a></span></span></div><div class="comment-replies"><div id="c6609721882673162814-rt" class="comment-thread inline-thread"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c6609721882673162814-ra" class="thread-chrome thread-expanded"><div><li class="comment" id="c5210228282184947997"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/17315694220686248753" rel="nofollow">Michael Sporer</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1426639914195#c5210228282184947997">March 17, 2015 at 5:51 PM</a></span></div><p class="comment-content">DRAM suppliers agree.  Everyone should buy new DRAM.  I wonder if they planned this.</p><span class="comment-actions secondary-text"><span class="item-control blog-admin blog-admin pid-33697961"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=5210228282184947997">Delete</a></span></span></div><div class="comment-replies"><div id="c5210228282184947997-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c5210228282184947997-ra" class="thread-chrome thread-expanded"><div></div><div id="c5210228282184947997-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="5210228282184947997" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c5210228282184947997-ce"></div></li></div><div id="c6609721882673162814-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="6609721882673162814" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c6609721882673162814-ce"></div></li><li class="comment" id="c2166610589423560819"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/_.jpg" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/03051371669923791312" rel="nofollow">Brett</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1426116036195#c2166610589423560819">March 11, 2015 at 4:20 PM</a></span></div><p class="comment-content">This comment has been removed by the author.</p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="2166610589423560819" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin "><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=2166610589423560819">Delete</a></span></span></div><div class="comment-replies"><div id="c2166610589423560819-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c2166610589423560819-ra" class="thread-chrome thread-expanded"><div></div><div id="c2166610589423560819-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="2166610589423560819" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c2166610589423560819-ce"></div></li><li class="comment" id="c7227335716128886093"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blank.gif" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user">Anonymous</cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1426148753559#c7227335716128886093">March 12, 2015 at 1:25 AM</a></span></div><p class="comment-content">The problem seems not solvable by DRAM-testing at the memory-manufacturers. Even if the testing gets intesified, DRAMs degredate and might show the issues lateron.<br>DRAM memory is not like a simple switch that is either on or off. The databits are stored in leaky capacitors having a size of a few nanometers, holding a charge of less than 10 to the power of -15 coulombs (that is "femtocoulombs'!). If the charge is above a certain level, the bit is a 1 and otherwise a 0. The charge leaks out within a few milliseconds and must be refreshed by the CPU. At the same time we expect the memory cells to be able to change their content 1.6 billion times per second or more, we want billions of bits to be in a tiny little chip and it should please consume practically no power.<br>DRAM memory is extremely sensitive. All the cells are connected to each other by bitlines, wordlines, address lines. If you store a pattern of bits into one corner, some of the power leaks out to other memory cells and affects them. Some cells have better isolation and can hold the data a few milliseconds longer than others. Heat, antennas, radiation, electromagnetic fields stress the memory. DRAM memory also degradates over time. That means: New DRAM memory often is failure-free for a while, but at some point of time sometimes shows a single bit-flip here or there.<br>Bit-flips in DRAM do happen quite often, but they are not 'defects'! They are transient effects having many possible root-causes. Overwriting the flipped bit works and the issue is not directly reproducable. This explains why every crashed application works fine again after a Reset, simply because there is no 'permanent defect', but just a 'bit-flip effect'.<br>I recommend to read this document: http://users.ece.cmu.edu/~yoonguk/papers/liu-isca13.pdf<br>It shows further examples of why bit-flips occur unexpectedly.<br><br>The only good news is: ECC error correction helps to solve or at least reduce the problem.<br><br>ECC does not only protect from hacker-attacks by row-hammering, it also improves the overall stability.<br><br>While a PC tends to fail sometimes with freezing mousepointers, crashing programs, erratic menu-bars or even blue-screens, you won't find such issues on systems equipped with ECC. Most servers use ECC and run for years without ever having to be rebooted. Some of the High-End Cisco routers use ECC-memory and never have issues.<br><br>For PCs and laptops, there are new memory-modules coming to the market which are built with Intelligent Memory ECC DRAMs. These are Non-ECC DIMMs and SO-DIMMs made of DRAMs that have an on-chip ECC correction (called ECC DRAM, read more here: http://www.intelligentmemory.com/fileadmin/download/PB_IM_ECC_DRAM.pdf).<br><br>The modules made of those ECC DRAMs will be called intECC-modules and are about to hit the market next week.<br>Unfortunately the maximum memory capacity is limited to 2GB per module for the time being.<br><br>The Intelligent Memory ECC DRAM chips which are used on the upcoming intECC memory modules, could also be used on many other electronic products of our daily life to make them more reliable.<br>How often does your WiFi-Router, smartphone, settop box, DVR or other electronics need to be rebooted? I bet the first thing we all learn about a new device is how to restart it. Many or maybe most of these hiccups are bit-errors in the memory, which ECC protects from.<br><br>Even HDD drives use a DRAM-memory chip for the write-buffer/cache. A bit flip in the DRAM on the HDD can cause those ugly effects of "file is corrupted and can not be opened".<br>If the manufacturers would replace the conventional unprotected memory chips with those new ECC DRAMs, I am sure we'd see a new level of reliability with much less failures.<br></p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="7227335716128886093" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-558445630"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=7227335716128886093">Delete</a></span></span></div><div class="comment-replies"><div id="c7227335716128886093-rt" class="comment-thread inline-thread"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c7227335716128886093-ra" class="thread-chrome thread-expanded"><div><li class="comment" id="c5280092536643459561"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/02059089675346921519" rel="nofollow">randomusername9</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1426170405898#c5280092536643459561">March 12, 2015 at 7:26 AM</a></span></div><p class="comment-content">Alas, most such issues as you describe are caused by bugs in the software - in the kernel, the applications, or the libraries used. The errors caused by ram errors are comparatively infrequent. I have definitely found strong correlation of bugginess with particular applications or device driver versions, no matter what hardware it is running on. ECC ram is nice, but the stability you are seeing is simply due to a lot of work by the engineers working on the higher price systems.</p><span class="comment-actions secondary-text"><span class="item-control blog-admin blog-admin pid-402570259"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=5280092536643459561">Delete</a></span></span></div><div class="comment-replies"><div id="c5280092536643459561-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c5280092536643459561-ra" class="thread-chrome thread-expanded"><div></div><div id="c5280092536643459561-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="5280092536643459561" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c5280092536643459561-ce"></div></li><li class="comment" id="c5587907859338045032"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blank.gif" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user">Anonymous</cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1426183817706#c5587907859338045032">March 12, 2015 at 11:10 AM</a></span></div><p class="comment-content">Well, if this was the case, then why does a server with ECC - running Windows server and many complex software 24/7 for years - never fail? ECC does not help when the software is buggy, but the PC also runs Windows and less complex software, but you can hardly keep it switched on for longer than a day and still randomly have unexpected erratic behaviour sometimes.<br></p><span class="comment-actions secondary-text"><span class="item-control blog-admin blog-admin pid-558445630"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=5587907859338045032">Delete</a></span></span></div><div class="comment-replies"><div id="c5587907859338045032-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c5587907859338045032-ra" class="thread-chrome thread-expanded"><div></div><div id="c5587907859338045032-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="5587907859338045032" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c5587907859338045032-ce"></div></li><li class="comment" id="c9019219237211153707"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/17315694220686248753" rel="nofollow">Michael Sporer</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1426640189131#c9019219237211153707">March 17, 2015 at 5:56 PM</a></span></div><p class="comment-content">Rowhammer is a defect of the memory array design, not a degradation of the device, although degradation DOES happen it is not related to row hammer.<br><br>Rowhammer is a problem because it causes corruption of multiple bits in a row.  This cannot be corrected by ECC.  </p><span class="comment-actions secondary-text"><span class="item-control blog-admin blog-admin pid-33697961"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=9019219237211153707">Delete</a></span></span></div><div class="comment-replies"><div id="c9019219237211153707-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c9019219237211153707-ra" class="thread-chrome thread-expanded"><div></div><div id="c9019219237211153707-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="9019219237211153707" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c9019219237211153707-ce"></div></li><li class="comment" id="c6472996342823860810"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/11294642008964098103" rel="nofollow">ruckb</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1427200237747#c6472996342823860810">March 24, 2015 at 5:30 AM</a></span></div><p class="comment-content">the chances to corrupt multi bits in a row that are used for ECC checksum correction are quite small. Statistically this will reduce the effect by many order of magnitudes. Once you have read out the data the ECC algorithm is finding the fail and correcting it. Double bits are still  detected, and also the chance to detect multibit errors is still given. <br>The test will run on all DRAMs of a rank in parallel. In case of controller based ECC you might get a chance that single bit flips on multiple DRAMs will happen. <br>if you use DRAM with integrated ECC as the Intelligent memory chips in combination with controller based ECC you would have double protection: one for a fail inside a DRAM and one for single bit fails over multiple DRAMs. <br>==&gt; on DRAMs it will always come down to statistics and propability when talking about fails .. but with ECC (controller and/or DRAM based) the propability to get fails is reduced by magnitudes .. <br>Hermann</p><span class="comment-actions secondary-text"><span class="item-control blog-admin blog-admin pid-1844380037"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=6472996342823860810">Delete</a></span></span></div><div class="comment-replies"><div id="c6472996342823860810-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c6472996342823860810-ra" class="thread-chrome thread-expanded"><div></div><div id="c6472996342823860810-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="6472996342823860810" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c6472996342823860810-ce"></div></li><li class="comment" id="c7600709372331382105"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/17315694220686248753" rel="nofollow">Michael Sporer</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1427215365937#c7600709372331382105">March 24, 2015 at 9:42 AM</a></span></div><p class="comment-content">Hermann, I'm not sure why you mention the statistical implications. We are not discussing typical system operation where statistical behavior applies, rather a pathological worst case exploit in which you need just one key to open the door. Yes, ECC covers SECDED, but can you explain why once you go beyond 2 bit errors you claim this is not a risk? <br>As I understand it RH has the potential in the worst case to corrupt all the bits in the physically adjacent row. Under this scenario what mechanisms does the system have to detect or protect against this?  Once that is determined we can then delve into the statistics of the implications of partial row corruption, all the way down to 3 bits.  Thanks,</p><span class="comment-actions secondary-text"><span class="item-control blog-admin blog-admin pid-33697961"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=7600709372331382105">Delete</a></span></span></div><div class="comment-replies"><div id="c7600709372331382105-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c7600709372331382105-ra" class="thread-chrome thread-expanded"><div></div><div id="c7600709372331382105-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="7600709372331382105" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c7600709372331382105-ce"></div></li><li class="comment" id="c8388332142481697203"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/11294642008964098103" rel="nofollow">ruckb</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1427217813815#c8388332142481697203">March 24, 2015 at 10:23 AM</a></span></div><p class="comment-content">Hi mgs,<br>in DRAM everything is about statistics .. Even DRAM spec up to DDR3 assumes a BER=0 (on interface and array) this is just a nice assumption but just not valid .. just DDR4 starts to take this into account. .. <br>All fail mechanisms (including RowHammer) are just a matter of probaility if it fails and if the fail can be corrected or detected with any means. Getting a 3bit error is haveing a low probability and once you got it you will have a statistical probability that you are going to catch it even with SECDED. I did not mention that it is no risk, I'm just saying this is question of statistics.<br><br>Yes, row hammer can have the potential to corrupt bits in adjacent rows (if the DRAM vendor did not a good job in either designing or testing the array). <br>You don't know at which point in time a single bit error occurs, and once you do a readout with ECC you will correct it. if you wait longer you might get a double bit error and an ECC based system will stop and tell you that it run into an uncorrectable error. If you get more than 2 errors there are still chances that that the error is detected and the system stops. if you run rowhammer too long you have so many errors that you can not attack the system any more, as the code crashes completely .. so we are back in probabilities if you want to use this behavior for attacking a system. And ECC will lower the probability that you will get a fail allows the attack.<br>If you combine now Chipset ECC (correcting one bit fail over 4, 8 or 16DRAM DQ width) with DRAM devices with built in ECC (correcting one fail for each DRAM burst) you are going to decrease the probability for a Fail that allows the attack even further. <br>And even if a single bit fails it need to be the right bit to allow the attack .. <br><br>Thats the reason why I think especially with ECC it's all about statistics for such a scenario ... <br><br>The question for me is: Why this discussion on RowHammer ?<br><br>You can get you fails in the DRAM much simpler, but maybe with less accuracy where the fail happens. Is this really less critical for security ? <br>- There is no protection to change the controller registers during runtime. So adjusting the Refreshtimes is very simple. Now you can either try rowhammer on with this weakend array or just access all other WL in order to refresh these by read accesses .. <br>- Maybe you want to check your SPD on the DIMMs ... is the Software Write protect really set ? <br>Change write recovery times for AP and do a lot of reads to one Row. Nobody says that the critical addresspace does not share one row. So you can introduce errors along the row .. <br><br>There are so many options to get a Fail on a DRAM .. it is just a question of statistics and probability which one leads fastest to a Fail that allows to attack a system. With ECC (on controller or on DRAM) this probaility is just lowered a lot .. but still not 0.<br><br>Hermann<br><br>  </p><span class="comment-actions secondary-text"><span class="item-control blog-admin blog-admin pid-1844380037"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=8388332142481697203">Delete</a></span></span></div><div class="comment-replies"><div id="c8388332142481697203-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c8388332142481697203-ra" class="thread-chrome thread-expanded"><div></div><div id="c8388332142481697203-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="8388332142481697203" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c8388332142481697203-ce"></div></li><li class="comment" id="c4908931128404362709"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/17315694220686248753" rel="nofollow">Michael Sporer</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1427219589502#c4908931128404362709">March 24, 2015 at 10:53 AM</a></span></div><p class="comment-content">It is just a given that the DRAM vendors as a whole did do a poor job designing the array. Prior to this it was assumed the DRAM were not susceptible to RH and on secure systems I'd assume the alternate attacks you mention are not possible. So in the past there was a zero risk from this. Now by introducing susceptible DRAM into a secure system the risk is non-zero and needs to be mitigated. It seems that every DRAM produced in the last 5 years has this susceptibility. That's a huge installed base at risk.</p><span class="comment-actions secondary-text"><span class="item-control blog-admin blog-admin pid-33697961"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=4908931128404362709">Delete</a></span></span></div><div class="comment-replies"><div id="c4908931128404362709-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c4908931128404362709-ra" class="thread-chrome thread-expanded"><div></div><div id="c4908931128404362709-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="4908931128404362709" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c4908931128404362709-ce"></div></li><li class="comment" id="c812142636756712599"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/11294642008964098103" rel="nofollow">ruckb</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1427222597310#c812142636756712599">March 24, 2015 at 11:43 AM</a></span></div><p class="comment-content">Hi mgs, sorry to destroy your secure world   ;-) .. <br>RowHammer is an old issue and DRAM has never been save (at least in my understanding).. in order to get save DRAM systems people implement things like chipkill, DIMM redundancy and other fancy features .. but only to lower the risk of a fail (or attack), not to have zero risk. <br>And I don't agree on DRAM vendors as ahole did a pure job. It is really a difficult task to Design a DRAM array and test it properly. How good it is done (especially the testing) is economy driven. <br>If you spend enough money you can buy DRAM and Systems that lower the probaility of a fail (that can be used for an attack) to very low numbers .. but industry is not willing to spend this money (and I have to admit, that also my system is having no ECC for the 100GB of Memory installed.) <br>Seems that probability of fail is still with conventional methods low enough .. <br><br>Why do you think the methods I describe are not possible? I think they are simpler to implement than row hammer code and have more potential to get a successfull attack executed.<br><br>Hermann<br><br>Hermann<br><br></p><span class="comment-actions secondary-text"><span class="item-control blog-admin blog-admin pid-1844380037"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=812142636756712599">Delete</a></span></span></div><div class="comment-replies"><div id="c812142636756712599-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c812142636756712599-ra" class="thread-chrome thread-expanded"><div></div><div id="c812142636756712599-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="812142636756712599" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c812142636756712599-ce"></div></li><li class="comment" id="c467666726236643686"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/17315694220686248753" rel="nofollow">Michael Sporer</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1427225834299#c467666726236643686">March 24, 2015 at 12:37 PM</a></span></div><p class="comment-content">This comment has been removed by the author.</p><span class="comment-actions secondary-text"><span class="item-control blog-admin blog-admin "><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=467666726236643686">Delete</a></span></span></div><div class="comment-replies"><div id="c467666726236643686-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c467666726236643686-ra" class="thread-chrome thread-expanded"><div></div><div id="c467666726236643686-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="467666726236643686" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c467666726236643686-ce"></div></li><li class="comment" id="c7507386641080657118"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/17315694220686248753" rel="nofollow">Michael Sporer</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1427226296741#c7507386641080657118">March 24, 2015 at 12:44 PM</a></span></div><p class="comment-content">I suppose you are right. The systems which are capable of being secured against the attacks you describe are built by companies who are also capable of and have already mitigated against RH. <br><br>I used to program ATE memory test a long time ago and row hammer never failed. I think this problem emerged when the DRAM makers made a conscious decision to design an array that had less margin to this failure mode. They were assuming that statistically, during normal system operation, that RH would never occur, and they were right. Until one day a certain server CPU maker decided to allow customers to turn off caching to speed up database performance. That's when row hammer re-appeared having been dormant for nearly 30 years, and caused system crashes on ECC protected, chipkill protected, high end enterprise servers. That was several years ago. The patents didn't start to appear until after that. <br></p><span class="comment-actions secondary-text"><span class="item-control blog-admin blog-admin pid-33697961"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=7507386641080657118">Delete</a></span></span></div><div class="comment-replies"><div id="c7507386641080657118-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c7507386641080657118-ra" class="thread-chrome thread-expanded"><div></div><div id="c7507386641080657118-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="7507386641080657118" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c7507386641080657118-ce"></div></li><li class="comment" id="c4551225797309005062"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/17315694220686248753" rel="nofollow">Michael Sporer</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1427226390808#c4551225797309005062">March 24, 2015 at 12:46 PM</a></span></div><p class="comment-content">and even so, row hammer defective DRAMs are still being produced.</p><span class="comment-actions secondary-text"><span class="item-control blog-admin blog-admin pid-33697961"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=4551225797309005062">Delete</a></span></span></div><div class="comment-replies"><div id="c4551225797309005062-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c4551225797309005062-ra" class="thread-chrome thread-expanded"><div></div><div id="c4551225797309005062-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="4551225797309005062" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c4551225797309005062-ce"></div></li></div><div id="c7227335716128886093-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="7227335716128886093" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c7227335716128886093-ce"></div></li><li class="comment" id="c134746835809791539"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/09845552406561554426" rel="nofollow">Asterix</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1426277387589#c134746835809791539">March 13, 2015 at 1:09 PM</a></span></div><p class="comment-content">So consumer-grade gear lacking ECC protection doesn't use anything at all to detect even single-bit errors?  Heck, the original IBM PC used DRAM parity.</p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="134746835809791539" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-2097762842"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=134746835809791539">Delete</a></span></span></div><div class="comment-replies"><div id="c134746835809791539-rt" class="comment-thread inline-thread"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c134746835809791539-ra" class="thread-chrome thread-expanded"><div><li class="comment" id="c7221143224518260092"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/17315694220686248753" rel="nofollow">Michael Sporer</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1426640343191#c7221143224518260092">March 17, 2015 at 5:59 PM</a></span></div><p class="comment-content">The IBM PC was a business machine and was built with DRAM that inherently had soft errors.  Eventually soft errors were bought down to a tolerable level and parity was dropped.  This row-hammer problem is a really big oops.  Fortunately DRAM makers have designed it out (again) in their newer array designs.</p><span class="comment-actions secondary-text"><span class="item-control blog-admin blog-admin pid-33697961"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=7221143224518260092">Delete</a></span></span></div><div class="comment-replies"><div id="c7221143224518260092-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c7221143224518260092-ra" class="thread-chrome thread-expanded"><div></div><div id="c7221143224518260092-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="7221143224518260092" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c7221143224518260092-ce"></div></li></div><div id="c134746835809791539-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="134746835809791539" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c134746835809791539-ce"></div></li><li class="comment" id="c6766719372588343026"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/02438613401562797068" rel="nofollow">Unknown</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1426523452034#c6766719372588343026">March 16, 2015 at 9:30 AM</a></span></div><p class="comment-content">We have been writing about this topic for almost 9 months now.  Glad Google gave us a mention.  We created a feature in our DDR Detective tool to detect excessive ACTIVATE (ACT) commands to a single row address on a DIMM or SODIMM module.  We have posted videos on our YouTube channel giving more information (FuturePlus Systems).  If you have critical applications I highly recommend you test to see if your application creates these excessive ACT commands.  Our tool is available for short term rental.  Please contact us barb.aichinger@futureplus.com if you would like more information.  Also check out www.DDRDetective.com/row-hammer for more information</p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="6766719372588343026" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-2103057842"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=6766719372588343026">Delete</a></span></span></div><div class="comment-replies"><div id="c6766719372588343026-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c6766719372588343026-ra" class="thread-chrome thread-expanded"><div></div><div id="c6766719372588343026-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="6766719372588343026" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c6766719372588343026-ce"></div></li><li class="comment" id="c7142280143434482199"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/crem1s.jpg" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/03874182840808039669" rel="nofollow">crem</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1427289927125#c7142280143434482199">March 25, 2015 at 6:25 AM</a></span></div><p class="comment-content">Amused me somewhat reading this that one of the first computers I built, back in 1979, used 4K x1 DRAM chips that ICL had rejected (and essentially thrown away) because they suffered from what they called pattern sensitivity failures... essentially the same problem as this, writing certain patterns into memory could induce changes in nearby bits if the memory timing was near the limit. </p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="7142280143434482199" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-172735180"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=7142280143434482199">Delete</a></span></span></div><div class="comment-replies"><div id="c7142280143434482199-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c7142280143434482199-ra" class="thread-chrome thread-expanded"><div></div><div id="c7142280143434482199-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="7142280143434482199" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c7142280143434482199-ce"></div></li><li class="comment" id="c5111020437984230156"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/06635124469512396080" rel="nofollow">Unknown</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1429245749387#c5111020437984230156">April 16, 2015 at 9:42 PM</a></span></div><p class="comment-content">&gt; In https://github.com/google/rowhammer-test<br>&gt; <br>&gt; How to run the test:<br>&gt;<br>&gt; ./make.sh<br>&gt; ./rowhammer_test<br>&gt; The test should work on Linux or Mac OS X, on x86 only.<br><br><br>Why on x86 only, is x86-64 is also ok?<br><br><br>x86 only.</p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="5111020437984230156" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-1759218300"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=5111020437984230156">Delete</a></span></span></div><div class="comment-replies"><div id="c5111020437984230156-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c5111020437984230156-ra" class="thread-chrome thread-expanded"><div></div><div id="c5111020437984230156-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="5111020437984230156" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c5111020437984230156-ce"></div></li><li class="comment" id="c7377645319834625031"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blank.gif" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user">Anonymous</cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1429269675530#c7377645319834625031">April 17, 2015 at 4:21 AM</a></span></div><p class="comment-content">I got some results from our own row-hammer tests performed on Non-ECC modules on different platforms using Memtest 6.0. All platforms failed the row-hammer test with different memories sooner or later.<br>Every single fail was a single bit flip and there were no double-bit flips at all. The amount of single-bit-flips per each pass of the test was between 3 and 40 bit-flips and spread over multiple different addresses and different DRAMs on the modules.<br> <br>Let's say a memory module uses 8 Chips of 2Gbit capacity each = 2GByte (256Mx64).<br>With 40 bit-flips in a row-hammer-test run by Memtest, this is averaging to 5 bit-flips per DRAM chip throughout a complete row-hammer test-pass. Unfortunately I do not know how often Memtest hammers the rows in one pass.<br> <br>The modules output data in 64 bit-words. There are 256 Million of such 64 Bit words in a 2GB module. By having ECC, each of these 256 million 64 bit words could have one bit-flip and ECC would still be able to correct them.<br>40 bit-flips within 256 million 64 bit-words is 'peanuts' for ECC! With such small amount of bit-flips it is very unlikely that TWO of those bit-flips occur in the same 64 bit-word causing an uncorrectable double-bit error.<br>This said, ECC is a very effective row-hammer protection-method.<br> <br>I doubt that TRR, MAC or increasing the refresh-rate can solve the problem. The theory is that adjacent rows survive a certain amount of row-hammers before they better should be refreshed. "Testing" if the DRAMs can take 300k hammer-cycles is not a guarantee that it will always survive 300k hammers. It could also sometimes fail after just a handful of accesses when you are unlucky. It is not the "amount of cycles" that causes the bit-flips.<br> <br>Also: Don't forget that DRAMs do degredate and get more sensitive to disturbances after some time of use. A brandnew DRAM might be surviving 300k hammers, but what if it gets a bit older?<br> <br>Besides row-hammering, DRAMs are also sensitive to heat and to radiation (from antennas or radioactivity, even natural ground-radiation). VRT-effects (variable retention time) and data-pattern-dependence (the retention time of each DRAM cell is significantly affected by the data stored in other DRAM cells) also cause bit-flips. TRR and MAC does not help against this at all.<br>The only solution is to detect and correct the bit-flips -&gt; ECC Error Correction<br> <br>Row-Hammer is a typical hacker-attack (=intentional), while all the other issues are non-intentional bit-flips. If you are unlucky, it does not even need a row-hammer software, but a simple multi-read of a row by your own software-code can cause a bit-flip in an adjacent row. <br><br>ANY bit-flip - no matter if intentionally triggered or not - can cause a malfunction of the software/the system, or result in a crash or data corruption. Please do not only look at PCs, laptops or servers, but also think of all the other intelligent electronics out there, like networking systems, access controls, telecommunication, medical devices, automotive, industrial computers of all kinds, etc. These will typically not be row-hammered, but they still sometimes fail and need to be reset, although they are expected to always run stable. <br>I think everybody had the experience that the smartphone, the settop box, the router or other electronics "needed a reset" -&gt; this was most-likely caused by a bit-flip. While home-electronics are less critical, most industrial electronics are expected not to have such issues. Still they do.<br> <br>All bit-flips have the same root-cause -&gt; weaknesses of memory-cells<br>The best solution for ALL above mentioned issues is to have ECC<br> <br>With ECC, all applications could become a lot more stable. They would run for years without ever having to be reset/rebooted. And at the same time they will also be row-hammer-safer.<br> <br>The DRAM makers should follow the trend that Intelligent Memory started: Integrate ECC into the DRAM-chips instead of trying to find insecure workarounds only against row-hammering by MAC, TRR, faster refreshing, etc.</p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="7377645319834625031" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-558445630"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=7377645319834625031">Delete</a></span></span></div><div class="comment-replies"><div id="c7377645319834625031-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c7377645319834625031-ra" class="thread-chrome thread-expanded"><div></div><div id="c7377645319834625031-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="7377645319834625031" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c7377645319834625031-ce"></div></li><li class="comment" id="c1409983569343216959"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/01931625743245716533" rel="nofollow">Unknown</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1455697742496#c1409983569343216959">February 17, 2016 at 12:29 AM</a></span></div><p class="comment-content">Can anyone suggest the equivalent instruction of CLFLUSH for ARM Processor. The CLFLUSH is specific to x86 Processor </p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="1409983569343216959" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-566568017"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=1409983569343216959">Delete</a></span></span></div><div class="comment-replies"><div id="c1409983569343216959-rt" class="comment-thread inline-thread"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c1409983569343216959-ra" class="thread-chrome thread-expanded"><div><li class="comment" id="c5049621445087231685"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/09137543460902907234" rel="nofollow">heliopoopter</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1466291001751#c5049621445087231685">June 18, 2016 at 4:03 PM</a></span></div><p class="comment-content">http://infocenter.arm.com/help/topic/com.arm.doc.ddi0092b/DDI0092B_ARM940T_TRM.pdf<br>Page 25</p><span class="comment-actions secondary-text"><span class="item-control blog-admin blog-admin pid-1403932578"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=5049621445087231685">Delete</a></span></span></div><div class="comment-replies"><div id="c5049621445087231685-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c5049621445087231685-ra" class="thread-chrome thread-expanded"><div></div><div id="c5049621445087231685-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="5049621445087231685" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c5049621445087231685-ce"></div></li></div><div id="c1409983569343216959-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="1409983569343216959" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c1409983569343216959-ce"></div></li><li class="comment" id="c2415221167712863020"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/12763353773126983531" rel="nofollow">Unknown</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1485438121999#c2415221167712863020">January 26, 2017 at 5:42 AM</a></span></div><p class="comment-content">How long exactly did you leave those test running to find those bit flips?<br><br>Are we talking about in 5 minutes, hours, days?</p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="2415221167712863020" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-537848787"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=2415221167712863020">Delete</a></span></span></div><div class="comment-replies"><div id="c2415221167712863020-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c2415221167712863020-ra" class="thread-chrome thread-expanded"><div></div><div id="c2415221167712863020-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="2415221167712863020" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c2415221167712863020-ce"></div></li><li class="comment" id="c4821199837507771152"><div class="avatar-image-container"><img src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/blogger_logo_round_35.png" alt=""></div><div class="comment-block"><div class="comment-header"><cite class="user"><a href="https://www.blogger.com/profile/14153734269848282203" rel="nofollow">Unknown</a></cite><span class="icon user "></span><span class="datetime secondary-text"><a rel="nofollow" href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html?showComment=1537512665375#c4821199837507771152">September 20, 2018 at 11:51 PM</a></span></div><p class="comment-content">I am confused as to why this problem is not treated as a memory defect due to which under certain conditions when a row is accessed many times the charge is leaks between cells in different rows? this sounds like something that the dram vendor could easily screen for with a memory test algorithm during production like they already do for other memory defect behaviors. I would think of this as a bad dram part being used in the system and hence causing unexpected behavior. </p><span class="comment-actions secondary-text"><a class="comment-reply" target="_self" data-comment-id="4821199837507771152" href="javascript:;">Reply</a><span class="item-control blog-admin blog-admin pid-1372990589"><a target="_self" href="https://www.blogger.com/delete-comment.g?blogID=4838136820032157985&amp;postID=4821199837507771152">Delete</a></span></span></div><div class="comment-replies"><div id="c4821199837507771152-rt" class="comment-thread inline-thread hidden"><span class="thread-toggle thread-expanded"><span class="thread-arrow"></span><span class="thread-count"><a target="_self" href="javascript:;">Replies</a></span></span><ol id="c4821199837507771152-ra" class="thread-chrome thread-expanded"><div></div><div id="c4821199837507771152-continue" class="continue"><a class="comment-reply" target="_self" data-comment-id="4821199837507771152" href="javascript:;">Reply</a></div></ol></div></div><div class="comment-replybox-single" id="c4821199837507771152-ce"></div></li></ol><div id="top-continue" class="continue hidden"><a class="comment-reply" target="_self" href="javascript:;">Add comment</a></div><div class="comment-replybox-thread" id="top-ce"><iframe allowtransparency="true" class="blogger-iframe-colorize blogger-comment-from-post" frameborder="0" height="195px" id="comment-editor" name="comment-editor" src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/comment-iframe.html" width="100%" style="display: block;" data-resized="true"></iframe></div><div class="loadmore hidden" data-post-id="4216316467888599950"><a target="_self">Load more...</a></div></div>
</div>
</div>
<p class="comment-footer">
</p><div class="comment-form">
<a name="comment-form"></a>
<p>
</p>
<a href="https://www.blogger.com/comment-iframe.g?blogID=4838136820032157985&amp;postID=4216316467888599950&amp;blogspotRpcToken=7507799" id="comment-editor-src"></a>

<script src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/3261120736-comment_from_post_iframe.js.下載" type="text/javascript"></script>
<script type="text/javascript">
      BLOG_CMT_createIframe('https://www.blogger.com/rpc_relay.html');
    </script>
</div>
<p></p>
<div id="backlinks-container">
<div id="Blog1_backlinks-container">
</div>
</div>
</div>
</div>

        </div></div>
      
</div>
<div class="blog-pager" id="blog-pager">
<span id="blog-pager-newer-link">
<a class="blog-pager-newer-link" href="https://googleprojectzero.blogspot.com/2015/03/taming-wild-copy-parallel-thread.html" id="Blog1_blog-pager-newer-link" title="Newer Post">Newer Post</a>
</span>
<span id="blog-pager-older-link">
<a class="blog-pager-older-link" href="https://googleprojectzero.blogspot.com/2015/02/feedback-and-data-driven-updates-to.html" id="Blog1_blog-pager-older-link" title="Older Post">Older Post</a>
</span>
<a class="home-link" href="https://googleprojectzero.blogspot.com/">Home</a>
</div>
<div class="clear"></div>
<div class="post-feeds">
<div class="feed-links">
Subscribe to:
<a class="feed-link" href="https://googleprojectzero.blogspot.com/feeds/4216316467888599950/comments/default" target="_blank" type="application/atom+xml">Post Comments (Atom)</a>
</div>
</div>
</div></div>
</div>
</div>
<div class="column-left-outer">
<div class="column-left-inner">
<aside>
</aside>
</div>
</div>
<div class="column-right-outer">
<div class="column-right-inner">
<aside>
<div class="sidebar section" id="sidebar-right-1"><div class="widget BlogSearch" data-version="1" id="BlogSearch1">
<h2 class="title">Search This Blog</h2>
<div class="widget-content">
<div id="BlogSearch1_form">
<form action="https://googleprojectzero.blogspot.com/search" class="gsc-search-box" target="_top">
<table cellpadding="0" cellspacing="0" class="gsc-search-box">
<tbody>
<tr>
<td class="gsc-input">
<input autocomplete="off" class="gsc-input" name="q" size="10" title="search" type="text" value="">
</td>
<td class="gsc-search-button">
<input class="gsc-search-button" title="search" type="submit" value="Search">
</td>
</tr>
</tbody>
</table>
</form>
</div>
</div>
<div class="clear"></div>
</div><div class="widget PageList" data-version="1" id="PageList1">
<h2>Pages</h2>
<div class="widget-content">
<ul>
<li>
<a href="https://googleprojectzero.blogspot.com/p/about-project-zero.html">About Project Zero</a>
</li>
<li>
<a href="https://googleprojectzero.blogspot.com/p/working-at-project-zero.html">Working at Project Zero</a>
</li>
<li>
<a href="https://googleprojectzero.blogspot.com/p/0day.html">0day "In the Wild"</a>
</li>
<li>
<a href="https://googleprojectzero.github.io/0days-in-the-wild/rca.html">0day Exploit Root Cause Analyses</a>
</li>
<li>
<a href="https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-faq.html">Vulnerability Disclosure FAQ</a>
</li>
</ul>
<div class="clear"></div>
</div>
</div><div class="widget BlogArchive" data-version="1" id="BlogArchive1">
<h2>Archives</h2>
<div class="widget-content">
<div id="ArchiveList"></div>
<script type="text/javascript">
//<![CDATA[
(function(){
  let archive_list = document.getElementById('ArchiveList');
  if (archive_list == null) return;
  let cur_year = archive_list.querySelector('.post-count-link').innerText.trim() - 0;
  let last_year = 2014;
  let elements = [];
  const MONTHS = ',Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(',');

  let parent = document.getElementById('ArchiveList');
  while (parent.childNodes.length) parent.removeChild(parent.childNodes[0]);

  function fetch_next_year() {
    let url = 'https://googleprojectzero.blogspot.com/?action=getTitles&widgetId=BlogArchive1&widgetType=BlogArchive&responseType=js&path=https%3A%2F%2Fgoogleprojectzero.blogspot.com%2F'+cur_year;
    fetch(url).then(resp => {
      if (!resp.ok) {
        console.log('http error');
        return;
      }
      resp.text().then(text => {
        let scope = {
          _WidgetManager: {
            _HandleControllerResult: (name, method, results) => {
              elements.push(document.createElement('hr'));
              let year_header = document.createElement('div');
              year_header.appendChild(document.createTextNode(cur_year));
              year_header.style.fontSize = 'large';
              elements.push(year_header);

              let list = document.createElement('ul');
              elements.push(list);

              for (let obj of results.posts) {
                let link_parts = obj.url.split('/');
                let year = link_parts[3];
                let month = link_parts[4];

                let el = document.createElement(/*'div'*/'li');
                el.style.listStyleType = 'square';
                el.style.listStylePosition = 'inside';
                let link = document.createElement('a');
                el.appendChild(link);
                link.appendChild(document.createTextNode(obj.title));
                link.href = obj.url;
                let date_trailer = document.createElement('span');
                el.appendChild(date_trailer);
                //date_trailer.appendChild(document.createTextNode(' ('+year+'-'+month+')'));
                date_trailer.appendChild(document.createTextNode(' ('+MONTHS[parseInt(month, 10)]+')'));
                //date_trailer.style.textAlign = 'right';
                //elements.push(el);
                list.appendChild(el);
              }
            }
          }
        };
        with (scope) { eval(text); }
        if (cur_year == last_year) {
          finish();
        } else {
          cur_year--;
          fetch_next_year();
        }
      });
    });
  }
  fetch_next_year();
  function finish() {
    for (let obj of elements) {
      parent.appendChild(obj);
    }
    console.log(elements);
  }
})();
//]]>
</script>
<div class="clear"></div>
</div>
</div></div>
<table border="0" cellpadding="0" cellspacing="0" class="section-columns columns-2">
<tbody>
<tr>
<td class="first columns-cell">
<div class="sidebar no-items section" id="sidebar-right-2-1"></div>
</td>
<td class="columns-cell">
<div class="sidebar no-items section" id="sidebar-right-2-2"></div>
</td>
</tr>
</tbody>
</table>
<div class="sidebar no-items section" id="sidebar-right-3"></div>
</aside>
</div>
</div>
</div>
<div style="clear: both"></div>
<!-- columns -->
</div>
<!-- main -->
</div>
</div>
<div class="main-cap-bottom cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
<footer>
<div class="footer-outer">
<div class="footer-cap-top cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left footer-fauxborder-left">
<div class="fauxborder-right footer-fauxborder-right"></div>
<div class="region-inner footer-inner">
<div class="foot no-items section" id="footer-1"></div>
<table border="0" cellpadding="0" cellspacing="0" class="section-columns columns-2">
<tbody>
<tr>
<td class="first columns-cell">
<div class="foot no-items section" id="footer-2-1"></div>
</td>
<td class="columns-cell">
<div class="foot no-items section" id="footer-2-2"></div>
</td>
</tr>
</tbody>
</table>
<!-- outside of the include in order to lock Attribution widget -->
<div class="foot section" id="footer-3" name="Footer"><div class="widget Attribution" data-version="1" id="Attribution1">
<div class="widget-content" style="text-align: center;">
Simple theme. Powered by <a href="https://www.blogger.com/" target="_blank">Blogger</a>.
</div>
<div class="clear"></div>
</div></div>
</div>
</div>
<div class="footer-cap-bottom cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
</footer>
<!-- content -->
</div>
</div>
<div class="content-cap-bottom cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
</div>
<script type="text/javascript">
    window.setTimeout(function() {
        document.body.className = document.body.className.replace('loading', '');
      }, 10);
  </script>

<script type="text/javascript" src="./2015 - Exploiting the DRAM rowhammer bug to gain kernel privileges_files/3630122430-widgets.js.下載"></script>
<script type="text/javascript">
window['__wavt'] = 'AOuZoY4vbF-lC-mvXMeiLzMxg_aSclQ0tA:1638466545561';_WidgetManager._Init('//www.blogger.com/rearrange?blogID\x3d4838136820032157985','//googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html','4838136820032157985');
_WidgetManager._SetDataContext([{'name': 'blog', 'data': {'blogId': '4838136820032157985', 'title': 'Project Zero', 'url': 'https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html', 'canonicalUrl': 'https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html', 'homepageUrl': 'https://googleprojectzero.blogspot.com/', 'searchUrl': 'https://googleprojectzero.blogspot.com/search', 'canonicalHomepageUrl': 'https://googleprojectzero.blogspot.com/', 'blogspotFaviconUrl': 'https://googleprojectzero.blogspot.com/favicon.ico', 'bloggerUrl': 'https://www.blogger.com', 'hasCustomDomain': false, 'httpsEnabled': true, 'enabledCommentProfileImages': true, 'gPlusViewType': 'FILTERED_POSTMOD', 'adultContent': false, 'analyticsAccountNumber': '', 'encoding': 'UTF-8', 'locale': 'en', 'localeUnderscoreDelimited': 'en', 'languageDirection': 'ltr', 'isPrivate': false, 'isMobile': false, 'isMobileRequest': false, 'mobileClass': '', 'isPrivateBlog': false, 'isDynamicViewsAvailable': true, 'feedLinks': '\x3clink rel\x3d\x22alternate\x22 type\x3d\x22application/atom+xml\x22 title\x3d\x22Project Zero - Atom\x22 href\x3d\x22https://googleprojectzero.blogspot.com/feeds/posts/default\x22 /\x3e\n\x3clink rel\x3d\x22alternate\x22 type\x3d\x22application/rss+xml\x22 title\x3d\x22Project Zero - RSS\x22 href\x3d\x22https://googleprojectzero.blogspot.com/feeds/posts/default?alt\x3drss\x22 /\x3e\n\x3clink rel\x3d\x22service.post\x22 type\x3d\x22application/atom+xml\x22 title\x3d\x22Project Zero - Atom\x22 href\x3d\x22https://www.blogger.com/feeds/4838136820032157985/posts/default\x22 /\x3e\n\n\x3clink rel\x3d\x22alternate\x22 type\x3d\x22application/atom+xml\x22 title\x3d\x22Project Zero - Atom\x22 href\x3d\x22https://googleprojectzero.blogspot.com/feeds/4216316467888599950/comments/default\x22 /\x3e\n', 'meTag': '', 'adsenseHostId': 'ca-host-pub-1556223355139109', 'adsenseHasAds': false, 'adsenseAutoAds': false, 'ieCssRetrofitLinks': '\x3c!--[if IE]\x3e\x3cscript type\x3d\x22text/javascript\x22 src\x3d\x22https://www.blogger.com/static/v1/jsbin/1155466832-ieretrofit.js\x22\x3e\x3c/script\x3e\n\x3c![endif]--\x3e', 'view': '', 'dynamicViewsCommentsSrc': '//www.blogblog.com/dynamicviews/4224c15c4e7c9321/js/comments.js', 'dynamicViewsScriptSrc': '//www.blogblog.com/dynamicviews/3f6f2296c2541ccc', 'plusOneApiSrc': 'https://apis.google.com/js/plusone.js', 'disableGComments': true, 'sharing': {'platforms': [{'name': 'Get link', 'key': 'link', 'shareMessage': 'Get link', 'target': ''}, {'name': 'Facebook', 'key': 'facebook', 'shareMessage': 'Share to Facebook', 'target': 'facebook'}, {'name': 'BlogThis!', 'key': 'blogThis', 'shareMessage': 'BlogThis!', 'target': 'blog'}, {'name': 'Twitter', 'key': 'twitter', 'shareMessage': 'Share to Twitter', 'target': 'twitter'}, {'name': 'Pinterest', 'key': 'pinterest', 'shareMessage': 'Share to Pinterest', 'target': 'pinterest'}, {'name': 'Email', 'key': 'email', 'shareMessage': 'Email', 'target': 'email'}], 'disableGooglePlus': true, 'googlePlusShareButtonWidth': 0, 'googlePlusBootstrap': '\x3cscript type\x3d\x22text/javascript\x22\x3ewindow.___gcfg \x3d {\x27lang\x27: \x27en\x27};\x3c/script\x3e'}, 'hasCustomJumpLinkMessage': false, 'jumpLinkMessage': 'Read more', 'pageType': 'item', 'postId': '4216316467888599950', 'pageName': 'Exploiting the DRAM rowhammer bug to gain kernel privileges', 'pageTitle': 'Project Zero: Exploiting the DRAM rowhammer bug to gain kernel privileges'}}, {'name': 'features', 'data': {'sharing_get_link_dialog': 'true', 'sharing_native': 'false'}}, {'name': 'messages', 'data': {'edit': 'Edit', 'linkCopiedToClipboard': 'Link copied to clipboard!', 'ok': 'Ok', 'postLink': 'Post Link'}}, {'name': 'template', 'data': {'name': 'custom', 'localizedName': 'Custom', 'isResponsive': false, 'isAlternateRendering': false, 'isCustom': true, 'variant': 'simplysimple', 'variantId': 'simplysimple'}}, {'name': 'view', 'data': {'classic': {'name': 'classic', 'url': '?view\x3dclassic'}, 'flipcard': {'name': 'flipcard', 'url': '?view\x3dflipcard'}, 'magazine': {'name': 'magazine', 'url': '?view\x3dmagazine'}, 'mosaic': {'name': 'mosaic', 'url': '?view\x3dmosaic'}, 'sidebar': {'name': 'sidebar', 'url': '?view\x3dsidebar'}, 'snapshot': {'name': 'snapshot', 'url': '?view\x3dsnapshot'}, 'timeslide': {'name': 'timeslide', 'url': '?view\x3dtimeslide'}, 'isMobile': false, 'title': 'Exploiting the DRAM rowhammer bug to gain kernel privileges', 'description': '   Rowhammer blog post (draft)         Posted by Mark Seaborn, sandbox builder and breaker, with contributions by Thomas Dullien, reverse en...', 'url': 'https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html', 'type': 'item', 'isSingleItem': true, 'isMultipleItems': false, 'isError': false, 'isPage': false, 'isPost': true, 'isHomepage': false, 'isArchive': false, 'isLabelSearch': false, 'postId': 4216316467888599950}}]);
_WidgetManager._RegisterWidget('_NavbarView', new _WidgetInfo('Navbar1', 'navbar', document.getElementById('Navbar1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_HeaderView', new _WidgetInfo('Header1', 'header', document.getElementById('Header1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_BlogView', new _WidgetInfo('Blog1', 'main', document.getElementById('Blog1'), {'cmtInteractionsEnabled': false, 'lightboxEnabled': true, 'lightboxModuleUrl': 'https://www.blogger.com/static/v1/jsbin/2908359363-lbx.js', 'lightboxCssUrl': 'https://www.blogger.com/static/v1/v-css/4076883957-lightbox_bundle.css'}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_BlogSearchView', new _WidgetInfo('BlogSearch1', 'sidebar-right-1', document.getElementById('BlogSearch1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_PageListView', new _WidgetInfo('PageList1', 'sidebar-right-1', document.getElementById('PageList1'), {'title': 'Pages', 'links': [{'isCurrentPage': false, 'href': 'https://googleprojectzero.blogspot.com/p/about-project-zero.html', 'id': '4384467920505278144', 'title': 'About Project Zero'}, {'isCurrentPage': false, 'href': 'https://googleprojectzero.blogspot.com/p/working-at-project-zero.html', 'id': '2459334498880008057', 'title': 'Working at Project Zero'}, {'isCurrentPage': false, 'href': 'https://googleprojectzero.blogspot.com/p/0day.html', 'id': '3414239791814532209', 'title': '0day \x22In the Wild\x22'}, {'isCurrentPage': false, 'href': 'https://googleprojectzero.github.io/0days-in-the-wild/rca.html', 'title': '0day Exploit Root Cause Analyses'}, {'isCurrentPage': false, 'href': 'https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-faq.html', 'id': '2935252455704572784', 'title': 'Vulnerability Disclosure FAQ'}], 'mobile': false}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_BlogArchiveView', new _WidgetInfo('BlogArchive1', 'sidebar-right-1', document.getElementById('BlogArchive1'), {'languageDirection': 'ltr', 'loadingMessage': 'Loading\x26hellip;'}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_AttributionView', new _WidgetInfo('Attribution1', 'footer-3', document.getElementById('Attribution1'), {}, 'displayModeFull'));
</script>

</body></html>