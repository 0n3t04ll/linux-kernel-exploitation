
<!-- saved from url=(0030)http://inertiawar.com/compat1/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">

<title>linux compat vulns (part 1)</title>
<link rel="stylesheet" href="./2010 - linux compat vulns (part 1)_files/inertia.css" type="text/css">
</head>
<body><table width="800px" style="margin-left: 13%">
	<tbody><tr>   
                <td height="150px" colspan="2" valign="bottom" align="right">
			<a href="http://inertiawar.com/">
                        			</a>
			<br><br>
                </td>
        </tr>
<tr>
<td width="30%" valign="top">
<img src="./2010 - linux compat vulns (part 1)_files/cybernetic2.jpg"><br>
<center><font style="font-size: 10px; color: grey">Ivan Chew, Cybernetic Hand (1990)</font></center>
</td>
<td valign="top">
The 32-bit compatibility mode in 64-bit Linux kernels (or in any kernel for that matter) is a <i>little bit</i> scary. Not just because it's an increased attack surface versus having purely 32-bit or purely 64-bit modes, but because of the type of input processing that has to be performed by any such compatibility layer. It invariably involves a significant amount of subtle bit wrangling between 32/64-bit values, using primitives that I'd argue most programmers aren't normally exposed to. The possibility of misuse and abuse is very real.<br><br>

I found this out over the last couple of weeks when I discovered two distinctly exploitable local privilege escalation vulnerabilities in x86_64 kernels with compatibility mode enabled (which unfortunately is in every 64-bit kernel configuration I've come across).<br><br>

I found the first vulnerability after Tavis Ormandy showed me a serious information leak bug he had found. One of the curiosities of his bug was a multiplication integer overflow in the argument to the access_ok method, which is used to check if a range of memory is safely within the bounds of userspace. Although this probably wouldn't lead to a security bug in most cases, my theory was that this was indicative of some fairly non-defensive programming habits, so I set about enumerating all the cases of this behavior that I could find.<br><br>

This lead to an interesting case in the video4linux subsystem where I thought there was a potential heap overflow. I wrote up a test case that triggered a kernel oops in the compat ioctl. After a little bit of idle day-dreaming about the feasibility of a Chat Roulette worm, I did some analysis on the crash and discovered that it wasn't what I thought it was; in fact not even close.<br><br>

I had actually triggered a stack pointer underflow - that is, my userspace stack pointer had been decremented into kernel space, and then the kernel was trying to write a value to the new "stack" location. The problem started in an allocation routine used by the compatibility layer, from "arch/x86/include/asm/compat.h":<br><br>
 
<pre style="white-space: pre-wrap;">static inline void __user *compat_alloc_user_space(long len)                    
{                                                                               
        struct pt_regs *regs = task_pt_regs(current);                           
        return (void __user *)regs-&gt;sp - len;                                   
}
</pre>

As you can see, no check is performed to ensure that the user space stack pointer doesn't underflow. If the compatibility layer uses the returned pointer without checking that it resides in user-space, kernel memory corruption can occur.<br><br>

In the end I found two cases where this could happen (and I probably missed some others). The first was the video4linux ioctl. The second case was in the IP multicast getsockopt compat layer, which had very good properties for exploitation. From compat_mc_getsockopt in "net/compat.c":<br><br>

<pre style="white-space: pre-wrap;">kgf = compat_alloc_user_space(klen+sizeof(*optlen));                            
                                                                                
if (!access_ok(VERIFY_READ, gf32, __COMPAT_GF0_SIZE) ||                         
      __get_user(interface, &amp;gf32-&gt;gf_interface) ||                             
      __get_user(fmode, &amp;gf32-&gt;gf_fmode) ||                                     
      __get_user(numsrc, &amp;gf32-&gt;gf_numsrc) ||                                   
      __put_user(interface, &amp;kgf-&gt;gf_interface) ||                              
      __put_user(fmode, &amp;kgf-&gt;gf_fmode) ||                                      
      __put_user(numsrc, &amp;kgf-&gt;gf_numsrc) ||                                    
      copy_in_user(&amp;kgf-&gt;gf_group,&amp;gf32-&gt;gf_group,sizeof(kgf-&gt;gf_group)))       
          return -EFAULT;                                                       
</pre>

The value of klen is a non-negative 32-bit integer supplied from user space, meaning the kgf pointer can be wrapped around to point somewhere high in kernel space. The gf32 pointer is a valid user space address, and the contents of the structure are controlled. Note that the "nocheck" version of put_user is used (meaning no further access_ok is performed), so the fact that kgf points to kernel space doesn't matter; the controlled values will be written to the kgf structure.<br><br>

This path allows an attacker to write a chosen value to anywhere within the top 31 bits of the kernel address space. In practice, this seems to be more than enough for exploitation. My proof of concept overwrote the interrupt descriptor table, but it's likely there are other good options too.<br><br>

You can see the patch for CVE-2010-3081 here:<br><br>

<a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=c41d68a513c71e35a14f66d71782d27a79a81ea6">http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=c41d68a513c71e35a14f66d71782d27a79a81ea6</a><br><br>

<a href="http://inertiawar.com/compat2/">Part 2</a> covers a "rediscovered" vulnerability originally found by the late Wojciech "cliph" Purczynski.<br><br>

- hawkes@inertiawar.com (<a href="https://twitter.com/benhawkes">@benhawkes</a>)

                <br><br>

</td>
</tr>
</tbody></table>


</body></html>