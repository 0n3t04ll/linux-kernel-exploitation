<!DOCTYPE html>
<!-- saved from url=(0067)https://blog.nelhage.com/2010/12/cve-2010-4258-from-dos-to-privesc/ -->
<html class="js video maskImage placeholder" lang="en"><!--<![endif]--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>CVE-2010-4258: Turning denial-of-service into privilege escalation - Made of Bugs</title>
  <meta name="author" content="Nelson Elhage">

  
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1">
  <meta name="generator" content="Hugo 0.72.0">

  <link rel="canonical" href="https://blog.nelhage.com/2010/12/cve-2010-4258-from-dos-to-privesc/">
  <link href="https://blog.nelhage.com/favicon.png" rel="icon">
  <link href="./2010 - CVE-2010-4258 Turning denial-of-service into privilege escalation_files/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="https://blog.nelhage.com/atom.xml" rel="alternate" title="Made of Bugs" type="application/atom+xml">
  <script src="./2010 - CVE-2010-4258 Turning denial-of-service into privilege escalation_files/modernizr-2.0.js.‰∏ãËºâ"></script>
  <script src="./2010 - CVE-2010-4258 Turning denial-of-service into privilege escalation_files/jquery.min.js.‰∏ãËºâ"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="./2010 - CVE-2010-4258 Turning denial-of-service into privilege escalation_files/octopress.js.‰∏ãËºâ" type="text/javascript"></script>
<link href="./2010 - CVE-2010-4258 Turning denial-of-service into privilege escalation_files/css" rel="stylesheet" type="text/css">
  <link href="./2010 - CVE-2010-4258 Turning denial-of-service into privilege escalation_files/css(1)" rel="stylesheet" type="text/css">



</head>
<body class="collapse-sidebar sidebar-footer">
  <header role="banner">
    <hgroup>
      <h1><a href="https://blog.nelhage.com/">Made of Bugs</a></h1>
      <h3>It's software. It's made of bugs.</h3>
    </hgroup>
  </header>
  <div class="navi">
<ul>
  <li><a href="https://blog.nelhage.com/post/">Archives</a></li>
  <li><a href="https://blog.nelhage.com/subscribe">Subscribe</a></li>
  <li><a href="https://nelhage.com/">Author</a></li>
</ul>
</div>

  <div id="main">
    <div id="content">


<div>
  <article class="hentry" role="article">
    <header>
  <h1 class="entry-title">CVE-2010-4258: Turning denial-of-service into privilege escalation</h1>
  <p class="meta">
    
    <time datetime="2010-12-10T12:02:11Z" pubdate="">
      Dec 10, 2010
    </time>
    
  </p>
</header>

<div class="entry-content">
  <p>Dan Rosenberg recently <a href="http://thread.gmane.org/gmane.comp.security.full-disclosure/76457">released</a> a privilege escalation bug
for Linux, based on three different kernel vulnerabilities I reported
recently. This post is about CVE-2010-4258, the most interesting of them, and,
as Dan writes, the reason he wrote the exploit in the first place. In it, I‚Äôm
going to do a brief tour of the various kernel features that collided to make
this bug possible, and explain how they combine to turn an otherwise-boring oops
into privilege escalation.</p>
<h2 id="access_ok"><code>access_ok</code>&nbsp;<a class="anchor" href="https://blog.nelhage.com/2010/12/cve-2010-4258-from-dos-to-privesc/#access_ok"><i class="small linkify icon">	üîóÔ∏é</i></a> </h2>
<p>When a user application passes a pointer to the kernel, and the kernel
wants to read or write from that pointer, the kernel needs to perform
various checks that a buggy or malicious userspace app hasn‚Äôt passed
an ‚Äúevil‚Äù pointer.</p>
<p>Because the kernel and userspace run in the same address space, the
most important check is simply that the pointer points into the
‚Äúuserspace‚Äù part of the address space. User applications are protected
by page table permissions from writing into kernel memory, but the
kernel isn‚Äôt, and so must explicitly check that any pointers given to
it by a user don‚Äôt point into the kernel region.</p>
<p>The address space is laid out such that user applications get the
bottom portion, and the kernel gets the top, so this check is a simple
comparison against that boundary. The kernel function that performs
this check is called <code>access_ok</code>, although there are various other
functions that do the same check, implicitly or otherwise.</p>
<h2 id="get_fs-and-set_fs"><code>get_fs()</code> and <code>set_fs()</code>&nbsp;<a class="anchor" href="https://blog.nelhage.com/2010/12/cve-2010-4258-from-dos-to-privesc/#get_fs-and-set_fs"><i class="small linkify icon">	üîóÔ∏é</i></a> </h2>
<p>Occasionally, however, the kernel finds it useful to change the rules for what
<code>access_ok</code> will allow. <code>set_fs()</code><sup><a href="https://blog.nelhage.com/2010/12/cve-2010-4258-from-dos-to-privesc/#fn.1" class="footnote" name="fnr.1">1</a></sup> is an internal Linux function that is used to
override the definition of the user/kernel split, for the current process.</p>
<p>After a <code>set_fs(KERNEL_DS)</code>, no checking is performed that user pointers
point to userspace ‚Äì <code>access_ok</code> will always return
true. <code>set_fs(KERNEL_DS)</code> is mainly used to enable the kernel to wrap
functions that expect user pointers, by passing them pointers into the
kernel address space. A typical use reads something like this:</p>
<pre><code>old_fs = get_fs(); set_fs(KERNEL_DS);
vfs_readv(file, kernel_buffer, len, &amp;pos);
set_fs(old_fs);
</code></pre>
<p><code>vfs_readv</code> expects a user-provided pointer, so without the <code>set_fs()</code>, the
<code>access_ok()</code> inside <code>vfs_readv()</code> would fail on our kernel buffer, so we use
<code>set_fs()</code> to effectively temporarily disable that checking.</p>
<h2 id="kernel-oopses">Kernel oopses&nbsp;<a class="anchor" href="https://blog.nelhage.com/2010/12/cve-2010-4258-from-dos-to-privesc/#kernel-oopses"><i class="small linkify icon">	üîóÔ∏é</i></a> </h2>
<p>When the kernel oopses, perhaps because of a <code>NULL</code> pointer
dereference in kernelspace, or because of a call to the <code>BUG()</code> macro
to indicate an assertion failure, the kernel attempts to clean up, and
then tries to kill the current process by calling the <code>do_exit()</code>
function to exit the current process.</p>
<p>When the kernel does so, it‚Äôs still running in the same process
context it was before the oops occured, including any <code>set_fs()</code>
override, if applicable. Which means that <code>do_exit</code> will get called
with <code>access_ok</code> disabled ‚Äì not something anyone expected when they
wrote the individual pieces of this system.</p>
<h2 id="clear_child_tid"><code>clear_child_tid</code>&nbsp;<a class="anchor" href="https://blog.nelhage.com/2010/12/cve-2010-4258-from-dos-to-privesc/#clear_child_tid"><i class="small linkify icon">	üîóÔ∏é</i></a> </h2>
<p>As it turns out, <code>do_exit</code> contains a write to a user-controlled
address that expects <code>access_ok</code> to be working properly!</p>
<p><code>clear_child_tid</code> is a feature where, on thread exit, the kernel can
be made to write a zero into a specified address in that thread‚Äôs
address space, in order to notify other threads of that exit.</p>
<p>This is implemented by simply storing a pointer to the to-be-zeroed
address inside <code>struct task_struct</code> (which represents a single thread
or process), and, on exit, <code>mm_release</code>, called from <code>do_exit</code>, does:</p>
<pre><code>put_user(0, tsk-&gt;clear_child_tid);
</code></pre>
<p>This is normally safe, because <code>put_user</code> checks that its second
argument falls into the ‚Äúuserspace‚Äù segment before doing a write. But,
if we are running with <code>get_fs() == KERNEL_DS</code>, it will happily accept
any address at all, even one pointing into kernel space.</p>
<p>So, if we find any kernel <code>BUG()</code> or <code>NULL</code> dereference, or other page
fault, that we can trigger after a <code>set_fs(KERNEL_DS)</code>, we can trick
the kernel into a user-controlled write into kernel memory!</p>
<h2 id="splice-et-al"><code>splice()</code> et. al.&nbsp;<a class="anchor" href="https://blog.nelhage.com/2010/12/cve-2010-4258-from-dos-to-privesc/#splice-et-al"><i class="small linkify icon">	üîóÔ∏é</i></a> </h2>
<p>An obvious question at this point is: How much of the kernel can an
attacker cause to run with <code>get_fs() == KERNEL_DS</code>?</p>
<p>There are a number of small special cases. For example, the binary
sysctl compatibility code works by calling the normal <code>/proc/</code> write
handlers from kernelspace, under <code>set_fs()</code>. handful of compat-mode
(32 on 64) syscalls work similarly.</p>
<p>By far the biggest source I‚Äôve found, however, is the <code>splice()</code>
system call. The <code>splice()</code> system call is a relatively recent
addition to Linux, and allows for zero-copy transfer of pages between
a pipe and another file descriptor.</p>
<p>As of 2.6.31, attempts to <code>splice()</code> to or from an fd that doesn‚Äôt
support special handling to actually do zero-copy <code>splice</code>, will fall
back on doing an ordinary <code>read()</code>, <code>write()</code>, or <code>sendmsg()</code> on the
fd ‚Ä¶ from the kernel, using set_fs() in order to pass in kernel
buffers.</p>
<p>What that means it that by using <code>splice()</code>, an attacker can call the
bulk of the code in most obscure filesystems and socket types (which
tend not to have explicit <code>splice()</code> support) with a segment override
in place. Conveniently for an attacker, that is also exactly a
description of where the bulk of the random security bugs tend to be.</p>
<p>This is also exactly the technique Dan‚Äôs exploit uses. He uses
CVE-2010-3849, an otherwise boring <code>NULL</code> pointer dereference I
reported in the Econet network protocol. His exploit code does a
<code>splice()</code> to an econet socket, causing the <code>econet_sendsmg</code> handler to
get called under <code>set_fs(KERNEL_DS)</code>. When it oopses, <code>do_exit</code> is
called, and he gets a user-controlled write into kernel
memory. Everything else is just details.</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn.1" href="https://blog.nelhage.com/2010/12/cve-2010-4258-from-dos-to-privesc/#fnr.1">1</a></sup> Back in Linux 1.x, this function actually set the <tt>%fs</tt> register on i386. It hasn't in years, but it's used in too many places for changing the name to be worth it.</p>
<p></p>
<p></p>
</div>


</div>

    <footer>

      <div class="c2a">
        <form action="https://buttondown.email/api/emails/embed-subscribe/nelhage" method="post" target="popupwindow" onsubmit="window.open(&#39;https://buttondown.email/nelhage&#39;, &#39;popupwindow&#39;)" class="embeddable-buttondown-form">
          <p>
            <label for="bd-email">Subscribe to my newsletter (~1 post/week and blog updates):</label>
          </p>
          <p>
          <input type="email" name="email" placeholder="email@domain.com" id="bd-email">
          <input type="hidden" value="1" name="embed">
          <input type="submit" value="Subscribe">
          </p>
          <p>
            <a href="https://buttondown.email/" target="_blank">Powered by Buttondown.</a>
          </p>
        </form>
      </div>

    <p class="meta">
      
        <a class="basic-alignment left" href="https://blog.nelhage.com/2010/11/exploiting-cve-2010-3081/" title="Previous Post: Some notes on CVE-2010-3081 exploitability">¬´ Some notes on CVE-2010-3081 exploitability</a>
      
      
        <a class="basic-alignment right" href="https://blog.nelhage.com/2010/12/some-android-reverse-engineering-tools/" title="Next Post: Some Android reverse-engineering tools">Some Android reverse-engineering tools ¬ª</a>
      
    </p>
  </footer>
</div></article>
</div>

<hr>

</div>
</div>
<footer role="contentinfo">

  <p>
    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
      <img alt="Creative Commons License" style="border-width:0" src="./2010 - CVE-2010-4258 Turning denial-of-service into privilege escalation_files/88x31.png">
    </a>
    <br>
    <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Made of Bugs</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://nelhage.com/" property="cc:attributionName" rel="cc:attributionURL">Nelson Elhage</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative
    Commons Attribution 4.0 International License</a>.
  </p>
</footer>
<script async="" defer="" src="./2010 - CVE-2010-4258 Turning denial-of-service into privilege escalation_files/latest.js.‰∏ãËºâ"></script>
<noscript><img src="https://sa.nelhage.com/noscript.gif" alt=""/></noscript>



</body></html>