<!DOCTYPE html>
<!-- saved from url=(0051)https://f0rm2l1n.github.io/2021-07-23-Blue-Klotski/ -->
<html lang="en"><!-- Beautiful Jekyll 5.0.0 | Copyright Dean Attali 2020 --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  

  

  <title>Blue Klotski (CVE-2021-3573) and the story for fixing</title>

  
  <meta name="author" content="f0rm2l1n">
  

  <meta name="description" content="Anyway I am sorry for everything">

  

  

  <link rel="alternate" type="application/rss+xml" title="Monte Cristo" href="https://f0rm2l1n.github.io/feed.xml">

  

  

  

  


  
    
      
  <link href="./2021 - Blue Klotski (CVE-2021-3573) and the story for fixing_files/bootstrap.min.css" rel="stylesheet" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">


    
      
  <link rel="stylesheet" href="./2021 - Blue Klotski (CVE-2021-3573) and the story for fixing_files/all.min.css">


    
      
  <link rel="stylesheet" href="./2021 - Blue Klotski (CVE-2021-3573) and the story for fixing_files/css">


    
      
  <link rel="stylesheet" href="./2021 - Blue Klotski (CVE-2021-3573) and the story for fixing_files/css(1)">


    
  

  
    
      <link rel="stylesheet" href="./2021 - Blue Klotski (CVE-2021-3573) and the story for fixing_files/bootstrap-social.css">
    
      <link rel="stylesheet" href="./2021 - Blue Klotski (CVE-2021-3573) and the story for fixing_files/beautifuljekyll.css">
    
  

  

  
  
  

  

  
  <meta property="og:site_name" content="Monte Cristo">
  <meta property="og:title" content="Blue Klotski (CVE-2021-3573) and the story for fixing">
  <meta property="og:description" content="Anyway I am sorry for everything">

  
  <meta property="og:image" content="https://f0rm2l1n.github.io/assets/img/avatar-icon.png">
  

  
  <meta property="og:type" content="article">
  <meta property="og:article:author" content="f0rm2l1n">
  <meta property="og:article:published_time" content="2021-07-23T00:00:00-04:00">
  <meta property="og:url" content="https://f0rm2l1n.github.io/2021-07-23-Blue-Klotski/">
  <link rel="canonical" href="https://f0rm2l1n.github.io/2021-07-23-Blue-Klotski/">
  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:site" content="@daattali">
  <meta name="twitter:creator" content="@daattali">

  <meta property="twitter:title" content="Blue Klotski (CVE-2021-3573) and the story for fixing">
  <meta property="twitter:description" content="Anyway I am sorry for everything">

  
  <meta name="twitter:image" content="https://f0rm2l1n.github.io/assets/img/avatar-icon.png">
  

  


  

  

</head>


<body>

  


  <nav class="navbar navbar-expand-xl navbar-light fixed-top navbar-custom top-nav-regular"><a class="navbar-brand" href="https://f0rm2l1n.github.io/">Monte Cristo</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="main-navbar">
    <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <a class="nav-link" href="https://f0rm2l1n.github.io/aboutme">About Me</a>
          </li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="https://f0rm2l1n.github.io/2021-07-23-Blue-Klotski/#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Resources</a>
            <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                  <a class="dropdown-item" href="https://beautifuljekyll.com/">Beautiful Jekyll</a>
                  <a class="dropdown-item" href="https://www.markdowntutorial.com/">Learn markdown</a>
            </div>
          </li>
        
        <li class="nav-item">
          <a class="nav-link" id="nav-search-link" href="https://f0rm2l1n.github.io/2021-07-23-Blue-Klotski/#" title="Search">
            <span id="nav-search-icon" class="fa fa-search"></span>
            <span id="nav-search-text">Search</span>
          </a>
        </li></ul>
  </div>

  

  
    <div class="avatar-container">
      <div class="avatar-img-border">
        <a href="https://f0rm2l1n.github.io/">
          <img alt="Navigation bar avatar" class="avatar-img" src="./2021 - Blue Klotski (CVE-2021-3573) and the story for fixing_files/avatar-icon.png">
        </a>
      </div>
    </div>
  

</nav>



<div id="beautifuljekyll-search-overlay">

  <div id="nav-search-exit" title="Exit search">✕</div>
  <input type="text" id="nav-search-input" placeholder="Search">
  <ul id="search-results-container"></ul>
  
  <script src="./2021 - Blue Klotski (CVE-2021-3573) and the story for fixing_files/simple-jekyll-search.min.js.下載"></script>
  <script>
    var searchjson = '[ \
       \
        { \
          "title"    : "Blue Klotski (CVE-2021-3573) and the story for fixing", \
          "category" : "CVEKernel", \
          "url"      : "/2021-07-23-Blue-Klotski/", \
          "date"     : "July 23, 2021" \
        }, \
       \
        { \
          "title"    : "Notice in the clave", \
          "category" : "Life", \
          "url"      : "/2021-07-21-notice-in-the-cave/", \
          "date"     : "July 21, 2021" \
        }, \
       \
        { \
          "title"    : "Syzkaller diving 03", \
          "category" : "FuzzingKernel", \
          "url"      : "/2021-02-10-syzkaller-diving-03/", \
          "date"     : "February 10, 2021" \
        }, \
       \
        { \
          "title"    : "Syzkaller diving 02", \
          "category" : "FuzzingKernel", \
          "url"      : "/2021-02-04-syzkaller-diving-02/", \
          "date"     : "February  4, 2021" \
        }, \
       \
        { \
          "title"    : "Syzkaller Diving 01", \
          "category" : "FuzzingKernel", \
          "url"      : "/2021-02-02-syzkaller-diving-01/", \
          "date"     : "February  2, 2021" \
        }, \
       \
        { \
          "title"    : "MOSEC 2020", \
          "category" : "Life", \
          "url"      : "/2020-07-25-MOSEC-2020/", \
          "date"     : "July 25, 2020" \
        }, \
       \
        { \
          "title"    : "A Simple Question Between User and Kernel", \
          "category" : "Kernel", \
          "url"      : "/2020-06-21-A-Simple-Question-Between-User-And-Kernel/", \
          "date"     : "June 21, 2020" \
        }, \
       \
        { \
          "title"    : "Thorough Understanding with Anonymous MMAP", \
          "category" : "Kernel", \
          "url"      : "/2020-06-18-Thorough-Understanding-With-Anonymous-MMAP/", \
          "date"     : "June 18, 2020" \
        }, \
       \
        { \
          "title"    : "CVE-2016-0728", \
          "category" : "CVEKernel", \
          "url"      : "/2020-06-07-CVE-2016-0728/", \
          "date"     : "June  7, 2020" \
        }, \
       \
        { \
          "title"    : "CVE-2016-5195", \
          "category" : "CVEKernel", \
          "url"      : "/2020-06-06-CVE-2016-5195/", \
          "date"     : "June  6, 2020" \
        }, \
       \
        { \
          "title"    : "CVE-2015-3636", \
          "category" : "CVEKernel", \
          "url"      : "/2020-05-07-CVE-2015-3636/", \
          "date"     : "May  7, 2020" \
        }, \
       \
        { \
          "title"    : "Journey through old Linux kernel CVEs", \
          "category" : "CVEKernel", \
          "url"      : "/2020-05-01-Journey-through-old-Linux-kernel-CVEs/", \
          "date"     : "May  1, 2020" \
        }, \
       \
       \
        { \
          "title"    : "About me", \
          "category" : "page", \
          "url"      : "/aboutme/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "Treasure Cave", \
          "category" : "page", \
          "url"      : "/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "Tag Index", \
          "category" : "page", \
          "url"      : "/tags/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "Treasure Cave", \
          "category" : "page", \
          "url"      : "/page2/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "Treasure Cave", \
          "category" : "page", \
          "url"      : "/page3/", \
          "date"     : "January 1, 1970" \
        } \
       \
    ]';
    searchjson = JSON.parse(searchjson);

    var sjs = SimpleJekyllSearch({
      searchInput: document.getElementById('nav-search-input'),
      resultsContainer: document.getElementById('search-results-container'),
      json: searchjson
    });
  </script>
</div>





  <!-- TODO this file has become a mess, refactor it -->







<header class="header-section ">

<div class="intro-header no-img">
  <div class="container-md">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
        <div class="post-heading">
          <h1>Blue Klotski (CVE-2021-3573) and the story for fixing</h1>
          
            
              <h2 class="post-subheading">Anyway I am sorry for everything</h2>
            
          

          
            <span class="post-meta">Posted on July 23, 2021</span>
            
            
          
        </div>
      </div>
    </div>
  </div>
</div>
</header>





<div class=" container-md ">
  <div class="row">
    <div class=" col-xl-8 offset-xl-2 col-lg-10 offset-lg-1 ">

      

      

      <article role="main" class="blog-post">
        <p>Recently me and my friends, as Greg KH said, are hammering on the bluetooth stack of the Linux kernel. And luckily, we found some pretty good vulnerability bugs that can lead to code execution.</p>

<p>In this post, I will introduce one typical one: the Blue Klotski (CVE-2021-3573).</p>

<h2 id="brief-introduction">Brief Introduction</h2>

<p>The CVE-2021-3573 is one UAF vulnerability caused by race condition when a BT controller is removed. With the <em>CAP_NET_ADMIN</em> privilege, an <strong>local attacker</strong> can emulate a fake controller from user space and detach it to trigger the UAF. The attacker can further escalate the privilege by carefully spray the freed objects to achieve arbitrary code execution.</p>

<h2 id="bug-details">Bug Details</h2>

<p>Before we take a look at these two threads (the USING thread and the FREEING thread), let’s audit the <code class="language-plaintext highlighter-rouge">hci_sock_bind()</code> function.</p>

<blockquote>
  <p>Note: the code I refer will take v5.12.0 as the example.</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">hci_sock_bind</span><span class="p">(</span><span class="k">struct</span> <span class="nc">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">addr_len</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">haddr</span><span class="p">.</span><span class="n">hci_channel</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HCI_CHANNEL_RAW</span><span class="p">:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hci_pi</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EALREADY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">haddr</span><span class="p">.</span><span class="n">hci_dev</span> <span class="o">!=</span> <span class="n">HCI_DEV_NONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hdev</span> <span class="o">=</span> <span class="n">hci_dev_get</span><span class="p">(</span><span class="n">haddr</span><span class="p">.</span><span class="n">hci_dev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdev</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">promisc</span><span class="p">);</span>
		<span class="p">}</span>
<span class="p">...</span>
        <span class="n">hci_pi</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">hdev</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In short, the <code class="language-plaintext highlighter-rouge">hci_sock_bind()</code> function will fetch the hdev based on the user supplied index, and attach it to the sockets with <code class="language-plaintext highlighter-rouge">hci_pi(sk)-&gt;hdev = hdev</code>. For now, this HCI socket becomes a “bound” socket because it has some connection with the BT controller.</p>

<p>Moreoever, the <code class="language-plaintext highlighter-rouge">hci_dev_get()</code> function is used to increase the <code class="language-plaintext highlighter-rouge">refcnt</code> of the <code class="language-plaintext highlighter-rouge">hdev</code>, keep this in memory because we will use it later.</p>

<h3 id="using-routine">USING routine</h3>

<p>Once the socket is bound to one controller, the function <code class="language-plaintext highlighter-rouge">hci_sock_bound_ioctl()</code> is allowed.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Ioctls that require bound socket */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hci_sock_bound_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="nc">hci_dev</span> <span class="o">*</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">hci_pi</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">;</span>
<span class="p">...</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>

	<span class="k">case</span> <span class="n">HCIGETCONNINFO</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">hci_get_conn_info</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">HCIGETAUTHINFO</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">hci_get_auth_info</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">HCIBLOCKADDR</span><span class="p">:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">hci_sock_blacklist_add</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">HCIUNBLOCKADDR</span><span class="p">:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">hci_sock_blacklist_del</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>There are four commands offered in this function, all these commands have their utitily function to further operate on the linked list in <code class="language-plaintext highlighter-rouge">hdev</code> object. The very check in top of the <code class="language-plaintext highlighter-rouge">hci_sock_bound_ioctl</code> will make sure only the bound sockets will be manipulated.</p>

<p>We can see on of these commands, like the <code class="language-plaintext highlighter-rouge">hci_sock_blacklist_add()</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">hci_sock_blacklist_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bdaddr_t</span> <span class="n">bdaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdaddr</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bdaddr</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">hci_dev_lock</span><span class="p">(</span><span class="n">hdev</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">hci_bdaddr_list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">blacklist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdaddr</span><span class="p">,</span> <span class="n">BDADDR_BREDR</span><span class="p">);</span>

	<span class="n">hci_dev_unlock</span><span class="p">(</span><span class="n">hdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It’s a quite simple function: gets the argument from the user pointer, obtains the lock, operates the list and then releases the lock. In short, this function will finally change the hdev-&gt;blacklist and add one allocated BT address on it.</p>

<h3 id="freeing-routine">FREEING routine</h3>

<p>Normally, the bound socket is expected to drop the bind when the socket is closed.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">hci_sock_release</span><span class="p">(</span><span class="k">struct</span> <span class="nc">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hdev</span> <span class="o">=</span> <span class="n">hci_pi</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">promisc</span><span class="p">);</span>
		<span class="n">hci_dev_put</span><span class="p">(</span><span class="n">hdev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As you can see, this is highly symmetry to the <code class="language-plaintext highlighter-rouge">hci_sock_bind()</code>. Just looks quite safe.</p>

<p>However, is this the only place the socket drop the refcnt? The answer is NO. We know that the bound socket means somewhat a connection between the sock and the hardware controller. What if this controller is unplugged? The sock must be aware of this event.</p>

<p>The relevant function is <code class="language-plaintext highlighter-rouge">hci_sock_dev_event()</code>. When the controller is getting removed, the kernel will awake the <code class="language-plaintext highlighter-rouge">hci_unreigster_dev()</code> function, which will then call <code class="language-plaintext highlighter-rouge">hci_sock_dev_event()</code> with <code class="language-plaintext highlighter-rouge">HCI_DEV_UNREG</code> argument.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">hci_sock_dev_event</span><span class="p">(</span><span class="k">struct</span> <span class="nc">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">HCI_DEV_UNREG</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="nc">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

		<span class="cm">/* Detach sockets from device */</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hci_sk_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">sk_for_each</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hci_sk_list</span><span class="p">.</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bh_lock_sock_nested</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hci_pi</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hdev</span> <span class="o">==</span> <span class="n">hdev</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hci_pi</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// {1}</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="n">EPIPE</span><span class="p">;</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">BT_OPEN</span><span class="p">;</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

				<span class="n">hci_dev_put</span><span class="p">(</span><span class="n">hdev</span><span class="p">);</span> <span class="c1">// {2}</span>
			<span class="p">}</span>
			<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hci_sk_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This function will traverse the list of sockets through <code class="language-plaintext highlighter-rouge">hci_sk_list</code> and find out the sockets that may bound to the unregistering <code class="language-plaintext highlighter-rouge">hdev</code>. It will then updates the sock (like <code class="language-plaintext highlighter-rouge">{1}</code> mark) and drop the refcnt (like <code class="language-plaintext highlighter-rouge">{2}</code> mark).</p>

<p>The <code class="language-plaintext highlighter-rouge">hdev</code> object will be ultimately released when the underground driver calls <code class="language-plaintext highlighter-rouge">hci_free_dev()</code>, which will drop the last refcnt and later to <code class="language-plaintext highlighter-rouge">kfree</code>.</p>

<p>This abnormal <code class="language-plaintext highlighter-rouge">hdev</code> refcnt dropping routine is not safe as expected. In fact, it can easily race with the USING routine like below.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hci_sock_bound_ioctl thread    |    hci_unregister_dev thread
                               |
                               |
if (!hdev)                     |    
    return -EBADFD;            |    
                               |
                               |    hci_pi(sk)-&gt;hdev = NULL;
                               |    ...
                               |    hci_dev_put(hdev);
                               |    ...
                               |    hci_free_dev(hdev);
// UAF, for example            |
hci_dev_lock(hdev);            |
                               |
                               |
</code></pre></div></div>

<p>You can refer to the oss report (https://www.openwall.com/lists/oss-security/2021/06/08/2) for details like POC and crash log.</p>

<h2 id="the-exploitation">The Exploitation</h2>

<p>Some readers may begin to complain: race? Hmmmmm… It’s not stable and not interesing.</p>

<p>Well, I have to tell you that this race is an exception, for it can be one hundred percent stably triggered. :)</p>

<p>If you read the above kernel code carefully, you will find the trick there.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">hci_sock_blacklist_add</span><span class="p">(</span><span class="k">struct</span> <span class="nc">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bdaddr_t</span> <span class="n">bdaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdaddr</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bdaddr</span><span class="p">)))</span> <span class="c1">// {3}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">{3}</code> marked code get its content from userspace, which means we can adopt the <a href="https://man7.org/linux/man-pages/man2/userfaultfd.2.html">userfaultfd</a> technique to hang this routine. And we can wake it until the <code class="language-plaintext highlighter-rouge">hdev</code> is already freed to cause the UAF.</p>

<p>The race will be like below.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hci_sock_bound_ioctl thread    |    hci_unregister_dev thread
                               |
                               |
if (!hdev)                     |    
    return -EBADFD;            |    
                               |
copy_from_user()               |
____________________________   |
                               |
                               |    hci_pi(sk)-&gt;hdev = NULL;
                               |    ...
    userfaultfd hang           |    hci_dev_put(hdev);
                               |    ...
                               |    hci_free_dev(hdev);
____________________________   |
// UAF, for example            |
hci_dev_lock(hdev);            |
                               |
                               |
</code></pre></div></div>

<p>Therefore, with this stable UAF, let’s write our exploit.</p>

<blockquote>
  <p>To be honest, this is my first time to write one 0-day exploit. Thankfully, this makes no big difference comparing to a CTF challenge.
BTW, the hci_sock_bound_ioctl() has limited operations hence I choose the hci_sock_sendmsg() as the USING routine in my exploits.</p>
</blockquote>

<h3 id="leaking">Leaking</h3>

<p>The first question is how to bypass the KASLR. I have been blocked there for a while as I wanted to leak some code/data pointers with some known skills. Like the <a href="https://marc.info/?l=linux-bluetooth&amp;m=162174982523451&amp;w=2">OOB read</a> in bluetooth I have reported to the community.</p>

<p>After some fail attempts, I choose to do the leaking with the Blue Klotski and it turns out to be totally enough. I just have to find some place that may trigger a kernel WARNING and I can get the pointers I wanted from the printed report.</p>

<p>For instance, one NPD in the workqueue functions.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[   17.793908] BUG: kernel NULL pointer dereference, address: 0000000000000000
[   17.794222] #PF: supervisor read access in kernel mode
[   17.794405] #PF: error_code(0x0000) - not-present page
[   17.794637] PGD 0 P4D 0
[   17.794816] Oops: 0000 [#1] SMP NOPTI
[   17.795043] CPU: 0 PID: 119 Comm: exploit Not tainted 5.12.1 #18
[   17.795217] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014
[   17.795543] RIP: 0010:__queue_work+0xb2/0x3b0
[   17.795728] Code: 8b 03 eb 2f 83 7c 24 04 40 0f 84 ab 01 00 00 49 63 c4 49 8b 9d 08 01 00 00 49 03 1c c6 4c 89 ff e8 73 fb ff ff 48 85 c0 74 d5 &lt;48&gt; 39 030
[   17.796191] RSP: 0018:ffffac4d8021fc20 EFLAGS: 00000086
[   17.796329] RAX: ffff9db3013af400 RBX: 0000000000000000 RCX: 0000000000000000
[   17.796545] RDX: 0000000000000000 RSI: 0000000000000003 RDI: ffffffffbdc4cf10
[   17.796769] RBP: 000000000000000d R08: ffff9db301400040 R09: ffff9db301400000
[   17.796926] R10: 0000000000000000 R11: ffffffffbdc4cf18 R12: 0000000000000000
[   17.797109] R13: ffff9db3021b4c00 R14: ffffffffbdb106a0 R15: ffff9db302260860
[   17.797328] FS:  00007fa9edf9d740(0000) GS:ffff9db33ec00000(0000) knlGS:0000000000000000
[   17.797541] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   17.797699] CR2: 0000000000000000 CR3: 000000000225c000 CR4: 00000000001006f0
[   17.797939] Call Trace:
[   17.798694]  queue_work_on+0x1b/0x30
[   17.798865]  hci_sock_sendmsg+0x3bc/0x960
[   17.798973]  sock_sendmsg+0x56/0x60
[   17.799081]  sock_write_iter+0x92/0xf0
[   17.799170]  do_iter_readv_writev+0x145/0x1c0
[   17.799303]  do_iter_write+0x7b/0x1a0
[   17.799386]  vfs_writev+0x93/0x160
[   17.799527]  ? hci_sock_bind+0xbe/0x650
[   17.799638]  ? __sys_bind+0x8f/0xe0
[   17.799725]  ? do_writev+0x53/0x120
[   17.799804]  do_writev+0x53/0x120
[   17.799882]  do_syscall_64+0x33/0x40
[   17.799969]  entry_SYSCALL_64_after_hwframe+0x44/0xae
[   17.800186] RIP: 0033:0x7fa9ee08d35d
[   17.800405] Code: 28 89 54 24 1c 48 89 74 24 10 89 7c 24 08 e8 ca 26 f9 ff 8b 54 24 1c 48 8b 74 24 10 41 89 c0 8b 7c 24 08 b8 14 00 00 00 0f 05 &lt;48&gt; 3d 008
[   17.800798] RSP: 002b:00007ffe3c870e00 EFLAGS: 00000293 ORIG_RAX: 0000000000000014
[   17.800969] RAX: ffffffffffffffda RBX: 0000556f50a02f30 RCX: 00007fa9ee08d35d
[   17.801118] RDX: 0000000000000003 RSI: 00007ffe3c870ea0 RDI: 0000000000000005
[   17.801267] RBP: 00007ffe3c870ee0 R08: 0000000000000000 R09: 00007fa9edf87700
[   17.801413] R10: 00007fa9edf879d0 R11: 0000000000000293 R12: 0000556f50a00fe0
[   17.801560] R13: 00007ffe3c870ff0 R14: 0000000000000000 R15: 0000000000000000
[   17.801769] Modules linked in:
[   17.801928] CR2: 0000000000000000
[   17.802233] ---[ end trace 2bbc14e693eb3d8f ]---
[   17.802373] RIP: 0010:__queue_work+0xb2/0x3b0
[   17.802492] Code: 8b 03 eb 2f 83 7c 24 04 40 0f 84 ab 01 00 00 49 63 c4 49 8b 9d 08 01 00 00 49 03 1c c6 4c 89 ff e8 73 fb ff ff 48 85 c0 74 d5 &lt;48&gt; 39 030
[   17.802874] RSP: 0018:ffffac4d8021fc20 EFLAGS: 00000086
[   17.803019] RAX: ffff9db3013af400 RBX: 0000000000000000 RCX: 0000000000000000
[   17.803166] RDX: 0000000000000000 RSI: 0000000000000003 RDI: ffffffffbdc4cf10
[   17.803313] RBP: 000000000000000d R08: ffff9db301400040 R09: ffff9db301400000
[   17.803458] R10: 0000000000000000 R11: ffffffffbdc4cf18 R12: 0000000000000000
[   17.803605] R13: ffff9db3021b4c00 R14: ffffffffbdb106a0 R15: ffff9db302260860
[   17.803753] FS:  00007fa9edf9d740(0000) GS:ffff9db33ec00000(0000) knlGS:0000000000000000
[   17.803921] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   17.804042] CR2: 0000000000000000 CR3: 000000000225c000 CR4: 00000000001006f0
</code></pre></div></div>

<p>The registers RDI, R11 and R14 seems store some kernel pointers. Taking a look at the System.map, you will find out the R14 is points to the global variable <code class="language-plaintext highlighter-rouge">__per_cpu_offset</code>. It will help us to calculate the KASLR offset and then bypass the protection.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ffffffff825106a0 R __per_cpu_offset
</code></pre></div></div>

<h3 id="exploitation">Exploitation</h3>

<h4 id="rip-hijacking">RIP hijacking</h4>

<p>With the KASLR bypassed, the next target is to hijack the control flow. To achieve this, the simplest thing is to compromise a code pointer (see below). That is, we have to spray the kernel heap to overwrite the released <code class="language-plaintext highlighter-rouge">hdev</code>. Thankfully, it is a piece of cake to spray as the <code class="language-plaintext highlighter-rouge">hdev</code> is one <code class="language-plaintext highlighter-rouge">kmalloc-8k</code> object. The big size makes its cache rather stable and I can easily spray the <code class="language-plaintext highlighter-rouge">hdev</code> with <code class="language-plaintext highlighter-rouge">setxattr</code> syscall.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">hci_dev</span> <span class="p">{</span>
<span class="p">...</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">close</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">flush</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">send</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">notify</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">evt</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hw_error</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">code</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">post_init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_diag</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_bdaddr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span> <span class="k">const</span> <span class="n">bdaddr_t</span> <span class="o">*</span><span class="n">bdaddr</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cmd_timeout</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">prevent_wake</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hci_dev</span> <span class="o">*</span><span class="n">hdev</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Assuming we can overwrite the entire <code class="language-plaintext highlighter-rouge">hdev</code> and corrupt the above code pointers, can we achive RIP hijacking? Well. things don’t seem to be so simple and these code pointers are used out of the USING routine.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">hci_sock_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="nc">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
	<span class="n">hdev</span> <span class="o">=</span> <span class="n">hci_pi</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hdev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">...</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcpy_from_msg</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span> <span class="n">msg</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hci_skb_pkt_type</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hci_pi</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">==</span> <span class="n">HCI_CHANNEL_USER</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hci_skb_pkt_type</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">==</span> <span class="n">HCI_COMMAND_PKT</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ogf</span> <span class="o">==</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">raw_q</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">queue_work</span><span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">tx_work</span><span class="p">);</span> <span class="c1">// {4}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Stand-alone HCI commands must be flagged as
			 * single-command requests.
			 */</span>
			<span class="n">bt_cb</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hci</span><span class="p">.</span><span class="n">req_flags</span> <span class="o">|=</span> <span class="n">HCI_REQ_START</span><span class="p">;</span>

			<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">cmd_q</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">queue_work</span><span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">cmd_work</span><span class="p">);</span> <span class="c1">// {5}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_RAW</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">raw_q</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">tx_work</span><span class="p">);</span> <span class="c1">// {4}</span>
	<span class="p">}</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As you can see, the <code class="language-plaintext highlighter-rouge">hci_sock_senmsg()</code> function doesn’t call any code pointers but only uses some data candidates in <code class="language-plaintext highlighter-rouge">hdev</code>. We may have to compromise the data in <code class="language-plaintext highlighter-rouge">hdev</code> first and figure out how to affect the control flow.</p>

<p>Which candidate can we exploit? If you are familar with the workqueue in kernel, you may find the answer. Yes, the <code class="language-plaintext highlighter-rouge">work_struct</code>. The <code class="language-plaintext highlighter-rouge">hci_sock_sendmsg</code> function, as the handler of <code class="language-plaintext highlighter-rouge">send</code> syscall, will allocate the <code class="language-plaintext highlighter-rouge">skb</code> and queue it to corresponding <code class="language-plaintext highlighter-rouge">sk_buff</code> queues. It will then queue relevant <code class="language-plaintext highlighter-rouge">work_struct</code> to <code class="language-plaintext highlighter-rouge">hdev-&gt;workqueue</code> to issue these <code class="language-plaintext highlighter-rouge">skb</code>.</p>

<p>The layout of the <code class="language-plaintext highlighter-rouge">work_struct</code> is quite juicy.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">work_func_t</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="k">struct</span> <span class="nc">work_struct</span> <span class="p">{</span>
	<span class="n">atomic_long_t</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">list_head</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">work_func_t</span> <span class="n">func</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_LOCKDEP
</span>	<span class="k">struct</span> <span class="nc">lockdep_map</span> <span class="n">lockdep_map</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div>

<p>Whoooo, <code class="language-plaintext highlighter-rouge">func</code> is a code pointer. As we can overwrite the entire <code class="language-plaintext highlighter-rouge">hdev</code>, we are able to compomise the <code class="language-plaintext highlighter-rouge">func</code> in either <code class="language-plaintext highlighter-rouge">hdev-&gt;cmd_work</code> or <code class="language-plaintext highlighter-rouge">hdev-&gt;tx_work</code> to allow control flow being controllered.</p>

<p>But I failed again.</p>

<p>This is because the <code class="language-plaintext highlighter-rouge">hdev-&gt;workqueue</code> is already destoryed is the <code class="language-plaintext highlighter-rouge">hci_unregister_dev()</code> function. The <code class="language-plaintext highlighter-rouge">work_struct</code> queued into this workqueue will not be scheduled at all.</p>

<p>Wait? didn’t I say I can compromise the entire <code class="language-plaintext highlighter-rouge">hdev</code>? Why just I also compromise the <code class="language-plaintext highlighter-rouge">hdev-&gt;workqueue</code> to allow the planed attack?</p>

<p>It sounds like a plan but not an easy one for I have to leak the adress of one valid <code class="language-plaintext highlighter-rouge">workqueue_struct</code>. This is not like the KASLR offset leak as the <code class="language-plaintext highlighter-rouge">workqueue_struct</code> is allocated in the kernel slub caches. I need strong primitive to leak the heap layout and possibly find one living <code class="language-plaintext highlighter-rouge">workqueue_struct</code>.</p>

<p>After some fail attempts again, I decide to change my mind. I can use the original <code class="language-plaintext highlighter-rouge">hdev-&gt;workqueue</code> pointer to fulfill my want. Although the object it points to is currently destroyed, but we can “spray” the heap to put a new one there. This is the second spray in the exploit and interesting enough, this spray is not aim to overwrite data but provide qualified data.</p>

<blockquote>
  <p>The spray for <code class="language-plaintext highlighter-rouge">workqueue_struct</code> (kmalloc-512 object) is much harder than the <code class="language-plaintext highlighter-rouge">hdev</code> because there are some other places keeping allocate this size of objects. To achieve the spray I play some sequence tricks and you can refer to the exploits for detail.</p>
</blockquote>

<p>Well done, when the <code class="language-plaintext highlighter-rouge">workqueue</code> pointer is pointing to one living <code class="language-plaintext highlighter-rouge">workqueue_struct</code>, the <code class="language-plaintext highlighter-rouge">queue_work(hdev-&gt;workqueue, ...)</code> is assumed to be completed successfully. A little frustrated thing is that the <code class="language-plaintext highlighter-rouge">func</code> pointer in <code class="language-plaintext highlighter-rouge">work_struct</code> is behind the <code class="language-plaintext highlighter-rouge">workqueue</code> so we still cannot get the RIP for now. (We have to keep the <code class="language-plaintext highlighter-rouge">workeuque</code> the same)</p>

<p>It’s fine because both the <code class="language-plaintext highlighter-rouge">hci_tx_work</code> function and the <code class="language-plaintext highlighter-rouge">hci_cmd_work</code> function will call the <code class="language-plaintext highlighter-rouge">hci_send_frame()</code>, which will call the <code class="language-plaintext highlighter-rouge">hdev-&gt;send(...)</code>, the code pointer that we can overwrite.</p>

<p>And I failed here again, the third time.</p>

<p>This is because we cannot easily exploit the time when the queued <code class="language-plaintext highlighter-rouge">work_struct</code> is being scheduled. As I said before, we cannot overwrite the <code class="language-plaintext highlighter-rouge">workqueue</code> before the <code class="language-plaintext highlighter-rouge">queue_work()</code> is finished. But we have to overwrite the code pointers before it is used.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>====&gt; overwrite the hdev
+--+-----------+-----+---------+----------+---------+-----+---------------+
   | workqueue | ... | rx_work | cmd_work | tx_work | ... | code pointers |
+--+-----------+-----+---------+----------+---------+-----+---------------+
</code></pre></div></div>

<p>This unpredictable time window makes the expoit rather unstable: I can rarely spray the <code class="language-plaintext highlighter-rouge">send</code> code pointer at the right time. What should we do? Is there any hope?</p>

<p>Of course it is, when god closes a door, he opens a window there. :)</p>

<p>The answer I picked is the <code class="language-plaintext highlighter-rouge">delayed_work</code> in <code class="language-plaintext highlighter-rouge">hci_cmd_work()</code> function.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">hci_cmd_work</span><span class="p">(</span><span class="k">struct</span> <span class="nc">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="nc">hci_dev</span> <span class="o">*</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">hci_dev</span><span class="p">,</span> <span class="n">cmd_work</span><span class="p">);</span>
<span class="p">...</span>
		<span class="n">hdev</span><span class="o">-&gt;</span><span class="n">sent_cmd</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">sent_cmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="p">...</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">HCI_RESET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
				<span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">cmd_timer</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">cmd_timer</span><span class="p">,</span>
						      <span class="n">HCI_CMD_TIMEOUT</span><span class="p">);</span> <span class="c1">// {6}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">cmd_q</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">queue_work</span><span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">cmd_work</span><span class="p">);</span>
		<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">{6}</code> marked code starts a delayed work to handle the situation where the sent command is failed to receive proper reply in time. The most important thing here is this <code class="language-plaintext highlighter-rouge">HCI_CMD_TIMEOUT</code> is one predicatable time window.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define HCI_CMD_TIMEOUT		msecs_to_jiffies(2000)	</span><span class="cm">/* 2 seconds */</span><span class="cp">
</span></code></pre></div></div>

<p>Takine a further look at the <code class="language-plaintext highlighter-rouge">delayed_work</code> struct, you can find the juicy <code class="language-plaintext highlighter-rouge">work_struct</code> there.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">delayed_work</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="nc">work_struct</span> <span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">timer_list</span> <span class="n">timer</span><span class="p">;</span>

	<span class="cm">/* target workqueue and CPU -&gt;timer uses to queue -&gt;work */</span>
	<span class="k">struct</span> <span class="nc">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>That is to say, we can wait for a predicatable delay and then start the overwriting to compromise the <code class="language-plaintext highlighter-rouge">work_struct</code> in the <code class="language-plaintext highlighter-rouge">delayed_work</code>. This steady time window can boost the success rate of our attack and finally we have our primitive to achieve RIP hijacking.</p>

<h4 id="rop">ROP</h4>

<p>The ROP story is simpler compared with the above one, but also very interesting. The most interesting part is about the stack pivoting.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* HCI command timer function */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hci_cmd_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="nc">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="nc">hci_dev</span> <span class="o">*</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">hci_dev</span><span class="p">,</span>
					    <span class="n">cmd_timer</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
<span class="p">...</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">cmd_timeout</span><span class="p">)</span>
		<span class="n">hdev</span><span class="o">-&gt;</span><span class="n">cmd_timeout</span><span class="p">(</span><span class="n">hdev</span><span class="p">);</span>
</code></pre></div></div>

<p>In the very first attempt, I stick into the original delay target function <code class="language-plaintext highlighter-rouge">hci_cmd_timeout</code> and take <code class="language-plaintext highlighter-rouge">hdev-&gt;cmd_timeout</code> as the target code pointer and try to find proper gadgets to pivot the stack to some place I can control. However, almost all pivoting gadgets count on the register rax.</p>

<p>For example, the popular one</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0xffffffff81e0103f: mov rsp, rax; push r12; ret;
</code></pre></div></div>

<p>But the sad thing is the register rax is not controllable in <code class="language-plaintext highlighter-rouge">hci_cmd_timeout</code> function. (In fact, the indirect call is achieved by <code class="language-plaintext highlighter-rouge">__x86_indirect_thunk_rax</code> hence the rax is stored the gadget address).</p>

<p>This problem also makes me suffer for hours. Thanks to my friend @Nop, we finally find one very great pivoting solution.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   0xffffffff81060a41 &lt;__efi64_thunk+81&gt;:	mov    rsp,QWORD PTR [rsp+0x18]
   0xffffffff81060a46 &lt;__efi64_thunk+86&gt;:	pop    rbx
   0xffffffff81060a47 &lt;__efi64_thunk+87&gt;:	pop    rbp
   0xffffffff81060a48 &lt;__efi64_thunk+88&gt;:	ret
</code></pre></div></div>

<p>This part of code will update the rsp to the value stored in rsp+0x18. By corrupt the <code class="language-plaintext highlighter-rouge">delay_struct</code> to function <code class="language-plaintext highlighter-rouge">hci_error_reset</code> and take the <code class="language-plaintext highlighter-rouge">hdev-&gt;hw_error</code> as the critical code pointer, the <code class="language-plaintext highlighter-rouge">[rsp+0x18]</code> falls within the <code class="language-plaintext highlighter-rouge">hdev</code> object I expected.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">hci_error_reset</span><span class="p">(</span><span class="k">struct</span> <span class="nc">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="nc">hci_dev</span> <span class="o">*</span><span class="n">hdev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">hci_dev</span><span class="p">,</span> <span class="n">error_reset</span><span class="p">);</span>

	<span class="n">BT_DBG</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdev</span><span class="o">-&gt;</span><span class="n">hw_error</span><span class="p">)</span>
		<span class="n">hdev</span><span class="o">-&gt;</span><span class="n">hw_error</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">hw_error_code</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">bt_dev_err</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span> <span class="s">"hardware error 0x%2.2x"</span><span class="p">,</span> <span class="n">hdev</span><span class="o">-&gt;</span><span class="n">hw_error_code</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And the remain job is just standard kernel ROP. For demonstration purpose, I choose to corrupt the <code class="language-plaintext highlighter-rouge">modprobe_path</code> variable to allow root level arbitary code execution. You can play with this with provided demo.</p>

<p>open source: https://github.com/f0rm2l1n/ExP1oiT5/tree/main/CVE-2021-3573</p>

<h2 id="story-for-patching">Story for patching</h2>

<p>How will you guys fix this vulnerability? When I report this CVE, I provide the kernel with below patch.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">---
</span> net/bluetooth/hci_sock.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/net/bluetooth/hci_sock.c b/net/bluetooth/hci_sock.c
<span class="gh">index 251b9128f530..eed0dd066e12 100644
</span><span class="gd">--- a/net/bluetooth/hci_sock.c
</span><span class="gi">+++ b/net/bluetooth/hci_sock.c
</span><span class="p">@@ -762,7 +762,7 @@</span> void hci_sock_dev_event(struct hci_dev *hdev, int event)
 		/* Detach sockets from device */
 		read_lock(&amp;hci_sk_list.lock);
 		sk_for_each(sk, &amp;hci_sk_list.head) {
<span class="gd">-			bh_lock_sock_nested(sk);
</span><span class="gi">+			lock_sock(sk);
</span> 			if (hci_pi(sk)-&gt;hdev == hdev) {
 				hci_pi(sk)-&gt;hdev = NULL;
 				sk-&gt;sk_err = EPIPE;
<span class="p">@@ -771,7 +771,7 @@</span> void hci_sock_dev_event(struct hci_dev *hdev, int event)
 
 				hci_dev_put(hdev);
 			}
<span class="gd">-			bh_unlock_sock(sk);
</span><span class="gi">+			release_sock(sk);
</span> 		}
 		read_unlock(&amp;hci_sk_list.lock);
 	}
<span class="gd">-- 
</span><span class="p">2.30.2
</span></code></pre></div></div>

<p>From my point of view, the root cause of this BUG is that the device detaching routine drop the refcnt of <code class="language-plaintext highlighter-rouge">hdev</code> without giving concern that other routine may still use it (<code class="language-plaintext highlighter-rouge">hci_sock_bound_ioctl</code> and <code class="language-plaintext highlighter-rouge">hci_sock_sendmsg</code>).</p>

<p>Hence, as the USING routine will use <code class="language-plaintext highlighter-rouge">lock_sock</code> to defend against the race, I replace the <code class="language-plaintext highlighter-rouge">bh_lock_sock</code> to <code class="language-plaintext highlighter-rouge">lock_sock</code> too to serialize these affiars. With this fix, my POC won’t cause any KASan report and I think this is a very proper patch.</p>

<p>But I failed, one more time.</p>

<p>Because I am just a noob of the kernel locking mechanism, I just make a huge mistake in this patch: the <code class="language-plaintext highlighter-rouge">lock_sock</code> here violates the kernel atomoic lock rules and it may lead to dead lock (I really didn’t know this when designing the patch T.T).</p>

<p>And what’s worse, the kernel community is happy to adopt this patch without much hesitation.</p>

<p>The disaster shows itself about a week after the patch is merged to the mainline. I started to receive email that tells me the patch is ridiculous. The very first one is <a href="https://github.com/akmistry">Anand K. Mistry</a> from Google Australia, he showed me the report from his computer and explained me the possibility of the dead lock.</p>

<p>After that, more and more developers are start to give their concern. One big reason for that is the syzkaller keeps generating the fuzzing report for this misused lock.</p>

<blockquote>

  <p>Also, this regression is currently 7th top crashers for syzbot</p>

</blockquote>

<p>I am just feel too ashamed to bring this trouble XD. Several discussions are raised to solve this and I have to say sorry that I failed to reply with some emails timely because I had to handle the exam week in school. Below are some links you guys can follow to catch up.</p>

<p>https://lore.kernel.org/linux-bluetooth/nycvar.YFH.7.76.2107131924280.8253@cbobk.fhfr.pm/
https://www.spinics.net/lists/linux-bluetooth/msg92649.html
https://marc.info/?l=linux-bluetooth&amp;m=162441276805113&amp;w=2
https://marc.info/?l=linux-bluetooth&amp;m=162653675414330&amp;w=2</p>

<p>The point is this race condition is not an easy fixed one (Check these links to find the intense discussion). Thanks to kernel developer Tetsuo Handa, and the maintainer <a href="https://github.com/Vudentz">Luiz</a>, I think the proper patch will soon be settled down.</p>

<p>You can do your own selection before that: https://lkml.kernel.org/r/05535d35-30d6-28b6-067e-272d01679d24@i-love.sakura.ne.jp</p>

<h2 id="conclusion">Conclusion</h2>

<p>I’ve learnt a lot during my first 0-day exploit and all this is just beautiful like an art.</p>

<p>Of course, this bug is not a very perfect one as it asks CAP_NET_ADMIN privilege and the fullchain requires the attacker to compromise one daemon first.</p>

<p>This is the inherent flaws for exploiting local Linux BT stack. You can to get this privilege to emulate a userspace controller or you have to use a real one. The better vulnerabilities should be like as the <a href="https://github.com/google/security-research/tree/master/pocs/linux/bleedingtooth">BleedingTooth</a>, which requires nothing and can achieve code execution remotely.</p>

<p>That type of bugs will be our utilimate goals.</p>

      </article>

      
        <div class="blog-tags">
          <span>Tags:</span>
          
            <a href="https://f0rm2l1n.github.io/tags#CVE">CVE</a>
          
            <a href="https://f0rm2l1n.github.io/tags#Kernel">Kernel</a>
          
        </div>
      

      

      
        <!-- Check if any share-links are active -->




<section id="social-share-section">
  <span class="sr-only">Share: </span>

  
    <a href="https://twitter.com/intent/tweet?text=Blue+Klotski+%28CVE-2021-3573%29+and+the+story+for+fixing&amp;url=https%3A%2F%2Ff0rm2l1n.github.io%2F2021-07-23-Blue-Klotski%2F" class="btn btn-social-icon btn-twitter" title="Share on Twitter">
      <span class="fab fa-fw fa-twitter" aria-hidden="true"></span>
      <span class="sr-only">Twitter</span>
    </a>
  

  
    <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Ff0rm2l1n.github.io%2F2021-07-23-Blue-Klotski%2F" class="btn btn-social-icon btn-facebook" title="Share on Facebook">
      <span class="fab fa-fw fa-facebook" aria-hidden="true"></span>
      <span class="sr-only">Facebook</span>
    </a>
  

  
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A%2F%2Ff0rm2l1n.github.io%2F2021-07-23-Blue-Klotski%2F" class="btn btn-social-icon btn-linkedin" title="Share on LinkedIn">
      <span class="fab fa-fw fa-linkedin" aria-hidden="true"></span>
      <span class="sr-only">LinkedIn</span>
    </a>
  

  

  

</section>



      

      <ul class="pagination blog-pager">
        
        <li class="page-item previous">
          <a class="page-link" href="https://f0rm2l1n.github.io/2021-07-21-notice-in-the-cave/" data-toggle="tooltip" data-placement="top" title="Notice in the clave">← Previous Post</a>
        </li>
        
        
      </ul>
      
  
  
  

  




    </div>
  </div>
</div>


  <footer>
  <div class="container-md beautiful-jekyll-footer">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
      <ul class="list-inline text-center footer-links"><li class="list-inline-item">
    <a href="https://f0rm2l1n.github.io/feed.xml" title="RSS">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">RSS</span>
    </a>
  </li><li class="list-inline-item">
    <a href="mailto:someone@example.com" title="Email me">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Email me</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://www.facebook.com/deanattali" title="Facebook">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-facebook fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Facebook</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://github.com/daattali" title="GitHub">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-github fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">GitHub</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://twitter.com/daattali" title="Twitter">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Twitter</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://www.youtube.com/c/daattali" title="YouTube">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-youtube fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">YouTube</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://patreon.com/DeanAttali" title="Patreon">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-patreon fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Patreon</span>
    </a>
  </li></ul>

      
      <p class="copyright text-muted">
      
        f0rm2l1n
        &nbsp;•&nbsp;
      
      2021

      
        &nbsp;•&nbsp;
        <span class="author-site">
          <a href="https://f0rm2l1n.github.io/">MyWebsite.com</a>
        </span>
      

      
      </p>
      <p class="theme-by text-muted">
        Powered by
        <a href="https://beautifuljekyll.com/">Beautiful Jekyll</a>
      </p>
      </div>
    </div>
  </div>
</footer>


  
  
    
  <script src="./2021 - Blue Klotski (CVE-2021-3573) and the story for fixing_files/jquery-3.5.1.slim.min.js.下載" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" crossorigin="anonymous"></script>


  
    
  <script src="./2021 - Blue Klotski (CVE-2021-3573) and the story for fixing_files/popper.min.js.下載" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>


  
    
  <script src="./2021 - Blue Klotski (CVE-2021-3573) and the story for fixing_files/bootstrap.min.js.下載" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>


  



  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
      <script src="./2021 - Blue Klotski (CVE-2021-3573) and the story for fixing_files/beautifuljekyll.js.下載"></script>
    
  











</body></html>