<!DOCTYPE html>
<!-- saved from url=(0088)https://starlabs.sg/blog/2022/06/io_uring-new-code-new-bugs-and-a-new-exploit-technique/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>STAR Labs | Blog | io_uring - new code, new bugs, and a new exploit technique</title><meta name="description" content=""><script type="application/javascript">window.location.hostname.match(/^(192\.168\.|10\.|localhost$)/i)&&(window.ga=function(){})</script><script type="application/javascript">var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-134746054-1","auto"),ga("send","pageview"))</script><script async="" src="./STAR Labs _ Blog _ io_uring - new code, new bugs, and a new exploit technique_files/analytics.js.ä¸‹è¼‰"></script>
<link type="text/css" rel="stylesheet" href="./STAR Labs _ Blog _ io_uring - new code, new bugs, and a new exploit technique_files/pure.min.css"><link type="text/css" rel="stylesheet" href="./STAR Labs _ Blog _ io_uring - new code, new bugs, and a new exploit technique_files/starlabs.min.css"><link rel="stylesheet" href="./STAR Labs _ Blog _ io_uring - new code, new bugs, and a new exploit technique_files/simple-line-icons.css"><link rel="stylesheet" href="./STAR Labs _ Blog _ io_uring - new code, new bugs, and a new exploit technique_files/linearicons.css"><link rel="alternate" type="application/rss+xml" href="https://starlabs.sg/blog/index.xml"><meta property="og:title" content="io_uring - new code, new bugs, and a new exploit technique"><meta property="og:description" content="For the past few weeks, I have been working on conducting N-day analysis and bug hunting in the io_uring subsystem of the Linux kernel with the guidance of my mentors, Billy and Ramdhan.
In this article, I will briefly discuss the io_uring subsystem, as well as my approach to discovering and developing a new kernel exploit technique during my N-day analysis of CVE-2021-41073. I will also discuss two bugs I found while analyzing a new io_uring feature."><meta property="og:type" content="article"><meta property="og:url" content="https://starlabs.sg/blog/2022/06/io_uring-new-code-new-bugs-and-a-new-exploit-technique/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-06-24T00:00:00+00:00"><meta property="article:modified_time" content="2022-06-24T00:00:00+00:00"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="io_uring - new code, new bugs, and a new exploit technique"><meta name="twitter:description" content="For the past few weeks, I have been working on conducting N-day analysis and bug hunting in the io_uring subsystem of the Linux kernel with the guidance of my mentors, Billy and Ramdhan.
In this article, I will briefly discuss the io_uring subsystem, as well as my approach to discovering and developing a new kernel exploit technique during my N-day analysis of CVE-2021-41073. I will also discuss two bugs I found while analyzing a new io_uring feature."><link href="./STAR Labs _ Blog _ io_uring - new code, new bugs, and a new exploit technique_files/css" rel="stylesheet"></head><body><div class="header"><div class="topnav at-top pure-menu pure-menu-horizontal pure-menu-fixed"><ul class="pure-menu-list"><li class="pure-menu-item"><a href="https://starlabs.sg/" class="pure-menu-link">Home</a></li><li class="pure-menu-item"><a href="https://starlabs.sg/advisories/" class="pure-menu-link">Advisories</a></li><li class="pure-menu-item pure-menu-selected"><a href="https://starlabs.sg/blog/" class="pure-menu-link">Blog</a></li></ul></div></div><div class="splash-container"><div class="splash"><div class="pure-g"><div class="pure-u-1-5 pure-sm-1-2"><img class="logo" src="./STAR Labs _ Blog _ io_uring - new code, new bugs, and a new exploit technique_files/logo-white.png"></div><div class="pure-u-4-5 pure-sm-1-2"><h1 class="splash-head">Blog</h1></div></div></div></div><div class="content-wrapper"><div class="content pure-g"><div class="articles-wrapper pure-u-1 pure-u-md-3-4"><h1 class="list-heading"><a href="https://starlabs.sg/blog/2022/06/io_uring-new-code-new-bugs-and-a-new-exploit-technique/">io_uring - new code, new bugs, and a new exploit technique</a></h1><div class="post-meta content-subhead"><span><i class="icon icon-clock"></i>Jun 24, 2022</span><span>
<i class="icon icon-user"></i>Lam Jun Rong (@junr0n)</span></div><p>For the past few weeks, <a href="https://twitter.com/junr0n">I</a> have been working on conducting N-day analysis and bug hunting in the io_uring subsystem of the Linux kernel with the guidance of my mentors, <a href="https://twitter.com/st424204">Billy</a> and <a href="https://twitter.com/n0psledbyte">Ramdhan</a>.</p><p>In this article, I will briefly discuss the io_uring subsystem, as well as my approach to discovering and developing a new kernel exploit technique during my N-day analysis of <code>CVE-2021-41073</code>. I will also discuss two bugs I found while analyzing a new io_uring feature.</p><h1 id="what-is-io_uring">What is io_uring?</h1><p>The io_uring subsystem was created by <a href="https://twitter.com/axboe">Jens Axboe</a> to improve the performance of I/O operations (file read/write, socket send/receive). Traditionally, such I/O operations that require interaction with the kernel occur via system calls (syscalls), which incur significant overhead due to the need for context switches from user to kernel mode and back. This can have a significant impact on programs that perform a large number of such I/O operations, such as web servers. It is currently <a href="https://github.com/nginx/unit/issues/511">planned</a> to be integrated into NGINX Unit. io_uring consists of both a kernel subsystem (mostly located in <code>fs/io_uring.c</code>) and a userland library (<a href="https://github.com/axboe/liburing">liburing</a>).</p><p>Instead of using syscalls for every request, io_uring enables communication between user and kernel mode via two ring buffers, which are shared between kernel and userland: the submission queue (SQ) and completion queue (CQ). As their names suggest, userland programs place I/O requests on the SQ, where they are dequeued and processed by the kernel. Completed requests are placed on the CQ, allowing the userland program to retrieve the results of the operation.</p><p>SQ and CQ operations are asynchronous: adding a request to the SQ will never block, unless the queue is full, in which case an error is returned.</p><p>io_uring can be configured to either continuously check (poll) the SQ for new requests, or a syscall (<code>io_uring_enter</code>) can be used to inform the kernel that new requests are present. The kernel can then either process the request in the current thread, or delegate it to other kernel worker threads.</p><p>io_uring is one of the fastest growing subsystems in the Linux kernel, with support for new kinds of I/O operations continuously being added. <code>fs/io_uring.c</code> is one of the largest files in the <code>fs</code> directory, with over 13,000 lines and 300,000 bytes (as of kernel v5.19-rc3).</p><p>With such a large and active codebase, it is no surprise that bugs such as <a href="https://www.zerodayinitiative.com/blog/2021/4/22/cve-2021-20226-a-reference-counting-bug-in-the-linux-kernel-iouring-subsystem">CVE-2021-20226</a> and <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d1f82808877bb10d3deee7cf3374a4eb3fb582db">CVE-2021-3491</a> (found by my mentor, Billy ðŸ™‚) are continually being found in this subsystem.</p><h1 id="provided-buffers">Provided buffers</h1><p>When synchronous I/O is performed, memory space to store results is required almost immediately. However, in asynchronous I/O, requests may not be processed for quite some time. Thus, allocating a buffer for each request consumes an unnecessarily large amount of memory. It is more efficient to allocate a pool of buffers and hand it over to io_uring to select which buffer it wants to use for a certain request. The ID of the buffer selected is returned to the userland application. This is known as legacy provided buffers, or simply provided buffers.</p><p>Unfortunately, until <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/fs/io_uring.c?h=v5.18-rc1&amp;id=b1c62645758eb438179e3a0769168cb7b0a94d6b">recently</a> (kernel version 5.18-rc1), provided buffers were single use, and the application had to provide (or reregister) new buffers once the original buffers were used up. Very recently (mid May 2022, kernel version 5.19-rc1), <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/fs/io_uring.c?h=v5.19-rc1&amp;id=c7fb19428d67dd0a2a78a4f237af01d39c78dc5a">ring mapped</a> supplied buffers landed in io_uring. Provided buffers can now be tracked in a ring queue, with the first buffer in the queue being reused after the last one is used. While both are ring buffers, this mechanism is separate from the submission queue or completion queue.</p><p>The first kind of provided buffers will be relevant to the first part of the post, while the second (ring provided buffers) will be discussed in the second section.</p><h1 id="cve-2021-41073">CVE-2021-41073</h1><p>CVE-2021-41073 is an incorrect free in io_uring that was discovered by <a href="https://twitter.com/chompie1337">Valentina Palmiotti</a>. The bug occurs in <code>loop_rw_iter</code> when provided buffers are used.</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#66d9ef">static</span> ssize_t <span style="color:#a6e22e">loop_rw_iter</span>(<span style="color:#66d9ef">int</span> rw, <span style="color:#66d9ef">struct</span> io_kiocb <span style="color:#f92672">*</span>req, <span style="color:#66d9ef">struct</span> iov_iter <span style="color:#f92672">*</span>iter)
</span></span><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>    ...
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">while</span> (iov_iter_count(iter)) {
</span></span><span style="display:flex"><span>        <span style="color:#66d9ef">struct</span> iovec iovec;
</span></span><span style="display:flex"><span>        ssize_t nr;
</span></span><span style="display:flex"><span>        ... 
</span></span><span style="display:flex"><span>        <span style="color:#66d9ef">if</span> (rw <span style="color:#f92672">==</span> READ) {
</span></span><span style="display:flex"><span>            nr <span style="color:#f92672">=</span> file<span style="color:#f92672">-&gt;</span>f_op<span style="color:#f92672">-&gt;</span>read(file, iovec.iov_base,
</span></span><span style="display:flex"><span>                          iovec.iov_len, io_kiocb_ppos(kiocb));
</span></span><span style="display:flex"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex"><span>            <span style="color:#75715e">// write to file
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex"><span>        ...
</span></span><span style="display:flex"><span>        ret <span style="color:#f92672">+=</span> nr;
</span></span><span style="display:flex"><span>        <span style="color:#66d9ef">if</span> (nr <span style="color:#f92672">!=</span> iovec.iov_len)
</span></span><span style="display:flex"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex"><span>        req<span style="color:#f92672">-&gt;</span>rw.len <span style="color:#f92672">-=</span> nr;
</span></span><span style="display:flex"><span>        req<span style="color:#f92672">-&gt;</span>rw.addr <span style="color:#f92672">+=</span> nr; <span style="color:#75715e">// bug here!
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>        iov_iter_advance(iter, nr);
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>If provided buffers are used, <code>req-&gt;rw.addr</code> is a kernel pointer (to an <code>io_buffer</code> object that manages provided buffers), not a userland pointer. Due to the incorrect increment of this pointer, the <code>io_buffer</code> that is supposed to be freed is not, rather the object after it is freed instead.</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">io_put_kbuf</span>(<span style="color:#66d9ef">struct</span> io_kiocb <span style="color:#f92672">*</span>req, <span style="color:#66d9ef">struct</span> io_buffer <span style="color:#f92672">*</span>kbuf)
</span></span><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cflags;
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    cflags <span style="color:#f92672">=</span> kbuf<span style="color:#f92672">-&gt;</span>bid <span style="color:#f92672">&lt;&lt;</span> IORING_CQE_BUFFER_SHIFT;
</span></span><span style="display:flex"><span>    cflags <span style="color:#f92672">|=</span> IORING_CQE_F_BUFFER;
</span></span><span style="display:flex"><span>    req<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>REQ_F_BUFFER_SELECTED;
</span></span><span style="display:flex"><span>    kfree(kbuf); <span style="color:#75715e">// req-&gt;rw.addr is freed here
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> cflags;
</span></span><span style="display:flex"><span>}
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">io_put_rw_kbuf</span>(<span style="color:#66d9ef">struct</span> io_kiocb <span style="color:#f92672">*</span>req)
</span></span><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">struct</span> io_buffer <span style="color:#f92672">*</span>kbuf;
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    kbuf <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> io_buffer <span style="color:#f92672">*</span>) (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) req<span style="color:#f92672">-&gt;</span>rw.addr;
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">return</span> io_put_kbuf(req, kbuf);
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p><img src="./STAR Labs _ Blog _ io_uring - new code, new bugs, and a new exploit technique_files/io_uring_0x001.png" alt="io_uring_0x001.png"></p><p>How can we exploit this incorrect free? One typical technique is to manipulate the kernel into allocating another object into the memory that was incorrectly freed. Now two kernel objects occupy the same memory, resulting in use-after-free like overwriting of memory.</p><p><img src="./STAR Labs _ Blog _ io_uring - new code, new bugs, and a new exploit technique_files/io_uring_0x002.png" alt="io_uring_0x002.png"></p><h1 id="choosing-a-suitable-kernel-object">Choosing a suitable kernel object</h1><p>But what kernel objects should we use? Kernel memory is allocated in groups of similarly sized objects known as kmalloc caches. Each cache consists of pages which are divided into many objects of a certain size. The <code>io_buffer</code> is allocated to kmalloc-32, as it has a size of 32 bytes, although objects of between 16 and 32 bytes can be allocated there as well.</p><p>Much research (<a href="https://ptr-yudai.hatenablog.com/entry/2020/03/16/165628">here</a> and <a href="https://www.cnblogs.com/helica/p/12572931.html">here</a>) has been conducted on what kernel objects can be allocated into different kmalloc caches, and their value to an attacker seeking to achieve privilege escalation. For example, <code>shm_file_data</code>, an object allocated into kmalloc-32, can be used to leak both kernel heap and text section addresses.</p><p>However, objects that can be manipulated to be allocated into any kmalloc cache, a technique known as universal heap spray, are far and few between. Perhaps the most popular and well known is <code>msg_msg</code>, whose <code>next</code> pointer, when overwritten, allows an attacker to write to arbitrary locations in memory. Unfortunately, <code>msg_msg</code> objects can only be allocated into kmalloc-64 and above. A different object must be used for kmalloc-32.</p><p>In her original writeup, Valentina uses the <code>sk_filter</code>, which contains a pointer to an extended Berkeley Packet Filter (eBPF) program. By overwriting this pointer to an attacker controlled program, local privilege escalation can be achieved. However, this technique requires another subsystem (eBPF), another kernel object (the attackerâ€™s eBPF program), as well as another leak (the address of attackerâ€™s eBPF program). Additionally, eBPF is disabled by default in Ubuntu 21.10. There must be other structs for exploiting kmalloc-32.</p><h1 id="searching-for-kernel-structs">Searching for kernel structs</h1><p>I used <a href="https://manpages.ubuntu.com/manpages/impish/man1/pahole.1.html">pahole</a> to obtain the sizes of all the structs in the linux kernel:</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"><span style="display:flex"><span>pahole --sizes vmlinux &gt; all_structs.txt
</span></span></code></pre></div><p>Then I used a simple python script to filter the list of structs down to those with size 16-32 bytes. After extracting the definitions of each struct of interest from the kernel code, I used regex to identify structs containing a few interesting features:</p><ul><li>Function pointers</li><li>Pointers to structs containing <code>op</code> in their names (possibly pointers to function pointer structs)</li><li><code>list_head</code> structs: contains <code>next</code> and <code>prev</code> pointers that can be manipulated</li></ul><p>Out of all the resultant structs, I found the <code>simple_xattr</code> struct to be particularly interesting, as I had been using <code>setxattr</code> for other parts of the exploit and knew that <code>xattrs</code> are likely to be controllable from userspace.</p><p>Checking the size of the struct with pahole, it is indeed 32 bytes, and contains a <code>list_head</code> struct:</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#66d9ef">struct</span> simple_xattr {
</span></span><span style="display:flex"><span>        <span style="color:#66d9ef">struct</span> list_head           list;                 <span style="color:#75715e">/*     0    16 */</span>
</span></span><span style="display:flex"><span>        <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>                     name;                 <span style="color:#75715e">/*    16     8 */</span>
</span></span><span style="display:flex"><span>        size_t                     size;                 <span style="color:#75715e">/*    24     8 */</span>
</span></span><span style="display:flex"><span>        <span style="color:#66d9ef">char</span>                       value[];              <span style="color:#75715e">/*    32     0 */</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>        <span style="color:#75715e">/* size: 32, cachelines: 1, members: 4 */</span>
</span></span><span style="display:flex"><span>        <span style="color:#75715e">/* last cacheline: 32 bytes */</span>
</span></span><span style="display:flex"><span>};
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#66d9ef">struct</span> list_head {
</span></span><span style="display:flex"><span>	<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>next, <span style="color:#f92672">*</span>prev;
</span></span><span style="display:flex"><span>};
</span></span></code></pre></div><p>With some more research, I found that <code>simple_xattr</code> is used to store extended attributes (xattrs) for in-memory filesystems (such as tmpfs). <code>simple_xattr</code> objects for a certain file are stored in a linked list via the <code>list_head</code> pointers.</p><p><code>simple_xattr</code> objects are allocated in <a href="https://elixir.bootlin.com/linux/v5.18/source/fs/xattr.c#L949"><code>simple_xattr_alloc</code></a> when an xattr is set on tmpfs. As the value of the xattr is stored in this object, an attacker controlled amount of memory is allocated. This allows <code>simple_xattr</code> to be allocated into kmalloc caches from kmalloc-32 and up.</p><p>Unfortunately for an attacker, <code>simple_xattr</code> objects are not modified when an xattr is edited. Instead, the old <code>simple_xattr</code> is unlinked and a new object is allocated and added to the linked list. Thus, causing out-of-bounds/arbitrary write via overwriting the size or next pointer directly is not feasible.</p><p>Finally, the <a href="https://man7.org/linux/man-pages/man5/tmpfs.5.html">man page for tmpfs</a> states that</p><blockquote><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"><span style="display:flex"><span> The tmpfs filesystem supports extended attributes (see xattr(7)),
</span></span><span style="display:flex"><span> but user extended attributes are not permitted.
</span></span></code></pre></div></blockquote><p>This is slightly problematic, as non-privileged users cannot typically set xattrs in the other namespaces (security and trusted). However, this can be overcome by using a user namespace. In such a namespace, users can set xattrs in the security namespace, thus enabling unprivileged allocation of <code>simple_xattr</code>.</p><h1 id="unlinking-attack">Unlinking attack</h1><p>While an attacker cannot directly manipulate the next pointers for arbitrary write, the next and prev pointers can be used to execute an unlinking attack, resulting in a more limited arbitrary write when an xattr is removed.</p><p>Hereâ€™s the relevant code from <a href="https://elixir.bootlin.com/linux/v5.18/source/tools/include/linux/list.h#L87"><code>__list_del</code></a>:</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__list_del</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span> prev, <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span> next)
</span></span><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>	next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> prev; <span style="color:#75715e">// 1
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>	WRITE_ONCE(prev<span style="color:#f92672">-&gt;</span>next, next); <span style="color:#75715e">// 2
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Since we have total control over the <code>prev</code> and <code>next</code> pointers, the next pointer can be set to an address of interest, such as <code>modprobe_path</code>. The value of <code>prev</code> will be written to <code>next</code> in line 1.</p><p>Unfortunately, <code>next</code> is written to <code>prev</code> in line 2. This means that <code>prev</code> must be a valid pointer as well. This poses a significant restriction on the values that we can write to <code>next</code>. However, we can take advantage of the physmap to provide valid <code>prev</code> values.</p><p>The physmap is a region of kernel virtual memory where physical memory pages are mapped contiguously. For example, if a machine has 4GiB (2^32 bytes) of memory, 32 bits (4 bytes) are required to address each byte of physical memory available in the system. Assuming the physmap starts at 0xffffffff00000000, any address from 0xffffffff00000000 to 0xffffffffffffffff will be valid as every value (from 0x00000000-0xffffffff) of the lower 4 bytes are required to address memory.</p><p>Therefore, assuming the system has at least 4GiB of memory, an attacker can choose any value for the lower 4 bytes of <code>prev</code>, as long as the upper 4 bytes correspond to a physmap address.</p><p>As we are targeting <code>modprobe_path</code>, we will use <code>0xffffxxxx2f706d74</code> as the value of <code>prev</code>. If <code>next</code> is <code>modprobe_path+1</code>, <code>modprobe_path</code> will be overwritten to <code>/tmp/xxxxprobe </code>, where <code>xxxx</code> is the upper 4 bytes of <code>prev</code>. This is an attacker controlled path and can be <a href="https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/">triggered</a> to achieve userspace code execution as the root user.</p><h1 id="summary-of-simple_xattr-exploit-technique">Summary of <code>simple_xattr</code> exploit technique</h1><p>By triggering the allocation of <code>simple_xattr</code> into kmalloc caches from kmalloc-32 and up, and leveraging an unlinking attack, an attacker can escalate an overflow or incorrect free in the kernel heap to a limited arbitrary write. Although an attacker can only write 4 controlled bytes and 4 uncontrolled bytes, this is sufficient for Linux kernel LPE.</p><p>This technique also presents an advantage over other similar techniques such as the use of the <code>msg_msg</code> struct due to the lack of any metadata located before the <code>list_head</code> pointers. This technique requires an attacker to leak a pointer to somewhere in the physmap. However, many structures, including <code>shm_file_data</code> include pointers to both the text section and the physmap, so this is unlikely to be a major problem. It should also be noted that the chosen physmap address must be writable and any contents located there will be overwritten.</p><p>The entire exploit code can be found on our <a href="https://github.com/star-sg/CVE/">github repo</a>.</p><h1 id="demo">Demo</h1><p>Itâ€™s Demo Time.</p><p><a href="https://www.youtube.com/watch?v=M7bTKKQCRq8"><img src="./STAR Labs _ Blog _ io_uring - new code, new bugs, and a new exploit technique_files/mq3.jpg" alt=""></a></p><p>Alternatively, you can view it <a href="https://www.youtube.com/watch?v=yEpf5zCIdxc">here</a></p><h1 id="io_uring-bug-hunting">io_uring bug hunting</h1><p>After N-day analysis, I moved on to look at recent commits related to io_uring and hunt for any bugs introduced in them. <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/fs/io_uring.c?id=c7fb19428d67dd0a2a78a4f237af01d39c78dc5a">This commit</a> caught my attention as it introduced a fairly large number of changes, including a new mechanism for buffer selection, ring mapped provided buffers. This mechanism has been described in previous sections, so I will not explain it here.</p><p>The commit add <a href="https://elixir.bootlin.com/linux/v5.19-rc2/source/fs/io_uring.c#L3873"><code>io_ring_buffer_select</code></a>, a function to select a buffer from the ring of provided buffers. Hereâ€™s a short snippet:</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span>head <span style="color:#f92672">&amp;=</span> bl<span style="color:#f92672">-&gt;</span>mask;
</span></span><span style="display:flex"><span><span style="color:#66d9ef">if</span> (head <span style="color:#f92672">&lt;</span> IO_BUFFER_LIST_BUF_PER_PAGE) {
</span></span><span style="display:flex"><span>    buf <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>br<span style="color:#f92672">-&gt;</span>bufs[head];
</span></span><span style="display:flex"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">int</span> off <span style="color:#f92672">=</span> head <span style="color:#f92672">&amp;</span> (IO_BUFFER_LIST_BUF_PER_PAGE <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> head <span style="color:#f92672">/</span> IO_BUFFER_LIST_BUF_PER_PAGE <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex"><span>    buf <span style="color:#f92672">=</span> page_address(bl<span style="color:#f92672">-&gt;</span>buf_pages[index]);
</span></span><span style="display:flex"><span>    buf <span style="color:#f92672">+=</span> off;
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>The <code>head</code> variable is used to index the <code>br-&gt;bufs</code> array, which contains pointers to the provided buffers. Before array access, <code>head</code> is set to <code>head &amp; bl-&gt;mask</code>, which ensures that it wraps around, rather than exceeding the bounds of the array.</p><p>The math in the else block seems somewhat interesting. As the number of buffers can be very large, it might not be possible to fit all the structs containing pointers to provided buffers <a href="https://elixir.bootlin.com/linux/v5.19-rc2/source/include/uapi/linux/io_uring.h#L503"><code>io_uring_buf</code></a> in a single page. Thus, pages allocated to store <code>io_uring_buf</code> objects are stored in <code>bl-&gt;buf_pages</code>. <code>br-&gt;bufs</code> points to the first page.</p><p>On most machines, which have 4KiB (2^12 byte) pages, <code>IO_BUFFER_LIST_BUF_PER_PAGE</code> is defined to be 256. Thus <code>offset</code> is set to <code>head &amp; 255</code>, equivalent to <code>head % 256</code>, which makes sense. But why is <code>index = head / 256 - 1</code>? If <code>head</code> is 256, <code>index</code> would be 0, which means <code>buf</code> would point to the first page, which are occupied by buffers 0-255. This could cause two requests to use the same buffer, resulting in corruption of any data present in that buffer. This bug was <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/fs/io_uring.c?id=97da4a537924d87e2261773f3ac9365abb191fc9">fixed</a> before I could report it.</p><p>Next, I decided to look at where <code>head</code> is incremented. It appears that <code>head</code> is not incremented in <code>io_ring_buffer_select</code> for most cases. Instead, it is incremented in <a href="https://elixir.bootlin.com/linux/v5.19-rc2/source/fs/io_uring.c#L1654"><code>__io_puts_kbuf</code></a> which appears to be called only when the request is completed.</p><p>What if many requests were submitted at once? Would they all get assigned the same buffer as <code>head</code> is only incremented when the request completes? I decided to test it out:</p><p><img src="./STAR Labs _ Blog _ io_uring - new code, new bugs, and a new exploit technique_files/io_uring_0x003.png" alt="io_uring_0x003.png"></p><p>When 16 requests are submitted concurrently, 7 requests are allocated buffer 0, resulting in corrupted reads. This is a pretty clear race condition. As the <code>head</code> is not correctly incremented, the number of requests can exceed the number of available buffers. Thus, when these requests complete and increment <code>head</code>, <code>head</code> may exceed the number of buffers available. However, as <code>head &amp; bl-&gt;mask</code> ensures <code>head</code> does not exceed the length of the array, no out-of-bounds bug occurs.</p><p>Since I could not determine any security impact from this bug, I decided to <a href="https://github.com/axboe/liburing/issues/605">report</a> it on the projectâ€™s GitHub page. The projectâ€™s maintainers were very helpful in validating the bug and pushed a <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/fs/io_uring.c?id=6436c770f120a9ffeb4e791650467f30f1d062d1">fix</a> to the kernel within 24 hours.</p><p>Unfortunately, I still do not completely understand how the fix works, and it seems the bug is a lot more complicated than I had expected.</p><h1 id="conclusion">Conclusion</h1><p>As I had no prior experience with the Linux kernel, this internship was a completely new learning experience for me. I saw how the concepts I had picked up from modules on operating systems in school, such as memory management and paging, can be applied to the real world. Bug hunting has allowed me to reinforce and practice code review and exploitation techniques, such as use-after-free that can be applied to other programs. Through N-day analysis, I learnt how to write bug reports that concisely conveyed the vulnerability and exploit to ensure that all parties knew what the bug was and how to fix it. Finally, I would like to thank my mentors, Billy and Ramdhan, for their guidance and invaluable feedback throughout my internship. Itâ€™s been an amazing experience working and interacting with the employees and interns at STAR Labs, and I look forward to coming back again in the future!</p><h1 id="references">References</h1><ul><li><a href="https://www.graplsecurity.com/post/iou-ring-exploiting-the-linux-kernel">https://www.graplsecurity.com/post/iou-ring-exploiting-the-linux-kernel</a></li><li><a href="https://ptr-yudai.hatenablog.com/entry/2020/03/16/165628">https://ptr-yudai.hatenablog.com/entry/2020/03/16/165628</a></li><li><a href="https://www.cnblogs.com/helica/p/12572931.html">https://www.cnblogs.com/helica/p/12572931.html</a></li><li><a href="https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/">https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/</a></li></ul></div><div class="pure-u-1 pure-u-md-1-4 l-box"><h2>Latest</h2><ul><li><a href="https://starlabs.sg/blog/2022/06/io_uring-new-code-new-bugs-and-a-new-exploit-technique/" class="list-group-item">io_uring - new code, new bugs, and a new exploit technique</a></li><li><a href="https://starlabs.sg/blog/2022/06/trying-to-exploit-a-windows-kernel-arbitrary-read-vulnerability/" class="list-group-item">Trying To Exploit A Windows Kernel Arbitrary Read Vulnerability</a></li><li><a href="https://starlabs.sg/blog/2022/05/new-wine-in-old-bottle-microsoft-sharepoint-post-auth-deserialization-rce-cve-2022-29108/" class="list-group-item">New Wine in Old Bottle - Microsoft Sharepoint Post-Auth Deserialization RCE (CVE-2022-29108)</a></li><li><a href="https://starlabs.sg/blog/2022/01/the-cat-escaped-from-the-chrome-sandbox/" class="list-group-item">The Cat Escaped from the Chrome Sandbox</a></li><li><a href="https://starlabs.sg/blog/2021/11/diving-into-open-source-lms-codebases/" class="list-group-item">Diving into Open-source LMS Codebases</a></li><li><a href="https://starlabs.sg/blog/2021/11/diving-into-open-source-lms-codebases/" class="list-group-item">Diving into Open-source LMS Codebases</a></li><li><a href="https://starlabs.sg/blog/2021/09/analysis-of-cve-2021-1758-coretext-out-of-bounds-read/" class="list-group-item">Analysis of CVE-2021-1758 (CoreText Out-Of-Bounds Read)</a></li><li><a href="https://starlabs.sg/blog/2021/08/identifying-bugs-in-router-firmware-at-scale-with-taint-analysis/" class="list-group-item">Identifying Bugs in Router Firmware at Scale with Taint Analysis</a></li><li><a href="https://starlabs.sg/blog/2021/06/simple-vulnerability-regression-monitoring-with-v8harvest/" class="list-group-item">Simple Vulnerability Regression Monitoring with V8Harvest</a></li><li><a href="https://starlabs.sg/blog/2021/04/you-talking-to-me/" class="list-group-item">You Talking To Me?</a></li></ul></div></div><div class="l-box ribbon pure-g footer">
        <div class="pure-u-1-2 pure-u-lg-1-3 l-box">
            <h4 class="content-head content-head-ribbon">Contact Us</h4>
            <p><span class="lnr ico lnr-map-marker"></span>
            </p><div class="icotext">2 Boon Leat Terrace #05-02<br>Harbourside Building 2<br>Singapore 119844</div>
            <p></p>
            <p><span class="lnr ico lnr-phone-handset"></span>
            </p><div class="icotext">+65&nbsp;6-9090-754</div>
            <p></p>
            <p><span class="lnr ico lnr-envelope"></span>
            </p><div class="icotext">info@starlabs.sg</div>
            <p></p>
        </div>
        <div class="l-box pure-u-1-2 pure-u-lg-1-3">
            <h4 class="content-head content-head-ribbon">Social Media</h4>
            <p>
                <a target="_blank" title="Twitter" href="https://twitter.com/starlabs_sg"><i class="icon icon-social-twitter"></i></a>
                <a target="_blank" title="Linkedin" href="https://sg.linkedin.com/company/starlabs-sg"><i class="icon icon-social-linkedin"></i></a>
                <a target="_blank" title="Github" href="https://github.com/star-sg"><i class="icon icon-social-github"></i></a>
            </p>
        </div>
        <div class="l-box pure-u-1-1 pure-u-lg-1-3">
            <div class="logo"><img src="./STAR Labs _ Blog _ io_uring - new code, new bugs, and a new exploit technique_files/logo-white.png" class="pure-img-responsive" width="120">
                <p>Â© 2019â€“2022 Security Technologies and Advanced Research Labs Pte. Ltd.</p>
            </div>
        </div>
    </div></div><script>window.onscroll=function(){function t(e){e.className=e.className.replace(/\s*\bat-top\b/g,'')}function n(e){return document.body.scrollTop>e||document.documentElement.scrollTop>e}var e=document.querySelector(".topnav");n(50)?t(e):e.className+=" at-top"}</script></body></html>