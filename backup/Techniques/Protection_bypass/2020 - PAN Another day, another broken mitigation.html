<!DOCTYPE html>
<!-- saved from url=(0028)https://blog.siguza.net/PAN/ -->
<html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>siguza.github.io | Siguza’s Blog</title>
<meta name="generator" content="Jekyll v3.9.0">
<meta property="og:title" content="siguza.github.io">
<meta property="og:locale" content="en_US">
<meta name="description" content="Siguza’s Blog">
<meta property="og:description" content="Siguza’s Blog">
<link rel="canonical" href="https://blog.siguza.net/PAN/">
<meta property="og:url" content="https://blog.siguza.net/PAN/">
<meta property="og:site_name" content="siguza.github.io">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="siguza.github.io">
<script type="application/ld+json">
{"description":"Siguza’s Blog","url":"https://blog.siguza.net/PAN/","@type":"WebPage","headline":"siguza.github.io","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <style class="anchorjs"></style><link rel="stylesheet" href="./2020 - PAN Another day, another broken mitigation_files/style.css">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="https://blog.siguza.net/">siguza.github.io</a></h1>
      

      <p><em>Siguza, 07. Jan 2020</em></p>

<h1 id="pan">PAN</h1>

<p>Another day, another broken mitigation.</p>

<h3 id="introduction">Introduction<a class="anchorjs-link " href="https://blog.siguza.net/PAN/#introduction" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>CPUs these days have a feature that prevents inadvertent memory accesses from the kernel to userland memory. Intel calls this feature “SMAP” (Supervisor Mode Access Prevention) while ARM calls it “PAN” (Privileged Access Never). Apple’s A10 chips and later have this feature, meaning exploit payloads always need to be placed in kernel memory in some way, shape or form… or do they.<br>
At 0x41con 2019 I gave a talk about “Abusing Memory Access Protections”, specifically on arm64. One of the bugs presented there was a PAN bypass that I had originally found in October 2018 when working on <a href="https://media.ccc.de/v/36c3-11034-tales_of_old_untethering_ios_11">Spice</a> together with <a href="https://twitter.com/littlelailo/">lailo</a> and <a href="https://twitter.com/iBSparkes/">Sparkey</a>.</p>

<h3 id="broken-dreams">Broken Dreams<a class="anchorjs-link " href="https://blog.siguza.net/PAN/#broken-dreams" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>The bug/bypass I had seems to have been independently discovered now, so I’ll let <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=24cecc37746393432d994c0dbc251fb9ac7c5d72">this Linux kernel commit message</a> serve as a teaser:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>arm64: Revert support for execute-only user mappings
The ARMv8 64-bit architecture supports execute-only user permissions by
clearing the PTE_USER and PTE_UXN bits, practically making it a mostly
privileged mapping but from which user running at EL0 can still execute.

The downside, however, is that the kernel at EL1 inadvertently reading
such mapping would not trip over the PAN (privileged access never)
protection.
</code></pre></div></div>

<p>Now, of course I wouldn’t just let that sit there without proof that I did indeed have this bug before today. ;)<br>
Back in October 2018 I tweeted out a hash: https://twitter.com/s1guza/status/1054785195239452673<br>
And here’s how you can generate that hash yourself:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ curl 'https://siguza.github.io/PAN/tweet.txt' | shasum -a 512
c0e0319a5e3a12e4a6394a50c67c860b17b566e0af24515ae9b357d1c671985603cb80daf873512adfb4f631c5138abe1381fcd31d6b99a14d1f9a5bbd6a3e38  -
</code></pre></div></div>

<p>The file contains my initial assessment of the bug so feel free to check it out, but since it would spoil most of this blog post, I decided to not copy-paste it here. ;)</p>

<h3 id="the-bug">The Bug<a class="anchorjs-link " href="https://blog.siguza.net/PAN/#the-bug" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>As the commit message above gives away, the bug is plain and simple: <code class="language-plaintext highlighter-rouge">--x</code> memory doesn’t trigger PAN.<br>
As for where it comes from and why it wasn’t detected sooner, we’ll have to circle back and revisit some basics - specifically memory access protections.</p>

<p>In our mental models, we usually think of memory protections as three independent bits: read, write and execute. And that makes sense, as it represents the three fundamental types of accesses that can happen. But that alone has a catch already, as the <code class="language-plaintext highlighter-rouge">mmap(2)</code> man page notes:</p>

<blockquote>
  <p>Portable programs should not rely on these flags being separately enforcable.</p>
</blockquote>

<p>But when looking at this from an OS-design perspective, the real issue is that this only represents the userland view. But accesses can really happen from both EL0 and EL1 while running off one and the same translation table entry, so at the end of the day, in order to accurately implement the model we have in our minds, you’d need 6 bits in total.</p>

<p>Let’s look at how ARM does it. Here’s two exhibits from the <a href="https://developer.arm.com/docs/ddi0487/latest">ARMv8 Reference Manual</a>, specifically the TTE bits that make up access protections:</p>

<p><img src="./2020 - PAN Another day, another broken mitigation_files/1-ttebits.png" alt="TTE bits"></p>

<p><img src="./2020 - PAN Another day, another broken mitigation_files/2-access.png" alt="AP values"></p>

<p>These entangled <code class="language-plaintext highlighter-rouge">AP</code> bits are a bit awkward to read, but surprisingly the ARMv7 Manual has a nicer breakout available for us:</p>

<p><img src="./2020 - PAN Another day, another broken mitigation_files/3-realaccess.png" alt="Real AP values"></p>

<p>There are a few things to note here:</p>

<ul>
  <li>As is evident, there are 4 bits for memory access protections, not 6.</li>
  <li>Execute permission has its own bit for EL0 and EL1 each, so is independent from the rest.</li>
  <li>There is no bit for read permission. You can take away write access. You can take away userland access. But you cannot take away read access at EL1, no matter what.</li>
</ul>

<p>The last point is crucial. When you think of <code class="language-plaintext highlighter-rouge">--x</code> memory in userland, what the system sees is really <code class="language-plaintext highlighter-rouge">r--/--x</code> memory (in kernel/userland notation).<br>
But it’s all good, PAN should see that userland has execute permission and prevent the access… ah who am I kidding, we all know it’s broken at this point.</p>

<p>Memory access checks, including PAN, are handled by <code class="language-plaintext highlighter-rouge">AArch64.CheckPermission()</code> as given in the ARMv8 manual. This is the relevant part, PAN is handled in the last three lines, and I’ve highlighted the problematic part.</p>

<p><img src="./2020 - PAN Another day, another broken mitigation_files/4-pseudo.png" alt="AArch64.CheckPermission pseudocode"></p>

<p>The description for the PAN feature reads:</p>

<blockquote>
  <h3 id="about-pstatepan">About PSTATE.PAN<a class="anchorjs-link " href="https://blog.siguza.net/PAN/#about-pstatepan" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>
  <p>When the value of PSTATE.PAN is 1, any privileged data access from EL1, or EL2 when HCR_EL2.E2H is 1, to a virtual memory address that is accessible at EL0, generates a Permission fault.</p>
</blockquote>

<p>And this is weird. Normally I have found the ARM manual to be pedantic and overly explicit, but in this instance they’re vague - too vague, in fact. Because when they say “accessible”, it’s not clear what they mean. From the image above it’s evident that “accessible” here means “has read permissions”, but that is neither obvious nor reasonable, in my humble opinion.<br>
One could argue that rather than this being a bug in the specification, <code class="language-plaintext highlighter-rouge">--x</code> mappings are not supported and constitute misuse, however given the fact that <a href="https://lore.kernel.org/patchwork/patch/706340/">support for execute-only mappings in the Linux kernel was introduced by an ARM engineer</a>, I’d say that argument is pretty damn weak. And besides, there is no good reason for having PAN just <em>ignore</em> the UXN bit, so I will put this down as a bug in the specification.</p>

<h3 id="exploitability">Exploitability<a class="anchorjs-link " href="https://blog.siguza.net/PAN/#exploitability" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>This bug can be exploited on all ARMv8.1+ chips out there where the OS allows the creation of execute-only mappings.<br>
Linux used to be such an OS, up until yesterday (rest in RIP). I’ll admit I have no idea about Windows. But I know that iOS was vulnerable not long ago, and to the best of my knowledge, still is at the time of writing. So let’s say you can make the kernel dereference an arbitrary address, and let’s look at what can be done with this bug under XNU.</p>

<p>The first thing to note is that “execute-only” could mean both <code class="language-plaintext highlighter-rouge">r--/--x</code> or <code class="language-plaintext highlighter-rouge">rw-/--x</code>, and that makes quite a difference. Matching my expectations though, XNU obviously uses <code class="language-plaintext highlighter-rouge">r--/--x</code>, so no fake mach ports there. It’s definitely enough for fake vtables though, and most likely enough for a carefully crafted ROP stack that only uses gadgets that don’t modify the stack. Additionally, this could be very interesting for dereferencing 32-bit values, or de-facto NULL derefs with an offset of a whole page or more (combined with some compiler flags like <code class="language-plaintext highlighter-rouge">-Wl,-pagezero_size,0x4000</code> :P).</p>

<p>Another thing to note is that the memory needs to be faulted in, probably best wired even. This can easily be done with <code class="language-plaintext highlighter-rouge">mlock</code>, but faulting in an executable mapping means it needs a valid code signature. Realistically that should be no issue though, since the two most likely attack vectors are from a side-loaded app and from WebContent, one of which can have <code class="language-plaintext highlighter-rouge">get-task-allow</code> and be allowed dirty executable pages, while the other has <code class="language-plaintext highlighter-rouge">dynamic-codesigning</code>.</p>

<h3 id="fix-pls">Fix pls?<a class="anchorjs-link " href="https://blog.siguza.net/PAN/#fix-pls" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>So of course the obvious fix would be to replace that <code class="language-plaintext highlighter-rouge">user_r</code> in the ARMv8 specification with <code class="language-plaintext highlighter-rouge">(user_r || perms.xn == '0')</code>. But that comes a bit late now, so… hooray mitigations.<br>
Another obvious fix, as applied to the Linux kernel, is to simply forbid <code class="language-plaintext highlighter-rouge">--x</code> mappings now. I’m pretty sure that wouldn’t bode too well with the WebKit folks and their “bulletproof JIT” however.<br>
A third option would be to invalidate <code class="language-plaintext highlighter-rouge">ttbr0_el1</code> on entry to the kernel and only restore it inside of <code class="language-plaintext highlighter-rouge">copyio</code>, but my guess is that this would come with an unacceptable performance hit.</p>

<p>On Apple’s A10 chips and onward there is yet another option though, and actually one that should have really no downsides: APRR.<br>
If that Cryptic Apple Acronym™ doesn’t ring a bell, I’ve done a <a href="https://siguza.github.io/APRR/">blog post on it</a> a few months ago. If you don’t feel like reading that all, the TL;DR is that Apple’s A10 chips and newer have a proprietary hardware feature that allows them to strip individual permission bits out of the effective access permission for each bit combination. So they could easily make <code class="language-plaintext highlighter-rouge">r--/--x</code> actually become <code class="language-plaintext highlighter-rouge">---/--x</code>.<br>
Ironically, if they had done this from the start, they would’ve also detected the info leak bug I dropped in the APRR post. :P<br>
And while Apple can only do this on A10 and later, all their earlier chips didn’t have PAN anyway to begin with.</p>

<h3 id="conclusion">Conclusion<a class="anchorjs-link " href="https://blog.siguza.net/PAN/#conclusion" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h3>

<p>This was quite fun. Even though the bug didn’t live too long from the point I found it, finding a bug <em>in the specification</em> has something unique and arcane to it.<br>
Also I’m not even too sad it got burned now. Because while it was a fun bug, the reality is that, in practice, PAN was never even an issue to get around. :P</p>

<p>On a separate note, defensive security folks, and Apple in particular, loooooove mitigations. On iOS, Apple has lately been slapping proprietary mitigations around like there’s no tomorrow.<br>
But thing is, mitigations are often delicate creatures, with rather fragile assumptions. Having too many of them in one place can easily make them break one another, as happened here with execute-only memory vs PAN. And this isn’t the first time either, in my blog post about APRR it was ASLR that got broken by another mitigation, and there are a few more cases like this that I know of. As the number of mitigations around specific features increase, I expect collisions like these to become more common. But hey, something has to stay fun, right? :P</p>

<p>As always, feedback is greatly welcome (as is unrelated security chatter :P)! You can <a href="https://twitter.com/s1guza/">find me on Twitter</a> or reach me via email (<code class="language-plaintext highlighter-rouge">*@*.net</code> where <code class="language-plaintext highlighter-rouge">*</code> = <code class="language-plaintext highlighter-rouge">siguza</code>). :)</p>

<p>With that said, I think there’s nothing left to do but to wish you all a good one, give a hat tip to the folks who were at 0x41con, and show you the last slide of my deck:</p>

<p><img src="./2020 - PAN Another day, another broken mitigation_files/5-conclusions.png" alt="Conclusions"></p>



      
    </div>
    <script src="./2020 - PAN Another day, another broken mitigation_files/anchor.min.js.下載" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
  

</body></html>