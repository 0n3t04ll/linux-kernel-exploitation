<!DOCTYPE html>
<!-- saved from url=(0049)https://blog.frizn.fr/linux-kernel/cve-2020-14381 -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	
	<meta name="author" content="FrizN">
	<meta name="description" content="FrizN&#39;s blog: ctf writeups, pwnables, reverse engineering, sploits">
	<meta name="keywords" content="ctf,writeup,pwn,pwnable,reverse,reverse engineering,x64,sploit,native,cracking,0daysober">
	<meta name="category" content="IT,security,hack,hacking,pwn,sploit">
	<meta name="subject" content="FrizN&#39;s blog: ctf writeups, pwnables and reverse engineering">
	<meta name="expires" content="never">
	<meta name="robots" content="index, follow">
	<meta name="google-site-verification" content="oqJnYvg-qU4NGe6Zvk47P85UpaA-CaibWMt_vjlZgI4">

	<title>FrizN - Linux kernel - The curious case of CVE-2020-14381</title>
	
	<link rel="stylesheet" type="text/css" media="screen" href="./2021 - The curious case of CVE-2020-14381_files/presentation.css">
		
	<link href="./2021 - The curious case of CVE-2020-14381_files/prettify.css" type="text/css" rel="stylesheet">
	<script async="" src="./2021 - The curious case of CVE-2020-14381_files/analytics.js.下載"></script><script id="twitter-wjs" src="./2021 - The curious case of CVE-2020-14381_files/widgets.js.下載"></script><script type="text/javascript" src="./2021 - The curious case of CVE-2020-14381_files/prettify.js.下載"></script><link rel="stylesheet" type="text/css" href="./2021 - The curious case of CVE-2020-14381_files/prettify(1).css">

	<!--[if lt IE 9]>
		<script src="/js/html5.js"></script>
	<![endif]-->
	<script type="text/javascript" src="./2021 - The curious case of CVE-2020-14381_files/jquery-1.6.1.min.js.下載"></script>
<script charset="utf-8" src="./2021 - The curious case of CVE-2020-14381_files/button.0d6aa7fd095b2a9dd19cc66c7c2ed64b.js.下載"></script></head>



<body>
<div id="conteneur">
	<div id="entete">
		<div class="entetetitre">
			<a href="https://blog.frizn.fr/">
				<h1>FrizN</h1>
				<h2>Pwnable stories</h2>
			</a>
		</div>
		<div class="entetelang">
			<a href="https://blog.frizn.fr/fr/linux-kernel/cve-2020-14381"><img class="imglang" src="./2021 - The curious case of CVE-2020-14381_files/fr.png" alt="FR"></a> <a href="https://blog.frizn.fr/en/linux-kernel/cve-2020-14381"><img class="imglang" src="./2021 - The curious case of CVE-2020-14381_files/en.png" alt="EN"></a>		</div>
	</div>
	<br class="clear">

	<div id="corps">
		<div class="contenu">
					<p class="article-info"><a href="https://blog.frizn.fr/linux-kernel/">Linux kernel</a> &gt; <a href="https://blog.frizn.fr/linux-kernel/cve-2020-14381">The curious case of CVE-2020-14381</a></p>

                    <h3>The curious case of CVE-2020-14381</h3>                    
                    <p>Today is the one-year anniversary of this interesting kernel bug I worked
on last year with <a href="https://twitter.com/bluec0re" target="_blank">@bluec0re</a>,
and as it turns out I wrote something about it during one of these lockdown
weekends so I thought I'd release it. <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2015" target="_blank" title="CVE-2020-14381 get_futex_key use-after-free">The bug itself</a>
was discovered by <a href="https://twitter.com/tehjh" target="_blank">Jann Horn</a>
of Project Zero. While I touch most of the elements required to exploit the
bug, I stay superficial here since the exploit itself is not particularly
exciting. What makes this bug interesting to me is its lifecycle, in particular
how unevenly the patch was applied to the various distributions. I also talk
briefly about hardware side-channels since it was the first time I had ever
used one.</p>

<strong>The bug</strong>
<p>It’s already well-described in the bug tracker, but here is another summary.
The <span class="italique">futex</span> syscall's main parameter is a userland address, and this address
may belong to a file-backed mapping. In that case, the futex key kernel object
<a href="https://elixir.bootlin.com/linux/v5.4.7/source/kernel/futex.c#L707" target="_blank">held</a>
and <a href="https://elixir.bootlin.com/linux/v5.4.7/source/kernel/futex.c#L724" target="_blank">kept</a>
a reference to the inode object, but didn’t hold a reference to the file’s mountpoint.
If the mountpoint were to go away, its associated kernel structures would be
freed, but the inode wouldn’t. That’s an issue because the inode itself has
fields that point to some of these structures, such as its <a href="https://elixir.bootlin.com/linux/v5.4.7/source/include/linux/fs.h#L641" target="_blank">super_block</a>
struct.</p>

<p>Further use of the inode by <span class="italique">futex</span> code paths may therefore trigger
use-after-frees. One particular code path highlighted by Jann in the bug happens
when the <span class="italique">futex</span> is destroyed: the last reference to the inode is released
and the inode needs to be freed. This is done in <span class="italique">iput</span> which then calls
<span class="italique">iput_final</span>. <span class="italique">iput_final</span> and its subcalls will then call inode
management functions stored in the <a href="https://elixir.bootlin.com/linux/v5.4.7/source/include/linux/fs.h#L1942" target="_blank">super_operations</a>
struct accessed <a href="https://elixir.bootlin.com/linux/v5.4.7/source/fs/inode.c#L1533" target="_blank">from the super_block</a>
object. The first instance happens right at the beginning of <span class="italique">iput_final</span> with
a call to the <a href="https://elixir.bootlin.com/linux/v5.4.7/source/fs/inode.c#L1539" target="_blank">drop_inode</a>
function.</p>

<p>Exploiting this bug requires being able to:
</p><ul>
  <li>Successfully <span class="italique">umount</span> a mountpoint. A no-go a few years ago, but
  possible nowadays with the normalization of unprivileged user namespaces.
  It’s a good example that this feature was never a trivial security tradeoff
  (unprivileged sandboxes v. augmented kernel attack surface) which in turn
  makes it somewhat surprising that all mainstream distributions enabled them by default
  without much debate</li>
  <li>Survive the <span class="italique">op-&gt;drop_inode()</span> execution (non-SMEP or a KASLR bypass)</li>
  <li>Survive the <span class="italique">op-&gt;drop_inode</span> indirection just before that (non-SMAP
  or a stack/heap leak)</li>
  <li>Do everything in one call, because with an incorrect inode state, a corrupted
  super_block and some linked lists unlinks to do in the remainder of <span class="italique">iput_final</span>,
  it’s doubtful we can even get as far as the second <span class="italique">super_operations</span>
  function pointer call (<span class="italique">evict_inode</span>)</li>
</ul>
<p></p>

<strong>Exploitation</strong>
<p>The first exploitation pathway that comes to mind goes as follows:
</p><ul>
  <li>wait for the <span class="italique">super_block</span> to be freed. It’s done in <a href="https://elixir.bootlin.com/linux/v5.4.7/source/fs/super.c#L299" target="_blank">an RCU callback</a>
  so one way or another you need to wait for the end of the RCU grace period
  after <span class="italique">umount</span> returns, e.g. with <span class="italique">membarrier</span>. For a PoC, spraying
  allocs for the duration of the expedited grace period works well enough since
  the <span class="italique">super_block</span> slab, <span class="italique">kmalloc-2k</span>, is not super busy.</li>
  <li>overwrite the freed <span class="italique">super_block</span> via a dynamic heap allocation primitive
  (e.g. <a href="https://elixir.bootlin.com/linux/v5.4.7/source/net/socket.c#L2264" target="_blank">sendmsg ancillary data</a>).</li>
  <li>point <span class="italique">s_op</span> to an attacker-controlled buffer</li>
  <li>point <span class="italique">drop_inode</span> to a chain of gadgets that pivot the stack to
  either the <span class="italique">super_block</span> or <span class="italique">super_operations</span> bufffers (which
  are both necessarily in registers and almost fully controlled). Example of
  common gadgets that would work in this situation would be <span class="italique">push reg; jmp/call [reg+x]</span>
  that can then be chained with a <span class="italique">pop rsp; ret</span> gadget placed at <span class="italique">[reg+x]</span></li>
  <li>do whatever with your unconstrained ROP, fixup the stack and return</li>
</ul>
<p></p>

<p>This would be a sucky exploit to maintain as it relies on precise knowledge
of the kernel image, but that’s as good as it gets for a raw function pointer
execution without a read primitive in kernel space. The portability issues
for exploits like this are in themselves a significant bonus of SMEP: it rarely
prevents exploitation but makes many candidates much less appealing for weaponization.</p>

<p>We can take SMEP for granted. It’s only one CPU generation / 2 years older
than SMAP, but not having it is getting really rare. Plus if your exploit does
rely on no-SMEP but your target ends up having software SMEP enabled, which
you sometimes can't really tell at runtime, you've just turned a privesc attempt into
a lost foothold. No-SMAP however is still a thing for the time being. As a
random example the <a href="https://aws.amazon.com/intel/" target="_blank" title="AWS EC2 intel CPUs">AWS EC2 CPU roster</a>
shows some CPUs that do not support SMAP.</p>

<strong>On infoleak bugs</strong>
<p>In any case, to exploit this bug one needs at least one infoleak. The most
important is to get kernel base for gadgets, and then we could use a heap leak
or similar to support SMAP-capable CPUs (to have our "attacker-controlled
buffer" in point 3 above in kernel space). A heap/stack leak can often yield
a .text address as well so having one would kill two birds with one stone.
But, not everyone has the right infoleak in their stash ready to go, contrary
to a common anti-KASLR argument. And even when you do have an infoleak bug,
it doesn't mean that it will help with your current exploit.</p>

<p>For instance, a good infoleak candidate which was released around the same
time last year would be the one with uninitialized memory in coredumps, <a href="https://nvd.nist.gov/vuln/detail/CVE-2020-10732" target="_blank">CVE-2020-10732</a>.
But short of a public proof-of-concept, one needs to understand the coredump
generation code, then find an object in that slab that allows us to get
.text, and another one to deduce a heap address you control. In short, at least
as much work as the rest of the exploit we are looking at. And that's without
considering that using two bugs in one exploit also means that you need to
take into account both bugs limitations. Unprivileged user namespaces for the
main bug we are looking at (not a thing on e.g. RHEL 7), and for the coredump,
well the ability to retrieve the core files, i.e. not running in a container.
Luckily for our project, we already knew we were targeting non-SMAP containers
so we were able to avoid spending all that effort on an infoleak bug that
would have ended up being worthless; a luxury that real exploit developpers
preparing capabilities ahead of time do not have. But if we were targeting
SMAP containers, well that would have been it since more effort would have
exceeded our resource budget for this project.</p>

<strong>Hardware side-channels</strong>
<p>For kernel .text however, the situation is different since there are generic,
publicly-documented ways to obtain kernel base: hardware vulns. I personally
hadn’t ever used any and even saw them as a niche exploitation technique
relying on opaque CPU heuristics that don’t hold across models - not something
to be considered for resilient exploits. I was simply wrong, but thankfully
had access to many specialists (<a href="https://twitter.com/tehjh" target="_blank">@tehjh</a>,
<a href="https://twitter.com/_fel1x" target="_blank">@_fel1x</a>, <a href="https://twitter.com/_tsuro" target="_blank">@_tsuro</a>)
who knew better.</p>

<p>While side-channels that allow leaking memory across security boundaries
are hopefully bound to be mitigated, there are many side-channels that leak
addresses and which we haven’t heard much about since Spectre and friends.
These ones are probably here to stay even longer. For this project I used <a href="https://github.com/tpn/pdfs/blob/master/Jump%20Over%20ASLR%20-%20Attacking%20Branch%20Predictors%20to%20Bypass%20ASLR%20-%202016%20(micro16).pdf" target="_blank" title="jump over aslr paper">Jump Over ASLR</a>,
which was published before Spectre in 2016. It’s simple to understand (especially
with access to the aforementioned people) and there are PoCs that are just
waiting to be adjusted to your own scenario (e.g. <a href="https://github.com/felixwilhelm/mario_baslr" target="_blank" title="mario_baslr jump over aslr">mario_baslr</a>
from @_fel1x). Jump Over ASLR relies on the inner workings of the Branch Target
Buffer where user and kernel branches may collide. When that happens, the CPU
has more work to do and that can be observed. This allows leaking kernel base 
as long as you have offsets of branches hit during a short kernel path you
can trigger at will: you can then leverage the low entropy of KASLR to try
all possible base addresses and find the one where the branches are hit.</p>

<p>For the parameters (the branches to measure) you can really use whatever
you want. I only tried the <span class="italique">creat</span> syscall with arguments that cause a
fast return to userland, and then measured whether the <span class="italique">sys_creat</span> and
<span class="italique">do_sys_open</span> offsets had been hit. The offsets need to be fairly precise
but not to the byte since there seems to be some aliasing going on in the branch
predictor: I originally used <span class="italique">__fentry__</span> as an additional branch target
at a +5 offset for both symbols which still worked even though I later learned
these calls get <a href="https://lwn.net/Articles/747256/" target="_blank">dynamically patched out</a>.
</p>

<p></p>With proper filtering of both false negatives and false positives (essentially
double checking each address) this works like a charm on recent Intel CPUs,
and it’s one of many such techniques that have been published in the past
6 years or so. That makes it something we should be able to rely on as exploit
developers for the foreseeable future. So for a known kernel image at least,
we are essentially back to pre-KASLR times - and keep in mind that it’s a
field I know fairly poorly so other side-channels are probably even better.<p></p>

<strong>Patch gap</strong>
<p>Ok here is what I personally found really interesting because I had never
looked into kernel bug timelines before. This bug was initially reported on
February 28 2020, and fixed in tip on March 3. At this point it’s essentially
public for anyone keeping an eye out for interesting kernel patches - even
if you don’t spend too much time on it, a <span class="italique">reported-by</span> Jann Horn is
worth looking into. The main kernel lines were fixed either on March 25 or
April 2. If you’re thinking “oh wow one whole month”, please be seated for
what’s coming.</p>

<p>Some distros applied the patch almost immediately:
</p><ul>
  <li>Arch Linux: Mar 25</li>
  <li>Gentoo: Mar 25</li>
  <li>Fedora: Mar 26</li>
</ul>
<p></p>

<p>I know they are not supposed to target workstations specifically but outside
of personal servers I don't think I have ever seen them used otherwise. The
2nd batch of distributions that fixed the bug is arguably more server-ready:
</p><ul>
  <li>Ubuntu 18.04 LTS: Apr 7</li>
  <li>Ubuntu 16.04 LTS: Apr 24</li>
  <li>Debian Buster (stable): Apr 27</li>
  <li>Debian Stretch (oldstable): Jul 6</li>
</ul>
<p></p>

<p>Debian is trailing a bit but all in all that’s within one month of the
patch being released which sounds reasonable considering additional processes
required to ensure better performance and stability guarantees. Oldstable,
well it’s old after all - it's just interesting to observe that Ubuntu's oldstable
did a much better job for this one bug. Of course that means that observant
attackers have had between 5 and 8 weeks to exploit the vulnerability on Ubuntu/Debian
stable releases.</p>

<p>On May 7, the Project Zero bug is unrestricted so it actually becomes public
for real. And around half a year later:
</p><ul>
  <li>openSUSE: Oct 11</li>
  <li>RHEL 8: Nov 4</li>
  <li>Oracle Linux 8: Nov 10</li>
  <li>CentOS 8: not sure I stopped monitoring on Nov 19</li>
</ul>
<p></p>

<p>So, attackers looking at exploiting the bug after it was publicly disclosed
had 5 months to exploit suse and between 6 and 7 months to exploit redhat
and derivates!! Keeping in mind that some groups may have noticed the bug
2 months earlier, it’s 7 and 8-9 months respectively. Of course, this is assuming
that the servers are updated and rebooted as soon as the patch is released
- which is far from what happens on average.</p>

<p>If you want a really scary prospect, then you should realize that the Linux
kernel receives literally hundreds of commits every month - who knows how many
of them fix bugs that are theoretically exploitable. In my opinion this goes
to show one main thing: kernel forks which integrate patches based on cherry-picking
strategies are doomed from a security perspective. And it’s not to throw
stones at anyone, but there is simply no way that a maintainer can properly
triage the commits to appropriately mark and apply all those that are potential
security problems. This bug is a great example of this process failing big
time. And all enterprise-facing kernels seem to be maintained that way.</p>

<p>From the offensive standpoint, it was already useful to keep an oldish
kernel exploit around given how rarely some companies both patch their kernels
and reboot the machines. But what was really enlightening here was that even
someone doing everything right could be exposed to an 8 months patch gap. It
means that solely relying on N-days to keep a Linux privesc capability in your
arsenal is a viable strategy - especially if you focus on bugs that no one
talks about.</p>

<p>And I'll see you in 4 years for the next post I guess.</p>

	</div> <!-- fin contenu -->

	<aside>
		<div id="gotroot">
			<img src="./2021 - The curious case of CVE-2020-14381_files/penguinroot.gif" alt="tux got root">
		</div>

		
		<div class="menulist">
			<h4>Last posts</h4>
			<ul>
			<div class="plainlist">
<ul>
<li>Feb. 2021
<ul>
<li><a href="https://blog.frizn.fr/linux-kernel/cve-2020-14381" title="linux kernel the curious case of cve-2020-14381 kernel use-after-free exploitation and patching in the various distributions">Linux kernel<br>The curious case of CVE-2020-14381</a> </li>
</ul>
</li>
<li>Feb. 2018
<ul>
<li><a href="https://blog.frizn.fr/glibc/glibc-heap-to-rip" title="glibc from heap to rip from glibc heap control to generic code execution">glibc<br>From Heap to RIP</a> </li>
</ul>
</li>
<li>Mar. 2016
<ul>
<li><a href="https://blog.frizn.fr/bkpctf-2016/qwn2own-bkpctf16" title="bkp ctf 2016 qwn2own - generic browser exploits vector corruption for browser exploitation">BKP CTF 2016<br>qwn2own - generic browser exploits</a> </li>
</ul>
</li>
				<div class="more"><a href="https://blog.frizn.fr/posts/recent">More...</a></div>
				</ul></div>
			</ul>
		</div>
		
		<div class="menulist">
			<h4>Most viewed content</h4>
			<ul><div class="plainlist">
				<ul>
					<li>Domains &amp; Techs						<ul>
				<li><a href="https://blog.frizn.fr/posts/tags?tag=Native+exploitation">Native exploitation</a></li>
<li><a href="https://blog.frizn.fr/posts/tags?tag=Reverse">Reverse</a></li>
<li><a href="https://blog.frizn.fr/posts/tags?tag=Linux">Linux</a></li>
<li><a href="https://blog.frizn.fr/posts/tags?tag=x64">x64</a></li>
<li><a href="https://blog.frizn.fr/posts/tags?tag=C%2B%2B">C++</a></li>
						</ul><div class="more"><a href="https://blog.frizn.fr/posts/tags">More...</a></div>
					</li>
					<li>Topics &amp; CTFs						<ul>
				<li><a href="https://blog.frizn.fr/linux-kernel/" title="linux kernel">Linux kernel</a></li>
<li><a href="https://blog.frizn.fr/ictf-2011/" title="ictf 2011">iCTF 2011</a></li>
<li><a href="https://blog.frizn.fr/plaidctf-2013/" title="plaidctf 2013">PlaidCTF 2013</a></li>
						</ul><div class="more"><a href="https://blog.frizn.fr/posts/categories">More...</a></div>
					</li>
				</ul>
				
			</div></ul>
		</div>
		
		<div id="twitter">
			<iframe id="twitter-widget-0" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" class="twitter-follow-button twitter-follow-button-rendered" style="position: static; visibility: visible; width: 83px; height: 28px;" title="Twitter Follow Button" src="./2021 - The curious case of CVE-2020-14381_files/follow_button.a53eecb4584348a2ad32ec2ae21f6eae.fr.html" data-screen-name="Friz_N"></iframe><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
		</div>
		
	</aside>



	
	</div> <!-- fin corps -->

	<div id="colDroite">
		
	</div>

	<div id="pied">
		<div class="footer-text">
			<a href="https://blog.frizn.fr/posts/" title="List of all blog posts and writeups">All posts</a> |
			<a href="https://blog.frizn.fr/site/sitemap" title="Get the blog&#39;s sitemap">Sitemap</a> |
			<a href="https://blog.frizn.fr/site/about" title="About me and this blog">About</a>
		</div>
		
		<div class="pubBas">
			
		</div>
	
	
	<div class="footer-text">
		Copyright © FrizN 2011-2021. All rights reserved.
	</div>

	</div>
</div> <!-- fin conteneur -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-47728226-1', 'frizn.fr');
  ga('send', 'pageview');

</script>
	
	<script type="text/javascript">prettyPrint();</script>


<iframe scrolling="no" frameborder="0" allowtransparency="true" src="./2021 - The curious case of CVE-2020-14381_files/widget_iframe.a53eecb4584348a2ad32ec2ae21f6eae.html" title="Twitter settings iframe" style="display: none;"></iframe><iframe id="rufous-sandbox" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" style="position: absolute; visibility: hidden; display: none; width: 0px; height: 0px; padding: 0px; border: none;" title="Twitter analytics iframe" src="./2021 - The curious case of CVE-2020-14381_files/saved_resource.html"></iframe></body></html>