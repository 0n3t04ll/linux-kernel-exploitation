<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<!-- saved from url=(0083)http://vulnfactory.org/blog/2011/06/05/smep-what-is-it-and-how-to-beat-it-on-linux/ -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Security Research by Dan Rosenberg</title>
	
	<link rel="stylesheet" href="./2011 - SMEP What is It, and How to Beat It on Linux_files/1.css" type="text/css" media="screen,projection">
</head>
<body>
<div id="vf_container">
        <div id="vf_header">
                <h1>It's Bugs All the Way Down</h1>
                <h2>Security Research by Dan Rosenberg</h2>
        </div>
        <div id="vf_nav">
                <ul id="menu">
                        <li><a href="http://vulnfactory.org/">Home</a></li>
                        <li><a href="http://vulnfactory.org/blog/"><em>Blog</em></a></li>
                        <li><a href="http://vulnfactory.org/vulns/">Vulnerabilities</a></li>
                        <li><a href="http://vulnfactory.org/exploits/">Exploits</a></li>
                        <li><a href="http://vulnfactory.org/research/">Research</a></li>
                        <li><a href="http://vulnfactory.org/contact/">Contact</a></li>
                </ul>
        </div>

        <div id="vf_content">


<div class="post-6 post type-post status-publish format-standard hentry category-exploitation category-kernel category-linux" id="post-6">
<h2>SMEP: What is It, and How to Beat It on Linux</h2>

<div>
<p>On May 16, 2011, Fenghua Yu <a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=de5397ad5b9ad22e2401c4dacdf1bb3b19c05679">submitted</a> a series of patches to the upstream Linux kernel implementing support  for a new Intel CPU feature: Supervisor Mode Execution Protection  (SMEP).  This feature is enabled by toggling a bit in the cr4 register,  and the result is the CPU will generate a fault whenever ring0 attempts  to execute code from a page marked with the user bit.</p>
<p><span id="more-6"></span>First, some background on why this feature is useful.  Like most  mainstream operating systems, the vanilla Linux kernel does not leverage  x86 segmentation, instead defining flat segment descriptors with limits  encompassing the entire 4gb address space.  Additionally, each process  has the kernel‚Äôs page table entries replicated, resulting in the kernel  address space being mapped in the upper 1gb of every user process.  Both  of these decisions are for performance reasons: reloading segment  selectors at every trap and kernel-to-user (or vice versa) copy  operation introduces a non-negligible (but not necessarily unacceptable)  performance hit, and having completely separate user and kernel address  spaces would necessitate a TLB flush on every trap, which is even more  expensive.</p>
<p>The result of this is that the kernel is free to incorrectly access data  residing in userspace, as well as execute code in the user region.  In  addition to enabling the exploitation of many bugs that rely on the  kernel incorrectly using user data, this allows kernel exploits to  simply map a suitable payload in userspace and divert kernel execution  to that payload.</p>
<p>The <a href="http://grsecurity.net/">PaX project</a> solves this problem in a general way with a feature called <a href="http://grsecurity.net/~spender/uderef.txt">PAX_UDEREF</a>.   When this feature is enabled, PaX leverages segmentation to isolate  user and kernel addresses, such that a fault will be generated when the  kernel incorrectly accesses user data or code.  Unfortunately, due to  the performance hit associated with reloading segment registers and the  fact that this touches mission-critical code, it‚Äôs unlikely that this  solution would be accepted into the upstream Linux kernel.</p>
<p><strong>Update:</strong> I‚Äôm told by the PaX team that recent benchmarks have  shown there is almost no measurable performance impact for UDEREF on  i386, as reloading segment registers has become much cheaper since the  initial benchmarks of this feature (on the order of 16 cycles).   However, it‚Äôs still unlikely that the upstream kernel would find the  feature suitable, since using segmentation would be a significant  departure from current kernel design principles.</p>
<p>Enter SMEP.  Now, the mainline Linux kernel can take advantage of a  subset of this protection at essentially no performance cost, as the  functionality is presumably implemented in hardware in a way that‚Äôs  similar to existing CPL checks.  With SMEP enabled, it‚Äôs no longer  possible to map exploit payloads in userland, as the CPU will trigger a  fault if it attempts to execute those user pages in kernel mode.  Note  that this is still only a subset of what UDEREF protects against, as it  does nothing to prevent the kernel from incorrectly accessing user  *data* as opposed to code.  But it‚Äôs certainly a start.</p>
<p>It may take awhile for the hardware to catch up ‚Äì it doesn‚Äôt seem any  existing CPUs actually implement SMEP, and we all know how long adoption  of hardware NX has taken (and continues to take).  However, once SMEP  is widespread, what are kernel exploit writers going to do?  Is this the  end of Linux kernel exploits?</p>
<p>Of course not.  While SMEP is definitely a very good security feature  and is a step in the right direction, no single feature is going to ‚Äúwin  security‚Äù.  Let‚Äôs go into a few ways to bypass this protection (I‚Äôm  sure there are more).</p>
<h1>RWX Kernel Pages</h1>
<p>The first problem is the kernel‚Äôs page permissions aren‚Äôt yet in a  completely sane state.  By compiling a kernel with CONFIG_X86_PTDUMP (or  using Kees Cook‚Äôs <a href="http://www.outflux.net/blog/archives/2011/04/27/non-executable-kernel-memory-progress/">modularized version</a> of this feature), we can take a look at the permissions of kernel pages via the <code>/sys/kernel/debug/kernel_page_tables</code> debugfs file.  In particular, we‚Äôre interested in pages that are both writable and executable:</p>
<pre># grep RW /sys/kernel/debug/kernel_page_tables | grep -v NX
0xc009b000-0xc009f000		16K	RW		GLB x	pte
0xc00a0000-0xc0100000		384K	RW		GLB x	pte
0xc1400000-0xc1580000		1536K	RW		GLB x	pte
</pre>
<p>The first two regions are especially useful, since they will appear at  static addresses on many modern 32-bit kernels.  The first region is  reserved for the BIOS, and the second is the so-called ‚ÄúI/O hole‚Äù used  for DMA.  While it‚Äôs probably best to avoid scribbling all over the I/O  hole, as it‚Äôs commonly used at runtime, there‚Äôs no reason that writing  into the BIOS region would cause any stability issues after booting is  complete.</p>
<p>So, if we have a kernel write primitive, all we have to do is write our  payload into the BIOS region and divert execution there.  If the target  kernel leaks symbol locations via <code>/proc/kallsyms</code> or  similar, then diverting execution is a simple matter of resolving the  address of a suitable function pointer, overwriting it, and triggering  it.  Otherwise, it‚Äôs trivial to issue a <code>sidt</code> instruction to  retrieve the address of the IDT and set up a trap handler pointing into  the payload.  SMEP will have nothing to complain about, since we never  cause the kernel to attempt to execute from user pages.</p>
<h1>Stack Metadata</h1>
<p>A second way to bypass this protection is to leverage the <code>addr_limit</code> variable, which resides in the <code>thread_info</code> structure at the base of each process‚Äô kernel stack.</p>
<p>As described in <a href="http://jon.oberheide.org/">Jon Oberheide‚Äôs</a> and my presentation on <a href="https://github.com/jonoberheide/stackjacking">Stackjacking</a>,  it‚Äôs possible to exploit the leakage of uninitialized stack data, a  common bug, in order to infer the address of the base of a process‚Äô  kernel stack.  I developed a library called libkstack to do so  generically.  Once this address is inferred, a kernel write  vulnerability can simply write <code>ULONG_MAX</code> (<code>0xffffffff</code>) into the <code>addr_limit</code> variable, which is at a reliable offset from the kernel stack base.  At  this point, arbitrary kernel memory can be read from and written to,  since all kernel copy functions will accept kernel pointers as user  arguments.  For example, you can do a <code>write(pipefd, kernel_addr, len)</code> to read the data from <code>kernel_addr</code> into a pipe, to be retrieved later.  Once you have an arbitrary kernel read and write, the current process‚Äô <code>cred</code> structure can be found and written into, escalating privileges to root.   Again, this attack does not require executing any user code with  kernel privileges, so SMEP cannot stop it.</p>
<p><strong>Update:</strong> it‚Äôs worth noting that <a href="http://grsecurity.net/">grsecurity</a> protects against this type of attack by removing the <code>thread_info</code> structure from the kernel stack.</p>
<h1>Return-Oriented Programming</h1>
<p>In the event that kernel symbols can be resolved on the target kernel  (especially common on distro kernels) and the attacker has a stack  overflow or another vulnerability that allows pivoting the stack pointer  into an area of attacker controlled data, kernel ROP is possible.   Fortunately, the <code>setup_smep</code> function, which has code to both enable and disable the SMEP bit in the cr4 register, is marked <code>__init</code>,  so it‚Äôs likely to have been cleaned up by the kernel after  initialization and is not a good candidate for ROP.  However, more  complex ROP payloads are certainly possible, as I hope to demonstrate  later this year.  For now, I‚Äôll leave this up to your imagination. üòâ</p>
<h1>What Needs to be Fixed</h1>
<p>Some progress on removing useful sources of information leakage has been made with the <a href="http://marc.info/?l=linux-kernel&amp;m=129306980917336&amp;w=2">kptr_restrict</a> and <a href="http://marc.info/?l=linux-kernel&amp;m=128943183202231&amp;w=2">dmesg_restrict</a> sysctls.  Continued work on plugging similar leaks should improve the  usefulness of these features.  However, it‚Äôs still trivial to resolve  the locations of kernel code and data on distribution kernels, since  they are shipped as binaries that are identical across all machines with  the same kernel version.  This is demonstrated perfectly by <a href="http://jon.oberheide.og/">Jon Oberheide‚Äôs</a> <a href="https://github.com/jonoberheide/ksymhunter">ksymhunter</a> project.</p>
<p>The solution I‚Äôm currently working on is implementing randomization of  the address at which the kernel is decompressed at boot. This way, even  if an attacker can download an identical kernel image as the target  host, he won‚Äôt know where kernel data and code resides in a running  kernel, assuming an absence of information leakage.  In order to be  effective, this solution requires relocating the IDT ‚Äì otherwise, it  will reside at the location pointed to by the <code>idt_table</code> symbol, and an <code>sidt</code> instruction would allow an attacker to calculate the offsets of every  other kernel symbol relative to the address of the IDT.  This has its  own challenges, but I‚Äôm making progress and hope to submit a working  version in the coming weeks.  This will also have the useful side effect  of marking the IDT read-only, which will prevent it from being a  generic target for kernel write vulnerabilities.</p>
<p>Next, more work needs to be done on making sure page protections in the  kernel are sane.  Most importantly, RWX mappings should be removed and  function pointer tables should be enforced read-only.  Fortunately,  efforts are underway in this area as well, with help from Kees Cook.</p>
<p>Hopefully, with the combined efforts to remove information leakage via  restricting leaks and kernel image randomization, stronger page  protections in the kernel, and SMEP, the Linux kernel will have  significantly raised the bar for exploitation.</p>


<p>
<small>
This entry was posted
on Sunday, June 5th, 2011 at 4:40 pm and is filed under <a href="http://vulnfactory.org/blog/category/exploitation/" rel="category tag">Exploitation</a>, <a href="http://vulnfactory.org/blog/category/kernel/" rel="category tag">Kernel</a>, <a href="http://vulnfactory.org/blog/category/linux/" rel="category tag">Linux</a>.
You can follow any responses to this entry through the <a href="http://vulnfactory.org/blog/2011/06/05/smep-what-is-it-and-how-to-beat-it-on-linux/feed/">RSS 2.0</a> feed.

Both comments and pings are currently closed.


</small>
</p>

</div>
</div>


			<div id="comments">





</div><!-- #comments -->



        </div>
</div>




<!-- Page generated by LiteSpeed Cache 3.6.4 on 2021-11-27 07:12:12 --></body></html>