<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<!-- saved from url=(0060)http://vulnfactory.org/blog/2013/02/06/a-linux-memory-trick/ -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Security Research by Dan Rosenberg</title>
	
	<link rel="stylesheet" href="./2013 - A Linux Memory Trick_files/1.css" type="text/css" media="screen,projection">
</head>
<body>
<div id="vf_container">
        <div id="vf_header">
                <h1>It's Bugs All the Way Down</h1>
                <h2>Security Research by Dan Rosenberg</h2>
        </div>
        <div id="vf_nav">
                <ul id="menu">
                        <li><a href="http://vulnfactory.org/">Home</a></li>
                        <li><a href="http://vulnfactory.org/blog/"><em>Blog</em></a></li>
                        <li><a href="http://vulnfactory.org/vulns/">Vulnerabilities</a></li>
                        <li><a href="http://vulnfactory.org/exploits/">Exploits</a></li>
                        <li><a href="http://vulnfactory.org/research/">Research</a></li>
                        <li><a href="http://vulnfactory.org/contact/">Contact</a></li>
                </ul>
        </div>

        <div id="vf_content">


<div class="post-513 post type-post status-publish format-standard hentry category-kernel category-linux" id="post-513">
<h2>A Linux Memory Trick</h2>

<div>
<p>I discovered a neat little trick on Linux: on x86 (and a few other less common architectures), it’s possible to determine from an unprivileged process whether an address residing within the kernel address space is mapped or unmapped.</p>
<p><span id="more-513"></span>The top-level page fault handler on x86 is <code>do_page_fault()</code>, found in <code>arch/x86/mm/fault.c</code>. When the CPU fires a page fault exception, it pushes an error code onto the stack, which is accessible as an argument to the page fault handler.</p>
<p>When a userland process attempts to access unmapped memory or memory whose page permissions do not allow the desired type of access, the following code path is invoked:<br>
<code><br>
do_page_fault()<br>
__do_page_fault()<br>
bad_area_nosemaphore()<br>
__bad_area_nosemaphore()<br>
show_signal_msg()<br>
</code></p>
<p>This last function prints a message to the kernel syslog with information about the uncaught <code>SIGSEGV</code> that is thrown as a result of the invalid memory access:</p>
<pre>static inline void
show_signal_msg(struct pt_regs *regs, unsigned long error_code,
        unsigned long address, struct task_struct *tsk)
{
    if (!unhandled_signal(tsk, SIGSEGV))
        return;
        
    if (!printk_ratelimit())
        return;
        
    printk("%s%s[%d]: segfault at %lx ip %p sp %p error %lx",
        task_pid_nr(tsk) &gt; 1 ? KERN_INFO : KERN_EMERG,
        tsk-&gt;comm, task_pid_nr(tsk), address,
        (void *)regs-&gt;ip, (void *)regs-&gt;sp, error_code);
    
    print_vma_addr(KERN_CONT " in ", regs-&gt;ip);

    printk(KERN_CONT "\n");
}
</pre>
<p>Note that the <code>error_code</code> printed to the syslog has been passed down all the way from the top-level page fault handler. It’s worth taking a look at what the bits of this error code correspond to. Most importantly, bit 0 is the Present flag, indicating whether or not the page the process was trying to access is present at all. Bit 1 is the Read/Write flag, indicating whether this was a read or write fault, and bit 2 is the User/Supervisor flag, which is 0 when the fault was caused by a supervisory process, and 1 if the fault was caused by a user process.</p>
<p>In other words, regardless of whether the attempted access resides in user or kernel space, the error code logged to the syslog indicates whether the address corresponds to a present or absent page. This can be verified as follows:</p>
<pre>$ cat trick.c
#include &lt;stdlib.h&gt;

int main(int argc, char **argv)
{
    int *ptr, foo;
    ptr = (int *)strtoul(argv[1], NULL, 16);
    foo = *ptr;
}

$ ./trick ffffffff81aa3690
Segmentation fault (core dumped)
$ ./trick ffffffffc1aa3690
Segmentation fault (core dumped)
$ dmesg | grep segfault
[391396.756467] trick[31865]: segfault at ffffffff81aa3690 ip 0000000000400528 sp 00007fff7c026ba0 error 5 in trick[400000+1000]
[391404.736606] trick[31872]: segfault at ffffffffc1aa3690 ip 0000000000400528 sp 00007fff170fac60 error 4 in trick[400000+1000]
</pre>
<p>The first invocation deliberately causes an access violation on a mapped kernel address, resulting in an error code of 5 (a read violation from user mode on a present page). The second invocation causes an access violation on an unmapped kernel address, resulting in an error code of 4 (a read violation from user mode on a non-present page).</p>
<p>This trick is only possible if you can read the syslog in the first place, so the <code>dmesg_restrict</code> sysctl must be disabled.</p>


<p>
<small>
This entry was posted
on Wednesday, February 6th, 2013 at 6:23 pm and is filed under <a href="http://vulnfactory.org/blog/category/kernel/" rel="category tag">Kernel</a>, <a href="http://vulnfactory.org/blog/category/linux/" rel="category tag">Linux</a>.
You can follow any responses to this entry through the <a href="http://vulnfactory.org/blog/2013/02/06/a-linux-memory-trick/feed/">RSS 2.0</a> feed.

Both comments and pings are currently closed.


</small>
</p>

</div>
</div>


			<div id="comments">





</div><!-- #comments -->



        </div>
</div>




<!-- Page generated by LiteSpeed Cache 3.6.4 on 2021-11-27 16:29:42 --></body></html>