<!DOCTYPE html>
<!-- saved from url=(0045)https://blog.lizzie.io/using-userfaultfd.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Using userfaultfd</title>
<!-- 2019-02-18 Mon 02:58 -->

<meta name="generator" content="Org-mode">
<meta name="author" content="Lizzie Dixon">
<link rel="icon" href="data:;base64,="><style type="text/css">@media (max-width: 1000) {
    pre {
	font-size: 8pt;
    }
}

body{
    margin: 1em auto;
    max-width: 62em;
    line-height: 1.6;
    color: #444;
    padding: 0 1em;
    font-size: 14pt;
}

p {
    text-align: justify;
}

input {
    font-size: 14pt;
}

a:visited {
    color: #666;
}

a {
    color: #555;
}

h1 {
    margin: 0.5em 0;
}

h1, h2, h3 {
    line-height: 1.2
}

[src$=".svg"] {
    width: 100%;
}

.org-src-container {
    margin: 1em;
}

pre {
    padding: 2em;
    overflow: auto;
    background-color: #eeeeee;
}

pre.example {
    margin: 1em;
}

table {
    background-color: #eeeeee;
    margin: 2em;
}

td  {
    padding: 0.75em 2em;
}

.mono {
    font-family: monospace;
}

li {
    padding: 0.1em 0;
}


#table-of-contents {
    width: 40%;
    float: right;
    padding: 0 2em;
}

#table-of-contents ul {
    padding: 0 1.2em;
    margin: 0;
}

#table-of-contents h2 {
    margin: 0.2em;
}

label.org-src-name {
    color: #666;
    margin-bottom: 1em;
}

label.org-src-name code {
    color: #666;
}

code {
    word-break: break-all;
}

span.navigation-links a, span.self-links a {
    padding-right: 0.4em;
}

span.self-links {
    float: right;
}

span.listing-number, span.figure-number {
    display: none;
}

div.figure {
    text-align: center;
    font-size: 0.8em;
    color: #777;
    max-width: 100%;
}

div.figure img, div.figure video, div.prompt {
    -webkit-box-shadow: 0px 0px 10px 0px rgba(0,0,0,0.75);
    -moz-box-shadow: 0px 0px 10px 0px rgba(0,0,0,0.75);
    box-shadow: 0px 0px 10px 0px rgba(0,0,0,0.75);
    border: 1px solid #444;
    max-width: 100%;
}

/* MailChimp Form Embed Code - Horizontal Super Slim - 12/16/2015 v10.7
Adapted from: http://blog.heyimcat.com/universal-signup-form/ */

#mc_embed_signup form {text-align:center; padding:10px 0 10px 0;}
.mc-field-group { display: inline-block; } /* positions input field horizontally */
#mc_embed_signup input.email {border: 1px solid #444;  -webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px; color: #343434; background-color: #fff; box-sizing:border-box; height:32px; padding: 0px 0.4em; display: inline-block; margin: 0; max-width:300px; vertical-align:top;}
#mc_embed_signup .clear {display: inline-block;} /* positions button horizontally in line with input */
#mc_embed_signup .button {border: 1px solid #444; -webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px; letter-spacing: .03em; color: #fff; background-color: #777; box-sizing:border-box; height:32px; line-height:32px; padding:0 18px; display: inline-block; margin: 0; transition: all 0.23s ease-in-out 0s;}
#mc_embed_signup .button:hover {background-color:#555; cursor:pointer;}
#mc_embed_signup div#mce-responses {float:left; top:-1.4em; padding:0em .5em 0em .5em; overflow:hidden; width:90%;margin: 0 5%; clear: both;}
#mc_embed_signup div.response {margin:1em 0; padding:1em .5em .5em 0; font-weight:bold; float:left; top:-1.5em; z-index:1; width:80%;}
#mc_embed_signup #mce-error-response {display:none;}
#mc_embed_signup #mce-success-response {color:#529214; display:none;}
#mc_embed_signup label.error {display:block; float:none; width:auto; margin-left:1.05em; text-align:left; padding:.5em 0;}
#mc_embed_signup input.email { display: inline-block; margin-bottom:5px;}
#mc_embed_signup .button { margin:0; }

div.prompt {
    border-radius: 3px;
    padding: 10px;
    margin: 10px;
    background-color: #fff;
    text-align:center;
    max-width: 800px;
    margin-left: auto;
    margin-right: auto;
    background-color: #fffaa2;
}

div.prompt-close {
    float: right;
    padding-left: 10px;
    padding-bottom: 10px;
    cursor: pointer;
    color: #777;
    font-size: 0.8em;
    font-weight: bold;
    margin-top: -5px;
}
</style><script>window.onload = function () {
    if (window.location.pathname !== "/"
	&& document.cookie.split(/ *; */).indexOf("closed_form=yes") < 0) {
	var prompt = document.createElement("div");
	var close = document.createElement("div");
	var content = document.getElementById("content");
	var h1 = content.getElementsByTagName("h1")[0];

	prompt.className = "prompt";
	prompt.innerHTML = "Like this writing? Subscribe to receive updates on vulnerabilities and software projects as soon as I publish them!<br><div id=\"mc_embed_signup\"><form action=\"https://lizzie.us20.list-manage.com/subscribe/post?u=a2011719c1a5ce9e37e7c3e82&amp;id=43ce08f401\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate><div id=\"mc_embed_signup_scroll\"><input type=\"email\" value=\"\" name=\"EMAIL\" class=\"email\" id=\"mce-EMAIL\" placeholder=\"email address\" required><div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_a2011719c1a5ce9e37e7c3e82_43ce08f401\" tabindex=\"-1\" value=\"\"></div> <div class=\"clear\"><input type=\"submit\" value=\"subscribe\" name=\"asubscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div></div></form></div>";

	close.innerHTML = "×";
	close.className = "prompt-close";	
	close.onclick = function () {
	    content.removeChild(prompt);
	    document.cookie = "closed_form=yes";
	}

	prompt.insertBefore(close, prompt.firstChild);
	content.insertBefore(prompt, h1.nextSibling);
    }
}
</script><meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="alternate" type="application/rss+xml" href="https://blog.lizzie.io/rss.xml">
</head>
<body>
<div id="navigation"><span class="navigation-links"><a href="https://blog.lizzie.io/rss.xml">rss</a> <a href="https://blog.lizzie.io/">home</a> </span><span class="self-links"><a href="https://github.com/startling">github</a> <a href="mailto:_@lizzie.io">email</a></span></div><div id="content">
<h1 class="title">Using <code>userfaultfd</code></h1><div class="prompt"><div class="prompt-close">×</div>Like this writing? Subscribe to receive updates on vulnerabilities and software projects as soon as I publish them!<br><div id="mc_embed_signup"><form action="https://lizzie.us20.list-manage.com/subscribe/post?u=a2011719c1a5ce9e37e7c3e82&amp;id=43ce08f401" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate=""><div id="mc_embed_signup_scroll"><input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required=""><div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_a2011719c1a5ce9e37e7c3e82_43ce08f401" tabindex="-1" value=""></div> <div class="clear"><input type="submit" value="subscribe" name="asubscribe" id="mc-embedded-subscribe" class="button"></div></div></form></div></div>
<p>
<code>userfaultfd</code> is <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=808">being used in kernel exploits</a> to <a href="https://cyseclabs.com/blog/cve-2016-6187-heap-off-by-one-exploit">temporarily stop
kernel execution</a>. I had trouble finding out how to use it, so I wrote
a little program. Some notes:
</p>

<ul class="org-ul">
<li>If you don't include <code>O_NONBLOCK</code> in the <code>userfaultfd</code> flags argument,
<code>poll</code> will always return a <code>POLLERR</code>.</li>
<li>The API is complicated by a backwards-compatibility mechanism. You're
supposed to issue some <code>ioctls</code> and examine the struct to check if it
supports the operations you want.</li>
<li><p>
It doesn't work to just check structs against for example
<code>UFFDIO_REGISTER</code> or <code>UFFDIO_COPY</code>. Instead you should check them
against <code>UFFD_API</code> and <code>UFFD_API_RANGE_IOCTLS</code>. This wasn't entirely
clear to me after reading the documentation:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/vm/userfaultfd.txt?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3"><code>Documentation/vm/userfaultfd.txt@c8d2bc</code></a></label><pre class="src src-text">Once the userfaultfd has been enabled the UFFDIO_REGISTER ioctl should
be invoked (if present in the returned uffdio_api.ioctls bitmask) to
register a memory range in the userfaultfd by setting the
uffdio_register structure accordingly. 
</pre>
</div>

<p>
but after I looked at the source I realized it was just returning
<code>UFFD_API_RANGE_IOCTLS</code>…
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/userfaultfd.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n871"><code>fs/userfaultfd.c:871@c8d2bc</code></a></label><pre class="src src-C">out_unlock:
        up_write(&amp;mm-&gt;mmap_sem);
        mmput(mm);
        if (!ret) {
                /*
                 * Now that we scanned all vmas we can already tell
                 * userland which ioctls methods are guaranteed to
                 * succeed on this range.
                 */
                if (put_user(UFFD_API_RANGE_IOCTLS,
                             &amp;user_uffdio_register-&gt;ioctls))
                        ret = -EFAULT;
        }
</pre>
</div>

<p>
which has, for example, <code>1 &lt;&lt; _UFFDIO_COPY</code> in it…
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/userfaultfd.h?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n25"><code>include/uapi/linux/userfaultfd.h:25@c8d2bc</code></a></label><pre class="src src-C">#define UFFD_API_RANGE_IOCTLS                   \
        ((__u64)1 &lt;&lt; _UFFDIO_WAKE |             \
         (__u64)1 &lt;&lt; _UFFDIO_COPY |             \
         (__u64)1 &lt;&lt; _UFFDIO_ZEROPAGE)

</pre>
</div>

<p>
which is <b>not</b> <code>UFFDIO_COPY</code>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/userfaultfd.h?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n55"><code>include/uapi/linux/userfaultfd.h:55@c8d2bc</code></a></label><pre class="src src-C">#define UFFDIO_COPY             _IOWR(UFFDIO, _UFFDIO_COPY,     \
                                      struct uffdio_copy)

</pre>
</div></li>

<li>If the <code>struct uffdio_register</code> <code>.len</code> isn't a multiple of the page
size, you get an <code>EINVAL</code>.</li>

<li>If you don't initialize it correctly, polling or reading on fd gets a
<code>POLLERR</code>.</li>
</ul>

<p>
So, the program:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span><a href="https://blog.lizzie.io/using-userfaultfd/userfaultfd.c"><code>userfaultfd.c</code></a></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror -lpthread userfaultfd.c -o userfaultfd" -*- */
/* Little illustration of userfaultfd. Set up a userfaultfd, mmap two
   pages. Whenever one of those pages is requested, fill it with a specific
   string.
*/
#include &lt;fcntl.h&gt;
#include &lt;poll.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;linux/userfaultfd.h&gt;

#define PAGESIZE 4096

int userfaultfd(int flags)
{
	return syscall(SYS_userfaultfd, flags);
}

void *print_virtual_memory(void *memory)
{
	fprintf(stderr, "%s", (char *)memory);
	fprintf(stderr, "%s", &amp;((char *)memory)[PAGESIZE]);
	return NULL;
}

int main (int argc, char **argv)
{
	int return_code = 0;

	int fd = 0;
	if ((fd = userfaultfd(O_NONBLOCK)) == -1) {
		fprintf(stderr, "++ userfaultfd failed: %m\n");
		goto cleanup_error;
	}
	/* When first opened the userfaultfd must be enabled invoking the
	   UFFDIO_API ioctl specifying a uffdio_api.api value set to UFFD_API
	   (or a later API version) which will specify the read/POLLIN protocol
	   userland intends to speak on the UFFD and the uffdio_api.features
	   userland requires. The UFFDIO_API ioctl if successful (i.e. if the
	   requested uffdio_api.api is spoken also by the running kernel and the
	   requested features are going to be enabled) will return into
	   uffdio_api.features and uffdio_api.ioctls two 64bit bitmasks of
	   respectively all the available features of the read(2) protocol and
	   the generic ioctl available. */
	struct uffdio_api api = { .api = UFFD_API };
	if (ioctl(fd, UFFDIO_API, &amp;api)) {
		fprintf(stderr, "++ ioctl(fd, UFFDIO_API, ...) failed: %m\n");
		goto cleanup_error;
	}
	/* "Once the userfaultfd has been enabled the UFFDIO_REGISTER ioctl
	   should be invoked (if present in the returned uffdio_api.ioctls
	   bitmask) to register a memory range in the userfaultfd by setting the
	   uffdio_register structure accordingly. The uffdio_register.mode
	   bitmask will specify to the kernel which kind of faults to track for
	   the range (UFFDIO_REGISTER_MODE_MISSING would track missing
	   pages). The UFFDIO_REGISTER ioctl will return the uffdio_register
	   . ioctls bitmask of ioctls that are suitable to resolve userfaults on
	   the range registered. Not all ioctls will necessarily be supported
	   for all memory types depending on the underlying virtual memory
	   backend (anonymous memory vs tmpfs vs real filebacked mappings)." */
	if (api.api != UFFD_API) {
		fprintf(stderr, "++ unexepcted UFFD api version.\n");
		goto cleanup_error;
	}
	/* mmap some pages, set them up with the userfaultfd. */
	void *pages = NULL;
	if ((pages = mmap(NULL, PAGESIZE * 2, PROT_READ,
			  MAP_PRIVATE | MAP_ANONYMOUS, 0, 0)) == MAP_FAILED) {
		fprintf(stderr, "++ mmap failed: %m\n");
		goto cleanup_error;
	}
	struct uffdio_register reg = {
		.mode = UFFDIO_REGISTER_MODE_MISSING,
		.range = {
			.start = (long) pages,
			.len = PAGESIZE * 2
		}
	};
	if (ioctl(fd, UFFDIO_REGISTER,  &amp;reg)) {
		fprintf(stderr, "++ ioctl(fd, UFFDIO_REGISTER, ...) failed: %m\n");
		goto cleanup_error;
	}
	if (reg.ioctls != UFFD_API_RANGE_IOCTLS) {
		fprintf(stderr, "++ unexpected UFFD ioctls.\n");
		goto cleanup_error;
	}
	/* start a thread that will fault... */
	pthread_t thread = {0};
	if (pthread_create(&amp;thread, NULL, print_virtual_memory, pages)) {
		fprintf(stderr, "++ pthread_create failed: %m\n");
		goto cleanup_error;
	}

	/* and then wait for the faults to happen. */
	char data[PAGESIZE] = "-- handled page fault.\n";
	struct pollfd evt = { .fd = fd, .events = POLLIN };
	while (poll(&amp;evt, 1, 10) &gt; 0) {
		/* unexpected poll events */
		if (evt.revents &amp; POLLERR) {
			fprintf(stderr, "++ POLLERR\n");
			goto cleanup_error;
		} else if (evt.revents &amp; POLLHUP) {
			fprintf(stderr, "++ POLLHUP\n");
			goto cleanup_error;
		}
		struct uffd_msg fault_msg = {0};
		if (read(fd, &amp;fault_msg, sizeof(fault_msg)) != sizeof(fault_msg)) {
			fprintf(stderr, "++ read failed: %m\n");
			goto cleanup_error;
		}
		char *place = (char *)fault_msg.arg.pagefault.address;
		if (fault_msg.event != UFFD_EVENT_PAGEFAULT
		    || (place != pages &amp;&amp; place != pages + PAGESIZE)) {
			fprintf(stderr, "unexpected pagefault?.\n");
			goto cleanup_error;
		}
		struct uffdio_copy copy = {
			.dst = (long) place,
			.src = (long) data,
			.len = PAGESIZE
		};
		if (ioctl(fd, UFFDIO_COPY, &amp;copy)) {
			fprintf(stderr, "++ ioctl(fd, UFFDIO_COPY, ...) failed: %m\n");
			goto cleanup_error;
		}
	}
	goto cleanup;
cleanup_error:
	return_code = 1;
cleanup:
	if (fd) close(fd);
	return return_code;
}
</pre>
</div>

<p>
and a modified one to pause in the kernel:
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span><a href="https://blog.lizzie.io/using-userfaultfd/userfaultfd_kernel.c"><code>userfaultfd_kernel.c</code></a></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror -lpthread userfaultfd_kernel.c -o userfaultfd_kernel" -*- */
/* Little illustration of userfaultfd. Set up a userfaultfd, mmap two
   pages. Whenever one of those pages is requested, fill it with a specific
   string.
*/
#include &lt;fcntl.h&gt;
#include &lt;poll.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/userfaultfd.h&gt;

struct thread_args {
	char *memory;
	int fd;
};

#define PAGESIZE 4096

int userfaultfd(int flags)
{
	return syscall(SYS_userfaultfd, flags);
}

void *write_virtual_memory(void *t_a)
{
	struct thread_args *args = (struct thread_args *) t_a;
	if (write(args-&gt;fd, args-&gt;memory, PAGESIZE) != PAGESIZE
	    || write(args-&gt;fd, args-&gt;memory + PAGESIZE, PAGESIZE) != PAGESIZE) {
		fprintf(stderr, "++ write failed: %m\n");
	}
	return NULL;
}

int main (int argc, char **argv)
{
	int return_code = 0;
	int fd = 0;
	int sockets[2] = {0};

	if (socketpair(AF_LOCAL, SOCK_SEQPACKET, 0, sockets)) {
		fprintf(stderr, "++ socketpair failed: %m\n");
		goto cleanup_error;
	}

	if ((fd = userfaultfd(O_NONBLOCK)) == -1) {
		fprintf(stderr, "++ userfaultfd failed: %m\n");
		goto cleanup_error;
	}
	/* When first opened the userfaultfd must be enabled invoking the
	   UFFDIO_API ioctl specifying a uffdio_api.api value set to UFFD_API
	   (or a later API version) which will specify the read/POLLIN protocol
	   userland intends to speak on the UFFD and the uffdio_api.features
	   userland requires. The UFFDIO_API ioctl if successful (i.e. if the
	   requested uffdio_api.api is spoken also by the running kernel and the
	   requested features are going to be enabled) will return into
	   uffdio_api.features and uffdio_api.ioctls two 64bit bitmasks of
	   respectively all the available features of the read(2) protocol and
	   the generic ioctl available. */
	struct uffdio_api api = { .api = UFFD_API };
	if (ioctl(fd, UFFDIO_API, &amp;api)) {
		fprintf(stderr, "++ ioctl(fd, UFFDIO_API, ...) failed: %m\n");
		goto cleanup_error;
	}
	/* "Once the userfaultfd has been enabled the UFFDIO_REGISTER ioctl
	   should be invoked (if present in the returned uffdio_api.ioctls
	   bitmask) to register a memory range in the userfaultfd by setting the
	   uffdio_register structure accordingly. The uffdio_register.mode
	   bitmask will specify to the kernel which kind of faults to track for
	   the range (UFFDIO_REGISTER_MODE_MISSING would track missing
	   pages). The UFFDIO_REGISTER ioctl will return the uffdio_register
	   . ioctls bitmask of ioctls that are suitable to resolve userfaults on
	   the range registered. Not all ioctls will necessarily be supported
	   for all memory types depending on the underlying virtual memory
	   backend (anonymous memory vs tmpfs vs real filebacked mappings)." */
	if (api.api != UFFD_API) {
		fprintf(stderr, "++ unexepcted UFFD api version.\n");
		goto cleanup_error;
	}
	/* mmap some pages, set them up with the userfaultfd. */
	void *pages = NULL;
	if ((pages = mmap(NULL, PAGESIZE * 2, PROT_READ,
			  MAP_PRIVATE | MAP_ANONYMOUS, 0, 0)) == MAP_FAILED) {
		fprintf(stderr, "++ mmap failed: %m\n");
		goto cleanup_error;
	}
	struct uffdio_register reg = {
		.mode = UFFDIO_REGISTER_MODE_MISSING,
		.range = {
			.start = (long) pages,
			.len = PAGESIZE * 2
		}
	};
	if (ioctl(fd, UFFDIO_REGISTER,  &amp;reg)) {
		fprintf(stderr, "++ ioctl(fd, UFFDIO_REGISTER, ...) failed: %m\n");
		goto cleanup_error;
	}
	if (reg.ioctls != UFFD_API_RANGE_IOCTLS) {
		fprintf(stderr, "++ unexpected UFFD ioctls.\n");
		goto cleanup_error;
	}
	/* start a thread that will fault... */
	pthread_t thread = {0};
	if (pthread_create(&amp;thread, NULL, write_virtual_memory,
			   &amp; (struct thread_args) {
				   .memory = pages,
				   .fd = sockets[1]
			   })) {
		fprintf(stderr, "++ pthread_create failed: %m\n");
		goto cleanup_error;
	}

	/* and then wait for the faults to happen. */
	char data[PAGESIZE] = "-- handled page fault.\n";
	struct pollfd evts[2] = {
		{ .fd = fd, .events = POLLIN },
		{ .fd = sockets[0], .events = POLLIN }
	};
	while (poll(evts, sizeof(evts) / sizeof(struct pollfd), 10) &gt; 0) {
		/* unexpected poll events */
		if (evts[0].revents &amp; POLLERR
		    || evts[1].revents &amp; POLLERR) {
			fprintf(stderr, "++ POLLERR\n");
			goto cleanup_error;
		} else if (evts[0].revents &amp; POLLHUP
			   || evts[1].revents &amp; POLLHUP) {
			fprintf(stderr, "++ POLLHUP\n");
			goto cleanup_error;
		}		
		/* handle the userfaultfd data */
		if (evts[0].revents &amp; POLLIN) {
			struct uffd_msg fault_msg = {0};
			if (read(fd, &amp;fault_msg, sizeof(fault_msg)) != sizeof(fault_msg)) {
				fprintf(stderr, "++ read failed: %m\n");
				goto cleanup_error;
			}
			char *place = (char *)fault_msg.arg.pagefault.address;
			if (fault_msg.event != UFFD_EVENT_PAGEFAULT
			    || (place != pages &amp;&amp; place != pages + PAGESIZE)) {
				fprintf(stderr, "unexpected pagefault?.\n");
				goto cleanup_error;
			}
			struct uffdio_copy copy = {
				.dst = (long) place,
				.src = (long) data,
				.len = PAGESIZE
			};
			if (ioctl(fd, UFFDIO_COPY, &amp;copy)) {
				fprintf(stderr, "++ ioctl(fd, UFFDIO_COPY, ...) failed: %m\n");
				goto cleanup_error;
			}
		}
		/* handle the child thread's data */
		if (evts[1].revents &amp; POLLIN) {
			char msg[PAGESIZE] = {0};
			if (read(sockets[0], &amp;msg, sizeof(msg)) == -1) {
				fprintf(stderr, "++ read failed: %m\n");
				goto cleanup_error;
			}
			printf("%s", msg);
		}
	}
	goto cleanup;
cleanup_error:
	return_code = 1;
cleanup:
	if (fd) close(fd);
	if (sockets[0]) close(sockets[0]);
	if (sockets[1]) close(sockets[1]);
	return return_code;
}
</pre>
</div>
</div>


</body></html>