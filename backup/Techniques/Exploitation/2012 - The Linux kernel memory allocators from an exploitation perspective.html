<!DOCTYPE html>
<!-- saved from url=(0065)https://argp.github.io/2012/01/03/linux-kernel-heap-exploitation/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link href="http://gmpg.org/xfn/11" rel="profile">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      The Linux kernel memory allocators from an exploitation perspective
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="./2012 - The Linux kernel memory allocators from an exploitation perspective_files/styles.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://argp.github.io/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="https://argp.github.io/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="argp" href="https://argp.github.io/atom.xml">

  <!-- Google Analytics -->
  <script async="" src="./2012 - The Linux kernel memory allocators from an exploitation perspective_files/analytics.js.下載"></script><script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-806065-7', 'auto');
    ga('send', 'pageview');
  </script>
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h3 class="masthead-title">

          <a href="https://argp.github.io/" title="Home">argp</a>
          
          <!-- <small>&#x26e7;</small> -->

          <!-- <img style="display: inline-block;" align="middle"
              width="2%" src="https://argp.github.io/public/5.svg"> -->

          &nbsp;&nbsp;&nbsp;
          
          &nbsp;&nbsp;&nbsp;
          <small><a href="https://argp.github.io/posts">posts</a></small>
          
          &nbsp;&nbsp;&nbsp;
          <small><a href="https://argp.github.io/research">research</a></small>
          
          &nbsp;&nbsp;&nbsp;
          <small><a href="https://argp.github.io/bugs">bugs</a></small>
          
        
        </h3>
      </header>

      <main>
        <article class="post">
  <h1 class="post-title">The Linux kernel memory allocators from an exploitation perspective</h1>
  <time datetime="2012-01-03T00:00:00+00:00" class="post-date">03 Jan 2012</time>
  <p>In anticipation of <a href="https://twitter.com/djrbliss">Dan Rosenberg’s</a>
talk on exploiting the Linux kernel’s SLOB memory allocator at the
<a href="http://infiltratecon.com/">Infiltrate security conference</a>
and because I recently had a discussion with some friends about the different
kernel memory allocators in Linux, I decided to write this quick introduction.
I will present some of the allocators’ characteristics and also provide
references to public work on exploitation techniques.</p>

<p align="center">
<img src="./2012 - The Linux kernel memory allocators from an exploitation perspective_files/slabs.jpg" width="300" height="225">
</p>

<p>At the time of this writing, the Linux kernel has three different memory
allocators in the official code tree, namely SLAB, SLUB and SLOB. These
allocators are on a memory management layer that is logically on top of the
system’s low level page allocator and are mutually exclusive (i.e. you
can only have one of them enabled/compiled in your kernel). They are used when
a kernel developer calls <code class="language-plaintext highlighter-rouge">kmalloc()</code> or a similar function. Unsurprisingly,
they can all be found in the
<a href="http://lxr.linux.no/linux+v3.1.6/mm/">mm directory</a>. All of them follow, to
various extends and by extending or simplifying, the <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.4759">traditional slab allocator
design</a> (notice
the lowercase “slab”; that’s the term for the general allocator design approach,
while “SLAB” is a slab implementation in the Linux kernel). Slab allocators
allocate prior to any request, for example at kernel boot time, large areas of
virtual memory (called “slabs”, hence the name). Each one of these slabs is then
 associated to a kernel structure of a specific type and size. Furthermore, each
slab is divided into the appropriate number of slots for the size of the kernel
structure it is associated with.</p>

<p>As an example consider that a slab for the structure <code class="language-plaintext highlighter-rouge">task_struct</code> has 31 slots.
The size of a <code class="language-plaintext highlighter-rouge">task_struct</code> is 1040 bytes, so assuming that a page is 4096 bytes
(the default) then a <code class="language-plaintext highlighter-rouge">task_struct</code> slab is 8 pages long. Apart from the
structure-specific slabs, like the one above for <code class="language-plaintext highlighter-rouge">task_struct</code>, there are also
the so called general purpose slabs which are used to serve arbitrary-sized
<code class="language-plaintext highlighter-rouge">kmalloc()</code> requests. These requests are adjusted by the allocator for alignment
and assigned to a suitable slab.</p>

<p>Let’s take a look at the slabs of a recent Linux kernel:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">cat</span> /proc/slabinfo
slabinfo - version: 2.1
...
fat_inode_cache       57     57    416   19    2 : tunables    0    0    0 : slabdata      3      3      0
fat_cache            170    170     24  170    1 : tunables    0    0    0 : slabdata      1      1      0
VMBlockInodeCache      7      7   4480    7    8 : tunables    0    0    0 : slabdata      1      1      0
blockInfoCache         0      0   4160    7    8 : tunables    0    0    0 : slabdata      0      0      0
AF_VMCI                0      0    704   23    4 : tunables    0    0    0 : slabdata      0      0      0
fuse_request          80     80    400   20    2 : tunables    0    0    0 : slabdata      4      4      0
fuse_inode         21299  21690    448   18    2 : tunables    0    0    0 : slabdata   1205   1205      0
...
kmalloc-8192          94     96   8192    4    8 : tunables    0    0    0 : slabdata     24     24      0
kmalloc-4096         118    128   4096    8    8 : tunables    0    0    0 : slabdata     16     16      0
kmalloc-2048         173    208   2048   16    8 : tunables    0    0    0 : slabdata     13     13      0
kmalloc-1024         576    640   1024   16    4 : tunables    0    0    0 : slabdata     40     40      0
kmalloc-512          904    992    512   16    2 : tunables    0    0    0 : slabdata     62     62      0
kmalloc-256          540    976    256   16    1 : tunables    0    0    0 : slabdata     61     61      0
kmalloc-128          946   1408    128   32    1 : tunables    0    0    0 : slabdata     44     44      0
kmalloc-64         13013  13248     64   64    1 : tunables    0    0    0 : slabdata    207    207      0
kmalloc-32         23624  27264     32  128    1 : tunables    0    0    0 : slabdata    213    213      0
kmalloc-16          3546   3584     16  256    1 : tunables    0    0    0 : slabdata     14     14      0
kmalloc-8           4601   4608      8  512    1 : tunables    0    0    0 : slabdata      9      9      0
kmalloc-192         3659   4620    192   21    1 : tunables    0    0    0 : slabdata    220    220      0
kmalloc-96         10137  11340     96   42    1 : tunables    0    0    0 : slabdata    270    270      0
kmem_cache            32     32    128   32    1 : tunables    0    0    0 : slabdata      1      1      0
kmem_cache_node      256    256     32  128    1 : tunables    0    0    0 : slabdata      2      2      0</code></pre></figure>

<p>Here you can see structure-specific slabs, for example <code class="language-plaintext highlighter-rouge">fuse_inode</code>, and
general purpose slabs, for example <code class="language-plaintext highlighter-rouge">kmalloc-96</code>.</p>

<p>When it comes to the exploitation of overflow bugs in the context of slab
allocators, there are three general approaches to corrupt kernel memory:</p>

<ul>
  <li>Corruption of the adjacent objects/structures of the same slab.</li>
  <li>Corruption of the slab allocator’s management structures
(referred to as <em>metadata</em>).</li>
  <li>Corruption of the adjacent <em>physical</em> page of the slab your vulnerable
structure is allocated on.</li>
</ul>

<p>The ultimate goal of the above approaches is of course to gain
control of the kernel’s execution flow and divert/hijack it to your own
code. In order to be able to manipulate the allocator and the state of its
slabs, arranging structures on them to your favor (i.e. next to each other on
the same slab, or at the end of a slab), it is nice (but not strictly required
;) to have some information on the allocator’s state. The proc filesystem
provides us with a way to get this information. Unprivileged local users can
simply <code class="language-plaintext highlighter-rouge">cat /proc/slabinfo</code> (as shown above) and see the allocator’s
slabs, the number of used/free structures on them, etc. <a href="http://thread.gmane.org/gmane.linux.kernel/1108378/">Is your distribution
still allowing this?</a></p>

<p>For each one of the Linux kernel’s allocators I will provide references to
papers describing practical attack techniques and examples of public exploits.</p>

<h3 id="slab">SLAB</h3>

<p>Starting with the oldest of the three allocators,
<a href="http://lxr.linux.no/linux+v3.1.6/mm/slab.c">SLAB</a> organizes physical memory
frames in caches. Each cache is responsible for a specific kernel structure.
Also, each cache holds slabs that consist of contiguous pages and these slabs
are responsible for the actual storing of the kernel structures of the
cache’s type. A SLAB’s slab can have both allocated (in use) and deallocated
(free) slots. Based on this and with the goal of reducing fragmentation of the
system’s virtual memory, a cache’s slabs are divided into three lists; a list
with full slabs (i.e slabs with no free slots), a list with empty slabs (slabs
on which all slots are free), and a list with partial slabs (slabs that have
slots both in use and free).</p>

<p>A SLAB’s slab is described by the following structure:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">slab</span>
<span class="p">{</span>
    <span class="k">union</span>
    <span class="p">{</span>
        <span class="k">struct</span>
        <span class="p">{</span>
            <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">colouroff</span><span class="p">;</span>
            <span class="kt">void</span> <span class="o">*</span><span class="n">s_mem</span><span class="p">;</span>            <span class="cm">/* including colour offset */</span>
            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inuse</span><span class="p">;</span>     <span class="cm">/* num of objs active in slab */</span>
            <span class="n">kmem_bufctl_t</span> <span class="n">free</span><span class="p">;</span>
            <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">nodeid</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">struct</span> <span class="n">slab_rcu</span> <span class="n">__slab_cover_slab_rcu</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">list</code> variable is used to place the slab in one of the lists I
described above. Coloring and the variable <code class="language-plaintext highlighter-rouge">colouroff</code> require some explanation
in case you haven’t seen them before. <em>Coloring</em> or <em>cache coloring</em> is a
performance trick to reduce processor L1 cache hits. This is accomplished by
making sure that the first “slot” of a slab (which is used to store
the slab’s <code class="language-plaintext highlighter-rouge">slab</code> structure, i.e. the slab’s metadata) is not
placed at the beginning of the slab (which is also at the start of a page) but
an offset <code class="language-plaintext highlighter-rouge">colouroff</code> from it. <code class="language-plaintext highlighter-rouge">s_mem</code> is a pointer to the first slot of the
slab that stores an actual kernel structure/object. <code class="language-plaintext highlighter-rouge">free</code> is an index to the
next free object of the slab.</p>

<p>As I mentioned in the previous paragraph, a SLAB’s slab
begins with a <code class="language-plaintext highlighter-rouge">slab</code> structure (the slab’s metadata) and is followed by
the slab’s objects. The stored objects on a slab are contiguous, with no
metadata in between them, making easier the exploitation approach of corrupting
adjacent objects. Easier means that when we overflow from one object to its
adjacent we don’t corrupt management data that could lead to making the
system crash.</p>

<p>By manipulating SLAB through controlled allocations and
deallocations from userland that affect the kernel (for example via system
calls) we can arrange that the overflow from a vulnerable structure will
corrupt an adjacent structure of our own choosing. The fact that SLAB’s
allocations and deallocations work in a LIFO manner is of course to our
advantage in arranging structures/objects on the slabs. As qobaiashi has
presented in his paper <a href="https://argp.github.io/public/kmalloc_exploitation.pdf">“The story of exploiting kmalloc()
overflows”</a>,
the system calls <code class="language-plaintext highlighter-rouge">semget()</code> and <code class="language-plaintext highlighter-rouge">semctl(..., ..., IPC_RMID)</code> is one way to make
controlled allocations and deallocations respectively. The term “controlled”
here refers to both the size of the allocation/deallocation and the fact that we
can use them directly from userland. Another requirement that these system
calls satisfy is that the structure they allocate can help us in our quest for
code execution when used as a victim object and corrupted from a vulnerable
object. Other ways/system calls that satisfy all the above requirements do
exist.</p>

<p>Another resource on attacking SLAB is “Exploiting kmalloc overflows to 0wn j00”
by amnesia and clflush. In that presentation the authors explained the
development process for a reliable exploit for vulnerability
<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0424">CVE-2004-0424</a>
(which was an integer overflow leading to a kernel heap buffer overflow found by
ihaquer and cliph). Both the presentation and the exploit are not public as far
as I know. However, a full exploit was published by twiz and sgrakkyu in
<a href="http://phrack.org/issues/64/6.html#article">Phrack #64</a> (<code class="language-plaintext highlighter-rouge">castity.c</code>).</p>

<h3 id="slub">SLUB</h3>

<p><a href="http://lxr.linux.no/linux+v3.1.6/mm/slub.c">SLUB</a> is currently the default
allocator of the Linux kernel. It follows the SLAB allocator I have already
described in its general design (caches, slabs, full/empty/partial lists of
slabs, etc.), however it has introduced simplifications in respect to management
overhead to achieve better performance. One of the main differences is that SLUB
has no metadata at the beginning of each slab like SLAB, but instead it has
added its metadata variables in the Linux kernel’s <code class="language-plaintext highlighter-rouge">page</code> structure to track the
allocator’s data on the physical pages.</p>

<p>The following excerpt includes only the relevant parts of the <code class="language-plaintext highlighter-rouge">page</code> structure,
see <a href="http://lxr.linux.no/linux+v3.1.6/include/linux/mm_types.h#L27">here</a> for
the complete version.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">page</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="k">struct</span>
    <span class="p">{</span>
        <span class="k">union</span>
        <span class="p">{</span>
            <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>          <span class="cm">/* Our offset within mapping. */</span>
            <span class="kt">void</span> <span class="o">*</span><span class="n">freelist</span><span class="p">;</span>         <span class="cm">/* slub first free object */</span>
        <span class="p">};</span>

        <span class="p">...</span>

        <span class="k">struct</span>
        <span class="p">{</span>
            <span class="kt">unsigned</span> <span class="n">inuse</span><span class="o">:</span><span class="mi">16</span><span class="p">;</span>
            <span class="kt">unsigned</span> <span class="n">objects</span><span class="o">:</span><span class="mi">15</span><span class="p">;</span>
            <span class="kt">unsigned</span> <span class="n">frozen</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="p">...</span>
    <span class="p">};</span>

    <span class="p">...</span>

    <span class="k">union</span>
    <span class="p">{</span>
        <span class="p">...</span>
        <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">slab</span><span class="p">;</span>        <span class="cm">/* SLUB: Pointer to slab */</span>  
        <span class="p">...</span>
    <span class="p">};</span>

    <span class="p">...</span>
<span class="p">};</span></code></pre></figure>

<p>Since there are no metadata on the slab itself, a <code class="language-plaintext highlighter-rouge">page</code>’s
<code class="language-plaintext highlighter-rouge">freelist</code> pointer is used to point to the first free object of the slab. A
free object of a slab has a small header with metadata that contain a pointer
to the next free object of the slab. The <code class="language-plaintext highlighter-rouge">index</code> variable holds the offset to
these metadata within a free object. <code class="language-plaintext highlighter-rouge">inuse</code> and <code class="language-plaintext highlighter-rouge">objects</code> hold respectively
the allocated and total number of objects of the slab. <code class="language-plaintext highlighter-rouge">frozen</code> is a flag that
specifies whether the page can be used by SLUB’s list management
functions. Specifically, if a page has been frozen by a CPU core, only this
core can retrieve free objects from the page, while the other available CPU
cores can only add free objects to it. The last interesting for our discussion
variable is <code class="language-plaintext highlighter-rouge">slab</code> which is of type <code class="language-plaintext highlighter-rouge">struct kmem_cache</code> and is a pointer to the
slab on the page.</p>

<p>The function <code class="language-plaintext highlighter-rouge">on_freelist()</code> is used by SLUB to determine if a
given object is on a given page’s <code class="language-plaintext highlighter-rouge">freelist</code> and provides a nice
introduction to the use of the above elements. The following snippet is an
example invocation of <code class="language-plaintext highlighter-rouge">on_freelist()</code> (taken from
<a href="http://lxr.linux.no/linux+v3.1.6/mm/slub.c#L3269">here</a>):</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">slab_lock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span><span class="n">on_freelist</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">object_err</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="s">"Object is on free-list"</span><span class="p">);</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">slab_unlock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span></code></pre></figure>

<p>Locking is required to avoid inconsistencies since <code class="language-plaintext highlighter-rouge">on_freelist()</code>
makes some modifications and it could be interrupted. Let’s take a look
at an excerpt from <code class="language-plaintext highlighter-rouge">on_freelist()</code> (the full version is
<a href="http://lxr.linux.no/linux+v3.1.6/mm/slub.c#L929">here</a>):</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">int</span> <span class="nf">on_freelist</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">search</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_objects</span><span class="p">;</span>

    <span class="n">fp</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">fp</span> <span class="o">&amp;&amp;</span> <span class="n">nr</span> <span class="o">&lt;=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">fp</span> <span class="o">==</span> <span class="n">search</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">check_valid_pointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">fp</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">object</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">object_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="s">"Freechain corrupt"</span><span class="p">);</span>
                <span class="n">set_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">slab_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="s">"Freepointer corrupt"</span><span class="p">);</span>
                <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">;</span>
                <span class="n">slab_fix</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">"Freelist cleared"</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">object</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">get_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
        <span class="n">nr</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>The function starts with a simple piece of code that walks the
<code class="language-plaintext highlighter-rouge">freelist</code> and demonstrates the use of SLUB internal variables. Of particular
interest is the call of the <code class="language-plaintext highlighter-rouge">check_valid_pointer()</code> function which verifies
that a <code class="language-plaintext highlighter-rouge">freelist</code>’s object’s address (variable <code class="language-plaintext highlighter-rouge">fp</code>) is within a
slab page. This is a check that safeguards against corruptions of the
<code class="language-plaintext highlighter-rouge">freelist</code>.</p>

<p>This brings us to attacks against the SLUB memory allocator. The
attack vector of corrupting adjacent objects on the same slab is fully
applicable to SLUB and largely works like in the case of the SLAB allocator.
However, in the case of SLUB there is an added attack vector: exploiting the
allocator’s metadata (the ones responsible for finding the next free
object on the slab). As twiz and sgrakkyu have demonstrated in
<a href="http://www.amazon.com/gp/product/1597494860/ref=as_li_ss_tl?ie=UTF8&amp;tag=oss042-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1597494860">their book on kernel
exploitation</a>, the slab
can be misaligned by corrupting the least significant byte of the metadata of a
free object that hold the pointer to the next free object. This misalignment of
the slab allows us to create an in-slab fake object and by doing so to a)
satisfy safeguard checks as the one I explained in the previous paragraph when
they are used, and b) to hijack the kernel’s execution flow to our own code.</p>

<p>An example of SLUB metadata corruption and slab misalignment is the
exploit for vulnerability
<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1046">CVE-2009-1046</a>
which was an off-by-two kernel heap overflow. In
<a href="http://kernelbof.blogspot.com/2009/07/even-when-one-byte-matters.html">this blog
post</a>
sgrakkyu explained how by using only an one byte overflow turned this
vulnerability into a reliable exploit (<code class="language-plaintext highlighter-rouge">tiocl_houdini.c</code>). If you’re wondering
why an one byte overflow is more reliable than a two byte overflow think about
little-endian representation.</p>

<p>A public example of corrupting adjacent SLUB objects is the exploit
<code class="language-plaintext highlighter-rouge">i-can-haz-modharden.c</code> by Jon Oberheide for vulnerability
<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2959">CVE-2010-2959</a>
discovered by Ben Hawkes. In <a href="https://jon.oberheide.org/blog/2010/09/10/linux-kernel-can-slub-overflow/">this blog
post</a>
you can find an overview of the exploit and the technique.</p>

<h3 id="slob">SLOB</h3>

<p>Finally, <a href="http://lxr.linux.no/linux+v3.1.6/mm/slob.c">SLOB</a> is a stripped down
kernel allocator implementation designed for systems with limited amounts of
memory, for example embedded versions/distributions of Linux. In fact its design
is closer to traditional userland memory allocators rather than the slab
allocators SLAB and SLUB. SLOB places all objects/structures on pages arranged
in three linked lists, for small, medium and large allocations. Small are the
allocations of size less than <code class="language-plaintext highlighter-rouge">SLOB_BREAK1</code> (256 bytes), medium those less than
<code class="language-plaintext highlighter-rouge">SLOB_BREAK2</code> (1024 bytes), and large are all the other allocations:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define SLOB_BREAK1 256
#define SLOB_BREAK2 1024
</span><span class="k">static</span> <span class="nf">LIST_HEAD</span><span class="p">(</span><span class="n">free_slob_small</span><span class="p">);</span>
<span class="k">static</span> <span class="nf">LIST_HEAD</span><span class="p">(</span><span class="n">free_slob_medium</span><span class="p">);</span>
<span class="k">static</span> <span class="nf">LIST_HEAD</span><span class="p">(</span><span class="n">free_slob_large</span><span class="p">);</span></code></pre></figure>

<p>Of course this means that in SLOB we can have objects/structures of
different types and sizes on the same page. This is the main difference between
SLOB and SLAB/SLUB. A SLOB page is defined as follows:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">slob_page</span>
<span class="p">{</span>
    <span class="k">union</span>
    <span class="p">{</span>
        <span class="k">struct</span>
        <span class="p">{</span>
            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>    <span class="cm">/* mandatory */</span>
            <span class="n">atomic_t</span> <span class="n">_count</span><span class="p">;</span>        <span class="cm">/* mandatory */</span>
            <span class="n">slobidx_t</span> <span class="n">units</span><span class="p">;</span>        <span class="cm">/* free units left in page */</span>
            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pad</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
            <span class="n">slob_t</span> <span class="o">*</span><span class="n">free</span><span class="p">;</span>           <span class="cm">/* first free slob_t in page */</span>
            <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>  <span class="cm">/* linked list of free pages */</span>
        <span class="p">};</span>

        <span class="k">struct</span> <span class="n">page</span> <span class="n">page</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span></code></pre></figure>

<p>The function <code class="language-plaintext highlighter-rouge">slob_alloc()</code> is SLOB’s main allocation routine
and based on the requested size it walks the appropriate list trying to find if
a page of the list has enough room to accommodate the new object/structure (the
full function is <a href="http://lxr.linux.no/linux+v3.1.6/mm/slob.c#L321">here</a>):</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">slob_alloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">align</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">slob_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">slob_list</span><span class="p">;</span>
    <span class="n">slob_t</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">SLOB_BREAK1</span><span class="p">)</span>
        <span class="n">slob_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">free_slob_small</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">SLOB_BREAK2</span><span class="p">)</span>
        <span class="n">slob_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">free_slob_medium</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">slob_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">free_slob_large</span><span class="p">;</span>

    <span class="p">...</span>

    <span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">slob_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span></code></pre></figure>

<p>I think this is a good place to stop since I don’t want to go
into too many details and because I really look forward to Dan Rosenberg’s talk.</p>

<p>Edit: Dan has published a whitepaper to accompany his talk with all
the details on SLOB exploitation; you can find it
<a href="http://vsecurity.com/download/papers/slob-exploitation.pdf">here</a>.</p>

<h3 id="notes">Notes</h3>

<p>Wrapping this post up, I would like to mention that there are other
slab allocators proposed and implemented for Linux apart from the above three.
<a href="http://thread.gmane.org/gmane.linux.kernel/780475">SLQB</a> and
<a href="http://thread.gmane.org/gmane.linux.kernel.mm/48394/">SLEB</a> come to mind,
however <a href="http://thread.gmane.org/gmane.linux.kernel.mm/48515">as the benevolent dictator has
ruled</a> they are not going
to be included in the mainline Linux kernel tree until one of the existing three
has been removed.</p>

<p>Exploitation techniques and methodologies like the ones I mentioned
in this post can be very helpful when you have a vulnerability you’re
trying to develop a reliable exploit for. However, you should keep in mind that
every vulnerability has its own set of requirements and conditions and
therefore every exploit is a different story/learning experience. Understanding
a bug and actually developing an exploit for it are two very different things.</p>

<p>Thanks to Dan for his comments.</p>

<h3 id="references">References</h3>

<p>The following resources were not linked directly in the discussion,
but would be helpful in case you want to look more into the subject.</p>

<ul>
  <li><a href="http://lxr.linux.no/linux+v3.1.6/">http://lxr.linux.no/linux+v3.1.6/</a></li>
  <li><a href="http://lwn.net/Articles/229984/">http://lwn.net/Articles/229984/</a></li>
  <li><a href="http://lwn.net/Articles/311502/">http://lwn.net/Articles/311502/</a></li>
  <li><a href="http://lwn.net/Articles/229096/">http://lwn.net/Articles/229096/</a></li>
  <li><a href="http://phrack.org/issues.html?issue=66&amp;id=15#article">http://phrack.org/issues.html?issue=66&amp;id=15#article</a></li>
  <li><a href="http://phrack.org/issues.html?issue=66&amp;id=8#article">http://phrack.org/issues.html?issue=66&amp;id=8#article</a></li>
</ul>

</article>

      </main>

      <footer class="footer">
        <small>
          <time datetime="2021-05-11T08:09:49+00:00">2021</time>;
          All rights and lefts reversed alike.
        </small>
      </footer>
    </div>

  

</body></html>