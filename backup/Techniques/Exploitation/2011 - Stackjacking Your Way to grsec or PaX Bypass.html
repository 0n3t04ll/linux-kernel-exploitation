<!DOCTYPE html>
<!-- saved from url=(0084)https://jon.oberheide.org/blog/2011/04/20/stackjacking-your-way-to-grsec-pax-bypass/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="viewport" content="width=device-width,minimum-scale=1">
  <meta name="author" content="Jon Oberheide">
  <meta name="description" content="Jon Oberheide&#39;s website">

  <title>Stackjacking Your Way to grsec/PaX Bypass | Jon Oberheide</title>
 
  
  
    <meta name="ROBOTS" content="INDEX, FOLLOW">

    
    <script async="" src="./2011 - Stackjacking Your Way to grsec or PaX Bypass_files/js"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-P6TVZTTZN2');
    </script>
  

  <link rel="preconnect" href="https://fonts.gstatic.com/">
  <link href="./2011 - Stackjacking Your Way to grsec or PaX Bypass_files/css2" rel="stylesheet">

  <link href="./2011 - Stackjacking Your Way to grsec or PaX Bypass_files/style.css" rel="stylesheet">
  <link href="./2011 - Stackjacking Your Way to grsec or PaX Bypass_files/fontawesome.css" rel="stylesheet">
  <link href="./2011 - Stackjacking Your Way to grsec or PaX Bypass_files/brands.css" rel="stylesheet">

</head>

<body>
  <aside>
    <div id="user_meta">
      <a href="https://jon.oberheide.org/">
        <img src="./2011 - Stackjacking Your Way to grsec or PaX Bypass_files/jono.jpg" alt="logo" id="logo">
      </a>
      <h2><a href="https://jon.oberheide.org/" class="nohover">Jon Oberheide</a></h2>
      
      <div class="social">
        <ul>
	  <li><a href="https://www.linkedin.com/in/jonoberheide">LinkedIn<i class="fab fa-linkedin fa-lg"></i></a></li>
	  <li><a href="https://twitter.com/jonoberheide">Twitter<i class="fab fa-twitter fa-lg"></i></a></li>  
	</ul>
      </div>
      <ul>
      </ul>
    </div>
  </aside>

  <main id="main">

    
    
    <header>
      <p id="header">
      <a href="https://jon.oberheide.org/">Home</a>
      | <a href="https://jon.oberheide.org/blog/">Blog</a>
      | <a href="https://jon.oberheide.org/research/">Research</a>
      | <a href="https://jon.oberheide.org/advisories/">Advisories</a>
      | <a href="https://jon.oberheide.org/projects/">Projects</a>
    </p></header>
    

    <article>
      <div class="article_title">
        <h1>Stackjacking Your Way to grsec/PaX Bypass</h1>
        
        
        
        <h4>Wednesday, April 20, 2011</h4>
        
      </div>

      <div class="article_text">
<p>This April at Hackito Ergo Sum in Paris and Immunity's Infiltrate in
Miami, <a href="http://vulnfactory.org/">Dan Rosenberg</a> and I presented on a
technique to exploit grsecurity/PaX-hardened Linux kernels. Read on for
a brief overview of our presentation and a link to the full slides and
PoC code.</p>
<p><a href="https://jon.oberheide.org/files/stackjacking-infiltrate11.pdf"><img src="./2011 - Stackjacking Your Way to grsec or PaX Bypass_files/title.png" alt="title"></a></p>
<h2 id="the-stackjacking-technique">The Stackjacking Technique</h2>
<p>In our slides, we presented a technique to exploit a
grsecurity/PaX-hardened Linux kernel (eg. GRKERNSEC_HIGH) given the
existence of two exploitation primitives:</p>
<ul>
<li>an arbitrary kernel write; and</li>
<li>a kernel stack memory disclosure</li>
</ul>
<p>To be clear, this attack vector is completelyunnecessary when exploiting
a vanilla Linux kernel, since an arbitrary write ismore than sufficient
to get root, given the vast amount of useful targetinginformation Linux
gives out via /proc, etc. Likewise, the kernel stack memory disclosure
is also unnecessary on vanilla, since there are mucheasier ways of
getting this information. However, due to GRKERNSEC_HIDESYM (which aims
to remove all knownsources of info leakage), PAX_KERNEXEC (which makes
global datastructures with known locations read-only), and other
mitigation features of grsecurity/PaX, effective exploitation is orders
of magnitude harder than a vanilla kernel and took a few interesting
twists.</p>
<p>Our technique can be broken down into three distinct stages:</p>
<ul>
<li>
<p><strong>Stack self-discovery:</strong> We observed that kernel stack memory
disclosures can leak sensitive addresses to userspace. In
particular, if we can leak a pointer TO the kernel stack that
resides ON the kernel stack, we can calculate the base of our own
process' kernel stack: kstack_base = leaked_addr &amp;
\~(THREAD_SIZE-1). We call this technique stack self-discovery.</p>
</li>
<li>
<p><strong>Stack groping:</strong> If our end goal is to read the address of our
process' cred structure and use our write to modify it and escalate
privileges, we need to turn our kleak+kwrite into an arbitrary read.
We discovered two such techniques to do this: (1) the Rosengrope
technique that modifies addr_limit in thread_info metadata stored
at the base of the kstack to allow arbitrary reads from kernel space
to userspace; and (2) the Obergrope technique that manipulates saved
registers within a kernel stack frame that are later popped and used
as the source address for copy_to_user()/put_user() operations.</p>
</li>
<li>
<p><strong>Stack jacking:</strong> After constructing our arbitrary read from a
kleak+kwrite, we read the task_struct address out of thread_info
at the base of the kstack and then read the cred struct address out
of task_struct. Armed with the address of our process' credential
structure and an arbitrary write, we modified our uids/gids/caps to
escalate privileges.</p>
</li>
</ul>
<p>For the full details, please see the presentation materials and PoC
code:</p>
<ul>
<li><a href="https://jon.oberheide.org/files/stackjacking-infiltrate11.pdf">Infiltrate 2011 [PDF]</a></li>
<li><a href="https://jon.oberheide.org/files/stackjacking-hes11.pdf">Hackito Ergo Sum 2011 [PDF]</a></li>
<li><a href="https://github.com/jonoberheide/stackjacking">PoC Code [GITHUB]</a></li>
</ul>
<p><img src="./2011 - Stackjacking Your Way to grsec or PaX Bypass_files/overview1.png" alt="overview"></p>
<h2 id="the-response">The Response</h2>
<p>If you haven't yet read <a href="http://forums.grsecurity.net/viewtopic.php?f=7&amp;t=2596">spender's
response</a> to our
presentation, I recommend doing so. While I'll refrain from commenting
on the political aspects of his post, I'll happily comment on the
technical aspects. The fixes that spender and pipacs have released have
mitigated the particular exploit vectors we used to perform the stack
groping stage of our attack against the grsec/PaX kernel:</p>
<ul>
<li>
<p>The thread_info struct has been moved out from the base of the
kernel stack preventing the Rosengrope technique from being able to
write KERNEL_DS into the addr_limit member.</p>
</li>
<li>
<p>The RANDKSTACK feature, now available on both i386 and amd64,
frustrates the Obergrope technique as the randomization of the
kernel stack pointer on each system call makes writing into a
particular offset in the stack frame unreliable.</p>
</li>
<li>
<p>USERCOPY has been enhanced to protect certain SLUB caches from being
read/written to/from with the userspaceaccessorfuntions. This
prevents our groping technique from being able to easily read
task_struct contents back out to userspace. Thanks to pipacs for
pointing this out!</p>
</li>
</ul>
<p>Props to spender and pipacs for cranking out those fixes as well as a
number of other enhancements. While the latest grsecurity patch
effectively prevents the current vectors we discovered and presented in
our talks at HES and Infiltrate, there are several loose ends I need to
investigate to ensure the fixes address other potential exploitation
vectors.</p>
<p>More on that later...</p>


      </div>
    </article>

    <div id="ending_message">
      <p>Copyright Â© 2021 - Jon Oberheide</p>
    </div>

  </main>



</body></html>