(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{396:function(e,t,i){e.exports=i.p+"assets/img/3.11-4.c7a070f4.png"},405:function(e,t,i){e.exports=i.p+"assets/img/3.1.6f3f3372.png"},406:function(e,t,i){e.exports=i.p+"assets/img/3.2.431dd776.png"},407:function(e,t,i){e.exports=i.p+"assets/img/3.3.d448380e.png"},408:function(e,t,i){e.exports=i.p+"assets/img/3.4.9ac27a8a.png"},409:function(e,t,i){e.exports=i.p+"assets/img/3.5.4860d569.png"},410:function(e,t,i){e.exports=i.p+"assets/img/3.6-1.5a475171.png"},411:function(e,t,i){e.exports=i.p+"assets/img/3.6-2.57bdba23.png"},412:function(e,t,i){e.exports=i.p+"assets/img/3.7.a5e256ae.png"},413:function(e,t,i){e.exports=i.p+"assets/img/3.8.a39c2b50.png"},414:function(e,t,i){e.exports=i.p+"assets/img/3.9.254263fa.png"},415:function(e,t,i){e.exports=i.p+"assets/img/3.10.e6d52d12.png"},416:function(e,t,i){e.exports=i.p+"assets/img/3.11-1.150b534a.png"},417:function(e,t,i){e.exports=i.p+"assets/img/3.11-2.72dc8202.png"},418:function(e,t,i){e.exports=i.p+"assets/img/3.11-3.4a432613.png"},419:function(e,t,i){e.exports=i.p+"assets/img/3.14.e9581a9b.png"},420:function(e,t,i){e.exports=i.p+"assets/img/3.15.edc5adaf.png"},421:function(e,t,i){e.exports=i.p+"assets/img/3.16.c7286d67.png"},422:function(e,t,i){e.exports=i.p+"assets/img/3.17.2286f974.png"},423:function(e,t,i){e.exports=i.p+"assets/img/3.18.438df6f4.png"},424:function(e,t,i){e.exports=i.p+"assets/img/4.1-1.93a74781.png"},425:function(e,t,i){e.exports=i.p+"assets/img/4.1-2.c624794d.png"},426:function(e,t,i){e.exports=i.p+"assets/img/4.2.6591b219.png"},427:function(e,t,i){e.exports=i.p+"assets/img/4.3.035099f6.png"},428:function(e,t,i){e.exports=i.p+"assets/img/4.4.1d3201e6.png"},493:function(e,t,i){"use strict";i.r(t);var r=i(15),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"ebpf-background"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ebpf-background"}},[e._v("#")]),e._v(" eBPF Background")]),e._v(" "),r("p",[r("em",[e._v("eBPF(Enhanced Berkeley Packet Filter)")]),e._v(" is an in-kernel virtual machine that is used as an interface to data link layers, allowing packets on the network to be filtered by rules. A userspace process will supply a filter program to specify which packets it wants to receive and eBPF will return packets that pass its filtering process.")]),e._v(" "),r("p",[e._v("Each BPF memory instructions are made up of 64 bits (8 bytes). 8 bits for opcode, 4 bits for source register, 4 bits for destination register, 16 bits for offset and 32 bits for immediate value.")]),e._v(" "),r("p",[e._v("eBPF consists of 10 64-bit register known as "),r("code",[e._v("r0 - r10")]),e._v(". "),r("code",[e._v("r0")]),e._v("  stores the return value, "),r("code",[e._v("r1")]),e._v(" to "),r("code",[e._v("r5")]),e._v(" is reserved for arguments, "),r("code",[e._v("r6")]),e._v(" to "),r("code",[e._v("r9")]),e._v(" is reserved for storing callee saved registers and "),r("code",[e._v("r10")]),e._v(" stores read-only frame pointer.")]),e._v(" "),r("p",[e._v("In order to keep state between invocations of eBPF programs, allow sharing data between eBPF kernel programs and also between kernel and user-space applications, eBPF utilizes different types of maps in the form of key-value pair. Two bpf functions, "),r("code",[e._v("BPF_MAP_LOOKUP_ELEM")]),e._v(" and "),r("code",[e._v("BPF_MAP_UPDATE_ELEM")]),e._v(" , are provided to facilitate sharing of data between programs.")]),e._v(" "),r("h2",{attrs:{id:"overview"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("CVSS v3 Score: 7.8\nConfidentiality: High\nIntegrity: High\nAuthority: High\n")])])]),r("p",[e._v("The vulnerability is caused by a sign extension from a signed 32-bit integer to an unsigned 64-bit integer, bypassing eBPF verifier and leading to local privilege escalation.")]),e._v(" "),r("p",[e._v("Before each of the BPF program runs, two passes of verifications are conducted to ensure its correctness. The first pass "),r("code",[e._v("check_cfg()")]),e._v(" ensures the code is loop-free using depth-first search. The second pass "),r("code",[e._v("do_check()")]),e._v(" runs a static analysis to emulate the execution of all possible paths derived from the first instruction. The program will be terminated if any invalid instruction or memory violation is found.")]),e._v(" "),r("p",[e._v("In the exploit, a set of BPF instructions are carefully crafted to bypass this filtering process through an unintentional sign extension from 32 bits to 64 bits. As a result, a few lines of malicious code attached managed to execute in the kernel space, resulting in privilege escalation.")]),e._v(" "),r("p",[e._v("This vulnerability allows attacker to have full control of the system with root access. The low complexity of the attack and low privileges required to perform this exploit makes it a high priority to fix.")]),e._v(" "),r("h2",{attrs:{id:"code-analysis"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#code-analysis"}},[e._v("#")]),e._v(" Code Analysis")]),e._v(" "),r("h3",{attrs:{id:"_1-ebpf-instruction-set"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-ebpf-instruction-set"}},[e._v("#")]),e._v(" 1. eBPF Instruction Set")]),e._v(" "),r("p",[e._v("User-supplied eBPF programs are written in a special machine language that runs on the eBPF virtual machine. The VM follows the generic Reduced Instruction Set Computer(RISC) design and has 10 general purpose registers and several named registers.")]),e._v(" "),r("img",{attrs:{src:i(405),width:"400",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("p",[r("em",[e._v("fig 3.1 Register Definitions in the eBPF VM, from /kernel/bpf/core.c")])]),e._v(" "),r("p",[e._v("Each BPF instruction on x64 platform is of 64-bit long. They are internally represented by a bpf_insn struct which contains the following fields (fig 3.2). Given the limited size of the opcode field, instructions are categorised into 8 classes(fig 3.3). For instance, "),r("code",[e._v("BPF_MOV")]),e._v(" shares the same opcode with "),r("code",[e._v("BPF_ALU64")]),e._v(" and "),r("code",[e._v("BPF_X")]),e._v(" by definition(fig 3.4).")]),e._v(" "),r("img",{attrs:{src:i(406),width:"450",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("p",[r("em",[e._v("fig 3.2 Structure of a BPF instruction, from /include/uapi/linux/bpf.h")])]),e._v(" "),r("img",{attrs:{src:i(407),width:"350",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("p",[r("em",[e._v("fig 3.3 BPF instruction classes, from /include/uapi/linux/bpf_common.h")])]),e._v(" "),r("img",{attrs:{src:i(408),width:"450",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("p",[r("em",[e._v("fig 3.4 Definition of BPF_MOV64_REG, from /include/linux/filter.h")])]),e._v(" "),r("h3",{attrs:{id:"_2-source-code-analysis"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-source-code-analysis"}},[e._v("#")]),e._v(" 2. Source Code Analysis")]),e._v(" "),r("p",[e._v("The exploit of CVE-2017-16995 boils down to a mere 40 eBPF instructions. We will be focusing on the first two instructions because they are mainly used to bypass the verification mechanism of eBPF.")]),e._v(" "),r("p",[r("img",{attrs:{src:i(409),alt:"Kernel-eBPF/3.5.png"}}),e._v(" "),r("em",[e._v("fig 3.5 eBPF code in the exploit of CVE-2017-16995 with annotation")])]),e._v(" "),r("p",[e._v("As mentioned before, eBPF performs a two round verification before actually running the user-supplied code. For this CVE we are only interested in second round check which is done in the "),r("code",[e._v("do_check()")]),e._v(" function. When the first instruction "),r("code",[e._v("BEF_MOV32_IMM")]),e._v(" is evaluated, it is passed to "),r("code",[e._v("check_alu_op()")]),e._v(" to process since "),r("code",[e._v("BEF_MOV32_IMM")]),e._v(" belongs to the "),r("code",[e._v("BPF_ALU")]),e._v(" group (fig 3.6). The immediate value "),r("code",[e._v("(0xFFFFFFFF)")]),e._v(" from the first instruction is then stored in the register "),r("code",[e._v("BPF_REG_9")]),e._v(" (fig 3.7).")]),e._v(" "),r("img",{attrs:{src:i(410),width:"500",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("img",{attrs:{src:i(411),width:"500",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("p",[r("em",[e._v("fig 3.6 do_check(), from /kernel/bpf/verifier.c")])]),e._v(" "),r("img",{attrs:{src:i(412),width:"500",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("p",[r("em",[e._v("fig 3.7 check_alu_op() from /kernel/bpf/verifier.c")])]),e._v(" "),r("p",[e._v("To make things clearer, we can take a look at how registers in eBPF are represented. The registered are stored in an array of structs named "),r("code",[e._v("reg_state")]),e._v(". The immediate value "),r("code",[e._v("0xFFFFFFFF")]),e._v(" is stored in a 64-bit int "),r("code",[e._v("imm")]),e._v(", which becomes "),r("code",[e._v("0x00000000FFFFFFFF")]),e._v(" in memory.")]),e._v(" "),r("img",{attrs:{src:i(413),width:"500",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("p",[r("em",[e._v("fig 3.8 struct reg_state, from /kernel/bpf/verifier.c")])]),e._v(" "),r("p",[e._v("Now the second instruction "),r("code",[e._v("BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2)")]),e._v(" is evaluated. The instruction compares the immediate value "),r("code",[e._v("0xFFFFFFFF")]),e._v(" with the content inside "),r("code",[e._v("BPF_REG_9")]),e._v(", and jump to the place that is 2 instructions away if the two values do not equal.")]),e._v(" "),r("p",[e._v("This time "),r("code",[e._v("do_check()")]),e._v(" calls "),r("code",[e._v("check_cond_jmp_op()")]),e._v(" to check for both type and value in dst_reg, which is "),r("code",[e._v("BPF_REG_9")]),e._v(" in this case (fig. 3.9). Clearly "),r("code",[e._v("(int)0x00000000FFFFFFFF = (s32)0xFFFFFFFF")]),e._v(" and "),r("code",[e._v("opcode != JEQ")]),e._v(", it falls under the case "),r("code",[e._v("imm != imm")]),e._v(" and the jump is not performed. The program continues until it hits "),r("code",[e._v("BPF_EXIT_INST()")]),e._v(" on line 4 and exit.")]),e._v(" "),r("img",{attrs:{src:i(414),width:"500",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("p",[r("em",[e._v("fig 3.9 check_cond_jmp_op(), from /kernel/bpf/verifier.c")])]),e._v(" "),r("p",[e._v("Usually, the eBPF verifier uses a stack to keep tracking branches that have not been evaluated and revise them later(fig 3.9, line 1236). However, since the integer comparison on line 1220 always equals, the code continue from line 1232 and the other branch is never pushed to the stack.")]),e._v(" "),r("p",[e._v("When the verifier evaluate "),r("code",[e._v("BPF_EXIT")]),e._v(", it tries to pop all uncheck branches from the stack(fig 3.10). The verification process will stop here since it knows the stack is empty. As a result, only the first 4 instructions in the exploit are verified while the rest 36 remain unchecked.")]),e._v(" "),r("img",{attrs:{src:i(415),width:"500",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("p",[r("em",[e._v("Fig 3.10 Evaluation of instruction BPF_EXIT, from /kernel/bpf/verifier.c")])]),e._v(" "),r("img",{attrs:{src:i(416),width:"300",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("br"),e._v(" "),r("img",{attrs:{src:i(417),width:"500",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("br"),e._v(" "),r("img",{attrs:{src:i(418),width:"300",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("br"),e._v(" "),r("img",{attrs:{src:i(396),width:"400",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("p",[r("em",[e._v("Fig 3.11 regs definition and __bpf_prog_run(), from /kernel/bpf/core.c")])]),e._v(" "),r("p",[e._v("After verification, eBPF runs the program through "),r("code",[e._v("__bpf_prog_run()")]),e._v(" in "),r("code",[e._v("core.c")]),e._v(" where eBPF instructions are translated to machine instructions using a jump table. Notice the type of regs here is u64. Using the same first two instructions in "),r("code",[e._v("exploit.c")]),e._v(", the sign extension occurs when we evaluate the first instruction "),r("code",[e._v("BPF_MOV32_IMM")]),e._v(". More specifically, it happens when we run "),r("code",[e._v("DST = (u32)IMM")]),e._v(" in line 350:")]),e._v(" "),r("ul",[r("li",[e._v("On the right hand side, "),r("code",[e._v("IMM")]),e._v(" is equivalent to "),r("code",[e._v("insn->imm")]),e._v(". imm is a signed 32-bit integer defined in "),r("code",[e._v("bpf_insn")]),e._v("(fig 3.2). Here "),r("code",[e._v("IMM = 0xFFFFFFFF")]),e._v(". We cast it to an unsigned 32-bit integer which is still "),r("code",[e._v("0xFFFFFFFF")]),e._v(".")]),e._v(" "),r("li",[e._v("On the left hand side, "),r("code",[e._v("DST")]),e._v(" is defined as "),r("code",[e._v("regs[insn->dst_reg]")]),e._v(", which is an unsigned 64-bit integer. When we let "),r("code",[e._v("DST = (u32) IMM")]),e._v(", sign extension applies and "),r("code",[e._v("DST")]),e._v(" becomes "),r("code",[e._v("0xFFFFFFFFFFFFFFFF")]),e._v(".")])]),e._v(" "),r("p",[e._v("Now if we evaluate the second instruction "),r("code",[e._v("JMP_JNE_K")]),e._v(", "),r("code",[e._v("DST")]),e._v(" becomes not equal to "),r("code",[e._v("IMM")]),e._v(" since "),r("code",[e._v("0xFFFFFFFFFFFFFFFF != 0xFFFFFFFF")]),e._v(". This is different from what we have seen in the verifier. As a result, the jump is taken and the program continue to run the malicious instructions from line 5 onwards.")]),e._v(" "),r("h3",{attrs:{id:"_3-explanation-for-the-exploit"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-explanation-for-the-exploit"}},[e._v("#")]),e._v(" 3. Explanation for the Exploit")]),e._v(" "),r("img",{attrs:{src:i(396),width:"500",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("p",[r("em",[e._v("Fig 3.13 Data flow in the exploit")])]),e._v(" "),r("p",[e._v("As mentioned earlier, eBPF uses shared memory for the kernel program to communicate with user applications. If we think about this carefully, this could be a potential channel for us to pass instructions to the kernel and to sneak kernel information to the outside. We shall soon see how the exploit uses this eBPF map to complete arbitrary kernel read/write in a short while.")]),e._v(" "),r("p",[e._v("To put it simply, the exploit comprises two parts: an eBPF filter programming running in the kernel and a helper program running in the user space. The attack can be generalised into the following steps:")]),e._v(" "),r("ul",[r("li",[r("p",[r("code",[e._v("exploit.c")]),e._v(" creates a eBPF map of size 3 using "),r("code",[e._v("bpf_creat_map()")]),e._v(" and loads the eBPF instructions "),r("code",[e._v("char *prog")]),e._v(" into the kernel using "),r("code",[e._v("bpf_prog_load()")]),e._v(".")])]),e._v(" "),r("li",[r("p",[e._v("The eBPF instructions serve as a agent which takes commands from the map and perform read/write in the kernel space accordingly. The layout of the map is defined as follows:")]),e._v(" "),r("table",[r("thead",[r("tr",[r("th",[e._v("Index of eBPF map")]),e._v(" "),r("th",[e._v("To read from kernel")]),e._v(" "),r("th",[e._v("To get the current frame pointer")]),e._v(" "),r("th",[e._v("To write to kernel")])])]),e._v(" "),r("tbody",[r("tr",[r("td",[e._v("0 (opcode)")]),e._v(" "),r("td",[e._v("0")]),e._v(" "),r("td",[e._v("1")]),e._v(" "),r("td",[e._v("2")])]),e._v(" "),r("tr",[r("td",[e._v("1 (address)")]),e._v(" "),r("td",[e._v("Target address")]),e._v(" "),r("td",[e._v("0")]),e._v(" "),r("td",[e._v("Target address")])]),e._v(" "),r("tr",[r("td",[e._v("2  (value)")]),e._v(" "),r("td",[e._v("(Content at the address)")]),e._v(" "),r("td",[e._v("0")]),e._v(" "),r("td",[e._v("0")])])])])]),e._v(" "),r("li",[r("p",[e._v("To trigger a read/write operation, "),r("code",[e._v("exploit.c")]),e._v(" firstly store the parameters in the map using "),r("code",[e._v("bpf_update_elem()")]),e._v(". It will then call "),r("code",[e._v("writemsg()")]),e._v(" which sends a few dummy packets to the socket and force the eBPF program to run.")]),e._v(" "),r("img",{attrs:{src:i(419),width:"400",align:"left"}})])]),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("p",[r("em",[e._v("Fig 3.14 __update_elem() from exploit.c")])]),e._v(" "),r("ul",[r("li",[r("p",[e._v("Given the helper tools above, now we can get the address of the current  frame pointer by instructing the BPF program to perform opcode 1. The return value is stored in the map at index 2.")]),e._v(" "),r("img",{attrs:{src:i(420),width:"400",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("p",[r("em",[e._v("Fig 3.15 __get_fp() from exploit.c")])])]),e._v(" "),r("li",[r("p",[e._v("After obtaining the frame pointer, it will be used to find the pointer of  "),r("code",[e._v("task_struct")]),e._v(" in the kernel stack(fig 3.16), which is inside a struct named "),r("code",[e._v("thread_info")]),e._v(". Since the stack size is 8KB, masking out the least significant 13 bits will give the address of thread_info. Hence, the value read from the address of "),r("code",[e._v("thread_info")]),e._v(" will be the address for "),r("code",[e._v("task_struct *task")]),e._v(".")]),e._v(" "),r("img",{attrs:{src:i(421),width:"400",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("p",[r("em",[e._v("Fig. 3.16 pwn() from exploit.c")])]),e._v(" "),r("img",{attrs:{src:i(422),width:"500",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("p",[r("em",[e._v("Fig 3.17 struct thread_info, from /arch/ia64/alpha/include/asm/thread_info.h")])])]),e._v(" "),r("li",[r("p",[e._v("Using the address of "),r("code",[e._v("task_struct")]),e._v(", we will be able to obtain the address of struct cred base as it is part of "),r("code",[e._v("task_struct")]),e._v(". In the struct cred, there will be a "),r("code",[e._v("uid_t uid")]),e._v(" which can be set to "),r("code",[e._v("0")]),e._v(" base on the offset from the address of "),r("code",[e._v("struct cred")]),e._v(". When this "),r("code",[e._v("uid")]),e._v(" is set to "),r("code",[e._v("0")]),e._v(", the process will be able to run its program with root privileges.")]),e._v(" "),r("img",{attrs:{src:i(423),width:"500",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("p",[r("em",[e._v("Fig 3.18 pwn() from exploit.c")])])])]),e._v(" "),r("h2",{attrs:{id:"the-patch"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#the-patch"}},[e._v("#")]),e._v(" The Patch")]),e._v(" "),r("h3",{attrs:{id:"_1-official-kernel-patch"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-official-kernel-patch"}},[e._v("#")]),e._v(" 1. Official Kernel Patch")]),e._v(" "),r("p",[r("img",{attrs:{src:i(424),alt:"Kernel-eBPF/4.1-1.png"}})]),e._v(" "),r("p",[r("img",{attrs:{src:i(425),alt:"Kernel-eBPF/4.1-2.png"}})]),e._v(" "),r("p",[r("em",[e._v("Fig4.1. Patch on verifier.c")])]),e._v(" "),r("p",[e._v("To resolve the inconsistent execution paths between the verifier and "),r("code",[e._v("__bpf_prog_run()")]),e._v(", the patch forces to convert any immediate in "),r("code",[e._v("BPF_MOV")]),e._v(" or "),r("code",[e._v("BPF_X")]),e._v(" to the type of u64 at the verification stage. As such, malicious payload that tries to read or write to kernel memory space will always be detected before it runs.")]),e._v(" "),r("p",[e._v("More specifically, when the verifier reads the s32 immediate value from the instruction struct i.e. "),r("code",[e._v("insn->imm")]),e._v(", the value is firstly casted to "),r("code",[e._v("u32")]),e._v(" and then passed to "),r("code",[e._v("__mark_reg_known()")]),e._v(" as an "),r("code",[e._v("u64")]),e._v(" parameter. The sign-extended "),r("code",[e._v("u64")]),e._v(" immediate value is stored in its various possible sign/unsigned forms in the register. This ensures all conditional checks will use the sign-extended form of imm for comparison.")]),e._v(" "),r("h3",{attrs:{id:"_2-our-implementation"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-our-implementation"}},[e._v("#")]),e._v(" 2. Our Implementation")]),e._v(" "),r("p",[e._v("Given the inspiration from the official patch,  we also developed our own implementation which is simpler but still effective.")]),e._v(" "),r("img",{attrs:{src:i(426),width:"500",align:"left"}}),e._v(" "),r("br",{attrs:{clear:"left"}}),e._v(" "),r("p",[r("em",[e._v("Fig 4.2  Patch implementation (Casting immediate value to unsigned 64 bits)")])]),e._v(" "),r("p",[e._v("From the source analysis, the vulnerability of the program is due to the sign extension of the  immediate value failing the comparison of the value stored in the register and immediate value. Hence, in order to prevent this bug from being exploited, we ensure that any 32 bit signed immediate value is casted to unsigned 64 bit immediate value before storing and using it for comparison as shown in Fig 4.2. With the implemented patch, the immediate value will always be sign extended when it is evaluated in the verifier.")]),e._v(" "),r("p",[r("img",{attrs:{src:i(427),alt:"Kernel-eBPF/4.3.png"}})]),e._v(" "),r("p",[r("em",[e._v("Fig 4.3 Exploit runs successfully before the patch")])]),e._v(" "),r("p",[r("img",{attrs:{src:i(428),alt:"Kernel-eBPF/4.4.png"}})]),e._v(" "),r("p",[r("em",[e._v("Fig 4.4  Exploit.c Demo with our patch implementation")])]),e._v(" "),r("p",[e._v("To demonstrate, before applying the patch, the exploit was done successfully after running the exploit.c(fig 4.3). This can be done as the kernel address for the frame pointer is leaked to find the top stack pointer "),r("code",[e._v("thread_info")]),e._v(". The "),r("code",[e._v("task_struct")]),e._v(" address ("),r("code",[e._v("0xffff880074c4c600")]),e._v(") is found from an offset from the top stack pointer while the address of the "),r("code",[e._v("uidptr")]),e._v(" ("),r("code",[e._v("0xffff88001d5b0604")]),e._v(") can be found from an offset from the struct cred which is within the "),r("code",[e._v("task_struct")]),e._v(". After calling the "),r("code",[e._v("id")]),e._v(" command, the uid has been successfully set to 0, resulting in a local privilege escalation.")]),e._v(" "),r("p",[e._v("After re-compiling the kernel with our patch implementation, another attempt to execute the "),r("code",[e._v("exploit.c")]),e._v(" was made. Instead of obtaining the root shell, an error "),r("code",[e._v("error: Permission denied")]),e._v(" as shown in Fig 4.4 was thrown demonstrating that the exploit has failed. This is because the verifier now compares the sign-extended value "),r("code",[e._v("0xFFFFFFFFFFFFFFFF")]),e._v(" in "),r("code",[e._v("BPF_REG_9")]),e._v(" with the immediate value "),r("code",[e._v("0xFFFFFFFF")]),e._v(" when verifying the second eBPF instruction "),r("code",[e._v("BPF_JMP_IMM")]),e._v(". This results in a jump on not equal and the rest of the malicious eBPF payload is checked against by the verifier. Hence, the exploit will be effectively stopped from running.")]),e._v(" "),r("h2",{attrs:{id:"references"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://man7.org/linux/man-pages/man2/bpf.2.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Man page of bpf()"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/iovisor/bpf-docs/blob/master/eBPF.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Unofficial eBPF Specification"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://elixir.bootlin.com/linux/v4.4.31/source/kernel/bpf",target:"_blank",rel:"noopener noreferrer"}},[e._v("BFP Source Code in Linux Kernel"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://people.canonical.com/~ubuntu-security/cve/2017/CVE-2017-16995.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("CVE-2017-16995 Patch Status on Ubuntu"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/iBearcat/CVE-2017-16995/blob/master/exploit.c",target:"_blank",rel:"noopener noreferrer"}},[e._v("Exploit of CVE-2017-16995"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://wiki.ubuntu.com/Kernel/BuildYourOwnKernel",target:"_blank",rel:"noopener noreferrer"}},[e._v("Building Ubuntu Kernel"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://dangokyo.me/2018/05/24/analysis-on-cve-2017-16995/",target:"_blank",rel:"noopener noreferrer"}},[e._v("dangokyo.me - Analysis Report of CVE-2017-16995"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://xz.aliyun.com/t/2212",target:"_blank",rel:"noopener noreferrer"}},[e._v("xz.aliyun.com - Analysis Report of CVE-2017-16995"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=s.exports}}]);