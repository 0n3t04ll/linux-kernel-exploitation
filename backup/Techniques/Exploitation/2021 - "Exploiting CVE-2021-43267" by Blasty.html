<!DOCTYPE html>
<html lang="en-us"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Exploiting CVE-2021-43267 - Haxxin</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="The HTML5 Herald">
<meta name="author" content="Peter Geissler"><meta property="og:title" content="Exploiting CVE-2021-43267">
<meta property="og:description" content="Exploiting a heap overflow in the TIPC subsystem of the Linux kernel">
<meta property="og:type" content="article">
<meta property="og:url" content="https://haxx.in/posts/pwning-tipc/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-11-24T18:06:18+01:00">
<meta property="article:modified_time" content="2021-11-24T18:06:18+01:00">


<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Exploiting CVE-2021-43267">
<meta name="twitter:description" content="Exploiting a heap overflow in the TIPC subsystem of the Linux kernel">

<meta name="generator" content="Hugo 0.89.4">
    

  <link rel="stylesheet" href="2021%20-%20%22Exploiting%20CVE-2021-43267%22%20by%20Blasty_files/normalize.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous">
  <link rel="stylesheet" href="2021%20-%20%22Exploiting%20CVE-2021-43267%22%20by%20Blasty_files/all.css">
  
    <link rel="stylesheet" href="2021%20-%20%22Exploiting%20CVE-2021-43267%22%20by%20Blasty_files/css.css">
  
  
  <link rel="stylesheet" type="text/css" href="2021%20-%20%22Exploiting%20CVE-2021-43267%22%20by%20Blasty_files/styles.css"><link disabled="" id="dark-mode-theme" rel="stylesheet" href="2021%20-%20%22Exploiting%20CVE-2021-43267%22%20by%20Blasty_files/dark.css">
</head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="https://haxx.in/">Haxxin</a>
            </h1>

      <ul id="social-media">
        <i id="dark-mode-toggle" class="fas fa-moon" alt="eyebleach"></i>
             <li>
               <a href="https://twitter.com/bl4sty" title="Twitter">
               <i class="fab fa-twitter fa-lg"></i>
               </a>
             </li>
      </ul>
      
      <p><em>computers &amp; stuff</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://haxx.in/about/">
                <i class="fa-li fa  fa-lg"></i><span>about</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://haxx.in/exploits/">
                <i class="fa-li fa  fa-lg"></i><span>exploits</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<article>

    <h1>Exploiting CVE-2021-43267</h1>

    
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2021-11-24T18:06:18+01:00">Nov 24, 2021</time>
        </li>
        
        

        

        <li>11 minutes read</li>
    </ul>
</aside>

    

    
<div class="featured_image">
    <a href="https://haxx.in/posts/pwning-tipc/" title="Exploiting CVE-2021-43267">
        <img src="">
    </a>
</div>



    <h2 id="introduction">Introduction</h2>
<p>A couple of weeks ago a heap overflow vulnerability in the TIPC subsystem of the
Linux kernel was disclosed by Max van Amerongen (<a href="https://twitter.com/maxpl0it">@maxpl0it</a>).
He posted a detailed write up about the bug on the <a href="https://www.sentinelone.com/labs/tipc-remote-linux-kernel-heap-overflow-allows-arbitrary-code-execution/">SentinelLabs website</a>.</p>
<p>It’s a pretty clear cut heap buffer overflow where we control the size and data of the overflow.
I decided I wanted to embark on a small exploit development adventure to see how hard it would be to exploit this bug
on a kernel with common mitigations in place (SMEP/SMAP/KASLR/KPTI).</p>
<p>If you came here to find novel new kernel exploitation strategies, you picked the
wrong blogpost, sorry!</p>
<h2 id="tipc">TIPC?</h2>
<p>To quote the <a href="http://tipc.sourceforge.net/intro.html">TIPC webpage</a>:</p>
<blockquote>
<p>Have you ever wished you had the convenience of Unix Domain Sockets 
even when transmitting data between cluster nodes? Where you yourself 
determine the addresses you want to bind to and use? Where you don’t 
have to perform DNS lookups and worry about IP addresses? Where you 
don’t have to start timers to monitor the continuous existence of peer 
sockets? And yet without the downsides of that socket type, such as the 
risk of lingering inodes?</p>
</blockquote>
<p>Well.. I have not. But then again, I’m just an opportunistic vulndev person.</p>
<blockquote>
<p>Welcome to the <strong>Transparent Inter Process Communication</strong> service, TIPC in short, which gives you all of this, and a lot more.</p>
</blockquote>
<p>Thanks for having me.</p>
<h2 id="how-to-tipc-over-udp">How to tipc-over-udp?</h2>
<p>In order to use the TIPC support provided by the Linux kernel you’ll have to compile
a kernel with TIPC enabled, or load the TIPC module which ships with many popular
distributions. To easily interface with the TIPC subsystem you can use the <code>tipc</code> utility
which is part of <code>iproute2</code>.</p>
<p>For example, to list all the node links you can issue <code>tipc link list</code>. We want to
talk to the TIPC subsystem over UDP, and for that we’ll have to enable the UDP bearer
media. This can be done using <code>tipc bearer enable media udp name &lt;NAME&gt; localip &lt;SOMELOCALIP&gt;</code>.</p>
<p>Under the hood the <code>tipc</code> userland utility uses netlink messages (using address family
<code>AF_TIPC</code>) to do its thing. Interestingly enough, these netlink messages can be sent
by any unprivileged user. So even if there’s no existing TIPC configuration in place,
this bug can still be exploited.</p>
<h2 id="how-to-reach-the-vulnerable-code-path">How to reach the vulnerable code path?</h2>
<p>So now we know how to <em>enable</em> the UDP listener for TIPC, how do we go about actually
reaching the vulnerable code? We’ll have to present ourselves as a valid <code>node</code> and
establish a <code>link</code> before we can trigger the <code>MSG_CRYPTO</code> code path. We can find a
<a href="http://tipc.sourceforge.net/protocol.html">protocol specification</a> on the TIPC webpage that details
everything about transport, addressing schemes, fragmentation and so on.</p>
<p>That’s a lot of really dry stuff though. I made some PCAPs of a tipc-over-udp
session setup and with some hand-waving and reading the kernel source narrowed
it down to a few packets we need to emit before we can start sending the messages
we are interested in.</p>
<p>In short, a typical TIPC datagram starts with a header, that consist out of at least
six 32bit words in big endian byte order. Those are typically referred to as <code>w0</code> through <code>w5</code>.
This header is (optionally) followed by a payload. <code>w0</code> encodes the TIPC version,
header size, payload size, the message ‘protocol’. There’s also a flag which
indicates whether this is a sequential message or not.</p>
<p><code>w1</code> encodes (among other things) a protocol message type specific to the protocol.</p>
<p>The header also specifies a <code>node_id</code> in <code>w3</code> which is a unique identifier a node
includes in every packet. Typically, nodes encode their IPv4 address to be their
<code>node_id</code>.</p>
<p>A quick way to learn about the various bit fields of the
header format is by consulting <a href="https://elixir.bootlin.com/linux/latest/source/net/tipc/msg.h"><code>net/tipc/msg.h</code></a>.</p>
<p>To establish a valid node link we send three packets:</p>
<pre tabindex="0"><code>protocol: LINK_CONFIG   -&gt; message type: DSC_REQ_MSG
protocol: LINK_PROTOCOL -&gt; message type: RESET_MSG
protocol: LINK_PROTOCOL -&gt; message type: STATE_MSG
</code></pre><p>The <code>LINK_CONFIG</code> packet will advertise ourselves. The link is then reset with the
<code>LINK_PROTOCOL</code> packet that has the <code>RESET_MSG</code> message type. Finally, the link
is brought up by sending a <code>LINK_PROTOCOL</code> packet with the <code>STATE_MSG</code> message type.</p>
<p>Now we are actually in a state where we can send <code>MSG_CRYPTO</code> TIPC packets and
start playing with the heap overflow bug.</p>
<h2 id="corrupting-some-memories">Corrupting some memories</h2>
<p>A <code>MSG_CRYPTO</code> TIPC packet payload looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00a8c8">struct</span> <span style="color:#111">tipc_aead_key</span> <span style="color:#111">{</span>
    <span style="color:#00a8c8">char</span> <span style="color:#111">alg_name</span><span style="color:#111">[</span><span style="color:#111">TIPC_AEAD_ALG_NAME</span><span style="color:#111">];</span>
    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">int</span> <span style="color:#111">keylen</span><span style="color:#111">;</span>
    <span style="color:#00a8c8">char</span> <span style="color:#111">key</span><span style="color:#111">[];</span>
<span style="color:#111">};</span>
</code></pre></div><p>As detailed in the SentinelLabs write up, the length of the <code>kmalloc</code>’d heap buffer is determined
by taking the payload size <strong>from the TIPC packet header</strong>. After which the key is <code>memcpy</code>’d
into this buffer with the length specified in the <code>MSG_CRYPTO</code> structure.</p>
<p>At first you’d think that means the overflow uses uncontrolled data.. but you can
send TIPC packets that lie about the actual length of the payload
(by making <code>tipc_hdr.payload_size</code> smaller than the actual payload size).
This passes all the checks and reaches the memcpy without the remainder of the
payload being discarded, giving us full control over the overflowed data. Great!</p>
<p>The length specified in <code>keylen</code> will be passed to <code>kmalloc</code> directly.</p>
<p>Smaller (up to 8KiB) heap objects allocated by the kernel using <code>kmalloc</code> end up in
caches that are grouped by size (powers of two). You can have a peep at <code>/proc/slabinfo</code>
and look at the entries prefixed by <code>kmalloc-</code> to get an overview of the general purpose
object cache sizes.</p>
<p>Since we can control the size of the heap buffer that will be allocated and overflowed,
we can pick in which of these caches our object ends up. This is a great ability, as it
allows us to overflow into adjacent kernel objects of a similar size!</p>
<h2 id="defeating-kaslr">Defeating KASLR</h2>
<p>If we want to do any kind of control flow hijacking we’re going to need an information leak
to disclose (at least) some kernel text/data addresses so we can deduce the randomized
base address.</p>
<p>It would be great if we could find some kernel objects that contain a pointer/offset/length
field early on in their structure, and that can be made to return data back to userland somehow.</p>
<p>While googling I stumbled on this <a href="https://dl.acm.org/doi/10.1145/3372297.3423353">cool paper</a>
by some Pennsylvania State University students who dubbed objects with such properties “Elastic Objects”.
Their research on the subject is quite exhaustive and covers Linux, BSD and XNU.. I definitley recommend
checking it out.</p>
<p>Since we can pick arbitrarily sized allocations, we’re free to target any convenient
elastic object. I went with <code>msg_msg</code>, which is <a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html">popular choice</a> amongst fellow exploitdevs. ;-)</p>
<p>The structure of a <code>msg_msg</code> as defined in <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/msg.h"><code>include/linux/msg.h</code></a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* one msg_msg structure for each message */</span>
<span style="color:#00a8c8">struct</span> <span style="color:#111">msg_msg</span> <span style="color:#111">{</span>
	<span style="color:#00a8c8">struct</span> <span style="color:#111">list_head</span> <span style="color:#111">m_list</span><span style="color:#111">;</span>
	<span style="color:#00a8c8">long</span> <span style="color:#111">m_type</span><span style="color:#111">;</span>
	<span style="color:#111">size_t</span> <span style="color:#111">m_ts</span><span style="color:#111">;</span>		<span style="color:#75715e">/* message text size */</span>
	<span style="color:#00a8c8">struct</span> <span style="color:#111">msg_msgseg</span> <span style="color:#f92672">*</span><span style="color:#111">next</span><span style="color:#111">;</span>
	<span style="color:#00a8c8">void</span> <span style="color:#f92672">*</span><span style="color:#111">security</span><span style="color:#111">;</span>
	<span style="color:#75715e">/* the actual message follows immediately */</span>
<span style="color:#111">};</span>
</code></pre></div><p>You can easily allocate <code>msg_msg</code> objects using the <code>msgsnd</code> system call. And
they can be freed again using the <code>msgrcv</code> system call. These system calls are
not to be confused with the <code>sendmsg</code> and <code>recvmsg</code> system calls btw, great naming scheme!</p>
<p>If we corrupt the <code>m_ts</code> field of a <code>msg_msg</code> object we can extend its size and get a relative kernel heap out-of-bounds
read back to userland when retrieving the message from the queue again using the <code>msgrcv</code>
system call.</p>
<p>A small problem with this is that overwriting the <code>m_ts</code> field also requires
trampling over the <code>struct list_head</code> members (a prev/next pointer). When <code>msgrcv</code>
is called and a matching message is found, it wants to unlink it from the linked list..
but since we’re still in the information leak stage of the exploit, we can’t put any legitimate/meaningful
pointers in there. Luckily, there’s a flag you can pass to <code>msgrcv</code> called <code>MSG_COPY</code>, which
will make a copy of the message and <em>not</em> unlink the original one, avoiding a bad pointer dereference.</p>
<p>So the basic strategy is to line up three objects like this:</p>
<pre tabindex="0"><code>msg_msg
msg_msg
some_interesting_object
</code></pre><p>and proceed to free the first <code>msg_msg</code> object and allocate the <code>MSG_CRYPTO</code> key
buffer into the hole it left behind. We corrupt the adjacent <code>msg_msg</code> using the
buffer overflow and subsequently leak data from <code>some_interesting_object</code> using
the <code>msgrcv</code> system call with the <code>MSG_COPY</code> flag set.</p>
<p>I chose to leak the data of <code>tty_struct</code>, which can easily be allocated by open()‘ing
<code>/dev/ptmx</code>. This <code>tty_struct</code> holds all kinds of state related to the tty, and
starts off like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00a8c8">struct</span> <span style="color:#111">tty_struct</span> <span style="color:#111">{</span>
    <span style="color:#00a8c8">int</span> <span style="color:#111">magic</span><span style="color:#111">;</span>
    <span style="color:#00a8c8">struct</span> <span style="color:#111">kref</span> <span style="color:#111">kref</span><span style="color:#111">;</span>
    <span style="color:#00a8c8">struct</span> <span style="color:#111">device</span> <span style="color:#f92672">*</span><span style="color:#111">dev</span><span style="color:#111">;</span> <span style="color:#75715e">/* class device or NULL (e.g. ptys, serdev) */</span>
    <span style="color:#00a8c8">struct</span> <span style="color:#111">tty_driver</span> <span style="color:#f92672">*</span><span style="color:#111">driver</span><span style="color:#111">;</span>
    <span style="color:#00a8c8">const</span> <span style="color:#00a8c8">struct</span> <span style="color:#111">tty_operations</span> <span style="color:#f92672">*</span><span style="color:#111">ops</span><span style="color:#111">;</span>
    <span style="color:#00a8c8">int</span> <span style="color:#111">index</span><span style="color:#111">;</span>
    <span style="color:#111">...</span>
<span style="color:#111">}</span>
</code></pre></div><p>A nice feature of this structure is the <code>magic</code> at the very start, it allows us
to easily confirm the validity of our leak by comparing it against the expected
value <code>TTY_MAGIC</code> (<code>0x5401</code>). A few members later we find <code>struct tty_operations *ops</code> which
points to a <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/tty_driver.h#L247">list of function pointers</a>
associated with various operations. This points to somewhere in kernel .data, and
thus we can use it to defeat KASLR!</p>
<p>Depending on whether the <code>tty_struct</code> being leaked belongs to a master pty or
slave pty (they are allocated in pairs) we’ll end up finding the address of <code>ptm_unix98_ops</code> or <code>pty_unix98_ops</code>.</p>
<p>As an added bonus, leaking <code>tty_struct</code> also allows us to figure out the address
of the <code>tty_struct</code> because <code>tty_struct.ldisc_sem.read_wait.next</code> points to itself!</p>
<h2 id="getting-rip-or-panic-tryin">Getting $RIP (or panic tryin’)</h2>
<p>Naturally, the <code>tty_operations</code> pointer is a nice target for overwriting to hijack
the kernel execution flow. So in the next stage of the exploit we start by spraying
a bunch of copies of a fake <code>tty_operations</code> table. We can accurately guesstimate
the address of one of these sprayed copies by utilizing the heap pointer we leaked
in the previous step.</p>
<p>Now we repeatedly: allocate msg_msg, allocate tty_struct(s), free msg_msg, trigger
TIPC bug to (hopefully) overflow into a <code>tty_struct</code>. To confirm we actually overwrote
(the first part) of a tty_struct we invoke <code>ioctl</code> on the <code>fd</code> we got from opening
<code>/dev/ptmx</code>, this will call <code>tty_struct.ops.ioctl</code> and should get us control over $RIP
if we managed to hijack the <code>ops</code> pointer of this object. If its not the case, we
<code>close()</code> the pty again to not exhaust resources.</p>
<h2 id="avoiding-rop-mostly">Avoiding ROP (mostly)</h2>
<p>Where to jump to in the kernel? We could set up a ROP stack somewhere and pivot
the stack into it.. but this can get messy quick, especially once you need to do
cleanup and resume the kernel thread like nothing ever happened.</p>
<p>If we  look at the prototype of the <code>ioctl</code> callback from the <code>ops</code> list, we see:</p>
<p><code>int  (*ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg);</code></p>
<p>We can set both <code>cmd</code> and <code>arg</code> from the userland invocation easily!</p>
<p>So effectively we have an arbitrary function call where we control the 2nd
and 3rd argument (<code>RSI</code> and <code>RDX</code> respectively). Well, <code>cmd</code> is actually truncated
to 32bit, but that’s good enough.</p>
<p>Let’s try to look for some gadget sequence that allows us to do an arbitrary write:</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ objdump -D -j .text ./vmlinux <span style="color:#8045ff">\
</span><span style="color:#8045ff"></span>    <span style="color:#111">|</span> grep -C1 <span style="color:#d88200">'mov    %rsi,(%rdx)'</span> <span style="color:#8045ff">\
</span><span style="color:#8045ff"></span>    <span style="color:#111">|</span> grep -B2 ret
..
ffffffff812c51f5:       <span style="color:#ae81ff">31</span> c0                   xor    %eax,%eax
ffffffff812c51f7:       <span style="color:#ae81ff">48</span> <span style="color:#ae81ff">89</span> <span style="color:#ae81ff">32</span>                mov    %rsi,<span style="color:#f92672">(</span>%rdx<span style="color:#f92672">)</span>
ffffffff812c51fa:       c3                      ret
..
</code></pre></div><p>This one is convenient, it also clears <code>rax</code> so the exploit can tell whether the
invocation was a success. We now have some arbitrary 64bit write gadget! (For some
definition of arbitrary, the value is always 32bit controlled + 32bit zeroes, but whatever)</p>
<h2 id="meet-my-friend-modprobe_path">Meet my friend: <code>modprobe_path</code></h2>
<p>Okay, we have this scuffed arbitrary write gadget we can repeatedly invoke, what do we
overwrite? Classic kernel exploits would target the <code>cred</code> structure of the current
task to elevate the privileges to uid0. We could of course build an arbitrary read
mechanism in the same way we build the arbitrary write.. but lets try something else.</p>
<p>There are various scenarios in which the kernel will spawn a userland process
(using the <code>usermode_helper</code> infrastructure in the kernel) to load additional
kernel modules when it thinks that is necessary. The process spawned to load
these modules is, of course: modprobe. The path to the modprobe binary is stored
in a global variable called <code>modprobe_path</code> and this can be set by a privileged
user through the sysfs node <code>/proc/sys/kernel/modprobe</code>.</p>
<p>This is a perfect candidate for overwriting using our write gadget. If we overwrite
this path and convince the kernel we need some additional module support we can invoke
any executable as root!</p>
<p>One of these modprobe scenarios is when you try to run a binary that has no known
magic, in <code>fs/exec.c</code> we see:</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/*
</span><span style="color:#75715e"> * cycle the list of binary formats handler, until one recognizes the image
</span><span style="color:#75715e"> */</span>
<span style="color:#00a8c8">static</span> <span style="color:#00a8c8">int</span> <span style="color:#75af00">search_binary_handler</span><span style="color:#111">(</span><span style="color:#00a8c8">struct</span> <span style="color:#111">linux_binprm</span> <span style="color:#f92672">*</span><span style="color:#111">bprm</span><span style="color:#111">)</span>
<span style="color:#111">{</span>
    <span style="color:#111">..</span>
    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">request_module</span><span style="color:#111">(</span><span style="color:#d88200">"binfmt-%04x"</span><span style="color:#111">,</span> <span style="color:#f92672">*</span><span style="color:#111">(</span><span style="color:#111">ushort</span> <span style="color:#f92672">*</span><span style="color:#111">)(</span><span style="color:#111">bprm</span><span style="color:#f92672">-&gt;</span><span style="color:#111">buf</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span><span style="color:#111">))</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span><span style="color:#111">)</span>
    <span style="color:#111">..</span>
<span style="color:#111">}</span>
</code></pre></div><p><code>request_module</code> ends up invoking <code>call_modprobe</code> which spawns a modprobe process
based on the path from <code>modprobe_path</code>.</p>
<h2 id="closing-words">Closing Words</h2>
<p>I hope you enjoyed the read. Feel free to reach out to point out any inaccuracies
or feedback. The full exploit code can be found <a href="https://haxx.in/files/blasty-vs-tipc.c">here</a></p>
<p>A succesful run of the exploit should look something like this:</p>
<p><img src="2021%20-%20%22Exploiting%20CVE-2021-43267%22%20by%20Blasty_files/tipc-poc.gif" alt="PoC in action"></p>


</article>


<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://haxx.in/posts/numeric-shellcode/"><i class="fa fa-chevron-circle-left"></i> Numeric Shellcode</a>
        </li>
        
        
    </ul>
</section>
  
    
    
  





</main>
    <footer>
        <h6> |
            Rendered by <a href="https://gohugo.io/" title="Hugo">Hugo</a> |
            <a href="https://haxx.in/index.xml">Subscribe </a></h6>
    </footer>
</div>
<script src="2021%20-%20%22Exploiting%20CVE-2021-43267%22%20by%20Blasty_files/scripts.js"></script>
<script src="2021%20-%20%22Exploiting%20CVE-2021-43267%22%20by%20Blasty_files/darkmode.js"></script>






</body></html>