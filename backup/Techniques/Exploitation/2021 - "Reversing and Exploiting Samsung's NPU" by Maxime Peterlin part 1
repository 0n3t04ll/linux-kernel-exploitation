<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <!-- Encoding -->
    <meta charset="utf-8">

    <!-- Title -->
    <title>Reversing and Exploiting Samsung's NPU (Part&nbsp;1) - Impalabs Blog</title>
    <meta name="description" content="This series of blogposts aims to describe and explain the internals of a recent addition to Samsung's system-on-chips, namely their Neural Processing Unit. The first part digs into the internals of the NPU and the second one focuses on the exploitation of some vulnerabilities we found in the implementation. If you're interested in reversing a minimal OS, want to understand how Android interacts with peripherals and do exploitation like it's the early 2000's, this series might be for you.">

    <!-- Favicons -->
    <link rel="icon" href="https://blog.impalabs.com/img/favicons/favicon.svg" type="image/svg+xml">
    <link rel="icon" href="https://blog.impalabs.com/img/favicons/favicon.ico">
    <link rel="apple-touch-icon" href="https://blog.impalabs.com/img/favicons/favicon-180.png">
    <link rel="manifest" href="https://blog.impalabs.com/img/favicons/manifest.webmanifest">

    <!-- CSS -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/style.css">

    <!-- SEO -->
    <meta property="og:title" content="Reversing and Exploiting Samsung's NPU (Part&nbsp;1)">
    <meta property="og:description" content="This series of blogposts aims to describe and explain the internals of a recent addition to Samsung's system-on-chips, namely their Neural Processing Unit. The first part digs into the internals of the NPU and the second one focuses on the exploitation of some vulnerabilities we found in the implementation. If you're interested in reversing a minimal OS, want to understand how Android interacts with peripherals and do exploitation like it's the early 2000's, this series might be for you.">
    <meta property="og:image" content="https://blog.impalabs.com/img/social/og.png">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@the_impalabs">
    <meta name="twitter:title" content="Reversing and Exploiting Samsung's NPU (Part&nbsp;1)">
    <meta name="twitter:description" content="This series of blogposts aims to describe and explain the internals of a recent addition to Samsung's system-on-chips, namely their Neural Processing Unit. The first part digs into the internals of the NPU and the second one focuses on the exploitation of some vulnerabilities we found in the implementation. If you're interested in reversing a minimal OS, want to understand how Android interacts with peripherals and do exploitation like it's the early 2000's, this series might be for you.">
    <meta name="twitter:image" content="https://blog.impalabs.com/img/social/twitter.png">
    <meta name="twitter:image:alt" content="impalabs blog logo twitter card">

    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="Impalabs Blog" href="https://blog.impalabs.com/feed.xml">
</head>

<body>
    <!-- Header -->
    <header class="impalabs-header">
        <!-- Stars -->
        <div class="impalabs-header-stars"></div>

        <!-- Navbar -->
        <nav class="navbar" aria-label="main navigation">
            <div class="container">
                <!-- Navbar logo -->
                <div class="navbar-brand">
                    <a class="navbar-item" href="https://blog.impalabs.com/">
                        <img src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/impalabs_logo_name_light.svg" alt="impalabs light logo and name" width="362.656px" height="96px">
                    </a>
                </div>

                <!-- Navbar burger toggle -->
                <input type="checkbox" id="navbar-burger-toggle" class="navbar-burger-toggle is-hidden">
                <label for="navbar-burger-toggle" class="navbar-burger">
                    <span></span>
                    <span></span>
                    <span></span>
                </label>

                <!-- Navbar menu -->
                <div class="navbar-menu">
                    <div class="navbar-end has-text-centered">
                        <a href="https://blog.impalabs.com/" class="navbar-item">
                            <button class="button is-primary">
                                Articles
                            </button>
                        </a>
                        <a href="https://blog.impalabs.com/tags/" class="navbar-item">
                            <button class="button is-primary">
                                Tags
                            </button>
                        </a>
                        <a type="application/rss+xml" href="https://blog.impalabs.com/feed.xml" class="navbar-item">
                            <button class="button is-primary">
                                RSS
                            </button>
                        </a>
                        <a href="https://impalabs.com/" class="navbar-item">
                            <button class="button is-primary">
                                Website
                            </button>
                        </a>
                    </div>
                </div>
            </div>
        </nav>

        <!-- Impalabs space base -->
        <div class="section" id="impalabs-space-base">
            <div class="container is-centered">
                <img src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/space_base.svg" alt="impalabs space base graphics" width="1133px" height="360px">
            </div>
        </div>
    </header>

    <!-- Blog content section -->
    <section id="content" class="section">
        <div class="container container-out">
            <div class="container content container-in">


<span itemscope="" itemtype="http://schema.org/BlogPosting">

<!-- Title -->
<span class="blog-title" itemprop="name headline">Reversing and Exploiting Samsung's NPU (Part&nbsp;1)</span>

<!-- Metadata -->
<div class="columns is-centered is-multiline blog-metadata">
    <!-- Date -->
    <div class="column is-narrow blog-date">
        <span itemprop="datePublished"><time datetime="2021-03-24"><img src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/calendar.svg" alt="Calendar icon" width="30px" height="30px"> Mar 24, 2021</time></span>
    </div>
    <!-- Authors -->
    <div class="column is-narrow blog-authors">
        <span><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <a href="https://blog.impalabs.com/authors/maxime-peterlin.html"><img src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/users.svg" alt="Users icon" width="30px" height="30px"> <span itemprop="name">Maxime Peterlin</span></a>
</span></span>
    </div>
    <!-- Tags -->
    <meta itemprop="keywords" content="Android,Kernel,Samsung,NPU,Reverse Engineering">
    <div class="column is-narrow blog-tags">
        <a href="https://blog.impalabs.com/tags/android.html">
    <img src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/tags.svg" alt="Tags icon" width="30px" height="30px"> Android</a> <a href="https://blog.impalabs.com/tags/kernel.html">
    <img src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/tags.svg" alt="Tags icon" width="30px" height="30px"> Kernel</a> <a href="https://blog.impalabs.com/tags/samsung.html">
    <img src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/tags.svg" alt="Tags icon" width="30px" height="30px"> Samsung</a> <a href="https://blog.impalabs.com/tags/npu.html">
    <img src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/tags.svg" alt="Tags icon" width="30px" height="30px"> NPU</a> <a href="https://blog.impalabs.com/tags/reverse-engineering.html">
    <img src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/tags.svg" alt="Tags icon" width="30px" height="30px"> Reverse Engineering</a>
    </div>
</div>

<!-- Disclaimer -->
<article id="disclaimer" class="message is-info">
    <div class="message-header is-info">Disclaimer</div>
    <div class="message-body">
        <p>This work was done while we were working at <a href="https://www.longterm.io/">Longterm Security</a> and they have kindly allowed us to mirror the <a href="https://blog.longterm.io/samsung_npu.html">original article</a> on our company's blog.</p>
    </div>
</article>

<!-- Summary -->
<meta itemprop="description" content="This series of blogposts aims to describe and explain the internals of a recent addition to Samsung's system-on-chips, namely their Neural Processing Unit. The first part digs into the internals of the NPU and the second one focuses on the exploitation of some vulnerabilities we found in the implementation. If you're interested in reversing a minimal OS, want to understand how Android interacts with peripherals and do exploitation like it's the early 2000's, this series might be for you.">
<span class="blog-summary"><p>This series of blogposts aims to describe 
and explain the internals of a recent addition to Samsung's 
system-on-chips, namely their Neural Processing Unit. The first part 
digs into the internals of the NPU and the second one focuses on the 
exploitation of some vulnerabilities we found in the implementation. If 
you're interested in reversing a minimal OS, want to understand how 
Android interacts with peripherals and do exploitation like it's the 
early 2000's, this series might be for you.</p></span>

<!-- Separator -->
<span id="blog-separator"></span>

<!-- Table of contents -->
<article class="message">
    <div class="message-body">
        <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#environment">Environment</a></li>
<li><a href="#initialization-of-the-npu-driver-and-loading-of-the-npu-firmware">Initialization of the NPU Driver and Loading of the NPU Firmware</a><ul>
<li><a href="#loading-of-the-npu-driver">Loading of the NPU Driver</a></li>
<li><a href="#npu-driver-power-management-and-firmware-loading">NPU Driver Power Management and Firmware Loading</a></li>
</ul>
</li>
<li><a href="#firmware-extraction-and-reverse-engineering">Firmware Extraction and Reverse Engineering</a></li>
<li><a href="#npu-operating-system">NPU Operating System</a><ul>
<li><a href="#npu-firmware-initialization">NPU Firmware Initialization</a></li>
<li><a href="#main-function">Main Function</a></li>
<li><a href="#heap">Heap</a></li>
<li><a href="#caches-exceptions-and-interrupts">Caches, Exceptions and Interrupts</a></li>
<li><a href="#tasks">Tasks</a></li>
<li><a href="#scheduling">Scheduling</a></li>
<li><a href="#timers">Timers</a></li>
<li><a href="#events">Events</a></li>
<li><a href="#semaphores">Semaphores</a></li>
<li><a href="#communication-channels">Communication Channels</a></li>
<li><a href="#running-the-system">Running the System</a></li>
</ul>
</li>
<li><a href="#interacting-with-the-npu">Interacting with the NPU</a><ul>
<li><a href="#sharing-resources-between-the-kernel-and-the-npu">Sharing Resources Between the Kernel and the NPU</a></li>
<li><a href="#from-the-kernel-to-the-npu">From the Kernel to the NPU</a></li>
<li><a href="#handling-commands-in-the-npu">Handling Commands in the NPU</a></li>
<li><a href="#from-the-npu-back-to-the-kernel">From the NPU Back to the Kernel</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>

    </div>
</article>


<!-- Blogpost content start =============================================== -->
<span itemprop="articleBody">
<h1 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">¶</a></h1>
<blockquote>
<p>A neural processor or a neural processing unit (NPU) is a specialized
 circuit that implements all the necessary control and arithmetic logic 
necessary to execute machine learning algorithms, typically by operating
 on predictive models such as artificial neural networks (ANNs) or 
random forests (RFs).</p>
</blockquote>
<p><strong>Source:</strong> <a href="https://en.wikichip.org/wiki/neural_processor">https://en.wikichip.org/wiki/neural_processor</a></p>
<p>At the time of writing, Samsung has released four <a href="https://en.wikipedia.org/wiki/Exynos#Exynos_9800_series_(2018/19)">SoCs embedding an NPU</a>:</p>
<ul>
<li>Exynos 9820</li>
<li>Exynos 9825</li>
<li>Exynos 980</li>
<li>Exynos 990</li>
</ul>
<p>This article focuses primarily on the Exynos 990 found on Galaxy S20 
devices; although, most of the concepts discussed here also apply to 
other SoCs.</p>
<p>An additional chip on a SoC often means dedicated firmware and therefore a larger attack surface. Google Project Zero has <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2073">disclosed and exploited vulnerabilities</a> affecting the Samsung NPU drivers and pointed out that it can be accessed with the <code>untrusted_app</code> SELinux context. These issues have now been patched and the SELinux contexts which have access to the NPU are more strict.</p>
<p>However there is currently no information on the actual NPU firmware 
implementation, how it works, and how it interacts with the rest of the 
system. This blogpost tries to answer some of those questions.</p>
<h1 id="environment">Environment<a class="headerlink" href="#environment" title="Permanent link">¶</a></h1>
<p>This analysis was performed on a rooted Samsung Galaxy S20 <code>SM-G980F</code> using the firmware <a href="https://www.sammobile.com/samsung/galaxy-s20/firmware/SM-G980F/XEF/download/G980FXXS5CTL5/1117440/">G980FXXS5CTL5</a>. It's important for the device to be rooted since we want access to <code>dmesg</code> and the NPU driver (which is not possible from the shell on the newest versions since Project Zero's disclosure).</p>
<p>It's not uncommon for Samsung to provide debug information in the components they develop and the NPU is no exception. Logs in <code>dmesg</code> are extremely verbose for both the NPU driver and firmware, as you can see below.</p>
<div class="codehilite"><pre><span></span><code><span class="gp">x1s:/ # </span>sysctl -w kernel.kptr_restrict<span class="o">=</span><span class="m">1</span>
<span class="gp">x1s:/ # </span>dmesg -w <span class="p">|</span> grep <span class="s2">"NPU:"</span>
<span class="go">[102.037911] [Exynos][NPU][NOTICE]: NPU:[*]npu_debug_open(221):start in npu_debug open</span>
<span class="go">[102.037928] [Exynos][NPU][NOTICE]: NPU:[*]npu_debug_open(222):complete in npu_debug open</span>
<span class="go">[102.037936] [Exynos][NPU][NOTICE]: NPU:[*]npu_log_open(1335):start in npu_log_open</span>
<span class="go">[102.037943] [Exynos][NPU][NOTICE]: NPU:[*]npu_log_open(1336):complete in npu_log_open</span>
<span class="go">[102.037951] [Exynos][NPU][NOTICE]: NPU:[*]npu_util_memdump_open(319):start in npu_util_memdump_open</span>
<span class="go">[102.037958] [Exynos][NPU][NOTICE]: NPU:[*]npu_util_memdump_open(344):complete in npu_util_memdump_open</span>
<span class="go">[102.037966] [Exynos][NPU][NOTICE]: NPU:[*]npu_scheduler_open(1458):done</span>
<span class="go">[102.039801] [Exynos][NPU][NOTICE]: NPU:[*]npu_system_resume(387):wake_lock, now(1)</span>
<span class="go">[102.039813] [Exynos][NPU][NOTICE]: NPU:[*]npu_system_alloc_fw_dram_log_buf(93):start: initialization.</span>
<span class="go">[102.040957] [Exynos][NPU][NOTICE]: NPU:[*]npu_system_alloc_fw_dram_log_buf(103):DRAM log buffer for kernel: size(2097152) / dv(0x0000000080000000) / kv(ffffff802ca85000)</span>
</code></pre></div>

<p>There are also <code>debugfs</code> entries that can be used to 
retrieve information about the NPU (the NPU driver has to be opened at 
least once for all of them to appear).</p>
<div class="codehilite"><pre><span></span><code><span class="gp">x1s:/ # </span>ls -la /d/npu/
<span class="go">total 0</span>
<span class="go">drwxr-xr-x  2 root   root   0 2021-01-30 18:18 .</span>
<span class="go">drwxr-xr-x 63 system system 0 1970-01-01 01:00 ..</span>
<span class="go">-rw-------  1 root   root   0 2021-01-30 18:21 SRAM-IDP</span>
<span class="go">-rw-------  1 root   root   0 2021-01-30 18:21 SRAM-TCU</span>
<span class="go">-r--------  1 root   root   0 2021-01-30 18:18 dev-log</span>
<span class="go">-r--------  1 root   root   0 2021-01-30 18:21 fw-log-SRAM</span>
<span class="go">-r--------  1 root   root   0 2021-01-30 18:18 fw-profile</span>
<span class="go">-r--------  1 root   root   0 2021-01-30 18:18 fw-report</span>
<span class="go">-rw-------  1 root   root   0 2021-01-30 18:18 idiot</span>
<span class="go">-r--------  1 root   root   0 2021-01-30 18:18 proto-drv-dump</span>
<span class="go">-r--------  1 root   root   0 2021-01-30 18:18 result-golden-match</span>
<span class="go">--w-------  1 root   root   0 2021-01-30 18:18 set-golden-desc</span>
</code></pre></div>

<p>All of this information is very helpful when trying to reverse engineer the NPU and understand the underlying concepts.</p>
<h1 id="initialization-of-the-npu-driver-and-loading-of-the-npu-firmware">Initialization of the NPU Driver and Loading of the NPU Firmware<a class="headerlink" href="#initialization-of-the-npu-driver-and-loading-of-the-npu-firmware" title="Permanent link">¶</a></h1>
<h2 id="loading-of-the-npu-driver">Loading of the NPU Driver<a class="headerlink" href="#loading-of-the-npu-driver" title="Permanent link">¶</a></h2>
<p>Before we can start analyzing the firmware in our favorite 
disassembler, we first need to locate it. This section explains how the 
NPU driver is started by the kernel and the operations it performs to 
load the firmware on the dedicated chip.</p>
<p>The initialization starts in the file <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-device.c">drivers/vision/npu/core/npu-device.c</a> with a call to <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-device.c#L737"><code>npu_device_init</code></a> when the kernel is booting.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">npu_device_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">npu_driver</span><span class="p">);</span>

    <span class="cm">/* [...] */</span>
<span class="p">}</span>

<span class="cm">/* [...] */</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">npu_device_init</span><span class="p">);</span>
</code></pre></div>

<p><code>npu_device_init</code> calls <code>platform_driver_register</code> and passes it the following structure as an argument:</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="k">struct</span> <span class="nc">platform_driver</span> <span class="n">npu_driver</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">probe</span>  <span class="o">=</span> <span class="n">npu_device_probe</span><span class="p">,</span>
    <span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">npu_device_remove</span><span class="p">,</span>
    <span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">name</span>   <span class="o">=</span> <span class="s">"exynos-npu"</span><span class="p">,</span>
        <span class="p">.</span><span class="n">owner</span>  <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
        <span class="p">.</span><span class="n">pm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">npu_pm_ops</span><span class="p">,</span>
        <span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">of_match_ptr</span><span class="p">(</span><span class="n">exynos_npu_match</span><span class="p">),</span>
    <span class="p">},</span>
<span class="p">};</span>
</code></pre></div>

<p>When the module is loaded by the kernel, the function <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-device.c#L251"><code>npu_device_probe</code></a> is called (error checks were removed from the following snippet for clarity).</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">npu_device_probe</span><span class="p">(</span><span class="k">struct</span> <span class="nc">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">npu_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>

    <span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">devm_kzalloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
    <span class="n">device</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">npu_system_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">system</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">npu_debug_probe</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">npu_log_probe</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">npu_vertex_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">proto_drv_probe</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">npu_sessionmgr_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sessionmgr</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NPU_GOLDEN_MATCH</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">register_golden_matcher</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_NPU_LOOPBACK</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">mailbox_mgr_mock_probe</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="cp">#endif</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">npu_profile_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">system</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">iovmm_activate</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
    <span class="n">iovmm_set_fault_handler</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">npu_iommu_fault_handler</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>

    <span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">probe_info</span><span class="p">(</span><span class="s">"complete in %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

    <span class="k">goto</span> <span class="n">ok_exit</span><span class="p">;</span>

<span class="nl">err_exit</span><span class="p">:</span>
    <span class="n">probe_err</span><span class="p">(</span><span class="s">"error on %s ret(%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
<span class="nl">ok_exit</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div>

<p>Essentially, <code>npu_device_probe</code> initializes the following components:</p>
<ul>
<li>interrupts (using the corresponding DTS file)</li>
<li>shared memory mappings</li>
<li>relevant IO devices mappings</li>
<li>npu interface and mailbox</li>
<li>firmware binary paths<ul>
<li><code>/data/NPU.bin</code> and <code>/vendor/firmware/NPU.bin</code></li>
<li>If these two paths don't exist, the device will try to load it from <code>npu/NPU.bin</code>, which is embedded inside the kernel image</li>
</ul>
</li>
<li>debugfs entries</li>
<li>vertex objects<ul>
<li>It sets, among other things, the file operations and ioctl handlers for the device:<ul>
<li><strong>File operations</strong>: <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-vertex.c#L315"><code>npu_vertex_fops</code></a></li>
<li><strong>Ioctl handlers</strong>: <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-vertex.c#L884"><code>npu_vertex_ioctl_ops</code></a></li>
</ul>
</li>
</ul>
</li>
<li>session manager</li>
<li>iovmm</li>
</ul>
<p>It's not too important to understand the details of these operations 
for the moment. Some of them are explained later in this article when it
 becomes relevant. For now, let's have a look at how the NPU is loaded 
onto the chip and started by the kernel.</p>
<h2 id="npu-driver-power-management-and-firmware-loading">NPU Driver Power Management and Firmware Loading<a class="headerlink" href="#npu-driver-power-management-and-firmware-loading" title="Permanent link">¶</a></h2>
<p>The <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-device.c#L726"><code>npu_driver</code></a> structure mentioned earlier also registers <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-device.c#L711"><code>npu_pm_ops</code></a> as its power management operation handlers.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">dev_pm_ops</span> <span class="n">npu_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">SET_SYSTEM_SLEEP_PM_OPS</span><span class="p">(</span><span class="n">npu_device_suspend</span><span class="p">,</span> <span class="n">npu_device_resume</span><span class="p">)</span>
    <span class="n">SET_RUNTIME_PM_OPS</span><span class="p">(</span><span class="n">npu_device_runtime_suspend</span><span class="p">,</span> <span class="n">npu_device_runtime_resume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div>

<p>When the device needs to start the NPU, it triggers a call to <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-device.c#L620"><code>npu_device_runtime_resume</code></a> in the power management system, and then to <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-system.c#L366"><code>npu_system_resume</code></a> (the snippet below was simplified for clarity).</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">npu_system_resume</span><span class="p">(</span><span class="k">struct</span> <span class="nc">npu_system</span> <span class="o">*</span><span class="n">system</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* [...] */</span>

    <span class="cm">/* Loads the firmware in memory from the filesystem */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">npu_firmware_load</span><span class="p">(</span><span class="n">system</span><span class="p">);</span>

    <span class="cm">/* Starts the NPU firmware */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">npu_system_soc_resume</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

    <span class="cm">/* Opens an interface to the NPU */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">npu_interface_open</span><span class="p">(</span><span class="n">system</span><span class="p">);</span>

    <span class="cm">/* [...] */</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-system.c#L593"><code>npu_firmware_load</code></a> calls <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-binary.c#L255"><code>npu_firmware_file_read</code></a> which tries to read the firmware from <code>/data/NPU.bin</code> or <code>/vendor/firmware/NPU.bin</code>. If none of those files exist, it tries to read it from the kernel filesystem at <code>npu/NPU.bin</code>. The content of the file is then copied into an iomem region at <code>system-&gt;fw_npu_memory_buffer-&gt;vaddr</code>.</p>
<p>The iomem region for the firmware is <code>FW_DRAM</code> and is defined in <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/arch/arm64/boot/dts/exynos/exynos9830.dts#L15164"><code>arch/arm64/boot/dts/exynos/exynos9830.dts</code></a> which is parsed by <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/soc/9830/npu-system-soc.c#L603"><code>init_iomem_area</code></a> during the initialization of the driver. In the NPU's address space, this region starts at physical address <code>0x50000000</code> and has a size of <code>0xe0000</code>. The corresponding address in the kernel is allocated dynamically.</p>
<p><strong>Note:</strong> IOMMU allocations are explained in more detail in the section <a href="#sharing-resources-between-the-kernel-and-the-npu">Sharing Resources Between the Kernel and the NPU</a>.</p>
<p>Finally <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/soc/9830/npu-system-soc.c#L164"><code>npu_system_soc_resume</code></a> is called to start the NPU using <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/soc/9830/npu-system-soc.c#L293"><code>npu_cpu_on</code></a>.</p>
<p>The NPU is started when <code>/dev/vertex10</code> is opened and stopped when it is closed. When opening the device you should then see logs in <code>dmesg</code> similar to the following ones:</p>
<div class="codehilite"><pre><span></span><code>[123.007254] NPU:[*]npu_debug_open(221):start in npu_debug open
[123.007264] NPU:[*]npu_debug_open(222):complete in npu_debug open
[123.007269] NPU:[*]npu_log_open(1152):start in npu_log_open
[123.007274] NPU:[*]npu_log_open(1153):complete in npu_log_open
[123.007279] NPU:[*]npu_util_memdump_open(317):start in npu_util_memdump_open
[123.007282] NPU:[*]npu_util_memdump_open(342):complete in npu_util_memdump_open
[123.007820] NPU:[*]npu_system_resume(346):wake_lock, now(1)
[123.007827] NPU:[*]npu_system_alloc_fw_dram_log_buf(93):start: initialization.
[123.009277] NPU:[*]npu_system_alloc_fw_dram_log_buf(103):DRAM log buffer for firmware: size(2097152) / dv(0x0000000080000000) / kv(ffffff803db75000)
[123.009293] NPU:[*]npu_store_log_init(216):Store log memory initialized : ffffff803db75000[Len = 2097152]
[123.009303] NPU:[*]npu_fw_test_initialize(290):fw_test : initialized.
[123.009309] NPU:[*]npu_system_alloc_fw_dram_log_buf(125):complete : initialization.
[123.009315] NPU:[*]npu_firmware_load(540):Firmware load : Start
[123.023161] NPU:[*]__npu_binary_read(215):success of binay(npu/NPU.bin, 475349) apply.
[123.023196] NPU:[*]print_fw_signature(111):NPU Firmware signature : 009:094 2019/04/25 14:56:44
[123.023210] NPU:[*]npu_firmware_load(572):complete in npu_firmware_load
[123.023233] NPU:[*]print_iomem_area(466):\x01c(TCU_SRAM) Phy(0x19200000)-(0x19280000) Virt(ffffff802b900000) Size(524288)
[123.023243] NPU:[*]print_iomem_area(466):\x01c(IDP_SRAM) Phy(0x19300000)-(0x19400000) Virt(ffffff802ba00000) Size(1048576)
[123.023251] NPU:[*]print_iomem_area(466):\x01c(SFR_NPU0) Phy(0x17900000)-(0x17a00000) Virt(ffffff802bc00000) Size(1048576)
[123.023259] NPU:[*]print_iomem_area(466):\x01c(SFR_NPU1) Phy(0x17a00000)-(0x17af0000) Virt(ffffff802be00000) Size(983040)
[123.023270] NPU:[*]print_iomem_area(466):\x01c( PMU_NPU) Phy(0x15861d00)-(0x15861e00) Virt(ffffff8010eedd00) Size(256)
[123.023279] NPU:[*]print_iomem_area(466):\x01c(PMU_NCPU) Phy(0x15862f00)-(0x15863000) Virt(ffffff8010ef5f00) Size(256)
[123.023288] NPU:[*]print_iomem_area(466):\x01c(MBOX_SFR) Phy(0x178b0000)-(0x178b017c) Virt(ffffff8010efd000) Size(380)
[123.023367] NPU:[*]npu_cpu_on(729):start in npu_cpu_on
[123.023420] NPU:[*]npu_cpu_on(736):complete in npu_cpu_on
[123.023445] NPU:[*]npu_system_soc_resume(513):CLKGate1_DRCG_EN_write_enable
[123.023451] NPU:[*]CLKGate4_IP_HWACG_qch_disable(261):start CLKGate4_IP_HWACG_qch_disable
[123.024797] NPU log sync [60544]
[123.024894] NPU:[*]npu_system_soc_resume(525):CLKGate5_IP_DRCG_EN_write_enable
[123.025842] NPU:[*]mailbox_init(46):mailbox initialize: start, header base at ffffff802b97ff7c
[123.025852] NPU:[*]mailbox_init(47):mailbox initialize: wait for firmware boot signature.
[123.036810] NPU:[*]mailbox_init(53):header signature \x09: C0FFEE0
[123.036821] NPU:[*]mailbox_init(76):header version \x09: 00060004
[123.036826] NPU:[*]mailbox_init(83):init. success in NPU mailbox
[123.036831] NPU:[*]npu_device_runtime_resume(582):npu_device_runtime_resume():0
</code></pre></div>

<h1 id="firmware-extraction-and-reverse-engineering">Firmware Extraction and Reverse Engineering<a class="headerlink" href="#firmware-extraction-and-reverse-engineering" title="Permanent link">¶</a></h1>
<p>At this stage, we know how the NPU is started and where is firmware 
is located. The next step is now to extract the binary from the device.</p>
<p>There are two different types of firmware, depending on the type of CPU used for the NPU.</p>
<ul>
<li>Exynos 9820 SoCs (Galaxy S10 models) use ARMv7 Cortex-M cores.</li>
<li>Exynos 990 SoCs (Galaxy S20 models) use ARMv7 Cortex-A cores.</li>
</ul>
<p>Both firmwares are very similar in their implementation, but there 
are still differences, especially during the initialization phase. In 
this article, we focus on the ARMv7-A implementation.</p>
<p>As explained in the previous section, the firmware can be found at three possible locations:</p>
<ul>
<li><code>/data/NPU.bin</code></li>
<li><code>/vendor/firmware/NPU.bin</code></li>
<li><code>npu/NPU.bin</code> (extracted from the kernel image)</li>
</ul>
<p>On the Galaxy S20, the NPU firmware is embedded inside the kernel 
image. It's possible to extract it from a rooted device using the 
following tool: <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/tools/npu_firmware_extractor/npu_firmware_extractor.py">npu_firmware_extractor.py</a> and passing it the <code>--cortex-a</code> flag.</p>
<div class="codehilite"><pre><span></span><code><span class="gp">$ </span>python3 npu_firmware_extractor.py -d . --cortex-a
<span class="go">[+] Connection to the device using ADB.</span>
<span class="go">[+] Pulling the kernel from the device to the host.</span>
<span class="go">[+] Extracting the firmware.</span>
<span class="go">[+] Done.</span>
<span class="gp">$ </span>ll
<span class="go">-rw-r--r--  1 lyte  staff   464K  4 jan 16:30 NPU.bin</span>
<span class="go">-rw-r--r--  1 lyte  staff    55M  4 jan 16:30 boot.img</span>
<span class="go">-rw-r--r--  1 lyte  staff   3,6K  4 jan 16:29 npu_firmware_extractor.py</span>
</code></pre></div>

<p>There is also the possibility of dumping the SRAM memory range 
allocated for the NPU firmware. Earlier, we have shown different debugfs
 entries. Among these, there is <code>SRAM-TCU</code> which can be used 
to dump the NPU's code and data at runtime. While this file works on the
 Samsung S10, the kernel will panic if you try to open it on the Samsung
 S20.</p>
<p>It's possible to fix this issue by recompiling a new version of the 
kernel. Samsung's kernel source code can be downloaded by following <a href="https://opensource.samsung.com/uploadList?menuItem=mobile&amp;classification1=mobile_phone">this link</a>, searching for <code>SM-G980F</code> and downloading the source code for the version <code>G980FXXU5CTL1</code>.</p>
<p>The following patch can be applied to the kernel to fix these issues:</p>
<div class="codehilite"><pre><span></span><code><span class="gh">diff --git a/drivers/vision/npu/core/npu-util-memdump.c b/drivers/vision/npu/core/npu-util-memdump.c</span>
<span class="gh">index 5711bbb..8749701 100755</span>
<span class="gd">--- a/drivers/vision/npu/core/npu-util-memdump.c</span>
<span class="gi">+++ b/drivers/vision/npu/core/npu-util-memdump.c</span>
<span class="gu">@@ -109,12 +109,13 @@ int ram_dump_fault_listner(struct npu_device *npu)</span>
 {
    int ret = 0;
    struct npu_system *system = &amp;npu-&gt;system;
<span class="gd">-   u32 *tcu_dump_addr = kzalloc(system-&gt;tcu_sram.size, GFP_ATOMIC);</span>
<span class="gi">+   u32 *tcu_dump_addr = kzalloc(system-&gt;fw_npu_memory_buffer-&gt;size, GFP_ATOMIC);</span>
    u32 *idp_dump_addr = kzalloc(system-&gt;idp_sram.size, GFP_ATOMIC);

    if (tcu_dump_addr) {
<span class="gd">-       memcpy_fromio(tcu_dump_addr, system-&gt;tcu_sram.vaddr, system-&gt;tcu_sram.size);</span>
<span class="gd">-       pr_err("NPU TCU SRAM dump - %pK / %paB\n", tcu_dump_addr, &amp;system-&gt;tcu_sram.size);</span>
<span class="gi">+       memcpy_fromio(tcu_dump_addr, system-&gt;fw_npu_memory_buffer-&gt;vaddr,</span>
<span class="gi">+           system-&gt;fw_npu_memory_buffer-&gt;size);</span>
<span class="gi">+       pr_err("NPU TCU SRAM dump - %pK / %paB\n", tcu_dump_addr, &amp;system-&gt;fw_npu_memory_buffer-&gt;size);</span>
    } else {
        pr_err("tcu_dump_addr is NULL\n");
        ret= -ENOMEM;
<span class="gu">@@ -281,20 +282,22 @@ DECLARE_NPU_SRAM_DUMP(idp);</span>
 int npu_util_memdump_probe(struct npu_system *system)
 {
    BUG_ON(!system);
<span class="gd">-   BUG_ON(!system-&gt;tcu_sram.vaddr);</span>
<span class="gi">+   BUG_ON(!system-&gt;fw_npu_memory_buffer-&gt;vaddr);</span>
 #ifdef CONFIG_NPU_LOOPBACK
    return 0;
 #endif
    atomic_set(&amp;npu_memdump.registered, 0);
<span class="gd">-   npu_memdump.tcu_sram = system-&gt;tcu_sram;</span>
<span class="gi">+   npu_memdump.tcu_sram.vaddr = system-&gt;fw_npu_memory_buffer-&gt;vaddr;</span>
<span class="gi">+   npu_memdump.tcu_sram.paddr = system-&gt;fw_npu_memory_buffer-&gt;paddr;</span>
<span class="gi">+   npu_memdump.tcu_sram.size = system-&gt;fw_npu_memory_buffer-&gt;size;</span>
    npu_memdump.idp_sram = system-&gt;idp_sram;
<span class="gd">-   probe_info("%s: paddr = %08x\n", FW_MEM_LOG_NAME,</span>
<span class="gd">-          system-&gt;tcu_sram.paddr + MEM_LOG_OFFSET</span>
<span class="gi">+   probe_info("%s: paddr = %08llx\n", FW_MEM_LOG_NAME,</span>
<span class="gi">+          system-&gt;fw_npu_memory_buffer-&gt;paddr + MEM_LOG_OFFSET</span>
           );
 #ifdef CONFIG_EXYNOS_NPU_DEBUG_SRAM_DUMP
<span class="gd">-   probe_info("%s: paddr = %08x\n", TCU_SRAM_DUMP_SYSFS_NAME,</span>
<span class="gd">-       system-&gt;tcu_sram.paddr);</span>
<span class="gd">-   tcu_sram_dump_size = system-&gt;tcu_sram.size;</span>
<span class="gi">+   probe_info("%s: paddr = %08llx\n", TCU_SRAM_DUMP_SYSFS_NAME,</span>
<span class="gi">+       system-&gt;fw_npu_memory_buffer-&gt;paddr);</span>
<span class="gi">+   tcu_sram_dump_size = system-&gt;fw_npu_memory_buffer-&gt;size;</span>
    probe_info("%s: paddr = %08x\n", IDP_SRAM_DUMP_SYSFS_NAME,
        system-&gt;idp_sram.paddr);
    idp_sram_dump_size = system-&gt;idp_sram.size;
</code></pre></div>

<p>After recompiling and booting the kernel, it's possible to dump the NPU's address space using <a href="https://github.com/LongtermSecurityInc/samsung-npu/-/tree/master/tools/npu_sram_dumper">npu_sram_dumper</a>.</p>
<div class="codehilite"><pre><span></span><code><span class="gp">$ </span>make run
</code></pre></div>

<p>These binaries can now be loaded into IDA or any other disassembler. For both Cortex-M and Cortex-A, the base address is <code>0</code>. If you want to follow along, here's a link to the binary that is analyzed in this article: <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/binaries/npu_s20_binary.bin">npu_s20_binary.bin</a>. However, this is just the plain firmware, if you also want some of the values initialized at runtime, you can have a look at <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/binaries/npu_s20_dump.bin">npu_s20_dump.bin</a>.</p>
<h1 id="npu-operating-system">NPU Operating System<a class="headerlink" href="#npu-operating-system" title="Permanent link">¶</a></h1>
<p>The NPU firmware implements a minimal operating system capable of 
handling the different requests from the kernel and sending back the 
results. This section gives an overview of the different components 
comprising the OS and tries to highlight their interactions.</p>
<p>A good chunk of the code presented in this section was reverse engineered and is available <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse">here</a>.
 All those snippets of code try to stay as true as possible to the 
original logic implemented, but there might be some deviations for the 
sake of simplicity (e.g. removing critical section wrappers that would 
multiply the number of functions by almost two). Also, even though this 
section explains the inner workings of components deemed relevant, 
readers interested in the actual implementations are encouraged to read 
the equivalent C code, since most of it is commented.</p>
<h2 id="npu-firmware-initialization">NPU Firmware Initialization<a class="headerlink" href="#npu-firmware-initialization" title="Permanent link">¶</a></h2>
<p>Since we're dealing with a 32-bit Cortex-A CPU, the exception vector is based on the following format:</p>
<div class="tablewrapper"><table>
<thead>
<tr>
<th>Offset</th>
<th>Handler</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>Reset</td>
</tr>
<tr>
<td>0x04</td>
<td>Undefined Instruction</td>
</tr>
<tr>
<td>0x08</td>
<td>Supervisor Call</td>
</tr>
<tr>
<td>0x0c</td>
<td>Prefetch Abort</td>
</tr>
<tr>
<td>0x10</td>
<td>Data Abort</td>
</tr>
<tr>
<td>0x14</td>
<td>Not used</td>
</tr>
<tr>
<td>0x18</td>
<td>IRQ interrupt</td>
</tr>
<tr>
<td>0x1c</td>
<td>FIQ interrupt</td>
</tr>
</tbody>
</table>
</div><p>When the NPU starts, the first instruction executed at offset 0 jumps to the function <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x00_init.c#L9"><code>reset_handler</code></a>.</p>
<p>Basically, this function is going to:</p>
<ul>
<li>Enable NEON instructions;</li>
<li>Make sure we're running in supervisor mode;</li>
<li>Initialize the page tables and activate the MPU;</li>
<li>Set the stack pointer for the different CPU mode (e.g. abort, FIQ, etc.);</li>
<li>Call the <code>main</code> function.</li>
</ul>
<p>Before we jump to the main function of the NPU, let's have a look at 
how page tables are set by the firmware to get an overview of memory 
mappings.</p>
<p>The function responsible for these operations is <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x00_init.c#L92"><code>init_memory_management</code></a>. If you look at the code, you might notice that it sets <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x00_init.c#L161"><code>SCR</code> to 0</a>,
 which means that the NPU could potentially access secure memory. 
Unfortunately for attackers, this component is not configured on the AXI
 bus as secure, which means that access to secure memory will result in 
an hardware exception.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">init_memory_management</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* [...] */</span>

    <span class="cm">/*</span>
<span class="cm">     * SCR - Secure Configuration Register</span>
<span class="cm">     *</span>
<span class="cm">     *     NS=0b0: Secure mode enabled.</span>
<span class="cm">     *     ...</span>
<span class="cm">     */</span>
    <span class="n">write_scr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">init_page_tables</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p>The function then goes on to call <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x00_init.c#L172"><code>init_page_tables</code></a>. This method calls <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x00_init.c#L244"><code>SetTransTable</code></a> to actually create the level 1 and level 2 page table entries. <code>init_page_tables</code> then writes the L1 page table address to <code>TTBR0</code> and clean the caches .</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">init_page_tables</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* [...] */</span>

    <span class="n">SetTransTable</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x50000000</span><span class="p">,</span> <span class="mh">0x1D000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x180D</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x1D000</span><span class="p">,</span> <span class="mh">0x5001D000</span><span class="p">,</span> <span class="mh">0x3000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x180D</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x20000</span><span class="p">,</span> <span class="mh">0x50020000</span><span class="p">,</span> <span class="mh">0xC000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x180D</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x2C000</span><span class="p">,</span> <span class="mh">0x5002C000</span><span class="p">,</span> <span class="mh">0x4000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x180D</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x30000</span><span class="p">,</span> <span class="mh">0x50030000</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x180D</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x31000</span><span class="p">,</span> <span class="mh">0x50031000</span><span class="p">,</span> <span class="mh">0x2800</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1C0D</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x33800</span><span class="p">,</span> <span class="mh">0x50033800</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1C0D</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x34800</span><span class="p">,</span> <span class="mh">0x50034800</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1C0D</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x35800</span><span class="p">,</span> <span class="mh">0x50035800</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1C0D</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x36800</span><span class="p">,</span> <span class="mh">0x50036800</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1C0D</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x37800</span><span class="p">,</span> <span class="mh">0x50037800</span><span class="p">,</span> <span class="mh">0x5000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1C0D</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x3C800</span><span class="p">,</span> <span class="mh">0x5003C800</span><span class="p">,</span> <span class="mh">0x2B800</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1C0D</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x68000</span><span class="p">,</span> <span class="mh">0x50068000</span><span class="p">,</span> <span class="mh">0x18000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1C01</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x80000</span><span class="p">,</span> <span class="mh">0x50080000</span><span class="p">,</span> <span class="mh">0x60000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1C0D</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x10000000</span><span class="p">,</span> <span class="mh">0x10000000</span><span class="p">,</span> <span class="mh">0x10000000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x816</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x40100000</span><span class="p">,</span> <span class="mh">0x40100000</span><span class="p">,</span> <span class="mh">0x100000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xC16</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x40300000</span><span class="p">,</span> <span class="mh">0x40300000</span><span class="p">,</span> <span class="mh">0x100000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1C0E</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x40600000</span><span class="p">,</span> <span class="mh">0x40600000</span><span class="p">,</span> <span class="mh">0x100000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1C12</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x40200000</span><span class="p">,</span> <span class="mh">0x40200000</span><span class="p">,</span> <span class="mh">0x100000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xC16</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x40300000</span><span class="p">,</span> <span class="mh">0x40300000</span><span class="p">,</span> <span class="mh">0x100000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1C0E</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x40700000</span><span class="p">,</span> <span class="mh">0x40700000</span><span class="p">,</span> <span class="mh">0x100000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1C12</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x50100000</span><span class="p">,</span> <span class="mh">0x50100000</span><span class="p">,</span> <span class="mh">0x200000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1C02</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x50000000</span><span class="p">,</span> <span class="mh">0x50000000</span><span class="p">,</span> <span class="mh">0xE0000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1C02</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x40400000</span><span class="p">,</span> <span class="mh">0x40400000</span><span class="p">,</span> <span class="mh">0x100000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1C02</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x40000000</span><span class="p">,</span> <span class="mh">0x40000000</span><span class="p">,</span> <span class="mh">0x100000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xC16</span><span class="p">);</span>
    <span class="n">SetTransTable</span><span class="p">(</span><span class="mh">0x80000000</span><span class="p">,</span> <span class="mh">0x80000000</span><span class="p">,</span> <span class="mh">0x60000000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1C02</span><span class="p">);</span>

    <span class="cm">/* [...] */</span>
</code></pre></div>

<p><strong>Note:</strong> this <a href="https://sudonull.com/post/11570-Virtual-memory-in-ARMv7">link</a> provides a nice refresher on how page tables work on ARMv7 and can be useful to comprehend the operations performed in <code>SetTransTable</code>.</p>
<p>After reversing <code>SetTransTable</code>, it's now very easy to retrieve all details on the NPU memory mappings, as shown in the table below.</p>
<div class="tablewrapper"><table>
<thead>
<tr>
<th>Type</th>
<th>Virtual Address</th>
<th>Physical Address</th>
<th>Size</th>
<th>PXN</th>
<th>XN</th>
<th>NS</th>
<th>AP</th>
<th>B</th>
<th>C</th>
<th>S</th>
</tr>
</thead>
<tbody>
<tr>
<td>Short Desc.</td>
<td>0x00000000</td>
<td>0x50000000</td>
<td>0x0001d000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Writes at PL0 generate Permission faults</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x0001d000</td>
<td>0x5001d000</td>
<td>0x00003000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Writes at PL0 generate Permission faults</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00020000</td>
<td>0x50020000</td>
<td>0x0000c000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Writes at PL0 generate Permission faults</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x0002c000</td>
<td>0x5002c000</td>
<td>0x00004000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Writes at PL0 generate Permission faults</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00030000</td>
<td>0x50030000</td>
<td>0x00001000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Writes at PL0 generate Permission faults</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00031000</td>
<td>0x50031000</td>
<td>0x00002800</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00033800</td>
<td>0x50033800</td>
<td>0x00001000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00034800</td>
<td>0x50034800</td>
<td>0x00001000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00035800</td>
<td>0x50035800</td>
<td>0x00001000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00036800</td>
<td>0x50036800</td>
<td>0x00001000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00037800</td>
<td>0x50037800</td>
<td>0x00005000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x0003c800</td>
<td>0x5003c800</td>
<td>0x0002b800</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00068000</td>
<td>0x50068000</td>
<td>0x00018000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>Short Desc.</td>
<td>0x00080000</td>
<td>0x50080000</td>
<td>0x00060000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Section</td>
<td>0x10000000</td>
<td>0x10000000</td>
<td>0x10000000</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Writes at PL0 generate Permission faults</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>Section</td>
<td>0x40100000</td>
<td>0x40100000</td>
<td>0x00100000</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>Section</td>
<td>0x40300000</td>
<td>0x40300000</td>
<td>0x00100000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Section</td>
<td>0x40600000</td>
<td>0x40600000</td>
<td>0x00100000</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Full access</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>Section</td>
<td>0x40200000</td>
<td>0x40200000</td>
<td>0x00100000</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>Section</td>
<td>0x40300000</td>
<td>0x40300000</td>
<td>0x00100000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Section</td>
<td>0x40700000</td>
<td>0x40700000</td>
<td>0x00100000</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Full access</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>Section</td>
<td>0x50100000</td>
<td>0x50100000</td>
<td>0x00200000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>Section</td>
<td>0x50000000</td>
<td>0x50000000</td>
<td>0x000e0000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>Section</td>
<td>0x40400000</td>
<td>0x40400000</td>
<td>0x00100000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>Section</td>
<td>0x40000000</td>
<td>0x40000000</td>
<td>0x00100000</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Full access</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>Section</td>
<td>0x80000000</td>
<td>0x80000000</td>
<td>0x60000000</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Full access</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
</div><p>As you can see, there are very few sections that use software 
mitigations, which will come in handy when we will exploit the NPU in 
the next article.</p>
<h2 id="main-function">Main Function<a class="headerlink" href="#main-function" title="Permanent link">¶</a></h2>
<p>After configuring the NPU's address space and other CPU-related 
settings, let's analyze the boot process of the operating system, 
starting with <code>main</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">heap_init</span><span class="p">();</span>
    <span class="n">arm_init</span><span class="p">();</span>
    <span class="n">timers_init</span><span class="p">();</span>
    <span class="n">events_init</span><span class="p">();</span>
    <span class="n">semaphores_init</span><span class="p">();</span>
    <span class="n">scheduler_init</span><span class="p">();</span>
    <span class="n">comm_channels_init</span><span class="p">();</span>
    <span class="n">run_native_tasks</span><span class="p">(</span><span class="mh">0x37800</span><span class="p">);</span>

    <span class="cm">/* Should not be reached */</span>
    <span class="n">abort</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p><code>main</code> doesn't do much by itself other than calling all 
the initialization routines to configure the heap, timers, etc. We'll 
look at each of these functions, and the subsystems they initialize, in 
the following sections.</p>
<h2 id="heap">Heap<a class="headerlink" href="#heap" title="Permanent link">¶</a></h2>
<p>The heap is set up in the function <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x01_heap.c#L9"><code>heap_init</code></a>.
 The idea behind the initialization of the heap is pretty simple. To be 
able to allocate memory from this memory region, it first needs to be 
marked as freed. To do this, the OS defines the whole heap as <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x01_heap.c#L40">a chunk</a>. A heap chunk is based on the following structure:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">heap_chunk</span> <span class="p">{</span>
    <span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">heap_chunk</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>The OS then <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x01_heap.c#L97">sets the size</a> of this first chunk to the size of the whole heap (i.e. <code>HEAP_END_ADDR - HEAP_START_ADDR = 0x60000</code>), before finally freeing this chunk. This process is illustrated in the figure below.</p>
<p><a href="https://blog.impalabs.com/rsc/2103_reversing-samsung-npu/heap_init.png"><img alt="image" src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/heap_init.png"></a></p>
<p>After this initialization step, it's now possible to manage memory dynamically using functions such as <code>malloc</code> and <code>free</code>.</p>
<p>To allocate memory from the heap, <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x01_heap.c#L109"><code>malloc</code></a>
 iterates through the single-linked freelist to find the first chunk big
 enough to satisfy the size constraints of the allocation. Chunks are 
sorted using their address and if the chunk found is bigger than what 
the OS requested, it is split in two, returning a chunk with the 
requested size and creating a new chunk with what's remaining.</p>
<p>For example, if the OS calls <code>malloc(0x50)</code> and a chunk of size <code>0x80</code> is found in the freelist, two new chunks are created:</p>
<ul>
<li>one chunk of <code>0x50</code> bytes returned to the OS;</li>
<li>one chunk of <code>0x30</code> bytes linked back into the freelist.</li>
</ul>
<p><a href="https://blog.impalabs.com/rsc/2103_reversing-samsung-npu/heap_malloc.png"><img alt="image" src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/heap_malloc.png"></a></p>
<p>The opposite process is performed when the OS asks for memory to be freed. <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x01_heap.c#L162"><code>free</code></a>
 iterates through the freelist and looks for the first chunk that has an
 address lower than the one we want to insert to keep the list sorted by
 chunk addresses. If two chunks are adjacent, they get coalesced.</p>
<p><a href="https://blog.impalabs.com/rsc/2103_reversing-samsung-npu/heap_free.png"><img alt="image" src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/heap_free.png"></a></p>
<h2 id="caches-exceptions-and-interrupts">Caches, Exceptions and Interrupts<a class="headerlink" href="#caches-exceptions-and-interrupts" title="Permanent link">¶</a></h2>
<p>After the initialization of the heap, the next function called is <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x02_arm.c#L9"><code>arm_init</code></a>.</p>
<p><code>arm_init</code> starts by initializing the CPU caches with a call to <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x02_arm.c#L30"><code>init_caches</code></a>.
 It basically just retrieves some information about CPU caches and 
invalidates different memory regions to start from a clean state.</p>
<p><code>arm_init</code> then initializes the exceptions in <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x02_arm.c#L101"><code>init_exception</code></a>.
 The exception handlers referenced by the ARM exception vector table are
 only wrappers using function pointers to call the actual handlers. And,
 as you might have guessed, these function pointers are set in <code>init_exception</code>.</p>
<p>Finally, <code>arm_init</code> initializes the interrupts in <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x02_arm.c#L115"><code>init_interrupt</code></a>.
 Basically, it configures the ARM Global Interrupt Controller and resets
 all pending interrupts. During the rest of the initialization process, 
the OS registers and enables multiple interrupt handlers using the 
function <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x02_arm.c#L176"><code>request_irq</code></a>. Now, when an interrupt occurs, it goes through the relevant exception handler and reaches <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x02_arm.c#L272"><code>irq_fiq_handler</code></a>. This function then calls <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x02_arm.c#L296"><code>handle_isr_func</code></a> which retrieves the interrupt ID and calls the associated handler.</p>
<p><strong>Note:</strong> There are a lot of details omitted regarding the interactions with ARM's GIC which can be found in the comments of the <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x02_arm.c">reversed functions</a>.</p>
<h2 id="tasks">Tasks<a class="headerlink" href="#tasks" title="Permanent link">¶</a></h2>
<p>In this section, we deviate a bit from the initialization order of the <code>main</code>
 function. The reason is that all the components other than the heap are
 directly linked to tasks, which is why they are explained first.</p>
<p>NPU tasks are based on the following structure:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">task</span> <span class="p">{</span>
    <span class="n">u32</span> <span class="n">magic</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">stack_ptr</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">stack_start</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">stack_end</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">stack_size</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">state</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">unknown</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">priority</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
    <span class="n">u32</span> <span class="n">max_sched_slices</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">total_sched_slices</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">remaining_sched_slices</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">delay</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">list_head</span> <span class="n">tasks_list_entry</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">list_head</span> <span class="n">ready_list_entry</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">list_head</span> <span class="n">delayed_list_entry</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">list_head</span> <span class="n">pending_list_entry</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">workqueue</span><span class="o">*</span> <span class="n">wait_queue</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">unknown2</span><span class="p">[</span><span class="mi">60</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div>

<p><strong>Note:</strong> All lists described in this article, apart from heap chunks, are doubly linked lists.</p>
<p>All tasks share the address space of the kernel, have their own 
dedicated stack and their execution time is managed by a scheduler 
(which is explained in the following section).</p>
<p>A task is created using the function <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x03_tasks.c#L9"><code>create_task</code></a>. It adds the task to the global task list and configures several properties such as:</p>
<ul>
<li>its name;</li>
<li>its priority;</li>
<li>the function it will run;</li>
<li>its state (initially set to suspended);</li>
<li>its stack's size, start and end address;</li>
<li>various scheduling settings.</li>
</ul>
<p><code>create_task</code> also initializes the values written on the stack using <code>init_task_stack</code>.
 These values will be used when the task is scheduled by the OS to set 
the registers, the CPSR and resume the execution. The initial values are
 the following:</p>
<div class="tablewrapper"><table>
<thead>
<tr>
<th>Offset</th>
<th>Name</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>sp+<code>0x00</code></td>
<td>r4</td>
<td>0</td>
</tr>
<tr>
<td>sp+<code>0x04</code></td>
<td>r5</td>
<td>0</td>
</tr>
<tr>
<td>sp+<code>0x08</code></td>
<td>r6</td>
<td>0</td>
</tr>
<tr>
<td>sp+<code>0x0c</code></td>
<td>r7</td>
<td>0</td>
</tr>
<tr>
<td>sp+<code>0x10</code></td>
<td>r8</td>
<td>0</td>
</tr>
<tr>
<td>sp+<code>0x14</code></td>
<td>r9</td>
<td>0</td>
</tr>
<tr>
<td>sp+<code>0x18</code></td>
<td>r10</td>
<td>0</td>
</tr>
<tr>
<td>sp+<code>0x1C</code></td>
<td>r11</td>
<td>0</td>
</tr>
<tr>
<td>sp+<code>0x20</code></td>
<td>r0</td>
<td>0</td>
</tr>
<tr>
<td>sp+<code>0x24</code></td>
<td>r1</td>
<td>0</td>
</tr>
<tr>
<td>sp+<code>0x28</code></td>
<td>r2</td>
<td>0</td>
</tr>
<tr>
<td>sp+<code>0x2c</code></td>
<td>r3</td>
<td>0</td>
</tr>
<tr>
<td>sp+<code>0x30</code></td>
<td>r12</td>
<td>0</td>
</tr>
<tr>
<td>sp+<code>0x34</code></td>
<td>lr</td>
<td>0</td>
</tr>
<tr>
<td>sp+<code>0x38</code></td>
<td>pc</td>
<td><code>run_task</code></td>
</tr>
<tr>
<td>sp+<code>0x3c</code></td>
<td>cpsr</td>
<td>0x153</td>
</tr>
</tbody>
</table>
</div><p>When a task gets scheduled for the first time, its entry point is <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x03_tasks.c#L66"><code>run_task</code></a>. This function is a state machine that calls the task's handler, suspends it when its done and loops back again.</p>
<p>Once a task is running it's possible to resume or suspend it.</p>
<ul>
<li>Suspending a task is performed by calling <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x03_tasks.c#L93"><code>__suspend_task</code></a>.
 Depending on the current state of the task (i.e. ready/running, 
sleeping, pending), it gets deleted from the list it's currently in 
(i.e. ready, delayed, pending) and its state set to <code>TASK_SUSPENDED</code>. The type of list a task can belong to is explained in the following section dedicated to the scheduler.</li>
<li>Resuming a task is performed by calling <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x03_tasks.c#L150"><code>__resume_task</code></a>. This function simply adds the list to the ready list and sets its state to <code>TASK_READY</code>.</li>
</ul>
<h2 id="scheduling">Scheduling<a class="headerlink" href="#scheduling" title="Permanent link">¶</a></h2>
<p>Like most operating systems, the NPU OS can handle multitasking and 
decides which task to run using a scheduler. The scheduler is 
initialized in the function <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x04_scheduling.c#L9"><code>scheduler_init</code></a> and its state is tracked using the following structure:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">scheduler_state_t</span> <span class="p">{</span>
    <span class="n">u32</span> <span class="n">scheduler_stopped</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">forbid_scheduling</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">prio_grp1</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="n">u8</span> <span class="n">prio_grp2</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">8</span><span class="p">];</span>
    <span class="n">u8</span> <span class="n">prio_grp0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">list_head</span> <span class="n">tasks_list</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">list_head</span> <span class="n">delayed_list</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">list_head</span> <span class="n">ready_list</span><span class="p">[</span><span class="n">TASK_MAX_PRIORITY</span><span class="p">];</span>
    <span class="n">u32</span> <span class="n">unknown</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">nb_tasks</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">count_sched_slices</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p><code>scheduler_init</code> simply initializes the task lists, the priority group values and sets <code>scheduler_stopped</code>/<code>forbid_scheduling</code>
 to signify to the OS that it should not schedule tasks for the moment. 
But, before we can go any further, we need to explain what priority 
groups are, ready lists and, more generally, the scheduling algorithm.</p>
<h3 id="priority-groups">Priority Groups<a class="headerlink" href="#priority-groups" title="Permanent link">¶</a></h3>
<p>The scheduler implemented in the NPU is based on the priority 
associated with a task during its creation. For the NPU OS, a 
distinction should be made between the <em>priority value</em> of a task and its actual <em>priority</em>,
 since they are inverted: a high-priority task has a low priority value.
 Therefore finding the next task to schedule equates to finding the 
lowest priority task ready to run.</p>
<p>The lists of tasks ready to execute are stored in the scheduler's 
global state structure, with one ready list for each priority values 
(which goes from <code>0x00</code> to <code>0xff</code>).</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#define TASK_MAX_PRIORITY 0x100</span>

<span class="k">struct</span> <span class="nc">scheduler_state_t</span> <span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="k">struct</span> <span class="nc">list_head</span> <span class="n">ready_list</span><span class="p">[</span><span class="n">TASK_MAX_PRIORITY</span><span class="p">];</span>
    <span class="cm">/* [...] */</span>
<span class="p">};</span>
</code></pre></div>

<p>Now to be able to find the list in which the lowest priority task is,
 there are different solutions possible. A naive approach would be to 
iterate through all of these lists, find the first one that is non-empty
 and return the first task in it. The implementation used by Samsung is a
 bit different. To understand it, let's have a look at the function that
 adds a task into its ready list: <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x04_scheduling.c#L328"><code>__add_to_ready_list</code></a>.</p>
<p><code>__add_to_ready_list</code> takes the priority of the task we want to add into the ready list and splits it into three groups:</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* Computes the priority group values based on the task's priority */</span>
<span class="n">u8</span> <span class="n">grp0_val</span> <span class="o">=</span> <span class="n">priority</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span>
<span class="n">u8</span> <span class="n">grp1_val</span> <span class="o">=</span> <span class="p">(</span><span class="n">priority</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
<span class="n">u8</span> <span class="n">grp2_val</span> <span class="o">=</span> <span class="n">priority</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
</code></pre></div>

<p>If we have a priority of <code>77</code>, or <code>0b01001101</code> in binary, its value would be split as follows:</p>
<p><a href="https://blog.impalabs.com/rsc/2103_reversing-samsung-npu/scheduler_prio.png"><img alt="image" src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/scheduler_prio.png"></a></p>
<p>These values are then used to set bits in the three bitfields of <code>g_scheduler_state</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* Adds the current task's priority to the priority group values */</span>
<span class="n">g_scheduler_state</span><span class="p">.</span><span class="n">prio_grp0</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">grp0_val</span><span class="p">;</span>
<span class="n">g_scheduler_state</span><span class="p">.</span><span class="n">prio_grp1</span><span class="p">[</span><span class="n">grp0_val</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">grp1_val</span><span class="p">;</span>
<span class="n">g_scheduler_state</span><span class="p">.</span><span class="n">prio_grp2</span><span class="p">[</span><span class="n">grp0_val</span><span class="p">][</span><span class="n">grp1_val</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">grp2_val</span><span class="p">;</span>
</code></pre></div>

<p>Below is a visual representation of how these bitfields are modified 
when adding a task of priority 77 and then one of priority 153.</p>
<p><a href="https://blog.impalabs.com/rsc/2103_reversing-samsung-npu/scheduler_prio_groups.png"><img alt="image" src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/scheduler_prio_groups.png"></a></p>
<p>Now that it's clear how task priorities are referenced by the 
scheduler, let's detail the algorithm used to find the lowest priority 
encoded in these bitfields.</p>
<h3 id="scheduling-algorithm">Scheduling Algorithm<a class="headerlink" href="#scheduling-algorithm" title="Permanent link">¶</a></h3>
<p>To understand the algorithm, let's have a look at <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x04_scheduling.c#L173"><code>schedule_task</code></a>. We can see that the values in the bitfields are retrieved and then used as indices into <code>g_priority_table</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* Finds the priority of the next task to schedule */</span>
<span class="n">u32</span> <span class="n">prio_grp0_idx</span> <span class="o">=</span> <span class="n">g_scheduler_state</span><span class="p">.</span><span class="n">prio_grp0</span><span class="p">;</span>
<span class="n">u32</span> <span class="n">prio_grp0_val</span> <span class="o">=</span> <span class="n">g_priority_table</span><span class="p">[</span><span class="n">prio_grp0_idx</span><span class="p">];</span>
<span class="n">u32</span> <span class="n">prio_grp1_idx</span> <span class="o">=</span> <span class="n">g_scheduler_state</span><span class="p">.</span><span class="n">prio_grp1</span><span class="p">[</span><span class="n">prio_grp0_val</span><span class="p">];</span>
<span class="n">u32</span> <span class="n">prio_grp1_val</span> <span class="o">=</span> <span class="n">g_priority_table</span><span class="p">[</span><span class="n">prio_grp1_idx</span><span class="p">];</span>
<span class="n">u32</span> <span class="n">prio_grp2_idx</span> <span class="o">=</span> <span class="n">g_scheduler_state</span><span class="p">.</span><span class="n">prio_grp2</span><span class="p">[</span><span class="n">prio_grp0_val</span><span class="p">][</span><span class="n">prio_grp1_val</span><span class="p">];</span>
<span class="n">u32</span> <span class="n">prio_grp2_val</span> <span class="o">=</span> <span class="n">g_priority_table</span><span class="p">[</span><span class="n">prio_grp2_idx</span><span class="p">];</span>
</code></pre></div>

<p>The value we get back from this table, which is given below, is actually the index of the least significant set bit.</p>
<div class="codehilite"><pre><span></span><code><span class="n">u8</span> <span class="n">g_priority_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
    <span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
    <span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
    <span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
    <span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
    <span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
    <span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
    <span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
    <span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
    <span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
    <span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
    <span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
    <span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
    <span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
    <span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
    <span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>

<p>Assuming you have a value between <code>0x00</code> and <code>0x100</code>, such as <code>0xc8</code> for example, the value you get back at this index is <code>3</code>, because <code>0xc8 = 0b11001000</code> and the least significant bit set is at index <code>3</code>. Since the position of a given bit in <code>g_scheduler_state</code>'s
 bitfields is directly determined by the priority of a task, finding the
 least significant bit set allows us to extract and reconstruct the 
lowest priority value that can be scheduled.</p>
<p>Using this property, we are able to compute the priority of the next 
task to schedule, i.e. the one with the lowest priority value. Below is 
an example of this process with four tasks of priorities 54, 77, 153 and
 252. We can see that after applying the algorithm, we get back the 
lowest priority value, which is <code>54</code> in this case.</p>
<p><a href="https://blog.impalabs.com/rsc/2103_reversing-samsung-npu/scheduler_algo.png"><img alt="image" src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/scheduler_algo.png"></a></p>
<p>When the lowest priority value is found, <code>schedule_task</code> checks if it's lower than the priority of the currently running task, selects the corresponding ready list in <code>g_scheduler_state.ready_list</code> and runs the first task in that list.</p>
<h3 id="using-the-scheduler">Using the Scheduler<a class="headerlink" href="#using-the-scheduler" title="Permanent link">¶</a></h3>
<p>At this point, we have a good understanding of how the scheduler 
makes a decision. However, we still don't know what triggers the 
scheduler. The operating systems we are generally most familiar with use
 preemption to stop a task that has been running for too long. This is 
not the case for the NPU; as far as we know, there is no preemption and 
tasks have to yield the CPU explicitly for other tasks to run. This can 
be done in multiple ways, e.g. by making the process sleep, wait for an 
event, etc., however it requires the task in question to explicitly call
 these functions at some point, otherwise they would monopolize CPU 
time.</p>
<p>All the operations listed above call, at some point, the function <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x04_scheduling.c#L106"><code>schedule</code></a>. It is responsible for saving the context of the current task, call <code>schedule_task</code>
 (which was explained in the previous section) and, if the task to 
schedule is different from the current one, do a context switch.</p>
<p>The only parts of the scheduler left to explain are the different lists used to manage tasks.</p>
<h3 id="ready-list">Ready List<a class="headerlink" href="#ready-list" title="Permanent link">¶</a></h3>
<p>As explained previously, ready lists are an array of lists indexed by
 the priority of the tasks they hold. It's possible to add and remove a 
task from a ready list using <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x04_scheduling.c#L328"><code>__add_to_ready_list</code></a> and <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x04_scheduling.c#L366"><code>__del_from_ready_list</code></a>. In a nutshell, these functions update the priority groups from <code>g_scheduler_state</code> and add or remove the task from the <code>g_scheduler_state.ready_list</code>
 entry that corresponds to the priority of the task. They are simply an 
extension of the algorithm explained in the previous section.</p>
<h3 id="delayed-list">Delayed List<a class="headerlink" href="#delayed-list" title="Permanent link">¶</a></h3>
<p>On other operating systems, it is possible to make a process sleep 
for a given duration. This is what delayed lists in the NPU are for. To 
manage the passing of time and know when to wake up a task, the handler 
for the timer IRQ, that happens every timer tick, calls <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x04_scheduling.c#L261"><code>schedule_tick</code></a> which decrements tasks' delay by one. Timer ticks, and also scheduler time-slices, are 1ms long.</p>
<p>A task can be delayed using the function <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x04_scheduling.c#L536"><code>__add_to_delayed_list</code></a>. The idea is to add the task to <code>g_scheduler_state.delayed_list</code>,
 but it needs to be sorted by delay first. An important thing to note, 
is that tasks' delay in the delayed list are relative to each other. For
 example, if a task A is delayed for three timer ticks and a task B for 
five timer ticks, then A is added to the list with a delay of three, but
 B is added with a delay of two (since <code>3 + 2 = 5</code>). The figure below illustrates the process of adding a task to the delayed list.</p>
<p><a href="https://blog.impalabs.com/rsc/2103_reversing-samsung-npu/scheduler_delayed.png"><img alt="image" src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/scheduler_delayed.png"></a></p>
<p>Removing a task from the delayed list can be done in two ways.</p>
<ul>
<li>The first one is an explicit call to <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x04_scheduling.c#L623"><code>__del_from_delayed_list</code></a>
 and does not wait for the delay to finish on its own. It takes the task
 we want to wake up, adds its delay to the next one and removes it from 
the list.</li>
<li>The second method is waiting for the delay to reach zero. Every time <code>schedule_tick</code>
 is called, it decrements the delay of the first task in the delayed 
list by one, but it also checks if one or more tasks has reached a delay
 of zero (or less) to wake them up.</li>
</ul>
<h3 id="pending-list">Pending List<a class="headerlink" href="#pending-list" title="Permanent link">¶</a></h3>
<p>The pending list is used to reference tasks waiting for a specific event to occur (e.g. a lock waiting to be released).</p>
<p>Contrary to ready and delayed lists, pending lists are not part of the <code>g_scheduler_state</code>, but of a <code>workqueue</code> defined by the following structure:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">workqueue</span> <span class="p">{</span>
    <span class="n">u32</span> <span class="n">task</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">list_head</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">service</span><span class="p">;</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">obj</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p><code>workqueue</code>-s are associated with a specific object 
(semaphore or event) and, when a task is waiting for an action from one 
of these objects, it gets added to the pending list <code>struct list_head head</code>. This operation is performed by functions that ultimately call <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x04_scheduling.c#L416"><code>__add_to_pending_list</code></a>. In a pending list, tasks can be sorted by priority, but it depends on the value of the field <code>service</code> (0 = no sorting, 1 = sorting by priority). Removing a task can be done using <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x04_scheduling.c#L509"><code>__del_from_pending_list</code></a> which basically just unlinks the task from the pending list in question.</p>
<p>We will give a bit more details on how this list is used in the sections on semaphores and events.</p>
<h2 id="timers">Timers<a class="headerlink" href="#timers" title="Permanent link">¶</a></h2>
<p>Everything related to time originates from the function <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x05_timers.c#L9"><code>timer_irq_handler</code></a> which is called every 1ms.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span> <span class="nf">timer_irq_handler</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">time_tick</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">g_scheduler_state</span><span class="p">.</span><span class="n">scheduler_stopped</span> <span class="p">)</span>
        <span class="n">schedule_tick</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p><a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x05_timers.c#L21"><code>time_tick</code></a>
 increments the global ticks counter (which is used in debug messages 
for example), but also handles timers. Timers can potentially be used by
 the NPU to execute functions at regular intervals and/or at a given 
time. However, it doesn't seem to be the case with this version of the 
NPU, so we'll keep this section short and skip to the next part.</p>
<h2 id="events">Events<a class="headerlink" href="#events" title="Permanent link">¶</a></h2>
<p>Because the NPU interacts with other components and, to some extent, 
the user of the device, exchanges are inherently asynchronous. There 
needs to be a mechanism able to manage these types of communications.</p>
<p>To handle this, the NPU uses objects called <code>events</code>, which are defined by the following structure:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">event</span> <span class="p">{</span>
    <span class="n">u32</span> <span class="n">magic</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">_unk_0c</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">state</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">list_head</span> <span class="n">event_list_entry</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">list_head</span> <span class="n">waiting_list_entry</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">workqueue</span> <span class="n">wq</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>As we will see later, events are used to make a function wait for a 
specific event. For example, we don't know when a new message is sent to
 a mailbox. So instead of waiting actively in a loop, the OS makes the 
task sleep, adds it to a waiting list and, when the event actually 
occurs, takes it out of the waiting list to handle the incoming message.</p>
<p>Events are initialized in the function <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x06_events.c#L9"><code>events_init</code></a>,
 which configures the number of active events, pending and event lists, 
counts and event objects (which are directly stored in the global state <code>g_events_state</code>).</p>
<p>Creating a new event is made through a call to <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x06_events.c#L36"><code>__alloc_event</code></a>. The function looks for an empty spot in the <code>g_events_state.events</code> array and then:</p>
<ul>
<li>sets its ID (with a value passed as argument);</li>
<li>sets its state to <code>EVENT_READY</code>;</li>
<li>adds it to the global event list <code>g_events_state.event_list</code>;</li>
<li>updates <code>g_events_state</code>'s counts, flags, etc.;</li>
<li>initializes the event's workqueue.</li>
</ul>
<p>The freeing process is simply the opposite of <code>__alloc_event</code> and is implemented in <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x06_events.c#L80"><code>__free_event</code></a>. It deinitializes the workqueue and resets the event in <code>g_events_state</code>.</p>
<p>Regarding the usage of events, there are two functions implemented.</p>
<ul>
<li><a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x06_events.c#L249"><code>__wait_event</code></a>,
 as its name suggests, makes a task wait for a specific event to occur. 
This function simply takes the task currently running, removes it from 
the ready list and adds it to the pending list of the event's workqueue.
 Additionally, if it has not already been done, the event is added to 
the waiting list of the corresponding ID (i.e. <code>struct list_head event_waiting_lists[MAX_EVENT_IDS + 1]</code>). There can be multiple events using the same ID and, therefore, in the same waiting list.</li>
<li>The function used to signify that an event occurred is <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x06_events.c#L116"><code>__set_event_no_schedule</code></a>.
 It seems a bit more complex, but it's not really the case because most 
of the code is duplicated. The general idea is that the function takes 
the ID from the event and retrieves the waiting list associated with it 
in <code>g_events_state</code>. It then goes through each event from the waiting list and tries to wake up all tasks waiting on these events.</li>
</ul>
<p>A simplified representation of this wait/set process is given in the figure below.</p>
<p><a href="https://blog.impalabs.com/rsc/2103_reversing-samsung-npu/event_wait_set.png"><img alt="image" src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/event_wait_set.png"></a></p>
<h2 id="semaphores">Semaphores<a class="headerlink" href="#semaphores" title="Permanent link">¶</a></h2>
<p>Semaphores are used in operating systems to control the access to 
shared resources and to prevent issues such as race conditions. A count 
is associated with them and every time a task takes a semaphore, its 
count is reduced by one. When the count is zero, the next task that 
tries to take the semaphore has to wait for another task to give back 
theirs.</p>
<p>In the NPU, the global structure <code>g_semaphores_state</code> used by semaphores is defined by the following structure:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">semaphores_state_t</span> <span class="p">{</span>
    <span class="n">u32</span> <span class="n">nb_semaphores</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">list_head</span> <span class="n">semaphore_list</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p><a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x07_semaphores.c#L9"><code>semaphores_init</code></a> simply initializes the semaphore counts and the semaphore list. At this point, it's possible to create a new semaphore using <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x07_semaphores.c#L20"><code>__create_semaphore</code></a>.
 It initializes its workqueue, its count, its name and then adds it to 
the global semaphore list. Conversely, a semaphore is deleted using <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x07_semaphores.c#L50"><code>__delete_semaphore</code></a>, which deinitializes and cleans up the workqueue as well as the rest of the semaphore parameters.</p>
<p>The behavior of a semaphore is pretty similar to that of an event. When taking a semaphore using <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x07_semaphores.c#L79"><code>__down</code></a>,
 it simply decrements the count by one each call. But when the count is 
less than zero, it removes the current task from the ready list, adds it
 to the pending list of the semaphore's workqueue and schedules a new 
task. Giving back a semaphore with <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x07_semaphores.c#L110"><code>__up</code></a>
 works in a similar manner. If the semaphore's workqueue is empty, it 
means no tasks are waiting on the semaphore, so we can simply increment 
the count by one. However, if the list is not empty, then the task 
waiting needs to be woken up and added back to the ready list using <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x07_semaphores.c#L130"><code>__up_sema_no_schedule</code></a>.</p>
<h2 id="communication-channels">Communication Channels<a class="headerlink" href="#communication-channels" title="Permanent link">¶</a></h2>
<p>This section deals with the initialization of the communication 
channels between the NPU and the AP (i.e. the application processor 
running Android). However, some functions related to this part are 
either irrelevant, unused or we're simply not sure what they do. 
Thankfully, they're not too important for the overall understanding of 
what's going on.</p>
<p>The configuration takes place in the function <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x08_comms.c#L10"><code>comm_channels_init</code></a>. It starts with the initialization of the mailbox with a call to <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x08_comms.c#L50"><code>mailbox_init</code></a>.
 This function allocates the events and sets up the interrupt handlers 
to notify the system of incoming messages in the high and low priority 
mailboxes. The next step is to call <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x08_comms.c#L98"><code>cmdq_init</code></a> which configures the CMDQ (Command Queue?) subsystem by performing similar operations than <code>mailbox_init</code>.</p>
<p>The rest of <code>comm_channels_init</code> initializes other 
components, but we were not able to figure out what they do exactly or 
how they are used by the rest of the system.</p>
<h2 id="running-the-system">Running the System<a class="headerlink" href="#running-the-system" title="Permanent link">¶</a></h2>
<p>We're finally reaching the end of the initialization process. The 
last thing left to do, before effectively starting the system, is to 
configure the core tasks handling all interactions between the AP and 
the NPU. These tasks, in the context of the NPU, are called <em>native tasks</em> and are based on the following structure:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">native_task</span> <span class="p">{</span>
    <span class="n">u32</span> <span class="n">unknown</span><span class="p">[</span><span class="mh">0xc</span><span class="p">];</span>
    <span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="n">u32</span> <span class="n">priority</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">handler</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">max_sched_slices</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">stack_addr</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">stack_size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">task</span> <span class="n">task</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">unknown</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Native tasks are set up in the function <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x09_native_tasks.c#L9"><code>run_native_tasks</code></a> and there are eleven of them. Below is a table that summarizes most of this information.</p>
<div class="tablewrapper"><table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Priority</th>
<th>Sched Slices</th>
<th>Stack Base</th>
<th>Stack Size</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x00</code></td>
<td>__MON</td>
<td><code>0x00</code></td>
<td><code>0x64</code></td>
<td><code>0x37800</code></td>
<td><code>0x400</code></td>
</tr>
<tr>
<td><code>0x01</code></td>
<td>_IDLE</td>
<td><code>0xff</code></td>
<td><code>0x64</code></td>
<td><code>0x37c00</code></td>
<td><code>0x200</code></td>
</tr>
<tr>
<td><code>0x02</code></td>
<td>__LOW</td>
<td><code>0x14</code></td>
<td><code>0x64</code></td>
<td><code>0x37e00</code></td>
<td><code>0x800</code></td>
</tr>
<tr>
<td><code>0x03</code></td>
<td>_HIGH</td>
<td><code>0x0a</code></td>
<td><code>0x64</code></td>
<td><code>0x38600</code></td>
<td><code>0x400</code></td>
</tr>
<tr>
<td><code>0x04</code></td>
<td>_RSPS</td>
<td><code>0x09</code></td>
<td><code>0x64</code></td>
<td><code>0x38a00</code></td>
<td><code>0x400</code></td>
</tr>
<tr>
<td><code>0x05</code></td>
<td>__RPT</td>
<td><code>0x14</code></td>
<td><code>0x64</code></td>
<td><code>0x38e00</code></td>
<td><code>0x400</code></td>
</tr>
<tr>
<td><code>0x06</code></td>
<td>__IMM</td>
<td><code>0x0e</code></td>
<td><code>0x64</code></td>
<td><code>0x39200</code></td>
<td><code>0x800</code></td>
</tr>
<tr>
<td><code>0x07</code></td>
<td>__BAT</td>
<td><code>0x0f</code></td>
<td><code>0x64</code></td>
<td><code>0x39a00</code></td>
<td><code>0x800</code></td>
</tr>
<tr>
<td><code>0x08</code></td>
<td>JOBQ0</td>
<td><code>0x15</code></td>
<td><code>0x64</code></td>
<td><code>0x3a200</code></td>
<td><code>0x1000</code></td>
</tr>
<tr>
<td><code>0x09</code></td>
<td>JOBQ1</td>
<td><code>0x16</code></td>
<td><code>0x64</code></td>
<td><code>0x3b200</code></td>
<td><code>0x200</code></td>
</tr>
<tr>
<td><code>0x0A</code></td>
<td>JOBQ2</td>
<td><code>0x17</code></td>
<td><code>0x64</code></td>
<td><code>0x3b400</code></td>
<td><code>0x200</code></td>
</tr>
</tbody>
</table>
</div><p>For each native task structure, a call to <code>create_task</code> is made to effectively instantiate the associated tasks. <code>resume_task</code> then adds them to their respective ready lists before the final call to <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x04_scheduling.c#L47"><code>schedule_start</code></a>.</p>
<p>The function <code>schedule_start</code>:</p>
<ul>
<li>Finds the lowest priority value encoded in the priority groups (in this case 0);</li>
<li>Sets <code>g_scheduler_state.scheduler_stopped</code> and <code>g_scheduler_state.forbid_scheduling</code> to 0, to signify to the OS that scheduling is now possible;</li>
<li>Makes a context switch to the highest priority task (in this case, the monitor).</li>
</ul>
<p>We won't detail all of the native tasks in this article, but simply 
give a brief description to get a general idea of what they do.</p>
<ul>
<li><strong>Monitor:</strong> initializes the intrinsic lib used for 
neural computations, the IOE dispatcher (?), the NCP manager that 
handles objects sent by the AP and finally the mailboxes. It also checks
 every second that a task has not timed out.</li>
<li><strong>Idle Task:</strong> does nothing and is just used to fill in until another task is ready to run.</li>
<li><strong>High &amp; Low Priority Mailboxes:</strong> receive and handle requests from the AP.</li>
<li><strong>Response Task:</strong> answers the AP.</li>
<li><strong>Report Task:</strong> sends logs to the AP.</li>
<li><strong>Imm &amp; Bat Dispatchers:</strong> unfortunately we didn't take time to look at these and therefore don't know what they do.</li>
<li><strong>Job Queues:</strong> only print a debug message and return.</li>
</ul>
<p>In the next section, we give more details on the mailbox 
implementations and explain how we can interact with the NPU from the 
AP.</p>
<h1 id="interacting-with-the-npu">Interacting with the NPU<a class="headerlink" href="#interacting-with-the-npu" title="Permanent link">¶</a></h1>
<p>As we've seen in the previous sections, it's possible to send 
messages to the NPU using its mailboxes. However, we've not explained 
their implementations yet. Since, communication channels also have a 
part implemented in the Android kernel, we'll detail the steps taken by a
 request from the moment an ioctl is made up to the reception of a 
response from the NPU by the kernel.</p>
<h2 id="sharing-resources-between-the-kernel-and-the-npu">Sharing Resources Between the Kernel and the NPU<a class="headerlink" href="#sharing-resources-between-the-kernel-and-the-npu" title="Permanent link">¶</a></h2>
<p>Before we can talk about communication between the NPU and the AP, we
 need to explain how they are able to exchange data and, more 
specifically, how memory sharing works between these two chips.</p>
<p>We've already introduced earlier the function <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/soc/9830/npu-system-soc.c#L603"><code>init_iomem_area</code></a> which is responsible for performing this mapping. It parses the file <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/arch/arm64/boot/dts/exynos/exynos9830.dts#L15164"><code>arch/arm64/boot/dts/exynos/exynos9830.dts</code></a> and, more specifically, the part given below.</p>
<div class="codehilite"><pre><span></span><code><span class="nf">npu_exynos</span><span class="cm"> </span><span class="p">{</span>
    <span class="p">...</span>
    <span class="n">samsung</span><span class="p">,</span><span class="n">npumem-address</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x00</span> <span class="mh">0x17800000</span> <span class="mh">0x100000</span> <span class="mh">0x00</span> <span class="mh">0x17900000</span> <span class="mh">0x100000</span> <span class="mh">0x00</span> <span class="mh">0x17a00000</span> <span class="mh">0x100000</span> <span class="mh">0x00</span> <span class="mh">0x17b00000</span> <span class="mh">0x40000</span> <span class="mh">0x00</span> <span class="mh">0x17c00000</span> <span class="mh">0x100000</span> <span class="mh">0x00</span> <span class="mh">0x17d00000</span> <span class="mh">0x100000</span> <span class="mh">0x00</span> <span class="mh">0x17e00000</span> <span class="mh">0x100000</span> <span class="mh">0x00</span> <span class="mh">0x17f00000</span> <span class="mh">0x100000</span> <span class="mh">0x00</span> <span class="mh">0x1e00c000</span> <span class="mh">0x1000</span> <span class="mh">0x00</span> <span class="mh">0x1e00b000</span> <span class="mh">0x1000</span> <span class="mh">0x00</span> <span class="mh">0x10040100</span> <span class="mh">0x08</span> <span class="mh">0x00</span> <span class="mh">0x106f0000</span> <span class="mh">0x1000</span> <span class="mh">0x00</span> <span class="mh">0x179c0000</span> <span class="mh">0x10000</span> <span class="mh">0x00</span> <span class="mh">0x17ac0000</span> <span class="mh">0x10000</span> <span class="mh">0x00</span> <span class="mh">0x19400000</span> <span class="mh">0x200000</span> <span class="mh">0x00</span> <span class="mh">0x50000000</span> <span class="mh">0xe0000</span> <span class="mh">0x00</span> <span class="mh">0x50100000</span> <span class="mh">0x200000</span> <span class="mh">0x00</span> <span class="mh">0x50300000</span> <span class="mh">0x200000</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="n">samsung</span><span class="p">,</span><span class="n">npumem-names</span> <span class="o">=</span> <span class="s">"SFR_DNC</span><span class="se">\0</span><span class="s">SFR_NPUC0</span><span class="se">\0</span><span class="s">SFR_NPUC1</span><span class="se">\0</span><span class="s">TCUSRAM</span><span class="se">\0</span><span class="s">SFR_NPU0</span><span class="se">\0</span><span class="s">SFR_NPU1</span><span class="se">\0</span><span class="s">SFR_NPU2</span><span class="se">\0</span><span class="s">SFR_NPU3</span><span class="se">\0</span><span class="s">SFR_CORESIGHT</span><span class="se">\0</span><span class="s">SFR_STM</span><span class="se">\0</span><span class="s">SFR_MCT_G</span><span class="se">\0</span><span class="s">PWM</span><span class="se">\0</span><span class="s">MAILBOX0</span><span class="se">\0</span><span class="s">MAILBOX1</span><span class="se">\0</span><span class="s">IDPSRAM</span><span class="se">\0</span><span class="s">FW_DRAM</span><span class="se">\0</span><span class="s">FW_UNITTEST</span><span class="se">\0</span><span class="s">FW_LOG"</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span>
</code></pre></div>

<p>It extracts the memory region names from <code>samsung,npumem-names</code> as well as the corresponding mappings in <code>samsung,npumem-address</code>. The mappings are encoded following the structure given below:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">iomem_reg_t</span> <span class="p">{</span>
    <span class="n">u32</span> <span class="n">dummy</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">start</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Using the values from the file above, we get the following mappings:</p>
<div class="tablewrapper"><table>
<thead>
<tr>
<th>Name</th>
<th>Dummy</th>
<th>Start</th>
<th>Size</th>
</tr>
</thead>
<tbody>
<tr>
<td>SFR_DNC</td>
<td>0x00</td>
<td>0x17800000</td>
<td>0x100000</td>
</tr>
<tr>
<td>SFR_NPUC0</td>
<td>0x00</td>
<td>0x17900000</td>
<td>0x100000</td>
</tr>
<tr>
<td>SFR_NPUC1</td>
<td>0x00</td>
<td>0x17a00000</td>
<td>0x100000</td>
</tr>
<tr>
<td>TCUSRAM</td>
<td>0x00</td>
<td>0x17b00000</td>
<td>0x40000</td>
</tr>
<tr>
<td>SFR_NPU0</td>
<td>0x00</td>
<td>0x17c00000</td>
<td>0x100000</td>
</tr>
<tr>
<td>SFR_NPU1</td>
<td>0x00</td>
<td>0x17d00000</td>
<td>0x100000</td>
</tr>
<tr>
<td>SFR_NPU2</td>
<td>0x00</td>
<td>0x17e00000</td>
<td>0x100000</td>
</tr>
<tr>
<td>SFR_NPU3</td>
<td>0x00</td>
<td>0x17f00000</td>
<td>0x100000</td>
</tr>
<tr>
<td>SFR_CORESIGHT</td>
<td>0x00</td>
<td>0x1e00c000</td>
<td>0x1000</td>
</tr>
<tr>
<td>SFR_STM</td>
<td>0x00</td>
<td>0x1e00b000</td>
<td>0x1000</td>
</tr>
<tr>
<td>SFR_MCT_G</td>
<td>0x00</td>
<td>0x10040100</td>
<td>0x08</td>
</tr>
<tr>
<td>PWM</td>
<td>0x00</td>
<td>0x106f0000</td>
<td>0x1000</td>
</tr>
<tr>
<td>MAILBOX0</td>
<td>0x00</td>
<td>0x179c0000</td>
<td>0x10000</td>
</tr>
<tr>
<td>MAILBOX1</td>
<td>0x00</td>
<td>0x17ac0000</td>
<td>0x10000</td>
</tr>
<tr>
<td>IDPSRAM</td>
<td>0x00</td>
<td>0x19400000</td>
<td>0x200000</td>
</tr>
<tr>
<td>FW_DRAM</td>
<td>0x00</td>
<td>0x50000000</td>
<td>0xe0000</td>
</tr>
<tr>
<td>FW_UNITTEST</td>
<td>0x00</td>
<td>0x50100000</td>
<td>0x200000</td>
</tr>
<tr>
<td>FW_LOG</td>
<td>0x00</td>
<td>0x50300000</td>
<td>0x200000</td>
</tr>
</tbody>
</table>
</div><p>The one we're interested in here is <code>FW_DRAM</code>. It maps the NPU firmware in the first <code>0x80000</code> bytes and shared data in the remaining <code>0x60000</code>. When <code>init_iomem_area</code> iterates over the different mappings, once it reaches <code>FW_DRAM</code>, it calls the function <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/soc/9830/npu-system-soc.c#L705"><code>npu_memory_alloc_from_heap</code></a> to create a shared memory mapping between the kernel and the NPU.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">init_iomem_area</span><span class="p">(</span><span class="k">struct</span> <span class="nc">npu_system</span> <span class="o">*</span><span class="n">system</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="n">iomem_count</span> <span class="o">=</span> <span class="n">of_property_count_strings</span><span class="p">(</span>
            <span class="n">dev</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="p">,</span> <span class="s">"samsung,npumem-names"</span><span class="p">);</span>
    <span class="cm">/* [...] */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iomem_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">of_property_read_string_index</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="p">,</span>
                <span class="s">"samsung,npumem-names"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iomem_name</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="cm">/* [...] */</span>
    <span class="p">}</span>
    <span class="cm">/* [...] */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">of_property_read_u32_array</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="p">,</span> <span class="s">"samsung,npumem-address"</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">iomem_data</span><span class="p">,</span>
            <span class="n">iomem_count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">iomem_reg_t</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
    <span class="cm">/* [...] */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iomem_name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* [...] */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">init_data</span><span class="p">[</span><span class="n">di</span><span class="p">].</span><span class="n">heapname</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* [...] */</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">npu_memory_alloc_from_heap</span><span class="p">(</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="o">*</span><span class="n">bd</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">iomem_data</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">init_data</span><span class="p">[</span><span class="n">di</span><span class="p">].</span><span class="n">heapname</span><span class="p">);</span>
            <span class="cm">/* [...] */</span>
        <span class="p">}</span>
        <span class="cm">/* [...] */</span>
    <span class="p">}</span>
    <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<p><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/soc/9830/npu-system-soc.c#L777"><code>npu_memory_alloc_from_heap</code></a> then gets the IOMMU domain associated to the device before calling <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/soc/9830/npu-system-soc.c#L844"><code>iommu_map</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">npu_memory_alloc_from_heap</span><span class="p">(</span><span class="k">struct</span> <span class="nc">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">npu_memory_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">paddr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">heapname</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/* [...] */</span>
        <span class="k">struct</span> <span class="nc">iommu_domain</span> <span class="o">*</span><span class="n">domain</span> <span class="o">=</span> <span class="n">iommu_get_domain_for_dev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_map</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">npu_err</span><span class="p">(</span><span class="s">"fail(err %pad) in iommu_map</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">daddr</span><span class="p">);</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">p_err</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<p><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/iommu/iommu.c#L1553"><code>iommu_map</code></a> finally calls <code>domain-&gt;ops-&gt;map</code> which effectively maps the memory region between the NPU and the AP through the IOMMU.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">iommu_map</span><span class="p">(</span><span class="k">struct</span> <span class="nc">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iova</span><span class="p">,</span>
          <span class="n">phys_addr_t</span> <span class="n">paddr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/* [...] */</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">pgsize</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>
        <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<p>However, you might want to know what the domain is and the operations
 associated with it, and for this we have to dig a little bit deeper. 
The path from the initialization of the NPU device to the moment the 
domain is set is the following:</p>
<ul>
<li><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/main/drivers/vision/npu/core/npu-device.c#L739"><code>npu_device_init</code></a></li>
<li><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/include/linux/platform_device.h#L197"><code>platform_driver_register</code></a> (using <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/base/platform.c#L1154"><code>platform_bus_type</code></a>)</li>
<li><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/base/platform.c#L634"><code>__platform_driver_register</code></a></li>
<li><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/base/driver.c#L170"><code>driver_register</code></a></li>
<li><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/base/bus.c#L672"><code>bus_add_driver</code></a></li>
<li><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/base/dd.c#L914"><code>driver_attach</code></a></li>
<li><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/base/dd.c#L895"><code>__driver_attach</code></a></li>
<li><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/base/dd.c#L661"><code>driver_probe_device</code></a></li>
<li><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/base/dd.c#L483"><code>really_probe</code></a></li>
<li><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/kernel/dma/mapping.c#L337"><code>dma_configure</code></a> (using <code>.dma_configure</code> from <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/base/platform.c#L1154"><code>platform_bus_type</code></a>)</li>
<li><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/base/platform.c#L1138"><code>platform_dma_configure</code></a></li>
<li><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/of/device.c#L162"><code>of_dma_configure</code></a></li>
<li><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/iommu/of_iommu.c#L184"><code>of_iommu_configure</code></a></li>
<li><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/iommu/of_iommu.c#L121"><code>of_iommu_xlate</code></a> (using <code>.of_xlate</code> from <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/iommu/exynos-iommu.c#L1370"><code>exynos_iommu_ops</code></a>)</li>
<li><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/iommu/exynos-iommu.c#L1266"><code>exynos_iommu_of_xlate</code></a></li>
</ul>
<p><code>exynos_iommu_of_xlate</code> finds the domain associated with the driver based on a list of clients.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">exynos_iommu_of_xlate</span><span class="p">(</span><span class="k">struct</span> <span class="nc">device</span> <span class="o">*</span><span class="n">master</span><span class="p">,</span>
                 <span class="k">struct</span> <span class="nc">of_phandle_args</span> <span class="o">*</span><span class="n">spec</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">owner</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* [...] */</span>
        <span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf_client</span><span class="p">,</span>
                    <span class="o">&amp;</span><span class="n">exynos_client_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">master_np</span> <span class="o">==</span> <span class="n">master</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">domain</span> <span class="o">=</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">vmm_data</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">;</span>
                <span class="n">vmm_data</span> <span class="o">=</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">vmm_data</span><span class="p">;</span>
                <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
                <span class="n">kfree</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* [...] */</span>
        <span class="n">owner</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span><span class="p">;</span>
        <span class="n">owner</span><span class="o">-&gt;</span><span class="n">vmm_data</span> <span class="o">=</span> <span class="n">vmm_data</span><span class="p">;</span>
        <span class="n">owner</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">=</span> <span class="n">master</span><span class="p">;</span>
        <span class="cm">/* [...] */</span>
    <span class="p">}</span>
    <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<p>The clients of an IOMMU domain are defined in the device tree file in the field <code>domain-clients</code>. They reference the <code>phandle</code> of the components that are associated with this domain. For example, in <code>iommu-domain_dnc</code>, the clients are <code>0x162</code>and <code>0x163</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="nf">iommu-domain_dnc</span><span class="cm"> </span><span class="p">{</span>
    <span class="kr">compatible</span> <span class="o">=</span> <span class="s">"samsung,exynos-iommu-bus"</span><span class="p">;</span>
    <span class="o">#</span><span class="n">dma-address-cells</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x01</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="o">#</span><span class="n">dma-size-cells</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x01</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="n">dma-window</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x80000000</span> <span class="mh">0x50000000</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="n">domain-clients</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x162</span> <span class="mh">0x163</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p><code>0x163</code> corresponds to the <code>phandle</code> of the NPU.</p>
<div class="codehilite"><pre><span></span><code><span class="nf">npu_exynos</span><span class="cm"> </span><span class="p">{</span>
    <span class="p">...</span>
    <span class="kr">phandle</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x163</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>These values are parsed in the function <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/iommu/exynos-iommu.c#L1558"><code>exynos_iommu_create_domain</code></a> which also calls <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/iommu/exynos-iovmm.c#L764"><code>exynos_create_single_iovmm</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">exynos_iommu_create_domain</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">device_node</span> <span class="o">*</span><span class="n">domain_np</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

    <span class="n">for_each_compatible_node</span><span class="p">(</span><span class="n">domain_np</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">"samsung,exynos-iommu-bus"</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* [...] */</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">of_get_dma_window</span><span class="p">(</span><span class="n">domain_np</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d_size</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* [...] */</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">d_addr</span><span class="p">;</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">d_addr</span> <span class="o">+</span> <span class="n">d_size</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/* [...] */</span>
        <span class="k">while</span> <span class="p">((</span><span class="n">np</span> <span class="o">=</span> <span class="n">of_parse_phandle</span><span class="p">(</span><span class="n">domain_np</span><span class="p">,</span> <span class="s">"domain-clients"</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmm</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">vmm</span> <span class="o">=</span> <span class="n">exynos_create_single_iovmm</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
                                <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
                <span class="cm">/* [...] */</span>
                <span class="cm">/* HACK: Make one group for one domain */</span>
                <span class="n">domain</span> <span class="o">=</span> <span class="n">to_exynos_domain</span><span class="p">(</span><span class="n">vmm</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>
                <span class="n">vmm</span><span class="o">-&gt;</span><span class="n">group</span> <span class="o">=</span> <span class="n">iommu_group_alloc</span><span class="p">();</span>
                <span class="n">iommu_attach_group</span><span class="p">(</span><span class="n">vmm</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">vmm</span><span class="o">-&gt;</span><span class="n">group</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="cm">/* Relationship between domain and client is added. */</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">exynos_client_add</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">vmm</span><span class="p">);</span>
            <span class="cm">/* [...] */</span>
        <span class="p">}</span>
        <span class="cm">/* [...] */</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><code>exynos_create_single_iovmm</code> then calls <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/iommu/iommu.c#L1312"><code>iommu_domain_alloc</code></a> which is a wrapper for <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/iommu/iommu.c#L1290"><code>__iommu_domain_alloc</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">exynos_iovmm</span> <span class="o">*</span><span class="n">exynos_create_single_iovmm</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
                    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="n">vmm</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">=</span> <span class="n">iommu_domain_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">platform_bus_type</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">iommu_domain</span> <span class="o">*</span><span class="n">iommu_domain_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="nc">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">__iommu_domain_alloc</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">IOMMU_DOMAIN_UNMANAGED</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Finally, in <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/iommu/iommu.c#L1302"><code>__iommu_domain_alloc</code></a>, <code>domain-&gt;ops</code> is set to <code>platform_bus_type.iommu_ops</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="k">struct</span> <span class="nc">iommu_domain</span> <span class="o">*</span><span class="n">__iommu_domain_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="nc">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
                         <span class="kt">unsigned</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="n">domain</span><span class="o">-&gt;</span><span class="n">ops</span>  <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">iommu_ops</span><span class="p">;</span>
    <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<p><code>iommu_ops</code> is set <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/iommu/exynos-iommu.c#L1623"><code>exynos_iommu_init</code></a> with a call to <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/iommu/iommu.c#L1241"><code>bus_set_iommu</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">exynos_iommu_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">bus_set_iommu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">platform_bus_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exynos_iommu_ops</span><span class="p">);</span>
    <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="k">struct</span> <span class="nc">iommu_ops</span> <span class="n">exynos_iommu_ops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">domain_alloc</span> <span class="o">=</span> <span class="n">exynos_iommu_domain_alloc</span><span class="p">,</span>
    <span class="p">.</span><span class="n">domain_free</span> <span class="o">=</span> <span class="n">exynos_iommu_domain_free</span><span class="p">,</span>
    <span class="p">.</span><span class="n">attach_dev</span> <span class="o">=</span> <span class="n">exynos_iommu_attach_device</span><span class="p">,</span>
    <span class="p">.</span><span class="n">detach_dev</span> <span class="o">=</span> <span class="n">exynos_iommu_detach_device</span><span class="p">,</span>
    <span class="p">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">exynos_iommu_map</span><span class="p">,</span>
    <span class="p">.</span><span class="n">unmap</span> <span class="o">=</span> <span class="n">exynos_iommu_unmap</span><span class="p">,</span>
    <span class="p">.</span><span class="n">iova_to_phys</span> <span class="o">=</span> <span class="n">exynos_iommu_iova_to_phys</span><span class="p">,</span>
    <span class="p">.</span><span class="n">pgsize_bitmap</span> <span class="o">=</span> <span class="n">SECT_SIZE</span> <span class="o">|</span> <span class="n">LPAGE_SIZE</span> <span class="o">|</span> <span class="n">SPAGE_SIZE</span><span class="p">,</span>
    <span class="p">.</span><span class="n">of_xlate</span> <span class="o">=</span> <span class="n">exynos_iommu_of_xlate</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>

<p>After all this, we know that when <code>domain-&gt;ops-&gt;map</code> is called in <code>iommu_map</code>, it's <code>exynos_iommu_map</code> that is actually executed.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">iommu_map</span><span class="p">(</span><span class="k">struct</span> <span class="nc">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iova</span><span class="p">,</span>
          <span class="n">phys_addr_t</span> <span class="n">paddr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/* [...] */</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">domain</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">pgsize</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>
        <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<p>Now that our shared memory mapping has been created, we can start 
analyzing the path taken by a request originating from the kernel and 
sent to the NPU.</p>
<h2 id="from-the-kernel-to-the-npu">From the Kernel to the NPU<a class="headerlink" href="#from-the-kernel-to-the-npu" title="Permanent link">¶</a></h2>
<p>To illustrate the path taken by a request sent from a user, we will take the ioctl <code>VS4L_VERTEXIOC_S_FORMAT</code> as an example.</p>
<p>Ioctl handling starts in the function <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/vision-core/vision-ioctl.c#L445"><code>vertex_ioctl</code></a> and reaches, in our example, the case <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/vision-core/vision-ioctl.c#L485"><code>VS4L_VERTEXIOC_S_FORMAT</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">long</span> <span class="nf">vertex_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">vision_device</span> <span class="o">*</span><span class="n">vdev</span> <span class="o">=</span> <span class="n">vision_devdata</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="nc">vertex_ioctl_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">ioctl_ops</span><span class="p">;</span>

    <span class="cm">/* temp var to support each ioctl */</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="cm">/* [...] */</span>
        <span class="k">struct</span> <span class="nc">vs4l_format_list</span> <span class="n">vsf</span><span class="p">;</span>
        <span class="cm">/* [...] */</span>
    <span class="p">}</span> <span class="n">vs4l_kvar</span><span class="p">;</span>

    <span class="cm">/* [...] */</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="k">case</span> <span class="nl">VS4L_VERTEXIOC_S_FORMAT</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">get_vs4l_format64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vs4l_kvar</span><span class="p">.</span><span class="n">vsf</span><span class="p">,</span>
                <span class="p">(</span><span class="k">struct</span> <span class="nc">vs4l_format_list</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vision_err</span><span class="p">(</span><span class="s">"get_vs4l_format64 (%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">vertexioc_s_format</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vs4l_kvar</span><span class="p">.</span><span class="n">vsf</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="n">vision_err</span><span class="p">(</span><span class="s">"vertexioc_s_format (%d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

        <span class="n">put_vs4l_format64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vs4l_kvar</span><span class="p">.</span><span class="n">vsf</span><span class="p">,</span>
                <span class="p">(</span><span class="k">struct</span> <span class="nc">vs4l_format_list</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="cm">/* [...] */</span>
</code></pre></div>

<p><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/vision-core/vision-ioctl.c#L105"><code>get_vs4l_format64</code></a> simply retrieves the structure from userspace and checks that values are sane. The execution flow is then handed over to <code>ops-&gt;vertexioc_s_format</code>, which corresponds to the function <code>npu_vertex_s_format</code>.</p>
<p><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-vertex.c#L359"><code>npu_vertex_s_format</code></a> then calls <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-vertex.c#L415"><code>npu_session_NW_CMD_LOAD</code></a> when sending an outgoing request.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">npu_vertex_s_format</span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">vs4l_format_list</span> <span class="o">*</span><span class="n">flist</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flist</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">==</span> <span class="n">VS4L_DIRECTION_OT</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">npu_session_NW_CMD_LOAD</span><span class="p">(</span><span class="n">session</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">chk_nw_result_no_error</span><span class="p">(</span><span class="n">session</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NPU_ERR_NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vctx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">NPU_VERTEX_FORMAT</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">goto</span> <span class="n">p_err</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<p><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-session.c#L1420"><code>npu_session_NW_CMD_LOAD</code></a> passes the current session and command to <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-session.c#L1433"><code>npu_session_put_nw_req</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">npu_session_NW_CMD_LOAD</span><span class="p">(</span><span class="k">struct</span> <span class="nc">npu_session</span> <span class="o">*</span><span class="n">session</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">nw_cmd_e</span> <span class="n">nw_cmd</span> <span class="o">=</span> <span class="n">NPU_NW_CMD_LOAD</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">session</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">npu_err</span><span class="p">(</span><span class="s">"invalid session</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">profile_point1</span><span class="p">(</span><span class="n">PROBE_ID_DD_NW_RECEIVED</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nw_cmd</span><span class="p">);</span>
    <span class="n">session</span><span class="o">-&gt;</span><span class="n">nw_result</span><span class="p">.</span><span class="n">result_code</span> <span class="o">=</span> <span class="n">NPU_NW_JUST_STARTED</span><span class="p">;</span>
    <span class="n">npu_session_put_nw_req</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">nw_cmd</span><span class="p">);</span>
    <span class="n">wait_event</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">nw_result</span><span class="p">.</span><span class="n">result_code</span> <span class="o">!=</span> <span class="n">NPU_NW_JUST_STARTED</span><span class="p">);</span>
    <span class="n">profile_point1</span><span class="p">(</span><span class="n">PROBE_ID_DD_NW_NOTIFIED</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nw_cmd</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-session.c#L96"><code>npu_session_put_nw_req</code></a> fills the request object and passes it to <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-session.c#L114"><code>npu_ncp_mgmt_put</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">npu_session_put_nw_req</span><span class="p">(</span><span class="k">struct</span> <span class="nc">npu_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">nw_cmd_e</span> <span class="n">nw_cmd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">npu_nw</span> <span class="n">req</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span>
        <span class="p">.</span><span class="n">bound_id</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">sched_param</span><span class="p">.</span><span class="n">bound_id</span><span class="p">,</span>
        <span class="p">.</span><span class="n">npu_req_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">.</span><span class="n">result_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">session</span><span class="p">,</span>
        <span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">nw_cmd</span><span class="p">,</span>
        <span class="p">.</span><span class="n">ncp_addr</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">ncp_info</span><span class="p">.</span><span class="n">ncp_addr</span><span class="p">,</span>
        <span class="p">.</span><span class="n">magic_tail</span> <span class="o">=</span> <span class="n">NPU_NW_MAGIC_TAIL</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">session</span><span class="p">);</span>

    <span class="n">req</span><span class="p">.</span><span class="n">notify_func</span> <span class="o">=</span> <span class="n">get_notify_func</span><span class="p">(</span><span class="n">nw_cmd</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">npu_ncp_mgmt_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">npu_uerr</span><span class="p">(</span><span class="s">"npu_ncp_mgmt_put failed"</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-if-session-protodrv.c#L136"><code>npu_ncp_mgmt_put</code></a> pushes the request in the <code>FREE</code> fifo list.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">npu_ncp_mgmt_put</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">npu_nw</span> <span class="o">*</span><span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

    <span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">kfifo_in_spinlocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">.</span><span class="n">ncp_mgmt_list</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">.</span><span class="n">ncp_mgmt_lock</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">ncp_mgmt_callback</span><span class="p">)</span>  <span class="p">{</span>
            <span class="n">ctx</span><span class="p">.</span><span class="n">ncp_mgmt_callback</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-protodrv.c#L1302"><code>npu_protodrv_handler_nw_free</code></a> retrieves this request and pushes it into the <code>REQUESTED</code> list.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">npu_protodrv_handler_nw_free</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* [...] */</span>

    <span class="cm">/* Take a entry from FREE list, before access the queue */</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">entry</span> <span class="o">=</span> <span class="n">proto_nw_lsm</span><span class="p">.</span><span class="n">lsm_get_entry</span><span class="p">(</span><span class="n">FREE</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Is request available ? */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nw_mgmt_op_get_request</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* [...] */</span>
            <span class="cm">/* Move to REQUESTED state */</span>
            <span class="n">proto_nw_lsm</span><span class="p">.</span><span class="n">lsm_put_entry</span><span class="p">(</span><span class="n">REQUESTED</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
            <span class="n">handle_cnt</span><span class="o">++</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">finally</span><span class="p">;</span>
            <span class="cm">/* [...] */</span>
</code></pre></div>

<p><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-protodrv.c#L1579"><code>npu_protodrv_handler_nw_requested</code></a> retrieves the request and passes it to <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-protodrv.c#L1642"><code>__mbox_nw_ops_put</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">npu_protodrv_handler_nw_requested</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="cm">/* Process each element in REQUESTED list one by one */</span>
    <span class="n">LSM_FOR_EACH_ENTRY_IN</span><span class="p">(</span><span class="n">proto_nw_lsm</span><span class="p">,</span> <span class="n">REQUESTED</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span>
        <span class="cm">/* [...] */</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nw</span><span class="p">.</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* [...] */</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="cm">/* Conventional command -&gt; Publish message to mailbox */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">__mbox_nw_ops_put</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* Success */</span>
                <span class="n">proto_nw_lsm</span><span class="p">.</span><span class="n">lsm_move_entry</span><span class="p">(</span><span class="n">PROCESSING</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
                <span class="n">proc_handle_cnt</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">)</span> <span class="cm">/* End of LSM_FOR_EACH_ENTRY_IN */</span>
    <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<p><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-protodrv.c#L1557"><code>__mbox_nw_ops_put</code></a> is simply a wrapper for <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-protodrv.c#L1572"><code>nw_mbox_ops_put</code></a>, which calls <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-protodrv.c#L1251"><code>npu_nw_mbox_ops_put</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">__mbox_nw_ops_put</span><span class="p">(</span><span class="k">struct</span> <span class="nc">proto_req_nw</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">nw_mbox_ops_put</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
    <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">nw_mbox_ops_put</span><span class="p">(</span><span class="k">struct</span> <span class="nc">proto_req_nw</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">npu_nw_mbox_ops_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">npu_proto_drv</span><span class="p">.</span><span class="n">msgid_pool</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-if-protodrv-mbox2.c#L85"><code>npu_nw_mbox_ops_put</code></a> then calls <code>npu_if_protodrv_mbox_ops.nw_post_request</code> on the request, which resolves to <code>nw_req_manager</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">npu_nw_mbox_ops_put</span><span class="p">(</span><span class="k">struct</span> <span class="nc">msgid_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">proto_req_nw</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="cm">/* Generate mailbox message with given msgid and post it */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">npu_if_protodrv_mbox_ops</span><span class="p">.</span><span class="n">nw_post_request</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">npu_if_protodrv_mbox_ops</span><span class="p">.</span><span class="n">nw_post_request</span><span class="p">(</span><span class="n">msgid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">nw</span><span class="p">);</span>
    <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">npu_if_protodrv_mbox_ops</span> <span class="n">npu_if_protodrv_mbox_ops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="p">.</span><span class="n">nw_post_request</span> <span class="o">=</span> <span class="n">nw_req_manager</span><span class="p">,</span>
    <span class="cm">/* [...] */</span>
<span class="p">};</span>
</code></pre></div>

<p><a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/interface/hardware/npu-interface.c#L380"><code>nw_req_manager</code></a> formats our message and passes it to <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/interface/hardware/npu-interface.c#L455"><code>npu_set_cmd</code></a>. Notice that the request is meant to be sent in the low priority mailbox using the flag <code>NPU_MBOX_REQUEST_LOW</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">nw_req_manager</span><span class="p">(</span><span class="kt">int</span> <span class="n">msgid</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">npu_nw</span> <span class="o">*</span><span class="n">nw</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">nw</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="k">case</span> <span class="nl">NPU_NW_CMD_LOAD</span><span class="p">:</span>
        <span class="n">cmd</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">load</span><span class="p">.</span><span class="n">oid</span> <span class="o">=</span> <span class="n">nw</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">;</span>
        <span class="n">cmd</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">load</span><span class="p">.</span><span class="n">tid</span> <span class="o">=</span> <span class="n">nw</span><span class="o">-&gt;</span><span class="n">bound_id</span><span class="p">;</span>
        <span class="n">hdr_size</span> <span class="o">=</span> <span class="n">get_ncp_hdr_size</span><span class="p">(</span><span class="n">nw</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hdr_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">npu_info</span><span class="p">(</span><span class="s">"fail in get_ncp_hdr_size: (%zd)"</span><span class="p">,</span> <span class="n">hdr_size</span><span class="p">);</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">nw_req_err</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">cmd</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">hdr_size</span><span class="p">;</span>
        <span class="n">cmd</span><span class="p">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">nw</span><span class="o">-&gt;</span><span class="n">ncp_addr</span><span class="p">.</span><span class="n">daddr</span><span class="p">;</span>
        <span class="n">msg</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">COMMAND_LOAD</span><span class="p">;</span>
        <span class="n">msg</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">command</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="cm">/* [...] */</span>
    <span class="p">}</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">mid</span> <span class="o">=</span> <span class="n">msgid</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">npu_set_cmd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">NPU_MBOX_REQUEST_LOW</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">nw_req_err</span><span class="p">;</span>
    <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<p>Finally, <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/interface/hardware/npu-interface.c#L224"><code>npu_set_cmd</code></a> calls <code>mbx_ipc_put</code> which writes our message into shared memory and sends the interrupt to signify that a new message has been sent.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">npu_set_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="nc">message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">command</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cmdType</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">mbx_ipc_put</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">interface</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">interface</span><span class="p">.</span><span class="n">mbox_hdr</span><span class="o">-&gt;</span><span class="n">h2fctrl</span><span class="p">[</span><span class="n">cmdType</span><span class="p">],</span> <span class="n">msg</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">I_ERR</span><span class="p">;</span>
    <span class="n">__send_interrupt</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span>
<span class="nl">I_ERR</span><span class="p">:</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">-</span><span class="nl">ERESOURCE</span><span class="p">:</span>
        <span class="n">npu_warn</span><span class="p">(</span><span class="s">"No space left on mailbox : ret = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="n">npu_err</span><span class="p">(</span><span class="s">"mbx_ipc_put err with %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="handling-commands-in-the-npu">Handling Commands in the NPU<a class="headerlink" href="#handling-commands-in-the-npu" title="Permanent link">¶</a></h2>
<p>At this stage in the execution, we know that a message is waiting in 
the low priority mailbox and that an interrupt was sent to the NPU. In 
this section, we give a quick rundown of the mailbox controls, which are
 used by the NPU and the AP to communicate the position of their 
read/write cursors in the shared ring buffer. Then we detail how the 
request is received, parsed and handled by the NPU. And, finally, we 
explain how the response is sent back to the kernel.</p>
<h3 id="mailbox-controls">Mailbox Controls<a class="headerlink" href="#mailbox-controls" title="Permanent link">¶</a></h3>
<p>The implementation of the mailbox used by the NPU is divided into 
five segments. One is the header of the mailbox and the other four are 
ring buffers used by:</p>
<ul>
<li>the low priority mailbox;</li>
<li>the high priority mailbox;</li>
<li>the response mailbox;</li>
<li>the report mailbox.</li>
</ul>
<p>Its layout looks as follows:</p>
<p><a href="https://blog.impalabs.com/rsc/2103_reversing-samsung-npu/mailbox_layout.png"><img alt="image" src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/mailbox_layout.png"></a></p>
<p>The mailbox header is defined using the structure <code>struct mailbox_hdr</code> below and is used to keep track of the different read/write pointers into the ring buffers.</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">mailbox_hdr</span> <span class="p">{</span>
    <span class="n">u32</span> <span class="n">max_slot</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">debug_time</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">debug_code</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">log_level</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">log_dram</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="k">struct</span> <span class="nc">mailbox_ctrl</span> <span class="n">h2fctrl</span><span class="p">[</span><span class="n">MAILBOX_H2FCTRL_MAX</span><span class="p">];</span>
    <span class="k">struct</span> <span class="nc">mailbox_ctrl</span> <span class="n">f2hctrl</span><span class="p">[</span><span class="n">MAILBOX_F2HCTRL_MAX</span><span class="p">];</span>
    <span class="n">u32</span> <span class="n">totsize</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">version</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">signature2</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">signature1</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>The four mailbox controllers used by the NPU are initialized by the monitor with a call to the function <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L16"><code>mailbox_controller_init</code></a>.</p>
<p><code>mailbox_controller_init</code> first calls <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L79"><code>init_ncp_handlers</code></a> to initialize the handlers for the commands sent by the AP.</p>
<div class="codehilite"><pre><span></span><code><span class="n">u32</span> <span class="nf">mailbox_controller_init</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* [...] */</span>

    <span class="cm">/* Initializes the NCP handlers used for neural computation */</span>
    <span class="n">init_ncp_handlers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_ncp_handler_state</span><span class="p">);</span>

    <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<p>These handlers are set in the NCP handler global state structure <code>g_ncp_handler_state</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span> <span class="nf">init_ncp_handlers</span><span class="p">(</span><span class="k">struct</span> <span class="nc">ncp_handler_state_t</span> <span class="o">*</span><span class="n">ncp_handler_state</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">_unk_0x364</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

    <span class="cm">/* Sets all messages as unused */</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NB_MESSAGES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">messages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">inuse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Initializes the handlers for the request commands */</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncp_manager_load</span><span class="p">;</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncp_manager_unload</span><span class="p">;</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncp_manager_process</span><span class="p">;</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile_control</span><span class="p">;</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncp_manager_purge</span><span class="p">;</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncp_manager_powerdown</span><span class="p">;</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncp_manager_policy</span><span class="p">;</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">ut_main_func</span><span class="p">;</span>
    <span class="n">ncp_handler_state</span><span class="o">-&gt;</span><span class="n">handlers</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncp_manager_end</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><code>mailbox_controller_init</code> then calls <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L130"><code>mbx_dnward_init</code></a> twice for the high and low priority mailboxes, <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L157"><code>mbx_upward_init</code></a> for the response mailbox and <code>mbx_report_init</code> for the reporting mailbox.</p>
<div class="codehilite"><pre><span></span><code><span class="n">u32</span> <span class="nf">mailbox_controller_init</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* [...] */</span>

    <span class="cm">/* Initializes the low priority mailbox */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">mbx_dnward_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_mailbox_h2fctrl_lpriority</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">g_mailbox_hdr</span><span class="p">.</span><span class="n">h2fctrl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sgmt_ofs</span><span class="p">,</span> <span class="mh">0x80000</span><span class="p">);</span>

    <span class="cm">/* Initializes the high priority mailbox */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">mbx_dnward_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_mailbox_h2fctrl_hpriority</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">g_mailbox_hdr</span><span class="p">.</span><span class="n">h2fctrl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">sgmt_ofs</span><span class="p">,</span> <span class="mh">0x80000</span><span class="p">);</span>

    <span class="cm">/* Initializes the response mailbox */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">mbx_upward_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_mailbox_f2hctrl_response</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">g_mailbox_hdr</span><span class="p">.</span><span class="n">f2hctrl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sgmt_ofs</span><span class="p">,</span> <span class="mh">0x80000</span><span class="p">);</span>

    <span class="cm">/* Initializes the report mailbox */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">mbx_report_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_mailbox_f2hctrl_report</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">g_mailbox_hdr</span><span class="p">.</span><span class="n">f2hctrl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">sgmt_ofs</span><span class="p">,</span> <span class="mh">0x80000</span><span class="p">);</span>

    <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<p>In a nutshell, these functions configure control values, lists of 
messages and events associated to the corresponding mailboxes. These 
different settings are detailed in the following sections.</p>
<h3 id="downward-mailboxes-receiving-messages-from-the-ap">Downward Mailboxes: Receiving Messages From the AP<a class="headerlink" href="#downward-mailboxes-receiving-messages-from-the-ap" title="Permanent link">¶</a></h3>
<p>Downward mailboxes receive and handle incoming requests from the AP. 
The handling of messages is the same for the low and high priority 
mailbox, which is why we take the low priority one to illustrate the 
explanations in this section. These mailboxes are based on the following
 structure:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">mailbox_dnward</span> <span class="p">{</span>
    <span class="n">u32</span> <span class="n">event_id_off</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">event</span><span class="o">*</span> <span class="n">event</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">mailbox_ctrl</span> <span class="o">*</span><span class="n">hctrl</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">mailbox_ctrl</span> <span class="n">fctrl</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Request handling starts in the mailbox task handler:</p>
<ul>
<li><a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L263"><code>TASK_mailbox_lowpriority</code></a>. This function is an infinite loop that calls two functions:</li>
<li><a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L327"><code>mbx_dnward_get</code></a>: to create a message object from the values found in the mailbox.</li>
<li><a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L438"><code>mbx_msghub_req</code></a>: to handle the request and send the message to the response mailbox.</li>
</ul>
<p>In <code>mbx_dnward_get</code> it waits for the event to be set, meaning that a new message is available in the mailbox, before calling <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L395"><code>mbx_ipc_get_msg</code></a>. This function creates a new message object with the value sent by the AP.</p>
<p>Another check performed by the NPU to verify that a message is indeed available, is to check the values in <code>struct mailbox_ctrl</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">mailbox_ctrl</span> <span class="p">{</span>
    <span class="n">u32</span> <span class="n">sgmt_ofs</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">sgmt_len</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">wptr</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">rptr</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p><code>hctrl</code> is the state of the host and <code>fctrl</code> 
the state of the firmware. These structures also store both the read and
 write pointers in the mailbox's ring buffer. In the case of a message 
sent by the AP, when both the read pointer of the firmware and the write
 pointer of the host point to the same location, then it means that 
there is no new message, all requests have already been handled because 
the firmware "caught up" to the host. However, if the host has sent a 
message, but the firmware hasn't got the chance to handle it yet, then 
it means the host is ahead of the firmware, i.e. its write pointer 
points to a location after the one pointed to by the read pointer of the
 firmware. The same scenario applies when it's a message sent by the 
NPU. Below is an illustration of this process.</p>
<p><a href="https://blog.impalabs.com/rsc/2103_reversing-samsung-npu/mailbox_ring_buffers.png"><img alt="image" src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/mailbox_ring_buffers.png"></a></p>
<p>Messages in the mailbox are divided into two parts:</p>
<ul>
<li>a header following the format of <code>struct message</code>;</li>
<li>a payload.</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">message</span> <span class="p">{</span>
    <span class="n">u32</span> <span class="n">magic</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">mid</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">command</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">length</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">self</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p><code>length</code> represents the size of the payload and <code>data</code> its offset from the beginning of the mailbox's segment. For example, the low priority mailbox segment is at address <code>0x80000-0x1400 = 0x7ec00</code>. If a message <code>data</code> in the low priority mailbox is at offset <code>0x60</code>, then the address of the payload is <code>0x7ec60</code>.</p>
<p>The message extracted is then passed to <code>mbx_msghub_req</code>, 
which is going to retrieve the command from the message and call the 
corresponding NCP handler. This handler performs, somewhere down the 
line, the actual neural processing. However, this part won't be 
explained in this article. One thing to note though, is that all 
handlers call the following functions:</p>
<ul>
<li>
<p><a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L891"><code>mbx_msghub_inp</code></a>: at the beginning of the handler to set the state of the message from <code>RESPONSE_READY</code> to <code>RESPONSE_IN_PROGRESS</code>;</p>
</li>
<li>
<p><a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L917"><code>mbx_msghub_res</code></a>: at the end of the handler, to fill the response with the resulting values.</p>
</li>
</ul>
<p>The result of an operation is stored in a <code>struct ncp_message</code> if everything went as expected or in a <code>struct ncp_error</code> if an error occured. Since these two structures are pretty similar, only <code>ncp_message</code> is given below:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">ncp_message</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">message</span> <span class="n">msg</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">message</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">mailbox_dnward</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">sgmt_cursor</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">_unk_38</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">_unk_3c</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">_unk_40</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">_unk_44</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">_unk_48</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">_unk_4c</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">_unk_50</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">_unk_58</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">_unk_5c</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">state</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">_unk_64</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>In both cases, the resulting response is passed to the function <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L771"><code>mbx_upward_issue</code></a>,
 which is going to add the result to the list of pending responses to 
send to the AP. We'll get back to this function in the next section.</p>
<h3 id="upward-mailbox-sending-messages-to-the-ap">Upward Mailbox: Sending Messages to the AP<a class="headerlink" href="#upward-mailbox-sending-messages-to-the-ap" title="Permanent link">¶</a></h3>
<p>Now that our request has been handled and its result is available, we
 can detail the final steps needed to send the response back to the 
kernel. The mailbox responsible for this operation is the <em>response mailbox</em> which uses the structure given below to keep track of its state.</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">mailbox_upward</span> <span class="p">{</span>
    <span class="n">u32</span> <span class="n">event_id_off</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">event</span><span class="o">*</span> <span class="n">event</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">mailbox_ctrl</span> <span class="o">*</span><span class="n">hctrl</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">response</span> <span class="n">responses</span><span class="p">[</span><span class="n">NB_MESSAGES</span><span class="p">];</span>
    <span class="k">struct</span> <span class="nc">response_list</span> <span class="n">available</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">response_list</span> <span class="n">pending</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>The two lists in this structure, <code>available</code> and <code>pending</code>, are used to reference:</p>
<ul>
<li>available reponses that can be used to store a result;</li>
<li>pending responses that are waiting to be sent to the kernel.</li>
</ul>
<p>To add a reponse to the pending list, the function <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L771"><code>mbx_upward_issue</code></a>
 is used. It takes an available response object, from the available 
list, attaches the result to it and adds it to the pending list with <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L822"><code>add_to_rsp_list</code></a>. Finally it notifies the response task that a new message is available with <code>__set_event</code>.</p>
<p>We've seen before that the response task's handler is <a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L540"><code>TASK_mailbox_response</code></a>. It's an infinite loop that calls three functions.</p>
<ul>
<li><a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L581"><code>mbx_upward_get</code></a>: it waits for a response with <code>wait_event</code> and, when one is available, takes it from the pending list and retrieves the original request's result from it.</li>
<li><a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L630"><code>mbx_dnward_put</code></a>: updates the host's read pointer to point to the next unhandled message.</li>
<li><a href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/reverse/0x0a_mailbox.c#L702"><code>mbx_upward_put</code></a>: writes the response and copies the payload into the response mailbox. It also updates the host's write pointer.</li>
</ul>
<h2 id="from-the-npu-back-to-the-kernel">From the NPU Back to the Kernel<a class="headerlink" href="#from-the-npu-back-to-the-kernel" title="Permanent link">¶</a></h2>
<p>We're finally at the stage where the result has been sent and is 
ready to be handled by the kernel. This section backtracks the path 
taken by the reponse all the way back to the original request.</p>
<p>The mailbox is probed by the function <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/interface/hardware/npu-interface.c#L527"><code>nw_rslt_manager</code></a>
 to check whether or not a new message has arrived. To do so, it looks 
at the values in the mailbox control structure we presented earlier.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">nw_rslt_manager</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">ret_msgid</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">npu_nw</span> <span class="o">*</span><span class="n">nw</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">mbx_ipc_peek_msg</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">interface</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">interface</span><span class="p">.</span><span class="n">mbox_hdr</span><span class="o">-&gt;</span><span class="n">f2hctrl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
    <span class="cm">/* [...] */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">mbx_ipc_get_msg</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">interface</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">interface</span><span class="p">.</span><span class="n">mbox_hdr</span><span class="o">-&gt;</span><span class="n">f2hctrl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
    <span class="cm">/* [...] */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">mbx_ipc_get_cmd</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">interface</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">interface</span><span class="p">.</span><span class="n">mbox_hdr</span><span class="o">-&gt;</span><span class="n">f2hctrl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
    <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<p><code>nw_rslt_manager</code> is actually a callback that is called in the function  <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-if-protodrv-mbox2.c#L51"><code>npu_nw_mbox_ops_get</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">npu_if_protodrv_mbox_ops</span> <span class="n">npu_if_protodrv_mbox_ops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="p">.</span><span class="n">nw_get_result</span> <span class="o">=</span> <span class="n">nw_rslt_manager</span><span class="p">,</span>
    <span class="cm">/* [...] */</span>
<span class="p">};</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="kt">int</span> <span class="nf">npu_nw_mbox_ops_get</span><span class="p">(</span><span class="k">struct</span> <span class="nc">msgid_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">proto_req_nw</span> <span class="o">**</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">npu_if_protodrv_mbox_ops</span><span class="p">.</span><span class="n">nw_get_result</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">npu_if_protodrv_mbox_ops</span><span class="p">.</span><span class="n">nw_get_result</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msgid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nw</span><span class="p">);</span>
    <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<p>The call to <code>npu_nw_mbox_ops_get</code> comes from the wrapper <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-protodrv.c#L1245"><code>nw_mbox_ops_get</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">nw_mbox_ops_get</span><span class="p">(</span><span class="k">struct</span> <span class="nc">proto_req_nw</span> <span class="o">**</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">npu_nw_mbox_ops_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">npu_proto_drv</span><span class="p">.</span><span class="n">msgid_pool</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Then we can see that <code>nw_mbox_ops_get</code> comes originates from <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-protodrv.c#L1691"><code>npu_protodrv_handler_nw_processing</code></a>. This functions puts the reponse into the <code>COMPLETED</code> queue.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span>  <span class="nf">npu_protodrv_handler_nw_processing</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* [...] */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">nw_mbox_ops_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* [...] */</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="cm">/* Result code already set on nw_mbox_ops_get() -&gt; Just change its state */</span>
            <span class="n">proto_nw_lsm</span><span class="p">.</span><span class="n">lsm_move_entry</span><span class="p">(</span><span class="n">COMPLETED</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
            <span class="n">handle_cnt</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/* [...] */</span>
    <span class="p">}</span>
    <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<p>Finally, <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-protodrv.c#L1772"><code>npu_protodrv_handler_nw_completed</code></a> is called to handle the response in the <code>COMPLETED</code> list. If everything went as expected, it will run the callback that was previously set in <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-session.c#L112"><code>npu_session_put_nw_req</code></a> with a call to <a href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-protodrv.c#L1175"><code>nw_mgmt_op_put_result</code></a>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">npu_protodrv_handler_nw_completed</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">handle_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">entryCnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="cm">/* For trace */</span>
    <span class="k">struct</span> <span class="nc">proto_req_nw</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">session_ref_entry</span> <span class="o">*</span><span class="n">session_ref_entry</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">transition</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">stat_buf</span><span class="p">[</span><span class="n">TIME_STAT_BUF_LEN</span><span class="p">];</span>

    <span class="cm">/* Process each element in REQUESTED list one by one */</span>
    <span class="n">LSM_FOR_EACH_ENTRY_IN</span><span class="p">(</span><span class="n">proto_nw_lsm</span><span class="p">,</span> <span class="n">COMPLETED</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span>
                <span class="cm">/* [...] */</span>
                <span class="k">switch</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nw</span><span class="p">.</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">case</span> <span class="nl">NPU_NW_CMD_LOAD</span><span class="p">:</span>
                    <span class="cm">/* [...] */</span>
                    <span class="n">transition</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="cm">/* [...] */</span>
        <span class="p">}</span>
        <span class="cm">/* Post result if processing can be completed */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">transition</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* [...] */</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nw_mgmt_op_put_result</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">npu_uinfo</span><span class="p">(</span><span class="s">"(COMPLETED)NW: notification sent result(0x%08x)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nw</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">nw</span><span class="p">.</span><span class="n">result_code</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="cm">/* [...] */</span>
        <span class="p">}</span>
    <span class="p">)</span> <span class="cm">/* End of LSM_FOR_EACH_ENTRY_IN */</span>
    <span class="cm">/* [...] */</span>
<span class="p">}</span>
</code></pre></div>

<p>This callback notifies the driver that the response is ready and that
 the user can now access the result of the computation, thus ending the 
transaction between the kernel and the NPU.</p>
<h1 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">¶</a></h1>
<p>In this article, from a single binary we've managed to get a pretty 
good understanding of the operating system implemented by Samsung for 
their Neural Processing Unit. There is still a lot of ground to cover, 
such as NCP handlers or neural computation routines in general, but at 
least we know the internals of the core components of the OS as well as 
how it interacts with the Android kernel. The next article in this 
series will highlight some vulnerabilities we found and exploited in the
 NPU to attack the kernel.</p>
<h1 id="references">References<a class="headerlink" href="#references" title="Permanent link">¶</a></h1>
<ul>
<li><em>Exynos</em> - Wikipedia<ul>
<li><a href="https://en.wikipedia.org/wiki/Exynos">https://en.wikipedia.org/wiki/Exynos</a></li>
</ul>
</li>
<li><em>Samsung NPU (Neural Processing Unit) memory corruption in shared memory parsing</em> - Project Zero's Bug Tracker<ul>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2073">https://bugs.chromium.org/p/project-zero/issues/detail?id=2073</a></li>
</ul>
</li>
<li><em>SM-G980F G980FXXS5CTL5 Firmware</em> - SamMobile<ul>
<li><a href="https://www.sammobile.com/samsung/galaxy-s20/firmware/SM-G980F/XEF/download/G980FXXS5CTL5/1117440/">https://www.sammobile.com/samsung/galaxy-s20/firmware/SM-G980F/XEF/download/G980FXXS5CTL5/1117440/</a></li>
</ul>
</li>
<li><em>Mobile Phone Source Code</em> - Samsung Open Source<ul>
<li><a href="https://opensource.samsung.com/uploadList?menuItem=mobile&amp;classification1=mobile_phone">https://opensource.samsung.com/uploadList?menuItem=mobile&amp;classification1=mobile_phone</a></li>
</ul>
</li>
</ul>
</span>
<!-- Blogpost content end ================================================= -->

</span>

            </div>

            <!-- Copyright & Links to social media -->
            <div id="copyright">
                <div id="links-social" class="columns is-centered">
                    <div class="column is-narrow is-full-mobile">
                        <a href="https://impalabs.com/">
                            <img src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/impalabs.svg" alt="Impalabs icon" width="30px" height="30px">&nbsp;Website
                        </a>
                        <a href="https://twitter.com/the_impalabs">
                            <img src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/twitter.svg" alt="Twitter icon" width="30px" height="30px">&nbsp;Twitter
                        </a>
                    </div>
                    <div class="column is-narrow is-full-mobile">
                        <a href="https://linkedin.com/company/impalabs">
                            <img src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/linkedin.svg" alt="Linkedin icon" width="30px" height="30px">&nbsp;LinkedIn
                        </a>
                        <a href="https://github.com/impalabs">
                            <img src="2021%20-%20%22Reversing%20and%20Exploiting%20Samsung's%20NPU%22%20by%20Maxime%20Peterlin%20part%201_files/github.svg" alt="Github icon" width="30px" height="30px">&nbsp;GitHub
                        </a>
                    </div>
                </div>
                <p class="copyright-text">Copyright © Impalabs 2021</p>
            </div>
        </div>
    </section>


</body></html>