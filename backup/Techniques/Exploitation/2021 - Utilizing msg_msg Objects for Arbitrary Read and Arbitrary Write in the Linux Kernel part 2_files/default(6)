// API callback
random_posts({"version":"1.0","encoding":"UTF-8","feed":{"xmlns":"http://www.w3.org/2005/Atom","xmlns$openSearch":"http://a9.com/-/spec/opensearchrss/1.0/","xmlns$blogger":"http://schemas.google.com/blogger/2008","xmlns$georss":"http://www.georss.org/georss","xmlns$gd":"http://schemas.google.com/g/2005","xmlns$thr":"http://purl.org/syndication/thread/1.0","id":{"$t":"tag:blogger.com,1999:blog-8814147965526194982"},"updated":{"$t":"2021-11-30T16:35:33.972-08:00"},"title":{"type":"text","$t":"Will's Root"},"subtitle":{"type":"html","$t":"Pentesting, CTFs, and Writeups"},"link":[{"rel":"http://schemas.google.com/g/2005#feed","type":"application/atom+xml","href":"https:\/\/www.willsroot.io\/feeds\/posts\/default"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default?alt=json-in-script\u0026start-index=5\u0026max-results=1"},{"rel":"alternate","type":"text/html","href":"https:\/\/www.willsroot.io\/"},{"rel":"hub","href":"http://pubsubhubbub.appspot.com/"},{"rel":"previous","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default?alt=json-in-script\u0026start-index=4\u0026max-results=1"},{"rel":"next","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default?alt=json-in-script\u0026start-index=6\u0026max-results=1"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"generator":{"version":"7.00","uri":"http://www.blogger.com","$t":"Blogger"},"openSearch$totalResults":{"$t":"54"},"openSearch$startIndex":{"$t":"5"},"openSearch$itemsPerPage":{"$t":"1"},"entry":[{"id":{"$t":"tag:blogger.com,1999:blog-8814147965526194982.post-3718504721840392190"},"published":{"$t":"2021-07-12T17:43:00.015-07:00"},"updated":{"$t":"2021-07-12T18:19:41.381-07:00"},"title":{"type":"text","$t":"RedpwnCTF 2021 Chromium SBX Tasks Writeup (Empires and Deserts)"},"content":{"type":"html","$t":"\u003Cp\u003EThis weekend, I participated in RedpwnCTF with my team Starrust Crusaders under the alias \"The Static Lifetime Society\", coming in second place overall. Since this was my first time doing a Chromium SBX challenge, I thought it would be a good idea to make a writeup. I'm still relatively unfamiliar with Mojo concepts and sbx escape, so feel free to point out any mistakes I make.\u003C\/p\u003E\u003Cp\u003EHere are some relevant resources I used to help me understand Chromium's architecture and sandbox escape techniques. I would recommend giving them a read before continuing.\u003C\/p\u003E\u003Cp\u003E\u003Ca href=\"https:\/\/chromium.googlesource.com\/chromium\/src\/+\/refs\/heads\/main\/docs\/mojo_and_services.md\" target=\"_blank\"\u003EIntro to Mojo\u003C\/a\u003E\u003C\/p\u003E\u003Cp\u003E\u003Ca href=\"https:\/\/robertchen.cc\/blog\/2021\/07\/07\/sbx-intro\" target=\"_blank\"\u003ENotDeGhost's Intro Post about SBX\u003C\/a\u003E\u003C\/p\u003E\u003Cp\u003E\u003Ca href=\"https:\/\/zicodeng.medium.com\/explore-the-magic-behind-google-chrome-c3563dbd2739\" target=\"_blank\"\u003EChromium Architectural Overview\u003C\/a\u003E\u003C\/p\u003E\u003Cp\u003E\u003Ca href=\"https:\/\/github.com\/allpaca\/chrome-sbx-db\" target=\"_blank\"\u003EGit Repo of Previous Real World SBX Escapes\u003C\/a\u003E\u003C\/p\u003E\u003Cp\u003E\u003Ca href=\"https:\/\/kiprey.github.io\/2020\/10\/mojo\/\" target=\"_blank\"\u003EPlaidCTF Mojo Writeup\u003C\/a\u003E\u003C\/p\u003E\u003Cp\u003E\u003Ca href=\"http:\/\/eternal.red\/2019\/monochromatic-writeup\/\" target=\"_blank\"\u003EGoogle Quals 2019 Monochromatic Writeup\u003C\/a\u003E\u003C\/p\u003E\u003Cp\u003E\u003Cbr \/\u003E\u003C\/p\u003E\u003Cp\u003EEmpires:\u003C\/p\u003E\u003Cp\u003EWe were given a Chromium binary, mojojs bindings, and a source patch. The only difference between the two parts is that part one is run with the CTF_CHALLENGE_EASY_MODE environment variable set. Chromium is also run with MojoJS bindings enabled. Usually in fullchain exploits, one would have to compromise the renderer first, overwrite the blink::RuntimeEnabledFeatures::is_mojo_js_enabled_\u0026nbsp; variable, refresh the page, and then attempt to escape the sandbox. Since we already have bindings enabled, we won't have to worry about any of that. Here's the provided patch:\u003C\/p\u003E\u003Cp\u003E\u003Cscript src=\"https:\/\/gist.github.com\/BitsByWill\/88dd6564ab5ed86c3b7be193aa84242e.js?file=chall.diff\"\u003E\u003C\/script\u003E\u003C\/p\u003E\u003Cp\u003EThe Wreck struct holds a size, a length_to_use, an optional\u0026nbsp;\u003Ca href=\"https:\/\/chromium.googlesource.com\/chromium\/src\/+\/refs\/heads\/main\/mojo\/public\/cpp\/base\/big_buffer.cc\" target=\"_blank\"\u003EBigBuffer\u003C\/a\u003E, and a DesertType enum with variants DESOLATE and EMPTY. Sand is an array of wrecks. The most important struct is Ozymandias, which has the methods Visage and Despair,\u0026nbsp; a pointer reserved for a mmap page and an \u003Ca href=\"https:\/\/chromium.googlesource.com\/chromium\/src\/+\/refs\/heads\/main\/base\/unguessable_token.h\" target=\"_blank\"\u003EUnguessableToken\u003C\/a\u003E. UnguessableTokens are cryptographically secure 128 bit random values. Note the author commented that the struct is 0x100 bytes, which can be verified as well when it hits in the new operator in that function (find the mangled name, and attach to the main privileged browser process to break).\u003C\/p\u003E\u003Cdiv\u003EThe CreateKingofKings functions allows us to have the renderer request an interface from the browser process for the Ozymandias objects. Despair loops over the wrecks in a sand argument, allocating a new uint8_t array with a size determined by the wreck's size field. It memsets it as 0 in both options (although the first option doesn't seem so from source, I believe the compiler optimized the argument to 0 as you can see in disassembly). For the DESOLATE option, if your BigBuffer has data and a size greater than or equal to the wreck's size field, it transfers the contents to the uint8_t array up to the array's size. Then, it creates a base::span (which is like std::span) based on the allocated uint8_t array's start and your current wreck's length_to_use field. Visage is a backdoor; it requires a uint8_t vector and an \u003Ca href=\"https:\/\/chromium.googlesource.com\/chromium\/src\/+\/refs\/heads\/main\/base\/unguessable_token.h\" target=\"_blank\"\u003EUnguessableToken\u003C\/a\u003E. If your token matches the current Ozymandias's UnguessableToken, the vector will be copied to a mmap rwx page and run as shellcode. One last thing to note is that when disassembling the constructor, you can see the UnguessableToken is a static variable. While randomized in different browser instances, it will remain the same within the same browser usage session.\u003C\/div\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003ESince the CTF_CHALLENGE_EASY_MODE env variable is set, we have a trivial heap OOB read because the length_to_use can now be bigger than size and the BigBuffer constructed from the span later will use length_to_use to bound the span. Moreover, the part that is unbounded by the size but bounded by the length_to_use will remain uninitialized. As the author mentioned, this concept is based on this \u003Ca href=\"https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=1151865\" target=\"_blank\"\u003Ereal life sbx escape bug\u003C\/a\u003E.\u0026nbsp;\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cdiv\u003EBased on these facts, the exploit plan is pretty simple. I don't know much about PartitionAlloc behavior, but it's pretty easy to see from a few leaks of uninitialized memory that chunks of similar sizes get returned in the same regions. This means that we can just spray some Ozymandias objects, and then also spray some chunks that allow for OOB uninitiailized read, and leak the token so we can abuse the backdoor.\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003ENow, it should be pretty easy to just send in a reverse shell shellcode and escape the sandbox. However, one issue does remain, in that the mojojs bindings for UnguessableToken requires JS numbers, which won't preserve the accuracy for many possible token values. However, this is a simple patch. I performed the following change in the bindings to encode them as doubles:\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cscript src=\"https:\/\/gist.github.com\/BitsByWill\/88dd6564ab5ed86c3b7be193aa84242e.js?file=mojojs_patch.js\"\u003E\u003C\/script\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EThen, this was my final exploit (I just used a x86_64 linux rev shell shellcode from \u003Ca href=\"http:\/\/shell-storm.org\/shellcode\/files\/shellcode-857.php\" target=\"_blank\"\u003Eshellstorm\u003C\/a\u003E):\u003C\/div\u003E\u003Cp\u003E\u003Cscript src=\"https:\/\/gist.github.com\/BitsByWill\/88dd6564ab5ed86c3b7be193aa84242e.js?file=empire.js\"\u003E\u003C\/script\u003E\u003C\/p\u003E\u003Cp\u003E\u003Cbr \/\u003E\u003C\/p\u003E\u003Cp\u003EAs for the html website to send to the browser bot, I used the following (which was based off of NotDeGhost's post):\u003C\/p\u003E\u003Cp\u003E\u003Cscript src=\"https:\/\/gist.github.com\/BitsByWill\/88dd6564ab5ed86c3b7be193aa84242e.js?file=exploit.html\"\u003E\u003C\/script\u003E\u003C\/p\u003E\u003Cp\u003E\u003Cbr \/\u003E\u003C\/p\u003E\u003Cp\u003EHere was the result from running the exploit on remote from my teammate's VPS (thanks Strellic!):\u003C\/p\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"https:\/\/1.bp.blogspot.com\/-VXpu98FE7KM\/YOzhi-ZCnFI\/AAAAAAAACD0\/kq15F7_Ql8cs1TlzjA2t-zqf_64XPvUKgCLcBGAsYHQ\/s643\/sbx1.png\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" data-original-height=\"547\" data-original-width=\"643\" height=\"544\" src=\"https:\/\/1.bp.blogspot.com\/-VXpu98FE7KM\/YOzhi-ZCnFI\/AAAAAAAACD0\/kq15F7_Ql8cs1TlzjA2t-zqf_64XPvUKgCLcBGAsYHQ\/w640-h544\/sbx1.png\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cp\u003E\u003Cbr \/\u003E\u003C\/p\u003E\u003Cp\u003EDeserts:\u003C\/p\u003E\u003Cp\u003ENow, the env variable is disabled. So what could possibly allow us to leak UnguessableTokens then? I have to admit that this step took an embarrassingly long time.\u003C\/p\u003E\u003Cp\u003EI first spent several hours reading up on this \u003Ca href=\"https:\/\/securitylab.github.com\/research\/chromium-ipc-vulnerabilities\/\" target=\"_blank\"\u003Epost\u003C\/a\u003E about common Chromium IPC vulns and tried to compare them to the diff. Nothing was found this way.\u003C\/p\u003E\u003Cp\u003EAnother idea teammates hypothesized was that maybe there is a TOCTOU race condition between when it checks for size and length_to_use and when length_to_use is used. However, data is serialized when passed to privileged browser process, so us trying to race in renderer is useless and will not apply changes there (and the window is too small since we need to abuse sizes of approximately 0x100).\u003C\/p\u003E\u003Cp\u003ELastly, what really caught my attention is that if you have it not hit any of the cases in the switch statement, you will still get an uninitialized read. To do that, you need a new enum value, and unfortunately, Mojo \u003Ca href=\"https:\/\/chromium.googlesource.com\/chromium\/src\/+\/HEAD\/mojo\/public\/tools\/bindings\/README.md#Message-Validation\" target=\"_blank\"\u003Evalidates\u003C\/a\u003E all enums (unless the keyword extensible is used) along with several other validation checks. I thought this was an interesting scenario as we can change how we send things from the mojojs bindings and wanted to see if validation can be bypassed somehow. As I was messing around with wreck types, I noticed that I suddenly achieved a leak when I set my BigBuffer tag to 2, which stands for \u003Ca href=\"https:\/\/chromium.googlesource.com\/chromium\/src\/+\/refs\/heads\/main\/mojo\/public\/cpp\/base\/big_buffer.h#69\" target=\"_blank\"\u003Einvalid storage\u003C\/a\u003E. Debugging the codeflow, I noticed that the contents of the DesertType enum became 0 there somehow (if you set it to zero normally from renderer before serializing and sending, a validation error will occur and your renderer process will be killed). I wasn't too sure why, but according to NotDeGhost after my solve, it is because this enum causes deserialization to fail, so the rest of the struct will not be populated (hence leaving DesertType to 0). The NOTREACHED() statement in the diff is not compiled into release builds, allowing for us to trigger this bug and get uninitialized read when it works with wreck structs.\u003C\/p\u003E\u003Cp\u003EThis time, however, we can't just spray some allocations and have an OOB leak data outside the chunk. We will need to free some OzymandiasImpl objects, which can be done pretty easily with .ptr.reset() as it is an interface implementation. Here is the final exploit:\u003C\/p\u003E\u003Cp\u003E\u003Cscript src=\"https:\/\/gist.github.com\/BitsByWill\/88dd6564ab5ed86c3b7be193aa84242e.js?file=desert.js\"\u003E\u003C\/script\u003E\u003C\/p\u003E\u003Cp\u003EHere is the result from remote:\u003C\/p\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"https:\/\/1.bp.blogspot.com\/-byjcAGIXtXc\/YOzhskmSl8I\/AAAAAAAACD4\/7KMdhovuBlQN2gp-TbFTTt41qYjpnK21ACLcBGAsYHQ\/s594\/sbx2.png\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" data-original-height=\"594\" data-original-width=\"531\" height=\"640\" src=\"https:\/\/1.bp.blogspot.com\/-byjcAGIXtXc\/YOzhskmSl8I\/AAAAAAAACD4\/7KMdhovuBlQN2gp-TbFTTt41qYjpnK21ACLcBGAsYHQ\/w572-h640\/sbx2.png\" width=\"572\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cp\u003EOverall, I thought these were amazing challenges and finally pushed me to mess around a bit with Chromium sandbox escapes. Though introductory challenges into this complex topic, many of the concepts and basic techniques can probably be re-applied on more difficult sandbox escape challenges.\u003C\/p\u003E\u003Cp\u003EHere is the \u003Ca href=\"https:\/\/robertchen.cc\/blog\/2021\/07\/12\/empires-and-deserts\" target=\"_blank\"\u003Eauthor's writeup\u003C\/a\u003E! Make sure to check it out.\u003C\/p\u003E\u003Cp\u003E\u003Cbr \/\u003E\u003C\/p\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/www.willsroot.io\/feeds\/3718504721840392190\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/www.willsroot.io\/2021\/07\/redpwnctf-2021-chromium-sbx-tasks.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default\/3718504721840392190"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/8814147965526194982\/posts\/default\/3718504721840392190"},{"rel":"alternate","type":"text/html","href":"https:\/\/www.willsroot.io\/2021\/07\/redpwnctf-2021-chromium-sbx-tasks.html","title":"RedpwnCTF 2021 Chromium SBX Tasks Writeup (Empires and Deserts)"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"https:\/\/1.bp.blogspot.com\/-VXpu98FE7KM\/YOzhi-ZCnFI\/AAAAAAAACD0\/kq15F7_Ql8cs1TlzjA2t-zqf_64XPvUKgCLcBGAsYHQ\/s72-w640-h544-c\/sbx1.png","height":"72","width":"72"},"thr$total":{"$t":"0"}}]}});