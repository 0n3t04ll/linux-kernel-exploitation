<!DOCTYPE html>
<!-- saved from url=(0089)https://jon.oberheide.org/blog/2010/11/29/exploiting-stack-overflows-in-the-linux-kernel/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="viewport" content="width=device-width,minimum-scale=1">
  <meta name="author" content="Jon Oberheide">
  <meta name="description" content="Jon Oberheide&#39;s website">

  <title>Exploiting Stack Overflows in the Linux Kernel | Jon Oberheide</title>
 
  
  
    <meta name="ROBOTS" content="INDEX, FOLLOW">

    
    <script async="" src="./2010 - Exploiting Stack Overflows in the Linux Kernel_files/js"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-P6TVZTTZN2');
    </script>
  

  <link rel="preconnect" href="https://fonts.gstatic.com/">
  <link href="./2010 - Exploiting Stack Overflows in the Linux Kernel_files/css2" rel="stylesheet">

  <link href="./2010 - Exploiting Stack Overflows in the Linux Kernel_files/style.css" rel="stylesheet">
  <link href="./2010 - Exploiting Stack Overflows in the Linux Kernel_files/fontawesome.css" rel="stylesheet">
  <link href="./2010 - Exploiting Stack Overflows in the Linux Kernel_files/brands.css" rel="stylesheet">

</head>

<body>
  <aside>
    <div id="user_meta">
      <a href="https://jon.oberheide.org/">
        <img src="./2010 - Exploiting Stack Overflows in the Linux Kernel_files/jono.jpg" alt="logo" id="logo">
      </a>
      <h2><a href="https://jon.oberheide.org/" class="nohover">Jon Oberheide</a></h2>
      
      <div class="social">
        <ul>
	  <li><a href="https://www.linkedin.com/in/jonoberheide">LinkedIn<i class="fab fa-linkedin fa-lg"></i></a></li>
	  <li><a href="https://twitter.com/jonoberheide">Twitter<i class="fab fa-twitter fa-lg"></i></a></li>  
	</ul>
      </div>
      <ul>
      </ul>
    </div>
  </aside>

  <main id="main">

    
    
    <header>
      <p id="header">
      <a href="https://jon.oberheide.org/">Home</a>
      | <a href="https://jon.oberheide.org/blog/">Blog</a>
      | <a href="https://jon.oberheide.org/research/">Research</a>
      | <a href="https://jon.oberheide.org/advisories/">Advisories</a>
      | <a href="https://jon.oberheide.org/projects/">Projects</a>
    </p></header>
    

    <article>
      <div class="article_title">
        <h1>Exploiting Stack Overflows in the Linux Kernel</h1>
        
        
        
        <h4>Monday, November 29, 2010</h4>
        
      </div>

      <div class="article_text">
<p>In this post, I'll introduce an exploitation technique for kernel stack
overflows in the Linux kernel. Keep in mind this does not refer to
buffer overflows on the kernel stack (whose exploitability is well
understood), but rather the improper expansion of the kernel stack
causing it to overlap with critical structures which may be subsequently
corrupted. This is a vulnerability class in the Linux kernel that I do
not believe have been exploited publicly in the past, but is relevant
due to a recent vulnerability in the Econet packet family.</p>
<h2 id="kernel-stack-layout">Kernel Stack Layout</h2>
<p>On Linux, every thread on your system has a corresponding kernel stack
allocated in kernel memory. Linux kernel stacks on x86 are either 4096
or 8192 bytes in size, depending on your distribution. While this size
may seem small to contain a full call chain and associated local stack
variables, in reality the kernel call chains are relatively shallow and
kernel functions are discouraged from abusing the precious space with
large local stack variables when efficient allocators such as the SLUB
are available.</p>
<p>The stack shares the 4k/8k total size with the thread_info structure,
which contains some metadata about the current thread, as seen in
include/linux/sched.h:</p>
<pre><code>union thread_union {
    struct thread_info thread_info;
    unsigned long stack[THREAD_SIZE/sizeof(long)];
};
</code></pre>
<p>The thread_info structure has the following definition on x86 from
arch/x86/include/asm/thread_info.h:</p>
<pre><code>struct thread_info {
    struct task_struct *task;
    struct exec_domain *exec_domain;
    __u32      flags;
    __u32      status;
    __u32      cpu;
    int          preempt_count;
    mm_segment_t  addr_limit;
    struct restart_block restart_block;
    void __user     *sysenter_return;
#ifdef CONFIG_X86_32
    unsigned long  previous_esp;
    __u8      supervisor_stack[0];
#endif
    int          uaccess_err;
};
</code></pre>
<p>Visually, a kernel stack looks like the following in memory:</p>
<p><img src="./2010 - Exploiting Stack Overflows in the Linux Kernel_files/kstack.png" alt="kstack"></p>
<p>So what happens when a function in the kernel requires more than 4k/8k
worth of stack space or a long call chain exceeds the available stack
space? Well, normally an overflow of the stack will occur and cause the
kernel to crash if the thread_info structure or critical memory beyond
it becomes corrupted. However, if the moons align and we have a
situation where we can actually control the data that is written to the
stack and beyond, we may have an exploitable condition.</p>
<h2 id="exploiting-a-stack-overflow">Exploiting a Stack Overflow</h2>
<p>Let's look at a simple example to see how overflowing the stack and
clobbering the thread_info structure can result in an exploitable
privilege escalation:</p>
<pre><code>static int blah(int __user *vals, int __user count)
{
    int i;
    int big_array[count];
    for (i = 0; i &lt; count; ++count) {
        big_array[i] = vals[i];
    }
}
</code></pre>
<p>In the above code, we have a variable length array on the stack
(big_array) whose size is based on an attacker-controlled count.
<a href="http://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html">Variable length
arrays</a> are
allowed in C99 and supported by GCC. GCC will simply calculate the
necessary size at runtime and decrement the stack pointer appropriately
to allocate space on the stack for the array.</p>
<p>However, if the attacker provides a sufficiently large count, the stack
may extend down past the boundary of thread_info, allowing the attacker
to subsequently write arbitrary values into the thread_info structure.
Extending the stack pointer past the thread_info boundary would look
like the following:</p>
<p><img src="./2010 - Exploiting Stack Overflows in the Linux Kernel_files/kstack-smash.png" alt="kstack smash"></p>
<p>So what is in the thread_info structure that may be useful for an
attacker to control? Ideally, we'd like to find something with a
function pointer that we can overwrite and redirect control flow to an
address of our choosing.</p>
<p>Let's take a deeper look at one promising member of thread_info:
restart_block. restart_block is a per-thread structure used to track
information and arguments for restarting system calls. System calls that
are interrupted by signals can either abort and return EINTR or
automatically restart themselves if SA_RESTART is specified in
sigaction(2). restart_block is defined as follows in
include/linux/thread_info.h:</p>
<pre><code>struct restart_block {
    long (*fn)(struct restart_block *);
    union {
        struct {
            ...
        };
        /* For futex_wait and futex_wait_requeue_pi */
        struct {
            ...
        } futex;
        /* For nanosleep */
        struct {
            ...
        } nanosleep;
        /* For poll */
        struct {
            ...
        } poll;
    };
};
</code></pre>
<p>Hey, that fn function pointer sure looks promising! Where in the kernel
does that function pointer actually get invoked? Why, right there in the
restart_syscall system call in kernel/signal.c:</p>
<pre><code>SYSCALL_DEFINE0(restart_syscall)
{
    struct restart_block *restart = &amp;current_thread_info()-&gt;restart_block;
    return restart-&gt;fn(restart);
}
</code></pre>
<p>The restart_syscall system call is defined in
arch/x86/kernel/syscall_table_32.S:</p>
<pre><code>.long sys_restart_syscall /* 0 - old "setup()" system call, used for restarting */
</code></pre>
<p>That's right, there's actually system call number zero. We couldn't
ask for anything easier! We can trivially invoke its functionality from
userspace via:</p>
<pre><code>syscall(SYS_restart_syscall);
</code></pre>
<p>Thereby causing the kernel to call the function pointer contained in the
restart_block structure.</p>
<p>So there we have it: if we can clobber the function pointer in the
restart_block member of thread_info, we can point it to a function in
userspace under our control, trigger its execution by invoking
sys_restart_syscall, and escalate privileges.</p>
<h2 id="econet-vulnerability">Econet Vulnerability</h2>
<p>As I mentioned previously, I'm not aware of any exploits that have used
such a technique in the past. And while the simple example above may
appear a bit contrived, there is a real-world example of this type of
vulnerability recently discovered by Nelson Elhage in the Econet packet
family.</p>
<p>In a forthcoming post, I'll describe the Econet vulnerability and
exploit in further detail. Until then, patch up!</p>


      </div>
    </article>

    <div id="ending_message">
      <p>Copyright Â© 2021 - Jon Oberheide</p>
    </div>

  </main>



</body></html>