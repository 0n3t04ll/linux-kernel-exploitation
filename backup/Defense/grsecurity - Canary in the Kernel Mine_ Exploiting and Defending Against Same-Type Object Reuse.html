<!DOCTYPE html>
<!-- saved from url=(0078)https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse -->
<html lang="en" class="wf-roboto-n3-active wf-roboto-i3-active wf-roboto-n4-active wf-roboto-n7-active wf-roboto-n9-active wf-droidserif-i4-active wf-droidserif-n4-active wf-droidserif-n7-active wf-droidserif-i7-active wf-active"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="preload" href="https://grsecurity.net/fonts/Roboto-regular/Roboto-regular.woff2" as="font">
<link rel="preload" href="https://grsecurity.net/fonts/Roboto-700/Roboto-700.woff2" as="font">
<link rel="preload" href="https://grsecurity.net/fonts/Roboto-300italic/Roboto-300italic.woff2" as="font">
<link rel="preload" href="https://grsecurity.net/fonts/Roboto-300/Roboto-300.woff2" as="font">
<link rel="preload" href="https://grsecurity.net/fonts/Droid-Serif-italic/Droid-Serif-italic.woff2" as="font">
<link rel="preload" href="https://grsecurity.net/fonts/Roboto-900/Roboto-900.woff2" as="font">
<!-- Google Tag Manager -->
<script type="text/javascript" async="" src="./grsecurity - Canary in the Kernel Mine_ Exploiting and Defending Against Same-Type Object Reuse_files/analytics.js.下載"></script><script async="" src="./grsecurity - Canary in the Kernel Mine_ Exploiting and Defending Against Same-Type Object Reuse_files/gtm.js.下載"></script><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-54V6PHM');</script>
<!-- End Google Tag Manager -->

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="robots" content="NOODP, NOARCHIVE">
<meta name="description" content="
This blog covers a difficult-to-defend subclass of use-after-free vulnerabilities in the Linux kernel, grsecurity&#39;s defense for it, and why our defense required compiler plugin involvement.  Included PoC exploits demonstrate the power and simplicity of this kind of vulnerability, as well as the effectiveness of grsecurity&#39;s defense.">

<meta name="twitter:creator" content="@grsecurity"><meta name="twitter:site" content="@grsecurity"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Canary in the Kernel Mine: Exploiting and Defending Against Same-Type Object Reuse"><meta name="twitter:description" content="This blog covers a difficult-to-defend subclass of use-after-free vulnerabilities in the Linux kernel, grsecurity&#39;s defense for it, and why our defense required compiler plugin involvement.  Included PoC exploits demonstrate the power and simplicity of this kind of vulnerability, as well as the effectiveness of grsecurity&#39;s defense."><meta name="twitter:image" content="https://grsecurity.net/canary_kernel_mine/twittercard.png">

<title>
grsecurity - Canary in the Kernel Mine: Exploiting and Defending Against Same-Type Object Reuse</title>


<link rel="apple-touch-icon" sizes="180x180" href="https://grsecurity.net/apple-touch-icon.png?v=5A5zyaR2my">
<link rel="icon" type="image/png" href="https://grsecurity.net/favicon-32x32.png?v=5A5zyaR2my" sizes="32x32">
<link rel="icon" type="image/png" href="https://grsecurity.net/favicon-16x16.png?v=5A5zyaR2my" sizes="16x16">
<link rel="manifest" href="https://grsecurity.net/manifest.json?v=5A5zyaR2my">
<link rel="mask-icon" href="https://grsecurity.net/safari-pinned-tab.svg?v=5A5zyaR2my" color="#344d83">
<link rel="shortcut icon" href="https://grsecurity.net/favicon.ico?v=5A5zyaR2my">
<meta name="theme-color" content="#ffffff">

<script type="text/javascript" src="./grsecurity - Canary in the Kernel Mine_ Exploiting and Defending Against Same-Type Object Reuse_files/header.js.下載"></script>
<link rel="stylesheet" href="./grsecurity - Canary in the Kernel Mine_ Exploiting and Defending Against Same-Type Object Reuse_files/style.css" type="text/css" media="all">

  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    h2 { margin-block-start: 1.25em; margin-block-end: 0.25em; }
    pre { color: #182024; background-color: #f0f0f0; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style><link rel="stylesheet" href="./grsecurity - Canary in the Kernel Mine_ Exploiting and Defending Against Same-Type Object Reuse_files/fonts.css" media="all">
</head>
<body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54V6PHM"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<header id="top" class="site-header" role="banner">

	<div class="header-content wrap">

		<h1 class="logo">
			<a href="https://grsecurity.net/"><img src="./grsecurity - Canary in the Kernel Mine_ Exploiting and Defending Against Same-Type Object Reuse_files/grsecurity.svg" alt="grsecurity"></a>
		</h1>

		<button class="menu-btn">Show Navigation</button>
<div class="nav-wrap">
	<nav class="access" role="navigation" aria-label="Primary" itemscope="" itemtype="http://www.schema.org/SiteNavigationElement">
		<ul>
			<li itemprop="name"><a href="https://grsecurity.net/" itemprop="url">Home</a></li>
			<li itemprop="name"><a href="https://grsecurity.net/features.php" itemprop="url">Features</a></li>
			<li itemprop="name"><a href="https://grsecurity.net/download.php" itemprop="url">Download</a></li>
			<li itemprop="name"><a href="https://grsecurity.net/support.php" itemprop="url">Support</a></li>
			<li itemprop="name"><a href="https://grsecurity.net/papers.php" itemprop="url">Papers</a></li>
			<li itemprop="name"><a href="https://grsecurity.net/blog.php" itemprop="url">Blog</a></li>
			<li><a href="https://grsecurity.net/purchase.php" class="btn" itemprop="url"><span itemprop="name">Purchase</span></a></li>
		</ul>

	</nav>
</div> <!-- .nav-wrap -->

	</div>

</header>
        <main>
                <article>
                        <header class="masthead">
                                <div class="wrap">
                                        <h1 class="large-headline">Canary in the Kernel Mine: Exploiting and Defending Against Same-Type Object Reuse</h1>
					<p>By Mathias Krause</p>
                                        <p>October 21, 2022</p>
                                        <div class="social">
                                        
<a href="https://facebook.com/sharer.php?u=https%3A%2F%2Fgrsecurity.net%2Fexploiting_and_defending_against_same_type_object_reuse" role="button" tabindex="0" class="social-share-btn social-icon-wrapper" style="background-color: rgb(59, 89, 152); border-radius: 16px;"><span class="social-visually-hidden">Share to Facebook</span><span class="social-icon-wrapper" style="line-height: 32px; height: 32px; width: 32px;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 32 32" version="1.1" role="img" style="fill: rgb(255, 255, 255); width: 32px; height: 32px;"><title>Facebook</title><g><path d="M22 5.16c-.406-.054-1.806-.16-3.43-.16-3.4 0-5.733 1.825-5.733 5.17v2.882H9v3.913h3.837V27h4.604V16.965h3.823l.587-3.913h-4.41v-2.5c0-1.123.347-1.903 2.198-1.903H22V5.16z" fill-rule="evenodd"></path></g></svg></span></a>
<a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A%2F%2Fgrsecurity.net%2Fexploiting_and_defending_against_same_type_object_reuse&amp;title=Canary+in+the+Kernel+Mine%3A+Exploiting+and+Defending+Against+Same-Type+Object+Reuse&amp;summary=This+blog+covers+a+difficult-to-defend+subclass+of+use-after-free+vulnerabilities+in+the+Linux+kernel%2C+grsecurity%27s+defense+for+it%2C+and+why+our+defense+required+compiler+plugin+involvement.++Included+PoC+exploits+demonstrate+the+power+and+simplicity+of+this+kind+of+vulnerability%2C+as+well+as+the+effectiveness+of+grsecurity%27s+defense.&amp;source=https%3A%2F%2Fgrsecurity.net%2Fexploiting_and_defending_against_same_type_object_reuse" role="button" tabindex="0" class="social-share-btn social-icon-wrapper" style="background-color: rgb(0, 119, 181); border-radius: 16px;"><span class="social-visually-hidden">Share to LinkedIn</span><span class="social-icon-wrapper" style="line-height: 32px; height: 32px; width: 32px;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 32 32" version="1.1" role="img" style="fill: rgb(255, 255, 255); width: 32px; height: 32px;"><title>LinkedIn</title><g><path d="M26 25.963h-4.185v-6.55c0-1.56-.027-3.57-2.175-3.57-2.18 0-2.51 1.7-2.51 3.46v6.66h-4.182V12.495h4.012v1.84h.058c.558-1.058 1.924-2.174 3.96-2.174 4.24 0 5.022 2.79 5.022 6.417v7.386zM8.23 10.655a2.426 2.426 0 0 1 0-4.855 2.427 2.427 0 0 1 0 4.855zm-2.098 1.84h4.19v13.468h-4.19V12.495z" fill-rule="evenodd"></path></g></svg></span></a>
<a href="https://twitter.com/share?url=https%3A%2F%2Fgrsecurity.net%2Fexploiting_and_defending_against_same_type_object_reuse&amp;text=Canary+in+the+Kernel+Mine%3A+Exploiting+and+Defending+Against+Same-Type+Object+Reuse&amp;hashtags=grsecurity&amp;related=grsecurity%2Copensrcsec" role="button" tabindex="0" class="social-share-btn social-icon-wrapper" style="background-color: rgb(29, 161, 242); border-radius: 16px;"><span class="social-visually-hidden">Share to Twitter</span><span class="social-icon-wrapper" style="line-height: 32px; height: 32px; width: 32px;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 32 32" version="1.1" role="img" style="fill: rgb(255, 255, 255); width: 32px; height: 32px;"><title>Twitter</title><g><path d="M27.996 10.116c-.81.36-1.68.602-2.592.71a4.526 4.526 0 0 0 1.984-2.496 9.037 9.037 0 0 1-2.866 1.095 4.513 4.513 0 0 0-7.69 4.116 12.81 12.81 0 0 1-9.3-4.715 4.49 4.49 0 0 0-.612 2.27 4.51 4.51 0 0 0 2.008 3.755 4.495 4.495 0 0 1-2.044-.564v.057a4.515 4.515 0 0 0 3.62 4.425 4.52 4.52 0 0 1-2.04.077 4.517 4.517 0 0 0 4.217 3.134 9.055 9.055 0 0 1-5.604 1.93A9.18 9.18 0 0 1 6 23.85a12.773 12.773 0 0 0 6.918 2.027c8.3 0 12.84-6.876 12.84-12.84 0-.195-.005-.39-.014-.583a9.172 9.172 0 0 0 2.252-2.336" fill-rule="evenodd"></path></g></svg></span></a>
<a href="https://reddit.com/submit?url=https%3A%2F%2Fgrsecurity.net%2Fexploiting_and_defending_against_same_type_object_reuse&amp;title=Canary+in+the+Kernel+Mine%3A+Exploiting+and+Defending+Against+Same-Type+Object+Reuse" role="button" tabindex="0" class="social-share-btn social-icon-wrapper" style="background-color: rgb(255, 87, 0); border-radius: 16px;"><span class="social-visually-hidden">Share to Reddit</span><span class="social-icon-wrapper" style="line-height: 32px; height: 32px; width: 32px;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 32 32" version="1.1" role="img" style="fill: rgb(255, 255, 255); width: 32px; height: 32px;"><title>Reddit</title><g><path d="M27 15.5a2.452 2.452 0 0 1-1.338 2.21c.098.38.147.777.147 1.19 0 1.283-.437 2.47-1.308 3.563-.872 1.092-2.06 1.955-3.567 2.588-1.506.634-3.143.95-4.91.95-1.768 0-3.403-.316-4.905-.95-1.502-.632-2.69-1.495-3.56-2.587-.872-1.092-1.308-2.28-1.308-3.562 0-.388.045-.777.135-1.166a2.47 2.47 0 0 1-1.006-.912c-.253-.4-.38-.842-.38-1.322 0-.678.237-1.26.712-1.744a2.334 2.334 0 0 1 1.73-.726c.697 0 1.29.26 1.78.782 1.785-1.258 3.893-1.928 6.324-2.01l1.424-6.467a.42.42 0 0 1 .184-.26.4.4 0 0 1 .32-.063l4.53 1.006c.147-.306.368-.553.662-.74a1.78 1.78 0 0 1 .97-.278c.508 0 .94.18 1.302.54.36.36.54.796.54 1.31 0 .512-.18.95-.54 1.315-.36.364-.794.546-1.302.546-.507 0-.94-.18-1.295-.54a1.793 1.793 0 0 1-.533-1.308l-4.1-.92-1.277 5.86c2.455.074 4.58.736 6.37 1.985a2.315 2.315 0 0 1 1.757-.757c.68 0 1.256.242 1.73.726.476.484.713 1.066.713 1.744zm-16.868 2.47c0 .513.178.95.534 1.315.356.365.787.547 1.295.547.508 0 .942-.182 1.302-.547.36-.364.54-.802.54-1.315 0-.513-.18-.95-.54-1.31-.36-.36-.794-.54-1.3-.54-.5 0-.93.183-1.29.547a1.79 1.79 0 0 0-.54 1.303zm9.944 4.406c.09-.09.135-.2.135-.323a.444.444 0 0 0-.44-.447c-.124 0-.23.042-.32.124-.336.348-.83.605-1.486.77a7.99 7.99 0 0 1-1.964.248 7.99 7.99 0 0 1-1.964-.248c-.655-.165-1.15-.422-1.486-.77a.456.456 0 0 0-.32-.124.414.414 0 0 0-.306.124.41.41 0 0 0-.135.317.45.45 0 0 0 .134.33c.352.355.837.636 1.455.843.617.207 1.118.33 1.503.366a11.6 11.6 0 0 0 1.117.056c.36 0 .733-.02 1.117-.056.385-.037.886-.16 1.504-.366.62-.207 1.104-.488 1.456-.844zm-.037-2.544c.507 0 .938-.182 1.294-.547.356-.364.534-.802.534-1.315 0-.505-.18-.94-.54-1.303a1.75 1.75 0 0 0-1.29-.546c-.506 0-.94.18-1.3.54-.36.36-.54.797-.54 1.31s.18.95.54 1.315c.36.365.794.547 1.3.547z" fill-rule="evenodd"></path></g></svg></span></a>
<a href="mailto:name@example.com?subject=grsecurity%3A+Canary+in+the+Kernel+Mine%3A+Exploiting+and+Defending+Against+Same-Type+Object+Reuse&amp;body=Hi%2C%0D%0A%0D%0AI%27d+like+you+to+check+out+the+following+post+from+Open+Source+Security%2C+Inc.++I+think+you+might+find+it+interesting.%0D%0A%0D%0Ahttps%3A%2F%2Fgrsecurity.net%2Fexploiting_and_defending_against_same_type_object_reuse%0D%0A%0D%0A" role="button" tabindex="0" class="social-share-btn social-icon-wrapper" style="background-color: rgb(132, 132, 132); border-radius: 16px;"><span class="social-visually-hidden">Share to Email</span><span class="social-icon-wrapper" style="line-height: 32px; height: 32px; width: 32px;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 32 32" version="1.1" role="img" style="fill: rgb(255, 255, 255); width: 32px; height: 32px;"><title>Email</title><g><g fill-rule="evenodd"></g><path d="M27 22.757c0 1.24-.988 2.243-2.19 2.243H7.19C5.98 25 5 23.994 5 22.757V13.67c0-.556.39-.773.855-.496l8.78 5.238c.782.467 1.95.467 2.73 0l8.78-5.238c.472-.28.855-.063.855.495v9.087z"></path><path d="M27 9.243C27 8.006 26.02 7 24.81 7H7.19C5.988 7 5 8.004 5 9.243v.465c0 .554.385 1.232.857 1.514l9.61 5.733c.267.16.8.16 1.067 0l9.61-5.733c.473-.283.856-.96.856-1.514v-.465z"></path></g></svg></span></a>
                                        </div>
                                </div>
                        </header>

                        <section class="bar pull-up blog">
                                <div class="wrap">
                                        <div class="panel">

<h2 id="introduction">Introduction</h2>
<p>Our goal at Open Source Security Inc. is to constantly push the envelope in Linux kernel security as attackers won’t be resting either. The team has been doing it for over two decades now and is still hungry. Our work not only involves analyzing and auditing existing hardening and exploit mitigations, but also to monitor current state of the art exploits to get feedback – so to say – on which technique or neat little trick we might have missed so far. As the state of art in exploitation is rather slowly moving – at least in public – we work on topics we know have been troublesome in the past or will be in the future and research possible defenses. This blog entry is about one of these research topics, namely, handling a special case of a use-after-free bug: same type, same address reuse.</p>
<h2 id="the-bug-ground-story">The Bug-ground Story</h2>
<p>During a brief code audit, quite a while ago already, we noticed a <a href="https://www.openwall.com/lists/oss-security/2021/04/29/5">bug</a> in the Nitro Enclaves driver. Faulty error handling code would leave a stale file pointer behind in a process’ file descriptor table. If a reallocation of the underlying file object happens to be in a privileged process that is opening a restricted file, the stale file descriptor entry in the exploiting process could be abused to access that file as well.</p>
<p>Our <a href="https://grsecurity.net/canary_kernel_mine/cve-2022-22942.c">proof-of-concept exploit</a> was making use of <code>passwd</code> as the privileged helper program to reallocate the dangling file object to gain access to <code>/etc/shadow</code>, a sensitive file containing hashed passwords of all local user accounts including the root user. But the bug isn’t limited to that. Virtually any file opened on the system can be accessed this way – Emails processed by a mail server, SSH private keys, root’s nobly maintained .bashrc. It’s just a matter of waiting for it to happen.</p>
<p>It’s a severe bug on affected systems, but it also showed a blind spot in our back-then implementation of <a href="https://grsecurity.net/how_autoslab_changes_the_memory_unsafety_game">AUTOSLAB</a>, a kernel heap hardening mechanism separating kernel memory allocations from each other. That separation would ensure that type confusion isn’t possible for a given slab page, as allocations will always be of the same type. But no type confusion nor buffer overflow, not even a KASLR leak is needed to successfully exploit the bug. All that’s required is to make the kernel reallocate the released memory for the same type of object; that’s likely to happen, because file objects use a <a href="https://github.com/torvalds/linux/blob/v6.0/fs/file_table.c#L138" title="Link to fs/file_table.c:__alloc_file()">dedicated slab cache</a>.</p>
<h2 id="defining-the-bug-class">Defining the Bug Class</h2>
<p>The underlying bug is not of the usual type confusion or buffer overflow kind which AUTOSLAB already helps tremendously to tackle. It’s “only” a violation of the temporal memory integrity by using an object after it was released and later reallocated – preserving the object’s type, bounds and address. It’s a same-type, same-address use-after-free bug.</p>
<p><img src="./grsecurity - Canary in the Kernel Mine_ Exploiting and Defending Against Same-Type Object Reuse_files/dangling_file.png" title="Visualization of a dangling file pointer pointing to a reallocated file object of another process."></p>
<p>The threat model to handle boils down to an attacker abusing a dangling pointer to a reallocated object of the same type at the same address.</p>
<h2 id="evaluating-existing-defenses">Evaluating Existing Defenses</h2>
<p>Exploiting such a bug relies on reallocating the underlying memory by a more privileged process, which makes instrumentation-based approaches like software-based <a href="https://docs.kernel.org/dev-tools/kasan.html">KASAN</a> only partially help to detect these. An attacker can simply wait long enough to be sure the object got through the mandatory quarantine delay and reallocated prior to attempting to exploit the hijacked file object.</p>
<p>Arm’s <a href="https://developer.arm.com/-/media/Arm%20Developer%20Community/PDF/Arm_Memory_Tagging_Extension_Whitepaper.pdf" title="Armv8.5-A Memory Tagging Extension White Paper">Memory Tagging Extension</a> (MTE) would be capable of handling the temporal violation aspect by assigning a new tag for each reallocation. But it’s only available for Armv8.5+, limiting its applicability to a narrow set of mostly mobile devices. There is even a KASAN mode that makes use of MTE. But aside from that, there’s no kernel-side use of MTE to protect kernel heap allocations for production-level workloads.</p>
<h2 id="designing-a-new-defense">Designing a New Defense</h2>
<p>Software-based tagging schemes making use of otherwise unused address bits are doomed to perform poorly, as each pointer indirection needs to be instrumented to do a tag check and mangle the pointer for the final memory access or make use of features like <a href="https://developer.arm.com/documentation/den0024/a/ch12s05s01">Top Byte Ignore</a> (TBI) to ensure using canonical addresses. TBI, however, is again an Arm-only feature so far.</p>
<p>The fortunate nature of the bug at hand is that the userspace API doesn’t allow a process to directly refer to a <em>file</em> object. There’s an indirection layer via <em>file descriptors</em> which are simple integer values used as indices into a table, which allows us to implement a pointer verification mechanism at the file descriptor lookup level. But to detect the reuse of a dangling file pointer, still some kind of <em>allocation generation</em> needs to be embedded somewhere – either encoded in the pointer or the pointed-to object itself.</p>
<p>We went with the latter, as instrumenting pointers in software brings an overhead for all users of such typed pointers we want to avoid for performance reasons. We only need to verify a pointer’s validity at the few transitioning places where userspace file descriptors get converted to file pointers. To do so, we added a <em>canary</em> member to <code>struct file</code> that can have three values: <code>FILE_MAGIC_ALIVE</code>, <code>FILE_MAGIC_DYING</code> and <code>FILE_MAGIC_DEAD</code> that correspond to the object’s current state: “alive”, as in being a valid object, “dying” to mark invalid objects that could still be found via <a href="https://www.kernel.org/doc/html/latest/RCU/whatisRCU.html">RCU</a> lookups and “dead” for no longer valid objects.</p>
<p>The canary member gets updated and verified during a file object’s lifecycle. Verification happens in <code>__fget_light()</code> and <code>__fget_files_rcu()</code> as these are the two core lookup functions to convert file descriptors into file objects.<a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> If a validation violation occurs, the offending process gets killed, but not immediately, as it’s still holding critical locks, but before returning from the currently executing system call.<a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>The mindful reader might be right to point out that the canary checking is still not sufficient to detect a malicious reuse of a dangling file pointer, as the reallocation will, for sure, turn a “dead” object into a valid one again. To address this part of the problem we use a probabilistic approach by adding a random factor to the second aspect of the bug class: the memory address.</p>
<p>Under our new defense, reallocated objects will, with a certain probability, use a different memory address, making the dangling pointer no longer point to the beginning of the reallocated object. The now offset dangling pointer will make the canary check logic look at the wrong memory location and make it fail, as the magic value can no longer be found.</p>
<p><img src="./grsecurity - Canary in the Kernel Mine_ Exploiting and Defending Against Same-Type Object Reuse_files/dangling_file_canary.png" title="Visualisation of an offset dangling file pointer pointing to a reallocated file object of another process."></p>
<p>With both mechanisms in place we ensure that:</p>
<ol type="1">
<li>File descriptors can only be turned into file pointers for live file objects and</li>
<li>Reallocating file objects will likely get them a different memory address.</li>
</ol>
<p>The first mechanism on its own is a cheap use-after-free detection, but we already mentioned that an attacker can simply wait until an object gets reallocated to overcome that. Combined with the second mechanism, however, this will lead to the canary check detecting the invalid use of a dangling pointer. The load of the canary member won’t actually read the file object’s canary value but some “random” (but safe) memory instead. Once detected, the current task gets terminated and further exploit handling is initiated.</p>
<p>This second defense comes at the cost of slightly higher memory usage to support the random object placing within a given allocation slot. By default, we use up to a cache line of slack space (64 bytes for most systems). We do, however, have to respect the object type’s alignment, reducing the total number of possible addresses per allocation slot.</p>
<p>For file objects on a 64-bit grsecurity kernel this leads to <code>64 / 8 + 1 = 9</code> possible addresses or a probability of ~11% of reallocating to the same address. That might seem disappointing at first, but the opposite is that the canary check will detect abuse of an invalid pointer with a probability of almost 90%. If a higher probability is wanted, one can get it by sacrificing a higher memory overhead and changing the slack space through a kernel command line parameter.</p>
<!-- notes:
- io_uring, kcmp: disabled in grsec
-->
<h2 id="trial-by-fire">Trial by Fire</h2>
<p>Eager to know if the mitigation will detect the bug class it was targeting, I was looking for a test case. I could have simply reintroduced the Nitro bug, but as that requires loading a driver for a special PCI device, more tweaks would have been needed and I didn’t wanted to do these again. So I started looking at some kernel code. Maybe there are more instances of the bug pattern?</p>
<p>Going through the list of files “<code>git grep fd_install</code>” was flagging as potential candidates made me find <a href="https://www.openwall.com/lists/oss-security/2022/01/27/4">one</a> in the vmwgfx driver. I knew QEMU had support for a VMware virtual graphics card, so I tried to target that bug. It still needed some tweaks to the driver to get it loaded in QEMU to be able to trigger the bug, but I could reuse most of last year’s PoC. I just had to change some <code>ioctl()</code> arguments and the path of the device node to operate on.</p>
<pre class="shell-session"><code>user@box:~$ gcc -o vmwgfx vmwgfx.c
user@box:~$ ./vmwgfx
[~] vmwgfx setup using /dev/dri/card0...
[i] confirmed to be targeting the right driver
[~] forking helper process...
[~] gathering stat info of '/etc/shadow'...
[i] predicted fence fd = 8
[~] signaling helper to get busy...
[~] triggering fence fd export...
[~] monitoring stale fd...Killed</code></pre>
<p>The exploit attempt was prevented and the process terminated with more details to be found in the kernel log (trimmed for readability):</p>
<pre><code>[   79.442649] grsec: exploit attempt detected, please report to support@grsecurity.net
[   79.442668] WARNING: CPU: 1 PID: 20765 at fs/file.c:862 __fdget_raw+0x105/0x140
[   79.445309] Modules linked in:
[   79.445934] CPU: 1 PID: 20765 Comm: vmwgfx Tainted: G                T  5.4.171-grsec-02834-gb64d26c913d9-dirty #234
[   79.447614] RIP: 0010:[&lt;ffffffff818ac195&gt;] __fdget_raw+0x105/0x140
[     ::::   ]
[   79.499088] grsec: banning user with uid 1000 until system restart for suspicious kernel crash
</code></pre>
<p>The canary check in <code>__fget_light()</code> (which was inlined into <code>__fdget_raw()</code>) detected the invalid file pointer and triggered the termination of the current process <code>vmwgfx</code>. Grsecurity’s exploit handling then banned the user, preventing any more exploit attempts happening from that user. The system is otherwise still functional, no locks are pending, no state is corrupted.</p>
<p>Fortunately, my tests were successful and we could deploy the defense in grsecurity already earlier this year.</p>
<h2 id="covering-more-object-types">Covering more Object Types</h2>
<p>Even though the technique is very effective for file objects as these go though the <em>file-descriptor-to-file</em> conversion where we placed the canary check, it’s not so much if there isn’t such a clear transition point. If a malicious process can refer to a freed object and is able to <em>probe</em> its validity without triggering the canary check logic, an attacker can just use this probe primitive to retry reallocating the targeted object until the address matches that of the dangling pointer again.</p>
<p>A task’s credentials are, no doubt, an object to protect, preferably by using a canary check. Unfortunately, cred objects trivially have such a probe primitive in the form of the <code>get*id()</code> system calls. An attacker can just loop over <code>geteuid()</code> until the dangling pointer gets the right offset again and returns a real user id – zero, root’s UID, would be what an attacker would be waiting for.</p>
<p>A task’s credentials are accessed directly by following a pointer in the <code>task_struct</code> object describing the various resources and properties attached to the corresponding thread of execution. One could think of adding canary checks to all the various wrappers like <code>current_cred()</code>, <code>current_real_cred()</code>, <code>__task_cred()</code> and so on. However, this would miss cases where the cred pointer only gets read and stored for later consumption, like the <code>f_creds</code> member in <code>struct file</code>, used to check the capabilities of the opener of a file; or within the <a href="https://kernel.dk/io_uring.pdf">io_uring</a> subsystem to be able to asynchronously execute an i/o operation with the right credentials – the one of the original task issuing the system call instead of the kernel worker thread handling it.</p>
<p>Cred objects already do have a canary based scheme behind the kernel configuration option <code>CONFIG_DEBUG_CREDENTIALS</code>. Its checks, though, are only exercised when a task’s credentials are intentionally modified, e.g.&nbsp;when reference counts change or credentials are temporarily overridden. However, for exploiting a dangling cred pointer nothing like that is needed. It’s just a matter of (ab)using the hijacked credentials to do privileged operations, like adding an entry to <code>/etc/shadow</code> or creating a suid root binary with the attacker’s code.</p>
<h2 id="compiler-plugins-to-the-rescue">Compiler Plugins to the Rescue!</h2>
<p>Instead of trying to find and patch all relevant places in the Linux kernel source where a cred object gets dereferenced, we can do better with the help of a compiler plugin that will add these checks prior to <em>using</em> a cred object. This not only allows to defer the canary check up to the point where a cred object actually gets used instead of only getting its pointer taken, it also allows finer-grained control over which kind of access needs to be validated.</p>
<p>For the compiler-based approach, we added another annotation in the form of a structure member attribute and added such an enriched member to <code>struct cred</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#cb3-1" aria-hidden="true"></a><span class="kw">struct</span> cred {</span>
<span id="cb3-2"><a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#cb3-2" aria-hidden="true"></a>    [...]</span>
<span id="cb3-3"><a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#cb3-3" aria-hidden="true"></a><span class="pp">#ifdef ....</span></span>
<span id="cb3-4"><a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#cb3-4" aria-hidden="true"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> canary __canary(CRED_MAGIC);</span>
<span id="cb3-5"><a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#cb3-5" aria-hidden="true"></a><span class="pp">#endif</span></span>
<span id="cb3-6"><a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#cb3-6" aria-hidden="true"></a>    [...]</span>
<span id="cb3-7"><a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#cb3-7" aria-hidden="true"></a>} __randomize_layout;</span></code></pre></div>
<p>This annotation will make the compiler plugin handle instances of <code>struct cred</code> specially: testing the <code>canary</code> member to have the value <code>CRED_MAGIC</code> prior to being dereferenced for a read operation. We explicitly care about read operations only, as a write to one of the members implies the process’ privilege to change, for example, the <code>uid</code> value has already been verified. This verification, in turn, implies a read operation of the current credentials to do the necessary checks. Security relevant writes are therefore strictly preceded by a read operation which will do the canary check as well.</p>
<p>This scheme also simplifies object initialization, as that’s just a series of writes to the object’s memory, allowing the canary to be initialized without creating a hen-and-egg problem of having a valid canary value to do the canary initialization.</p>
<p>The plugin in its current form instruments all read operations and relies on GCC’s dead code elimination pass to drop superfluous ones. GCC is actually pretty good at doing so and even moves checks out of loops if it can prove no writes to a cred object can happen within the loop. The overall instrumentation overhead is thereby condensed to the actual necessary ones, which happen to still be plentiful. However, as a canary check always precedes a real structure field read, its performance impact is benign, while its security impact is huge.</p>
<h2 id="fishing-credentials">Fishing Credentials</h2>
<p>I wanted to use <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-1043">CVE-2022-1043</a> as a litmus test for the canary plugin – a silently-fixed (at the time) vulnerability in the io_uring subsystem leading to a premature release of a process’ credentials affecting Linux kernel versions v5.12-rc3 to v5.14-rc6. As the bug was already fixed last year, I simply reverted the <a href="https://git.kernel.org/linus/a30f895ad323" title="io_uring: fix xa_alloc_cycle() error return value check">commit</a> on top of grsecurity’s current stable tree for Linux kernel v5.15. I also needed to lift the Kconfig restrictions on <code>CONFIG_IO_URING</code> to be able to actually enable the vulnerable subsystem, as it’s disabled by default in grsecurity.<a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>Writing a bug trigger was easy, turning it into a functional exploit not so much. After a day, I had cooked up <a href="https://grsecurity.net/canary_kernel_mine/cve-2022-1043.c">something</a> and made sure it could – beside all the subtleties that needed to be handled – “pop a shell”:</p>
<pre class="shell-session"><code>user@box:~$ uname -r
5.15.74-grsec+revert_a30f895a+
user@box:~$ zgrep -E 'OBJREUSE|IO_URING' /proc/config.gz
CONFIG_IO_URING=y
# CONFIG_GRKERNSEC_SLAB_OBJREUSE_HARDEN is not set
user@box:~$
user@box:~$ # We're running on a modified grsecurity kernel with commit a30f895ad323
user@box:~$ # ("io_uring: fix xa_alloc_cycle() error return value check") reverted,
user@box:~$ # IO_URING re-enabled and the canary plugin disabled.
user@box:~$
user@box:~$ gcc -pthread -o cve-2022-1043 cve-2022-1043.c
user@box:~$ ./cve-2022-1043
[~] forking helper process...
[~] creating worker threads...
[~] ID wrapped after 65536 allocation attempts! (id = 1)
[~] ID wrapped again after 131071 allocation attempts! (id = 1)
[~] waiting for creds to get reallocated...
[.] reused by uninteresting EUID -16843010 (PaX MEMORY_SANITIZE?)
[.] reused by uninteresting EUID 1000
[*] waiting for root shell...
# id
uid=0(root) gid=0(root) groups=0(root),1000(user)</code></pre>
<p>The above log shows the power of a same-type use-after-free bug: no ROP, no info leak, no SMEP / SMAP / PTI bypass is needed to exploit the bug. It’s a data-only attack violating the temporal integrity of an object allowing an attacker to escalate privileges if there are no mitigations in place.</p>
<p>Lets try again with the canary plugin enabled:</p>
<pre class="shell-session"><code>user@box:~$ uname -r
5.15.74-grsec+revert_a30f895a+
user@box:~$ zgrep -E 'OBJREUSE|IO_URING' /proc/config.gz
CONFIG_IO_URING=y
CONFIG_GRKERNSEC_SLAB_OBJREUSE_HARDEN=y
CONFIG_GRKERNSEC_SLAB_OBJREUSE_HARDEN_PLUGIN=y
user@box:~$
user@box:~$ # We're again running a modified grsecurity kernel with the bug fix
user@box:~$ # reverted and IO_URING re-enabled but this time with the canary
user@box:~$ # plugin enabled.
user@box:~$
user@box:~$ gcc -pthread -o cve-2022-1043 cve-2022-1043.c
user@box:~$ ./cve-2022-1043
[~] forking helper process...
[~] creating worker threads...
[~] ID wrapped after 65536 allocation attempts! (id = 1)
[~] ID wrapped again after 131071 allocation attempts! (id = 1)
[~] waiting for creds to get reallocated...
Killed</code></pre>
<p>The exploit was killed, the privilege escalation prevented.</p>
<p>Below is a trimmed-down kernel log relating to the failed exploit attempt. After some deciphering, one might see that the process that gets killed is <code>cve-2022-1043</code>, i.e. our exploit. It trips over the canary check in the <code>__do_sys_geteuid()</code> function which is implementing the <code>geteuid()</code> system call, which demonstrates that the plugin is instrumenting the code as expected and grsecurity’s exploit handling is working by banning the offending user:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb6-1"><a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#cb6-1" aria-hidden="true"></a>[  166.638648] invalid opcode: 0000 [#1] PREEMPT SMP</span>
<span id="cb6-2"><a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#cb6-2" aria-hidden="true"></a>[  166.639209] CPU: 1 PID: 809 Comm: cve-2022-1043 Not tainted 5.15.74-grsec+revert_a30f895a+ #203</span>
<span id="cb6-3"><a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#cb6-3" aria-hidden="true"></a>[  166.640024] RIP: 0010:[&lt;ffffffff811e7c06&gt;] __do_sys_geteuid+0x66/0x80</span>
<span id="cb6-4"><a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#cb6-4" aria-hidden="true"></a>[  166.640606] Code: 31 c0 e8 4d 16 12 00 89 c0 48 8b 55 08 4c 31 e3 48 39 da 75 1a 48 81 7a f0 51 20 00 e7 75 0d 48 8b 5d f8 c9 c3 cc 0f 1f 40 00 &lt;0f&gt; 0b 0f b9 10 0f b9 10 66 90 cc cc cc cc cc cc 48 b8 af df ff 18</span>
<span id="cb6-5"><a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#cb6-5" aria-hidden="true"></a>[     ::::   ]</span>
<span id="cb6-6"><a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#cb6-6" aria-hidden="true"></a>[  166.694859] grsec: current credential structure corrupted, determining user via fallback method</span>
<span id="cb6-7"><a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#cb6-7" aria-hidden="true"></a>[  166.695513] grsec: banning user with uid 1000 until system restart for suspicious kernel crash</span></code></pre></div>
<p>Having proven the effectiveness of the canary plugin to protect credentials, we were able to deploy this feature in grsecurity earlier this month in all supported kernels.</p>
<h2 id="supporting-features">Supporting Features</h2>
<p>As reusing file objects or credentials is a guessing game for an attacker with the defense in place, handling the violations is what really supports killing exploits. A canary check violation will always be handled as an exploit attempt. Grsecurity’s lockout feature will respond to such an event by terminating not only the triggering task, but also all other processes of the user that ran the exploit. The user also gets banned, preventing them from logging in again and attempting any other exploits while the system continues to operate.</p>
<p>For other bug class/exploit scenarios, proper structure layout randomization also deters attackers from crafting fake objects, spoofing canary values to spoil the canary checks.</p>
<h2 id="relevance">Relevance</h2>
<p>As shown by exercising real exploits, the new defense is effective in preventing exploitation of same-type, same-address use-after-free bugs for file objects and process credentials. Interestingly, the very same two object types are also specifically targeted in Zhenpeng Lin’s <a href="https://grsecurity.net/dirty_cred">DirtyCred</a> themed presentation. Both of his exploitation methods will fail on grsecurity kernels because the object offsetting by reallocating a memory slot and the canary checks will prevent exploiting the underlying use-after-free bug that’s needed to start off the attack.</p>
<h2 id="closing-remarks">Closing Remarks</h2>
<p>The general problem of <a href="https://www.openwall.com/lists/oss-security/2022/01/27/5">dangling file descriptors</a> became mostly a non-issue in grsecurity, while for upstream Linux it still means patching <a href="https://git.kernel.org/linus/ee12595147ac" title="fanotify: Fix stale file descriptor in copy_event_to_user()">one</a> <a href="https://git.kernel.org/linus/46963e2e0629" title="misc: fastrpc: avoid double fput() on failed usercopy">vulnerability</a> at a <a href="https://git.kernel.org/linus/c72ea2050361" title="iio: buffer: Fix file related error handling in IIO_BUFFER_GET_FD_IOCTL">time</a>. Dangling cred pointers got tamed as well, thanks to the new type canary plugin, thwarting a new bug class before it becomes a widespread threat.</p>
<p>We’ll keep on doing what we’ve been doing successfully for over two decades: pushing Linux kernel security to handle new threats as they arise and iteratively improving our own production-grade defenses to make them stronger. Stay tuned for more to come!</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn1" role="doc-endnote"><p>There are two functions just because the kernel optimizes for the common case of a single-threaded process where the file descriptor table isn’t shared with other tasks. As a process cannot interrupt itself, no concurrent modifications to the file descriptor table can happen, so a simple table access is sufficient to get a stable result – either a live file object pointer or NULL for an unused slot.<a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>In grsecurity this is implemented by <code>DEFERRED_BUG_ON(…)</code> which allows the current control flow to continue executing but signal an error to the caller and marking the current task to be terminated as soon as it’s safe to do so.<a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>grsecurity forcibly disables <code>CONFIG_IO_URING</code> as it has a <a href="https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=io_uring">track record</a> of serious exploitable vulnerabilities ever since its introduction with no end in sight.<a href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>


                                        </div><!-- .panel -->
                                </div><!-- .wrap -->
                        </section>
                </article>
        </main>

    <footer class="colophon" role="contentinfo">
            <div class="upper-footer wrap">
                <a class="back-to-top" href="https://grsecurity.net/exploiting_and_defending_against_same_type_object_reuse#top">Back to Top</a>

                <div class="col-1-3 first about">
                    <h4>About grsecurity</h4>
                    <p>grsecurity® is the only drop-in Linux kernel replacement offering high-performance, state-of-the-art exploit prevention against both known and unknown threats.</p>
                </div>
                <div class="col-1-3 quick-links">
                    <div class="upper-footer-inner-wrap">
                        <h4>Quick Links</h4>
                        <nav class="footer-menu">
                            <ul>
                               <li><a href="https://grsecurity.net/index.php">Home</a></li>
                                <li><a href="https://grsecurity.net/features.php">Features</a></li>
                                <li><a href="https://grsecurity.net/support.php">Support</a></li>
                                <li><a href="https://grsecurity.net/papers.php">Papers</a></li>
                                <li><a href="https://grsecurity.net/research.php">Research</a></li>
                                <li><a href="https://grsecurity.net/blog.php">Blog</a></li>
                                <li><a href="https://grsecurity.net/download.php">Download</a></li>
                            </ul>
                        </nav>
                    </div>
                </div>
                <div class="col-1-3 last contact">
                    <div class="upper-footer-inner-wrap">
                        <h4>Get in Touch</h4>
                        <span class="phone"><a href="tel:+1 949-424-7732">+1 949-424-7732</a></span>
                        <span class="email"><a href="mailto:contact@grsecurity.net">contact@grsecurity.net</a></span>
                        <span class="twitter"><a href="https://twitter.com/grsecurity">@grsecurity</a></span>
                    </div>
                </div>
            </div>
            <hr>
            <div class="lower-footer wrap">
                <div class="fine-print">
                    <a href="https://grsecurity.net/trademark_policy.php"><strong>Trademark Policy</strong></a> <a href="https://grsecurity.net/privacy_policy.php"><strong>Privacy Policy</strong></a> <a href="https://grsecurity.net/terms_and_conditions.php"><strong>Terms &amp; Conditions</strong></a>
                </div>
                <span class="text">© Open Source Security, Inc 2013-2022.</span><br>
		<span class="text">grsecurity and RAP are registered trademarks of Open Source Security, Inc.</span>
		<span class="text">Linux is the registered trademark of Linus Torvalds.</span>

            </div><!-- .lower-footer -->

    </footer><!-- .colophon -->

<script src="./grsecurity - Canary in the Kernel Mine_ Exploiting and Defending Against Same-Type Object Reuse_files/webfont.js.下載"></script>
<script src="./grsecurity - Canary in the Kernel Mine_ Exploiting and Defending Against Same-Type Object Reuse_files/webfont_load.js.下載"></script>

<script type="text/javascript" src="./grsecurity - Canary in the Kernel Mine_ Exploiting and Defending Against Same-Type Object Reuse_files/script.js.下載"></script>



</body></html>